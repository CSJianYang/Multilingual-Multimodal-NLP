[
    {
        "title": "Combination Sum IV",
        "question_content": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to&nbsp;target.\nThe test cases are generated so that the answer can fit in a 32-bit integer.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3], target = 4\nOutput: 7\nExplanation:\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n\nExample 2:\n\nInput: nums = [9], target = 3\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 200\n\t1 <= nums[i] <= 1000\n\tAll the elements of nums are unique.\n\t1 <= target <= 1000\n\n&nbsp;\nFollow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?",
        "solutions": [
            {
                "id": 85036,
                "title": "1ms-java-dp-solution-with-detailed-explanation",
                "content": "Think about the recurrence relation first. How does the # of combinations of the `target` related to the # of combinations of numbers that are smaller than the `target`? \\n\\nSo we know that `target` is the sum of numbers in the array. Imagine we only need one more number to reach target, this number can be any one in the array, right? So the # of combinations of `target`, `comb[target] = sum(comb[target - nums[i]]), where 0 <= i < nums.length, and target >= nums[i]`. \\n\\nIn the example given, we can actually find the # of combinations of 4 with the # of combinations of 3(4 - 1), 2(4- 2) and 1(4 - 3). As a result, `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. \\n\\nThen think about the base case. Since if the target is 0, there is only one way to get zero, which is using 0, we can set `comb[0] = 1`. \\n\\nEDIT: The problem says that target is a positive integer that makes me feel it's unclear to put it in the above way. Since `target == 0` only happens when in the previous call, target = nums[i], we know that this is the only combination in this case, so we return 1. \\n\\nNow we can come up with at least a recursive solution. \\n```\\npublic int combinationSum4(int[] nums, int target) {\\n    if (target == 0) {\\n        return 1;\\n    }\\n    int res = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (target >= nums[i]) {\\n            res += combinationSum4(nums, target - nums[i]);\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\nNow for a DP solution, we just need to figure out a way to store the intermediate results, to avoid the same combination sum being calculated many times. We can use an array to save those results, and check if there is already a result before calculation. We can fill the array with -1 to indicate that the result hasn't been calculated yet. 0 is not a good choice because it means there is no combination sum for the target. \\n\\n```\\nprivate int[] dp;\\n\\npublic int combinationSum4(int[] nums, int target) {\\n    dp = new int[target + 1];\\n    Arrays.fill(dp, -1);\\n    dp[0] = 1;\\n    return helper(nums, target);\\n}\\n\\nprivate int helper(int[] nums, int target) {\\n    if (dp[target] != -1) {\\n        return dp[target];\\n    }\\n    int res = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (target >= nums[i]) {\\n            res += helper(nums, target - nums[i]);\\n        }\\n    }\\n    dp[target] = res;\\n    return res;\\n}\\n```\\n\\nEDIT: The above solution is top-down. How about a bottom-up one?\\n```\\npublic int combinationSum4(int[] nums, int target) {\\n    int[] comb = new int[target + 1];\\n    comb[0] = 1;\\n    for (int i = 1; i < comb.length; i++) {\\n        for (int j = 0; j < nums.length; j++) {\\n            if (i - nums[j] >= 0) {\\n                comb[i] += comb[i - nums[j]];\\n            }\\n        }\\n    }\\n    return comb[target];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int combinationSum4(int[] nums, int target) {\\n    if (target == 0) {\\n        return 1;\\n    }\\n    int res = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (target >= nums[i]) {\\n            res += combinationSum4(nums, target - nums[i]);\\n        }\\n    }\\n    return res;\\n}\\n```\n```\\nprivate int[] dp;\\n\\npublic int combinationSum4(int[] nums, int target) {\\n    dp = new int[target + 1];\\n    Arrays.fill(dp, -1);\\n    dp[0] = 1;\\n    return helper(nums, target);\\n}\\n\\nprivate int helper(int[] nums, int target) {\\n    if (dp[target] != -1) {\\n        return dp[target];\\n    }\\n    int res = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (target >= nums[i]) {\\n            res += helper(nums, target - nums[i]);\\n        }\\n    }\\n    dp[target] = res;\\n    return res;\\n}\\n```\n```\\npublic int combinationSum4(int[] nums, int target) {\\n    int[] comb = new int[target + 1];\\n    comb[0] = 1;\\n    for (int i = 1; i < comb.length; i++) {\\n        for (int j = 0; j < nums.length; j++) {\\n            if (i - nums[j] >= 0) {\\n                comb[i] += comb[i - nums[j]];\\n            }\\n        }\\n    }\\n    return comb[target];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85120,
                "title": "c-template-for-all-combination-problem-set",
                "content": "\\n**Firstly, the Combination Sum 1 & 4 are similar, and Combination Sum 2 & 3 are similar !!!  Combination Sum 3 is the special case of Combination Sum 2, and the Combination Sum 4 return the count while Combination Sum return all the combination !**\\n**k sum problem is a good extension for the combination sum problem, k-sum 1 is to return the count while k-sum 2 return all the possible results** \\n\\n\\n* ****DP:  when solve the problem return the count****\\n\\n* **DFS :  for return all the possible result**\\n\\n**Update@08/05/2016 :**\\n\\nThere are 2 more interesting problem,  let us check it now !\\n\\n[**k Sum 1 & 2**]\\n\\n1.  return the count  Given n distinct positive integers, integer k (k <= n) and a number target.  Find k numbers where sum is target. Calculate how many solutions there are?\\n2. return alll \\n\\n**Solution to ksum-1  :**\\n\\n```\\nclass Solution {\\npublic:\\n    /**\\n     * @param A: an integer array.\\n     * @param k: a positive integer (k <= length(A))\\n     * @param target: a integer\\n     * @return an integer\\n     */\\n    int kSum(vector<int> A, int k, int target) {\\n        // wirte your code here\\n        const int n = A.size();\\n        /** dp[i][j][target] : # of ways to start from vector[0..i-1], choose j elements to sum to target **/\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(k + 1, vector<int>(target + 1, 0)));\\n        \\n        for(int i = 1; i <= n; i++) {\\n            if(A[i-1] <= target) {\\n                for(int j = i; j <= n; j++) {\\n                    dp[j][1][A[i-1]] =1;\\n                }\\n            }\\n        }\\n        /** for position i, we can choose it or not **/\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = min(i, k); j > 1; j--) {\\n                for(int p = 1; p <= target; p++) {\\n                    dp[i][j][p] = dp[i - 1][j][p];\\n                    if(p - A[i - 1] >= 0) {\\n                        dp[i][j][p] += dp[i - 1][j - 1][p - A[i - 1]];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][k][target];\\n    }\\n};\\n```\\n**Update @ 2016/09/07**\\nThere is a more easy to grasp solution :\\n\\n```\\nclass Solution {\\npublic:\\n    /**\\n     * @param A: an integer array.\\n     * @param k: a positive integer (k <= length(A))\\n     * @param target: a integer\\n     * @return an integer\\n     */\\nint kSum(vector<int> A, int k, int target) {\\n        // wirte your code here\\n        const int n = A.size();\\n        /** dp[i][j][target] : # of ways to start from vector[0..i-1], choose j elements to sum to target **/\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(k + 1, vector<int>(target + 1, 0)));\\n        \\n        for(int i = 0; i < A.size(); i++) {\\n            dp[i][0][0] = 1;\\n        }\\n        /** for position i, we can choose it or not **/\\n        for(int i = 1; i <= n; i++) {\\n            for(int j =1; j <= k; j++) {\\n                for(int p = 1; p <= target; p++) {\\n                    if (j > i) dp[i][j][p] = 0; \\n                    else dp[i][j][p] = dp[i-1][j][p];\\n                    if(p - A[i - 1] >= 0) {\\n                        dp[i][j][p] += dp[i - 1][j - 1][p - A[i - 1]];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][k][target];\\n    }\\n};\\n```\\n\\n**Solution to ksum-2  :**\\n\\n```\\nclass Solution {\\npublic:\\n    /**\\n     * @param A: an integer array.\\n     * @param k: a positive integer (k <= length(A))\\n     * @param target: a integer\\n     * @return a list of lists of integer\\n     */\\n    vector<vector<int>> kSumII(vector<int> A, int k, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(A, k, 0, target, curr, ans);\\n        return ans;\\n    }\\n\\n    void helper(vector<int> A, int k, int start, int target, vector<int>& curr, vector<vector<int>> & ans) {\\n        if (k < 0 || target < 0) {\\n            return;\\n        }\\n\\n        if (k == 0 && target == 0) {\\n            ans.emplace_back(curr);\\n            return;\\n        }\\n\\n        for (int i = start; i <= A.size() - k; i++) {\\n            curr.emplace_back(A[i]);\\n            helper(A, k - 1, i + 1, target - A[i], curr, ans);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n\\n***[Problem 39    Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.  The same repeated number may be chosen from C unlimited number of times.](https://leetcode.com/problems/combination-sum/)***\\n \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> result;\\n        vector<int> combination;\\n        dfs(candidates, target, result, combination, 0);\\n        return result;\\n    }\\n    \\n    void dfs(vector<int>& nums, int target, vector<vector<int>>& result, vector<int>& combination, int begin) {\\n        if (!target) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i < nums.size() && target >= nums[i]; i++) {\\n            combination.push_back(nums[i]);\\n            dfs(nums, target - nums[i], result, combination, i);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n\\n***[Problem 40    Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.  Each number in C may only be used once in the combination.](https://leetcode.com/problems/combination-sum-ii/)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> result;\\n        vector<int> combination;\\n        dfs(candidates, target, result, combination, 0);\\n        return result;\\n    }\\n    \\n    void dfs(vector<int>& nums, int target, vector<vector<int>>& result, vector<int>& combination, int begin) {\\n        if (!target) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i < nums.size() && target >= nums[i]; i++) {\\n            combination.push_back(nums[i]);\\n            //combinationSum1 : dfs(nums, target - nums[i], result, combination, i);\\n            dfs(nums, target - nums[i], result, combination, i + 1);\\n            combination.pop_back();\\n            //combinationSum1 : no this line to filter the duplicate cases \\n            while (i < nums.size() && nums[i] == nums[i+1]) i++;\\n        }\\n    }\\n};\\n```\\n  \\n***[Problem 216    Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.](https://leetcode.com/problems/combination-sum-iii/)***    \\n\\nThis problem is different from the 1 & 2, our choice is constrained to be [1,9], and our target is valid, then our bigest number is just sum from 1 to 9, our result is that number 1 to 9 can only be choosed for one time. All in all, this problem is a special case of the Combination Problem 2 \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> result;\\n        vector<int> path;\\n        dfs(1, path, result, k, n);\\n        return result;\\n    }\\n    \\n    void dfs(int pos, vector<int>& path, vector<vector<int>>& result, int k, int n) {\\n        //cut edge\\n        if (n < 0) return;\\n        //valid cases\\n        if (n == 0 && k == path.size()) result.push_back(path);\\n        for (int i = pos; i <= 9; i++) {\\n            path.push_back(i);\\n            dfs(i + 1, path, result, k, n - i);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n***[Problem 377   Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.](https://leetcode.com/problems/combination-sum-iv/)***    \\n\\nThis problem is just similar to the Combination Problem 1 , we only need to return the count but not all the possible result .\\n\\n\\n* dp[i] : record the possible combination count to sum to target value of i\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        sort (nums.begin(), nums.end());\\n        for (int i = 1; i <= target; i++) {\\n            for (auto num : nums) {\\n                if (i < num) break;\\n                dp[i] += dp[i - num];\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\n\\n[***Problem  77  Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.***](https://leetcode.com/problems/combinations/) \\n\\nThis problem is the almost same as the problem Combination sum 2, only with different ending conditions !\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > combine(int n, int k) {\\n        vector<vector<int> > res;\\n        vector<int> path;\\n        dfs(1, path, res, n, k);\\n        return res;\\n    }\\n    void dfs(int pos, vector<int> &path, vector<vector<int> > &res, int n, int k) {\\n        if (path.size() == k) res.push_back(path);\\n        else {\\n            for (int i = pos; i <= n; ++i) {\\n                path.push_back(i);\\n                dfs(i + 1, path, res, n, k);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n\\n***[Problem 17  Letter Combination  Given a digit string, return all possible letter combinations that the number could represent.  A mapping of digit to letters (just like on the telephone buttons) is given below.](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)***  \\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> res;\\n        if (digits.empty()) return res;\\n        vector<string> dict{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        dfs(digits, dict, 0, \"\", res);\\n        return res;\\n    }\\n    void dfs(string digits, vector<string>& dict, int pos, string path, vector<string> &res) {\\n        if (pos == digits.size()) res.push_back(path);\\n        else {\\n            string str = dict[digits[pos] - \\'0\\'];\\n            for (int i = 0; i < str.size(); ++i) {\\n                path.push_back(str[i]);\\n                dfs(digits, dict, pos + 1, path, res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n***Problem 254   Write a function that takes an integer n and return all possible combinations of its factors.  Note:  Each combination\\'s factors must be sorted ascending, for example: The factors of 2 and 6 is [2, 6], not [6, 2]. You may assume that n is always positive.***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getFactors(int n) {\\n        vector<vector<int>> result;\\n        vector<int> path;\\n        helper(n, 2, path, result);\\n        return result;\\n    }\\n    void helper(int remain, int start, vector<int> path, vector<vector<int>> &result) {\\n        if (remain == 1) {\\n            if (path.size() > 1) result.push_back(path);\\n        } else {\\n            for (int i = start; i <= remain; ++i) {\\n                if (remain % i == 0) {\\n                    path.push_back(i);\\n                    helper(remain / i, i, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n     * @param A: an integer array.\\n     * @param k: a positive integer (k <= length(A))\\n     * @param target: a integer\\n     * @return an integer\\n     */\\n    int kSum(vector<int> A, int k, int target) {\\n        // wirte your code here\\n        const int n = A.size();\\n        /** dp[i][j][target] : # of ways to start from vector[0..i-1], choose j elements to sum to target **/\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(k + 1, vector<int>(target + 1, 0)));\\n        \\n        for(int i = 1; i <= n; i++) {\\n            if(A[i-1] <= target) {\\n                for(int j = i; j <= n; j++) {\\n                    dp[j][1][A[i-1]] =1;\\n                }\\n            }\\n        }\\n        /** for position i, we can choose it or not **/\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = min(i, k); j > 1; j--) {\\n                for(int p = 1; p <= target; p++) {\\n                    dp[i][j][p] = dp[i - 1][j][p];\\n                    if(p - A[i - 1] >= 0) {\\n                        dp[i][j][p] += dp[i - 1][j - 1][p - A[i - 1]];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][k][target];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    /**\\n     * @param A: an integer array.\\n     * @param k: a positive integer (k <= length(A))\\n     * @param target: a integer\\n     * @return an integer\\n     */\\nint kSum(vector<int> A, int k, int target) {\\n        // wirte your code here\\n        const int n = A.size();\\n        /** dp[i][j][target] : # of ways to start from vector[0..i-1], choose j elements to sum to target **/\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(k + 1, vector<int>(target + 1, 0)));\\n        \\n        for(int i = 0; i < A.size(); i++) {\\n            dp[i][0][0] = 1;\\n        }\\n        /** for position i, we can choose it or not **/\\n        for(int i = 1; i <= n; i++) {\\n            for(int j =1; j <= k; j++) {\\n                for(int p = 1; p <= target; p++) {\\n                    if (j > i) dp[i][j][p] = 0; \\n                    else dp[i][j][p] = dp[i-1][j][p];\\n                    if(p - A[i - 1] >= 0) {\\n                        dp[i][j][p] += dp[i - 1][j - 1][p - A[i - 1]];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][k][target];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    /**\\n     * @param A: an integer array.\\n     * @param k: a positive integer (k <= length(A))\\n     * @param target: a integer\\n     * @return a list of lists of integer\\n     */\\n    vector<vector<int>> kSumII(vector<int> A, int k, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(A, k, 0, target, curr, ans);\\n        return ans;\\n    }\\n\\n    void helper(vector<int> A, int k, int start, int target, vector<int>& curr, vector<vector<int>> & ans) {\\n        if (k < 0 || target < 0) {\\n            return;\\n        }\\n\\n        if (k == 0 && target == 0) {\\n            ans.emplace_back(curr);\\n            return;\\n        }\\n\\n        for (int i = start; i <= A.size() - k; i++) {\\n            curr.emplace_back(A[i]);\\n            helper(A, k - 1, i + 1, target - A[i], curr, ans);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> result;\\n        vector<int> combination;\\n        dfs(candidates, target, result, combination, 0);\\n        return result;\\n    }\\n    \\n    void dfs(vector<int>& nums, int target, vector<vector<int>>& result, vector<int>& combination, int begin) {\\n        if (!target) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i < nums.size() && target >= nums[i]; i++) {\\n            combination.push_back(nums[i]);\\n            dfs(nums, target - nums[i], result, combination, i);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> result;\\n        vector<int> combination;\\n        dfs(candidates, target, result, combination, 0);\\n        return result;\\n    }\\n    \\n    void dfs(vector<int>& nums, int target, vector<vector<int>>& result, vector<int>& combination, int begin) {\\n        if (!target) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i < nums.size() && target >= nums[i]; i++) {\\n            combination.push_back(nums[i]);\\n            //combinationSum1 : dfs(nums, target - nums[i], result, combination, i);\\n            dfs(nums, target - nums[i], result, combination, i + 1);\\n            combination.pop_back();\\n            //combinationSum1 : no this line to filter the duplicate cases \\n            while (i < nums.size() && nums[i] == nums[i+1]) i++;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> result;\\n        vector<int> path;\\n        dfs(1, path, result, k, n);\\n        return result;\\n    }\\n    \\n    void dfs(int pos, vector<int>& path, vector<vector<int>>& result, int k, int n) {\\n        //cut edge\\n        if (n < 0) return;\\n        //valid cases\\n        if (n == 0 && k == path.size()) result.push_back(path);\\n        for (int i = pos; i <= 9; i++) {\\n            path.push_back(i);\\n            dfs(i + 1, path, result, k, n - i);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        sort (nums.begin(), nums.end());\\n        for (int i = 1; i <= target; i++) {\\n            for (auto num : nums) {\\n                if (i < num) break;\\n                dp[i] += dp[i - num];\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > combine(int n, int k) {\\n        vector<vector<int> > res;\\n        vector<int> path;\\n        dfs(1, path, res, n, k);\\n        return res;\\n    }\\n    void dfs(int pos, vector<int> &path, vector<vector<int> > &res, int n, int k) {\\n        if (path.size() == k) res.push_back(path);\\n        else {\\n            for (int i = pos; i <= n; ++i) {\\n                path.push_back(i);\\n                dfs(i + 1, path, res, n, k);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> res;\\n        if (digits.empty()) return res;\\n        vector<string> dict{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n        dfs(digits, dict, 0, \"\", res);\\n        return res;\\n    }\\n    void dfs(string digits, vector<string>& dict, int pos, string path, vector<string> &res) {\\n        if (pos == digits.size()) res.push_back(path);\\n        else {\\n            string str = dict[digits[pos] - \\'0\\'];\\n            for (int i = 0; i < str.size(); ++i) {\\n                path.push_back(str[i]);\\n                dfs(digits, dict, pos + 1, path, res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getFactors(int n) {\\n        vector<vector<int>> result;\\n        vector<int> path;\\n        helper(n, 2, path, result);\\n        return result;\\n    }\\n    void helper(int remain, int start, vector<int> path, vector<vector<int>> &result) {\\n        if (remain == 1) {\\n            if (path.size() > 1) result.push_back(path);\\n        } else {\\n            for (int i = start; i <= remain; ++i) {\\n                if (remain % i == 0) {\\n                    path.push_back(i);\\n                    helper(remain / i, i, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111860,
                "title": "coin-change-and-this-problem",
                "content": "If you accidentally remember the code in [Coin Change 2](https://leetcode.com/problems/coin-change-2/description/), you may find the solution to this problem is basically the same with that, except the order of for loop.\\n\\n```\\nclass Solution { // Coin Change 2\\n    public int change(int amount, int[] coins) {\\n        int[] dp = new int[amount + 1];\\n        dp[0] = 1;\\n        for (int coin : coins) {\\n            for (int i = 1; i <= amount; i++) {\\n                if (i >= coin) {\\n                    dp[i] += dp[i - coin];    \\n                }\\n            }\\n        }\\n        return dp[amount];\\n    }\\n}\\n```\\n```\\nclass Solution { // this problem\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int n : nums) {\\n                if (i >= n) {\\n                    dp[i] += dp[i - n];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```\\nIn this problem, we are required to count the *duplicate* results. However, in coin change, `1 + 1 + 2` is the same with `1 + 2 + 1`. The order of the for loop actually makes these two different problems.",
                "solutionTags": [],
                "code": "```\\nclass Solution { // Coin Change 2\\n    public int change(int amount, int[] coins) {\\n        int[] dp = new int[amount + 1];\\n        dp[0] = 1;\\n        for (int coin : coins) {\\n            for (int i = 1; i <= amount; i++) {\\n                if (i >= coin) {\\n                    dp[i] += dp[i - coin];    \\n                }\\n            }\\n        }\\n        return dp[amount];\\n    }\\n}\\n```\n```\\nclass Solution { // this problem\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int n : nums) {\\n                if (i >= n) {\\n                    dp[i] += dp[i - n];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166177,
                "title": "short-easy-w-explanation-optimization-from-brute-force-to-dp-solution",
                "content": "The problem asks us to find the number of possible combinations(and all permutations of that combination as well) of elements from *`nums`* that add up to *`target`*\\n\\n---\\n\\n\\u274C ***Solution - I (Brute Force)***\\n\\nLet\\'s start with the most basic approach. At each index, if the element is less than target, then we can always form a combination by picking the current element. The brute force is just based on this idea -\\n\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tif(target == 0) return 1;\\n\\tint ans = 0;\\n\\tfor(auto& num : nums)\\n\\t\\t// pick an element if it is less than target to be achieved and recurse for remaining amount.\\n\\t\\tif(num <= target) ans += combinationSum4(nums, target - num);\\n\\treturn ans;  \\n}\\n```\\n\\n***Time Complexity :*** **`O(N^T)`**. Please comment below if there\\'s a tighter upper bound.\\n\\n***Space Complexity :*** **`O(T)`**. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Top-Down Dynamic Programming)***\\n\\nBy drawing the recursion tree, we can see that for a target, we do the same calculations over and over again. This could be avoided by storing the number of combination obtained for a given target so that we don\\'t waste time recalculating it at each recursion.\\n\\nThis can be done by maintain a dp array where **`dp[i]`** will denote the number of combinations possible with `target = i`. Initially, all elements in `dp` will be initialized to -1 denoting that the number of combinations for those target aren\\'t calculated yet. \\n\\nOnce the number of combinations for subtarget = *`i`* (where `0<i<=target`) is calculated, it will be stored in *`dp[i]`* and the next time any recursive call asks for the same value, *`dp[i]`* will be returned directly instead of doing recomputation.\\n\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tvector<int> dp(target + 1, -1);  // at start, none of the values are computed\\n\\treturn helper(nums, target, dp);\\n}\\nint helper(vector<int>& nums, int target, vector<int>& dp){\\n\\tif(target == 0) return 1;  // base condition\\n\\tif(dp[target] != -1) return dp[target];  // if already computed for this value\\n\\t// recursive code starts -\\n\\tdp[target] = 0;\\n\\t// check for every element of nums. An element can only be taken if it is less than target.\\n\\t// If an element is chosen, recurse for remaining value.\\n\\tfor(auto& num : nums) \\n\\t\\tif(num <= target) dp[target] += helper(nums, target - num, dp);\\n\\treturn dp[target];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N * T)`**, where *`N`* is the number of elements in `nums` and *`T`* is equal to the given `target` value.\\n\\n***Space Complexity :*** **`O(T)`**. We need `O(T)` to maintain the dp array and in the worst case, we would have to do *`T`* numbers of recursive calls of helper. So, the overall space complexity becomes `O(T)`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Bottom-up Dynamic Programming)***\\n\\nThe idea in this approach is also the same. We just start filling dp from *`curTarget = 1`* all the way up to *`curTarget = target`*. At each `curTarget`, an element will be chosen if its value is less that target needed. \\n\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tvector<uint> dp(target + 1); dp[0] = 1;\\n\\t// start filling the dp array from bottom, i.e curTarget = 1 till target.\\n\\tfor (int curTarget = 1; curTarget <= target; curTarget++) \\n        for (auto& num : nums)     // check for all elements from nums\\n            if (num <= curTarget)  // an element will only be taken if it is less than target to be achieved\\n                // the optimal answer(no. of combination) of remaining value is added to dp[curTarget]\\n\\t\\t\\t\\tdp[curTarget] += dp[curTarget - num];   \\n    return dp[target];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N * T)`**\\n\\n***Space Complexity :*** **`O(T)`**. Although the space complexity remains the same, we are saving the space requried by implicit recursive stack.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution IV (Slightly efficient version of Solution - III)***\\n\\nThe above solution will always loop for `N` times for each *`curtarget`* from *`1`* to *`target`*. We could achieve slightly better performance if we sort the array at start and break as soon as `nums[i]` becomes greater than `curTarget` in the inner loop. The same optimization can be done for Top-Down approach of Solution - II as well.\\n\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tsort(begin(nums), end(nums));\\n    vector<uint> dp(target + 1); dp[0] = 1;\\n\\tfor (int curTarget = 1; curTarget <= target; curTarget++) \\n        for (auto& num : nums) \\n            if (num <= curTarget)  dp[curTarget] += dp[curTarget - num];\\n            else break;\\n    return dp[target];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N*T)`**. Although the time complexity remains same, the performance would be better in most cases since we wouldn\\'t need to loop *`N`* times for every *`curTarget`*\\n\\n***Space Complexity :*** **`O(T)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tif(target == 0) return 1;\\n\\tint ans = 0;\\n\\tfor(auto& num : nums)\\n\\t\\t// pick an element if it is less than target to be achieved and recurse for remaining amount.\\n\\t\\tif(num <= target) ans += combinationSum4(nums, target - num);\\n\\treturn ans;  \\n}\\n```\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tvector<int> dp(target + 1, -1);  // at start, none of the values are computed\\n\\treturn helper(nums, target, dp);\\n}\\nint helper(vector<int>& nums, int target, vector<int>& dp){\\n\\tif(target == 0) return 1;  // base condition\\n\\tif(dp[target] != -1) return dp[target];  // if already computed for this value\\n\\t// recursive code starts -\\n\\tdp[target] = 0;\\n\\t// check for every element of nums. An element can only be taken if it is less than target.\\n\\t// If an element is chosen, recurse for remaining value.\\n\\tfor(auto& num : nums) \\n\\t\\tif(num <= target) dp[target] += helper(nums, target - num, dp);\\n\\treturn dp[target];\\n}\\n```\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tvector<uint> dp(target + 1); dp[0] = 1;\\n\\t// start filling the dp array from bottom, i.e curTarget = 1 till target.\\n\\tfor (int curTarget = 1; curTarget <= target; curTarget++) \\n        for (auto& num : nums)     // check for all elements from nums\\n            if (num <= curTarget)  // an element will only be taken if it is less than target to be achieved\\n                // the optimal answer(no. of combination) of remaining value is added to dp[curTarget]\\n\\t\\t\\t\\tdp[curTarget] += dp[curTarget - num];   \\n    return dp[target];\\n}\\n```\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tsort(begin(nums), end(nums));\\n    vector<uint> dp(target + 1); dp[0] = 1;\\n\\tfor (int curTarget = 1; curTarget <= target; curTarget++) \\n        for (auto& num : nums) \\n            if (num <= curTarget)  dp[curTarget] += dp[curTarget - num];\\n            else break;\\n    return dp[target];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85041,
                "title": "7-liner-in-python-and-follow-up-question",
                "content": "```\\nclass Solution(object):\\n    def combinationSum4(self, nums, target):\\n        nums, combs = sorted(nums), [1] + [0] * (target)\\n        for i in range(target + 1):\\n            for num in nums:\\n                if num  > i: break\\n                if num == i: combs[i] += 1\\n                if num  < i: combs[i] += combs[i - num]\\n        return combs[target]\\n\\n# 17 / 17 test cases passed.\\n# Status: Accepted\\n# Runtime: 116 ms\\n```\\n\\n\\nThis is a 4-line top-down solution that doesn't get accepted due to recursion limit.\\n\\n```\\nclass Solution(object):\\n    def combinationSum4(self, nums, target, memo=collections.defaultdict(int)):\\n        if target < 0: return 0\\n        if target not in memo:\\n            memo[target] += sum((1, self.combinationSum4(nums, target - num))[target != num] \\n                                for num in nums)\\n        return memo[target]\\n```\\n\\nThe problem with negative numbers is that now the combinations could be potentially of infinite length. Think about `nums = [-1, 1]` and `target = 1`. We can have all sequences of arbitrary length that follow the patterns  `-1, 1, -1, 1, ..., -1, 1, 1` and `1, -1, 1, -1, ..., 1, -1, 1` (there are also others, of course, just to give an example). So we should limit the *length* of the combination sequence, so as to give a bound to the problem.\\n\\nThis is a recursive Python code that solves the above follow-up problem, so far it's passed all my test cases but comments are welcome.\\n\\n```\\nclass Solution(object):\\n    def combinationSum4WithLength(self, nums, target, length, memo=collections.defaultdict(int)):\\n        if length <= 0: return 0\\n        if length == 1: return 1 * (target in nums)\\n        if (target, length) not in memo: \\n            for num in nums:\\n                memo[target, length] += self.combinationSum4(nums, target - num, length - 1)\\n        return memo[target, length]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum4(self, nums, target):\\n        nums, combs = sorted(nums), [1] + [0] * (target)\\n        for i in range(target + 1):\\n            for num in nums:\\n                if num  > i: break\\n                if num == i: combs[i] += 1\\n                if num  < i: combs[i] += combs[i - num]\\n        return combs[target]\\n\\n# 17 / 17 test cases passed.\\n# Status: Accepted\\n# Runtime: 116 ms\\n```\n```\\nclass Solution(object):\\n    def combinationSum4(self, nums, target, memo=collections.defaultdict(int)):\\n        if target < 0: return 0\\n        if target not in memo:\\n            memo[target] += sum((1, self.combinationSum4(nums, target - num))[target != num] \\n                                for num in nums)\\n        return memo[target]\\n```\n```\\nclass Solution(object):\\n    def combinationSum4WithLength(self, nums, target, length, memo=collections.defaultdict(int)):\\n        if length <= 0: return 0\\n        if length == 1: return 1 * (target in nums)\\n        if (target, length) not in memo: \\n            for num in nums:\\n                memo[target, length] += self.combinationSum4(nums, target - num, length - 1)\\n        return memo[target, length]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020218,
                "title": "98-22-dynamic-programming-recursion-with-memoization",
                "content": "# Comprehensive Guide to Solving \"Combination Sum IV\": Dynamic Programming and Memoization Approaches\\n\\n## Introduction & Problem Statement\\n\\nWelcome, fellow coders! Today, we\\'ll dive deep into solving an intriguing combinatorial problem\\u2014**Combination Sum IV**. This problem serves as a fantastic playground to explore some powerful algorithmic paradigms. Imagine you have an array of unique integers called `nums` and a `target` integer. Your mission, should you choose to accept it, is to find out how many distinct combinations of numbers from `nums` add up to `target`.\\n\\n## Key Concepts and Constraints\\n\\n### What Makes this Problem Unique?\\n\\n1. **Combination**:  \\n   A combination here is a group of numbers taken from `nums` that, when summed up, equal `target`.\\n\\n2. **Order Matters**:  \\n   Yes, you read that right! This isn\\'t your typical combination problem where `[1, 2]` and `[2, 1]` would be considered the same. Here, the sequence matters, making each a distinct combination.\\n\\n3. **Constraints**:  \\n   - The length of `nums` will be between 1 and 200.\\n   - Each integer in `nums` will be between 1 and 1000.\\n   - The `target` is also between 1 and 1000.\\n\\n---\\n\\n# Strategies to Tackle the Problem: A Two-Pronged Approach\\n\\n## Live Coding, Dynamic Programming & More\\nhttps://youtu.be/BP09eTYEb64?si=NCbe-s7hT4Mha9Tj\\n\\n## Method 1: Dynamic Programming\\n\\n### The Ingenuity of Dynamic Programming\\n\\nDynamic Programming (DP) is a magical methodology that builds solutions from the ground up, much like constructing a pyramid. In this scenario, think of the `target` as the peak of your pyramid. You start with the foundational layer, which is your base case, and then build upon it, layer by layer, until you reach the apex. Each layer or block symbolizes a sub-problem that contributes to the solution of the overarching problem.\\n\\n### An In-Depth, Step-by-Step Guide\\n\\n1. **Initialization and Base Case**:  \\n   - Create an array `dp` with `target + 1` slots, each initialized to zero.  \\n   - This array will serve as our memory storage where `dp[i]` represents the number of combinations that can sum up to `i`.\\n   - Now, set `dp[0]` to 1. This serves as the base case, representing that there is one way to reach the target sum of zero: by using zero itself.\\n\\n2. **Filling up the DP Array (Iterative Computation)**:  \\n   - Start iterating from 1 up to `target`. For each `i`, the aim is to fill `dp[i]` with the number of combinations that can make up that sum.\\n   - To find `dp[i]`, you need to look at the previously calculated `dp` values. How? For every number `num` in `nums`, you add `dp[i - num]` to `dp[i]` (given that `i - num >= 0`).\\n   - In simpler terms, for each `i`, you\\'re summing up the number of ways to form `i` by looking at how you could have arrived at that sum using smaller numbers. \\n\\n3. **Reaching the Summit (Return the Result)**:  \\n   - After the loop concludes, you\\'ve successfully built your pyramid. At its peak, `dp[target]` will hold the total number of combinations that make up the target sum.\\n\\n### Nuances of Time and Space Complexity\\n\\n- **Time Complexity**: `O(N * target)`. The outer loop runs `target` times, and for each iteration, we potentially check all `N` numbers in `nums`.\\n- **Space Complexity**: `O(target)`. The array `dp` will have `target + 1` elements, each requiring constant space. So the overall space complexity is linear in terms of the target value.\\n\\n## Code Dynamic Programming\\n``` Python []\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i - num >= 0:\\n                    dp[i] += dp[i - num]\\n                    \\n        return dp[target]\\n```\\n``` Go []\\nfunc combinationSum4(nums []int, target int) int {\\n    dp := make([]int, target+1)\\n    dp[0] = 1\\n    \\n    for i := 1; i <= target; i++ {\\n        for _, num := range nums {\\n            if i - num >= 0 {\\n                dp[i] += dp[i - num]\\n            }\\n        }\\n    }\\n    \\n    return dp[target]\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn combination_sum4(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut dp = vec![0; (target + 1) as usize];\\n        dp[0] = 1;\\n        \\n        for i in 1..=target as usize {\\n            for &num in &nums {\\n                if i as i32 - num >= 0 {\\n                    dp[i] += dp[(i as i32 - num) as usize];\\n                }\\n            }\\n        }\\n        \\n        dp[target as usize]\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int combinationSum4(std::vector<int>& nums, int target) {\\n        std::vector<unsigned int> dp(target + 1, 0);\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= target; ++i) {\\n            for (int num : nums) {\\n                if (i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= target; i++) {\\n            for (int num : nums) {\\n                if (i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar combinationSum4 = function(nums, target) {\\n    const dp = Array(target + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    for (let i = 1; i <= target; i++) {\\n        for (const num of nums) {\\n            if (i - num >= 0) {\\n                dp[i] += dp[i - num];\\n            }\\n        }\\n    }\\n    \\n    return dp[target];\\n};\\n```\\n``` PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $target\\n     * @return Integer\\n     */\\n    function combinationSum4($nums, $target) {\\n        $dp = array_fill(0, $target + 1, 0);\\n        $dp[0] = 1;\\n        \\n        for ($i = 1; $i <= $target; $i++) {\\n            foreach ($nums as $num) {\\n                if ($i - $num >= 0) {\\n                    $dp[$i] += $dp[$i - $num];\\n                }\\n            }\\n        }\\n        \\n        return $dp[$target];\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int CombinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= target; i++) {\\n            foreach (int num in nums) {\\n                if (i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n}\\n```\\n## Method 2: Memoization with Recursion\\n\\n### The Art of Memoization\\n\\nMemoization is an optimization technique that stores the results of expensive function calls and returns the cached result when the same inputs occur again. Think of it as a wise elder who recalls past tales to shed light on current challenges. In this context, we utilize memoization to remember the number of combinations for smaller targets, preventing the need for redundant, time-consuming recalculations.\\n\\n### A Detailed Walkthrough\\n\\n1. **Preprocessing**:  \\n   - First and foremost, we sort the `nums` array. Why do we do this? Sorting allows us to iterate over the numbers in an ascending order. This order plays a crucial role in our early exit strategy during the recursive calls, ensuring we don\\'t waste time on numbers that won\\'t contribute to our solution.\\n\\n2. **Base Case and Early Exit**:  \\n   - If `n = 0`, this means we\\'ve successfully found a combination that sums up to the target. Hence, we return 1.\\n   - If `n < nums[0]`, given that `nums` is sorted, this means no combination can be formed to achieve the current `n`. So, we immediately return 0, optimizing our recursion.\\n\\n3. **The Recursive Magic**:  \\n   - For each value of `n`, we delve into its past (i.e., make recursive calls) to uncover the pathways that led to `n`.\\n   - As we iterate over the sorted `nums`, if `n - num < 0`, we hit a break. This is because, with a sorted array, if the current number causes the difference to be negative, all subsequent numbers will do the same, making them irrelevant for the current `n`. Thus, we break out early, optimizing our process.\\n\\n4. **Memoization in Action**:  \\n   - After calculating the number of combinations for a particular `n`, we store this value in a dictionary. This ensures that if we encounter the same `n` again, we can instantly retrieve its result rather than recalculating, saving precious time.\\n\\n5. **Returning the Final Verdict**:  \\n   - Once all recursive calls are settled, the answer for our primary `target` will be waiting in our memoization dictionary, ready to be unveiled.\\n\\n### Delving into the Time and Space\\n\\n- **Time Complexity**: `O(N * target)`. Each unique `target` value is calculated once. For each calculation, we might iterate over all `N` numbers in `nums`.\\n- **Space Complexity**: `O(target)`. This space is primarily used for our memoization dictionary, which can store up to `target` unique values.\\n\\n## Code Memoization with Recursion\\n``` Python []\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        nums.sort() \\n        memo = {}\\n        \\n        def helper(n):\\n            if n in memo:\\n                return memo[n]\\n            if n == 0:\\n                return 1\\n            if n < nums[0]:\\n                return 0\\n            \\n            count = 0\\n            for num in nums:\\n                if n - num < 0:\\n                    break \\n                count += helper(n - num)\\n                \\n            memo[n] = count\\n            return count\\n        \\n        return helper(target)\\n```\\n``` Go []\\nimport \"sort\"\\n\\nfunc helper(nums []int, n int, memo map[int]int) int {\\n    if val, found := memo[n]; found {\\n        return val\\n    }\\n    if n == 0 {\\n        return 1\\n    }\\n    if n < nums[0] {\\n        return 0\\n    }\\n    \\n    count := 0\\n    for _, num := range nums {\\n        if n - num < 0 {\\n            break\\n        }\\n        count += helper(nums, n - num, memo)\\n    }\\n    \\n    memo[n] = count\\n    return count\\n}\\n\\nfunc combinationSum4(nums []int, target int) int {\\n    sort.Ints(nums)\\n    memo := make(map[int]int)\\n    return helper(nums, target, memo)\\n}\\n```\\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn combination_sum4(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut nums = nums;\\n        nums.sort();\\n        let mut memo = HashMap::new();\\n        \\n        Self::helper(&nums, target, &mut memo)\\n    }\\n    \\n    fn helper(nums: &Vec<i32>, n: i32, memo: &mut HashMap<i32, i32>) -> i32 {\\n        if let Some(&count) = memo.get(&n) {\\n            return count;\\n        }\\n        if n == 0 {\\n            return 1;\\n        }\\n        if n < nums[0] {\\n            return 0;\\n        }\\n        \\n        let mut count = 0;\\n        for &num in nums {\\n            if n - num < 0 {\\n                break;\\n            }\\n            count += Self::helper(nums, n - num, memo);\\n        }\\n        \\n        memo.insert(n, count);\\n        count\\n    }\\n}\\n```\\n\\n## Performance\\n\\n| Language   | Time (ms) | Memory (MB) | Solution Type |\\n|------------|-----------|-------------|---------------|\\n| Rust       | 0 ms      | 2 MB        | DP            |\\n| C++        | 0 ms      | 6.6 MB      | DP            |\\n| Go         | 1 ms      | 2 MB        | DP            |\\n| Java       | 1 ms      | 39.6 MB     | DP            |\\n| PHP        | 6 ms      | 19.2 MB     | DP            |\\n| Python3    | 34 ms     | 16.7 MB     | Recursion     |\\n| Python3    | 36 ms     | 16.2 MB     | DP            |\\n| JavaScript | 56 ms     | 44 MB       | DP            |\\n| C#         | 78 ms     | 38.2 MB     | DP            |\\n\\n![99.png](https://assets.leetcode.com/users/images/f5ad3800-d995-45c2-bb64-d18024adec23_1694219926.7033563.png)\\n\\n## Live Coding Memoization\\nhttps://youtu.be/oHhmd5-IoM8?si=0yjXY02re64FJLaG\\n\\n## Code Highlights and Best Practices\\n\\n- Both Dynamic Programming and Memoization approaches build upon previous solutions, making them intuitive and efficient.\\n- Dynamic Programming is more straightforward but iterates through the entire `nums` array for each `target`, making it slightly slower in practice.\\n- Memoization with Recursion avoids redundant work, making it more efficient in practice.\\n\\nBy mastering these two approaches, you will be well-prepared to tackle similar combinatorial problems that involve finding the number of ways to reach a target sum.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i - num >= 0:\\n                    dp[i] += dp[i - num]\\n                    \\n        return dp[target]\\n```\n``` Go []\\nfunc combinationSum4(nums []int, target int) int {\\n    dp := make([]int, target+1)\\n    dp[0] = 1\\n    \\n    for i := 1; i <= target; i++ {\\n        for _, num := range nums {\\n            if i - num >= 0 {\\n                dp[i] += dp[i - num]\\n            }\\n        }\\n    }\\n    \\n    return dp[target]\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn combination_sum4(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut dp = vec![0; (target + 1) as usize];\\n        dp[0] = 1;\\n        \\n        for i in 1..=target as usize {\\n            for &num in &nums {\\n                if i as i32 - num >= 0 {\\n                    dp[i] += dp[(i as i32 - num) as usize];\\n                }\\n            }\\n        }\\n        \\n        dp[target as usize]\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int combinationSum4(std::vector<int>& nums, int target) {\\n        std::vector<unsigned int> dp(target + 1, 0);\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= target; ++i) {\\n            for (int num : nums) {\\n                if (i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= target; i++) {\\n            for (int num : nums) {\\n                if (i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar combinationSum4 = function(nums, target) {\\n    const dp = Array(target + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    for (let i = 1; i <= target; i++) {\\n        for (const num of nums) {\\n            if (i - num >= 0) {\\n                dp[i] += dp[i - num];\\n            }\\n        }\\n    }\\n    \\n    return dp[target];\\n};\\n```\n``` PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $target\\n     * @return Integer\\n     */\\n    function combinationSum4($nums, $target) {\\n        $dp = array_fill(0, $target + 1, 0);\\n        $dp[0] = 1;\\n        \\n        for ($i = 1; $i <= $target; $i++) {\\n            foreach ($nums as $num) {\\n                if ($i - $num >= 0) {\\n                    $dp[$i] += $dp[$i - $num];\\n                }\\n            }\\n        }\\n        \\n        return $dp[$target];\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int CombinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= target; i++) {\\n            foreach (int num in nums) {\\n                if (i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        nums.sort() \\n        memo = {}\\n        \\n        def helper(n):\\n            if n in memo:\\n                return memo[n]\\n            if n == 0:\\n                return 1\\n            if n < nums[0]:\\n                return 0\\n            \\n            count = 0\\n            for num in nums:\\n                if n - num < 0:\\n                    break \\n                count += helper(n - num)\\n                \\n            memo[n] = count\\n            return count\\n        \\n        return helper(target)\\n```\n``` Go []\\nimport \"sort\"\\n\\nfunc helper(nums []int, n int, memo map[int]int) int {\\n    if val, found := memo[n]; found {\\n        return val\\n    }\\n    if n == 0 {\\n        return 1\\n    }\\n    if n < nums[0] {\\n        return 0\\n    }\\n    \\n    count := 0\\n    for _, num := range nums {\\n        if n - num < 0 {\\n            break\\n        }\\n        count += helper(nums, n - num, memo)\\n    }\\n    \\n    memo[n] = count\\n    return count\\n}\\n\\nfunc combinationSum4(nums []int, target int) int {\\n    sort.Ints(nums)\\n    memo := make(map[int]int)\\n    return helper(nums, target, memo)\\n}\\n```\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn combination_sum4(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut nums = nums;\\n        nums.sort();\\n        let mut memo = HashMap::new();\\n        \\n        Self::helper(&nums, target, &mut memo)\\n    }\\n    \\n    fn helper(nums: &Vec<i32>, n: i32, memo: &mut HashMap<i32, i32>) -> i32 {\\n        if let Some(&count) = memo.get(&n) {\\n            return count;\\n        }\\n        if n == 0 {\\n            return 1;\\n        }\\n        if n < nums[0] {\\n            return 0;\\n        }\\n        \\n        let mut count = 0;\\n        for &num in nums {\\n            if n - num < 0 {\\n                break;\\n            }\\n            count += Self::helper(nums, n - num, memo);\\n        }\\n        \\n        memo.insert(n, count);\\n        count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166231,
                "title": "js-python-java-c-easy-dp-solutions-t-d-b-u-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWith this problem, we can easily imagine breaking up the solution into smaller pieces that we can use as stepping stones towards the overall answer. For example, if we\\'re searching for a way to get from **0** to our target number (**T**), and if **0 < x < y < T**, then we can see that finding out how many ways we can get from **y** to **T** will help us figure out how many ways we can get from **x** to **T**, all the way down to **0** to **T**. This is a classic example of a **top-down** (**memoization**) **dyanamic programming** (DP) solution.\\n\\nOf course, the reverse is also true, and we could instead choose to use a **bottom-up** (**tabulation**) DP solution with the same result.\\n\\n***Top-Down DP Approach***: Our DP array (**dp**) will contain cells (**dp[i]**) where **i** will represent the remaining space left before **T** and **dp[i]** will represent the number of ways the solution (**dp[T]**) can be reached from **i**.\\n\\nAt each value of **i** as we build out **dp** we\\'ll iterate through the different **num**s in our number array (**N**) and consider the cell that can be reached with each **num** (**dp[i-num]**). The value of **dp[i]** will therefore be the sum of the results of each of those possible moves.\\n\\nWe\\'ll need to seed **dp[0]** with a value of **1** to represent the value of the completed combination, then once the iteration is complete, we can **return dp[T]** as our final answer.\\n\\n***Bottom-Up DP Approach***: Our DP array (**dp**) will contain cells (**dp[i]**) where **i** will represent the current count as we head towards **T** and **dp[i]** will represent the number of ways we can reach **i** from the starting point (**dp[0]**). This means that **dp[T]** will represent our final solution.\\n\\nAt each value of **i** as we build out **dp** we\\'ll iterate through the different **num**s in our number array (**N**) and update the value of the cell that can be reached with each num (**dp[i+num]**) by adding the result of the current cell (**dp[i]**). If the current cell has no value, then we can **continue** without needing to iterate through **N**.\\n\\nWe\\'ll need to seed **dp[0]** with a value of **1** to represent the value of the common starting point, then once the iteration is complete, we can **return dp[T]** as our final answer.\\n\\nIn both the top-down and bottom-up DP solutions, the **time complexity** is **O(N * T)** and the **space complexity** is **O(T)**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor C++ we\\'ll have to make sure to use unsigned ints in our **dp** vector, otherwise we\\'ll get int overflow errors.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n##### ***w/ Top-Down DP:***\\n```javascript\\nvar combinationSum4 = function(N, T) {\\n    let dp = new Uint32Array(T+1)\\n    dp[0] = 1\\n    for (let i = 1; i <= T; i++)\\n        for (let num of N)\\n            if (num <= i) dp[i] += dp[i-num]\\n    return dp[T]\\n};\\n```\\n\\n##### ***w/ Bottom-Up DP:***\\n```javascript\\nvar combinationSum4 = function(N, T) {\\n    let dp = new Uint32Array(T+1)\\n    dp[0] = 1\\n    for (let i = 0; i < T; i++) {\\n        if (!dp[i]) continue\\n        for (let num of N)\\n            if (num + i <= T) dp[i+num] += dp[i]\\n    }\\n    return dp[T]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n##### ***w/ Top-Down DP:***\\n```python\\nclass Solution:\\n    def combinationSum4(self, N: List[int], T: int) -> int:\\n        dp = [0] * (T + 1)\\n        dp[0] = 1\\n        for i in range(1, T+1):\\n            for num in N:\\n                if num <= i: dp[i] += dp[i-num]\\n        return dp[T]\\n```\\n\\n##### ***w/ Bottom-Up DP:***\\n```python\\nclass Solution:\\n    def combinationSum4(self, N: List[int], T: int) -> int:\\n        dp = [0] * (T + 1)\\n        dp[0] = 1\\n        for i in range(T):\\n            if not dp[i]: continue\\n            for num in N:\\n                if num + i <= T: dp[i+num] += dp[i]\\n        return dp[T]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n##### ***w/ Top-Down DP:***\\n```java\\nclass Solution {\\n    public int combinationSum4(int[] N, int T) {\\n        int[] dp = new int[T+1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= T; i++)\\n            for (int num : N)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[T];\\n    }\\n}\\n```\\n\\n##### ***w/ Bottom-Up DP:***\\n```java\\nclass Solution {\\n    public int combinationSum4(int[] N, int T) {\\n        int[] dp = new int[T+1];\\n        dp[0] = 1;\\n        for (int i = 0; i < T; i++) {\\n            if (dp[i] == 0) continue;\\n            for (int num : N)\\n                if (num + i <= T) dp[i+num] += dp[i];\\n        }\\n        return dp[T];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ Top-Down DP:***\\n```c++\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& N, int T) {\\n        vector<unsigned int> dp(T+1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= T; i++)\\n            for (int num : N)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[T];\\n    }\\n};\\n```\\n\\n##### ***w/ Bottom-Up DP:***\\n```c++\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& N, int T) {\\n        vector<unsigned int> dp(T+1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < T; i++) {\\n            if (!dp[i]) continue;\\n            for (int num : N)\\n                if (num + i <= T) dp[i+num] += dp[i];\\n        }\\n        return dp[T];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar combinationSum4 = function(N, T) {\\n    let dp = new Uint32Array(T+1)\\n    dp[0] = 1\\n    for (let i = 1; i <= T; i++)\\n        for (let num of N)\\n            if (num <= i) dp[i] += dp[i-num]\\n    return dp[T]\\n};\\n```\n```javascript\\nvar combinationSum4 = function(N, T) {\\n    let dp = new Uint32Array(T+1)\\n    dp[0] = 1\\n    for (let i = 0; i < T; i++) {\\n        if (!dp[i]) continue\\n        for (let num of N)\\n            if (num + i <= T) dp[i+num] += dp[i]\\n    }\\n    return dp[T]\\n};\\n```\n```python\\nclass Solution:\\n    def combinationSum4(self, N: List[int], T: int) -> int:\\n        dp = [0] * (T + 1)\\n        dp[0] = 1\\n        for i in range(1, T+1):\\n            for num in N:\\n                if num <= i: dp[i] += dp[i-num]\\n        return dp[T]\\n```\n```python\\nclass Solution:\\n    def combinationSum4(self, N: List[int], T: int) -> int:\\n        dp = [0] * (T + 1)\\n        dp[0] = 1\\n        for i in range(T):\\n            if not dp[i]: continue\\n            for num in N:\\n                if num + i <= T: dp[i+num] += dp[i]\\n        return dp[T]\\n```\n```java\\nclass Solution {\\n    public int combinationSum4(int[] N, int T) {\\n        int[] dp = new int[T+1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= T; i++)\\n            for (int num : N)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[T];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int combinationSum4(int[] N, int T) {\\n        int[] dp = new int[T+1];\\n        dp[0] = 1;\\n        for (int i = 0; i < T; i++) {\\n            if (dp[i] == 0) continue;\\n            for (int num : N)\\n                if (num + i <= T) dp[i+num] += dp[i];\\n        }\\n        return dp[T];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& N, int T) {\\n        vector<unsigned int> dp(T+1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= T; i++)\\n            for (int num : N)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[T];\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& N, int T) {\\n        vector<unsigned int> dp(T+1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < T; i++) {\\n            if (!dp[i]) continue;\\n            for (int num : N)\\n                if (num + i <= T) dp[i+num] += dp[i];\\n        }\\n        return dp[T];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85079,
                "title": "my-3ms-java-dp-solution",
                "content": "Wish to learn better solutions from you guys.\\n\\n```\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int[] res = new int[target + 1];\\n        for (int i = 1; i < res.length; i++) {\\n\\t    for (int num : nums) {\\n\\t        if (num > i)\\n\\t\\t    break;\\n\\t\\telse if (num == i)\\n\\t\\t    res[i] += 1;\\n\\t\\telse\\n\\t\\t    res[i] += res[i-num];\\n\\t    }\\n\\t}\\n        return res[target];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int[] res = new int[target + 1];\\n        for (int i = 1; i < res.length; i++) {\\n\\t    for (int num : nums) {\\n\\t        if (num > i)\\n\\t\\t    break;\\n\\t\\telse if (num == i)\\n\\t\\t    res[i] += 1;\\n\\t\\telse\\n\\t\\t    res[i] += res[i-num];\\n\\t    }\\n\\t}\\n        return res[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381090,
                "title": "python-easily-understood-dp-faster-than-92-simple",
                "content": "**Appreciate if you could upvote this solution**\\n\\n\\n**Case 1**: `target` is small\\n\\nIf we want to find the combination of `target` made from `nums`, we can just find \\n`sum(target - nums[1] , target - nums[2], ..., target - nums[n-1])` where `n = len(nums)`\\n\\nThus, the easier method is to create a list `dp` with length equals to `target + 1`.\\nAnd using for loop to calculate `dp[x] += dp[x -nums[i]]` until `x = target`.\\nThen, the last loop should be `dp[target] += dp[taget-nums[i]]`\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (target+1)\\n        dp[0] = 1\\n        for i in range(1, target+1):\\n            for num in nums: \\n                num_before = i - num\\n                if num_before >= 0:\\n                    dp[i] += dp[num_before]\\n        return dp[target]\\n```\\n\\n<br/>\\n\\n**Case 2**: `target` is large\\n\\nThis method is similar to case 1,  we start at `target` but not `0`.\\nSInce `target` could be very large, the time and space complexities are high if we create a large `dp[]`\\nThus, we use `dict` and `recursion` to solve the problem.\\n\\nJust like case 1, we know that `target = sum(target - nums[1] , target - nums[2], ..., target - nums[n-1])`\\nThen, we can use a recursive function to calculate this:\\n`target = search(target - nums[1]) + search(target - nums[2]) + ... + search(target - nums[n-1])`\\n\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = {}\\n        dp[0] = [1]\\n\\n        def search(target):\\n            if target in dp:\\n                return dp[target]\\n            comb_sum = 0\\n            for num in nums:\\n                if target > num:\\n                    comb_sum += search(target - num)\\n                elif target == num:\\n                    comb_sum += 1\\n            dp[target] = comb_sum\\n            return comb_sum\\n\\n        return search(target)\\n```\\nLet `n` be `target` and `m` be the length of `nums`.\\n**Time complexity**: `O(n * m)`\\n**Space complexity**:  `O(n)`\\n<br/>",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (target+1)\\n        dp[0] = 1\\n        for i in range(1, target+1):\\n            for num in nums: \\n                num_before = i - num\\n                if num_before >= 0:\\n                    dp[i] += dp[num_before]\\n        return dp[target]\\n```\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = {}\\n        dp[0] = [1]\\n\\n        def search(target):\\n            if target in dp:\\n                return dp[target]\\n            comb_sum = 0\\n            for num in nums:\\n                if target > num:\\n                    comb_sum += search(target - num)\\n                elif target == num:\\n                    comb_sum += 1\\n            dp[target] = comb_sum\\n            return comb_sum\\n\\n        return search(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85060,
                "title": "java-recursion-solution-using-hashmap-as-memory",
                "content": "The DP solution goes through every possible sum from 1 to target one by one.\\nUsing recursion can skip those sums that are not the combinations of the numbers in the given array. Also, there is no need to sort the array first. \\n```\\npublic class Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int combinationSum4(int[] nums, int target) {\\n        int count = 0;\\n        if (nums == null || nums.length ==0 || target < 0 ) return 0;\\n        if ( target ==0 ) return 1;\\n        if (map.containsKey(target)) return map.get(target);\\n        for (int num: nums){\\n            count += combinationSum4(nums, target-num);\\n        }\\n        map.put(target, count);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int combinationSum4(int[] nums, int target) {\\n        int count = 0;\\n        if (nums == null || nums.length ==0 || target < 0 ) return 0;\\n        if ( target ==0 ) return 1;\\n        if (map.containsKey(target)) return map.get(target);\\n        for (int num: nums){\\n            count += combinationSum4(nums, target-num);\\n        }\\n        map.put(target, count);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85074,
                "title": "6-lines-c-dp-solution",
                "content": "result[i] is the possible combination of i.\\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> result(target + 1);\\n        result[0] = 1;\\n        for (int i = 1; i <= target; ++i) {\\n            for (int x : nums) {\\n                if (i >= x) result[i] += result[i - x];\\n            }\\n        }\\n        \\n        return result[target];\\n    }\\n```\\nThanks @HumbleCoder11, update the vector from int to unsigned int for new test case.",
                "solutionTags": [],
                "code": "```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> result(target + 1);\\n        result[0] = 1;\\n        for (int i = 1; i <= target; ++i) {\\n            for (int x : nums) {\\n                if (i >= x) result[i] += result[i - x];\\n            }\\n        }\\n        \\n        return result[target];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85038,
                "title": "java-follow-up-using-recursion-and-memorization",
                "content": "In order to allow negative integers, the length of the combination sum needs to be restricted, or the search will not stop. This is a modification from my [previous solution](https://discuss.leetcode.com/topic/52255/java-recursion-solution-using-hashmap-as-memory), which also use memory to avoid repeated calculations.\\n\\n```\\nMap<Integer, Map<Integer,Integer>> map2 = new HashMap<>();\\n    private int helper2(int[] nums, int len, int target, int MaxLen) {\\n    \\tint count = 0;\\n        if (  len > MaxLen  ) return 0;\\n        if ( map2.containsKey(target) && map2.get(target).containsKey(len)) { \\n        \\treturn map2.get(target).get(len);\\n        }\\n        if ( target == 0 )   count++;\\n        for (int num: nums) {\\n            count+= helper2(nums, len+1, target-num, MaxLen);\\n        }\\n        if ( ! map2.containsKey(target) ) map2.put(target, new HashMap<Integer,Integer>());\\n        Map<Integer,Integer> mem = map2.get(target);\\n        mem.put(len, count);\\n        return count;\\n    }\\n       \\n    public int combinationSum42(int[] nums, int target, int MaxLen) {\\n        if (nums == null || nums.length ==0 || MaxLen <= 0 ) return 0;\\n        map2 = new HashMap<>();\\n        return helper2(nums, 0,target, MaxLen);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nMap<Integer, Map<Integer,Integer>> map2 = new HashMap<>();\\n    private int helper2(int[] nums, int len, int target, int MaxLen) {\\n    \\tint count = 0;\\n        if (  len > MaxLen  ) return 0;\\n        if ( map2.containsKey(target) && map2.get(target).containsKey(len)) { \\n        \\treturn map2.get(target).get(len);\\n        }\\n        if ( target == 0 )   count++;\\n        for (int num: nums) {\\n            count+= helper2(nums, len+1, target-num, MaxLen);\\n        }\\n        if ( ! map2.containsKey(target) ) map2.put(target, new HashMap<Integer,Integer>());\\n        Map<Integer,Integer> mem = map2.get(target);\\n        mem.put(len, count);\\n        return count;\\n    }\\n       \\n    public int combinationSum42(int[] nums, int target, int MaxLen) {\\n        if (nums == null || nums.length ==0 || MaxLen <= 0 ) return 0;\\n        map2 = new HashMap<>();\\n        return helper2(nums, 0,target, MaxLen);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020303,
                "title": "100-c-java-python-dp-recursive-iterative-commented-code",
                "content": "# Problem Description\\n- You are given an array of **distinct integers**, nums, and an integer **target**. \\n- The **objective** is to determine the number of **possible combinations** that can be formed using elements from nums such that they add up to the given target. \\n- Each element in nums can be **used multiple times in a combination**.\\n- **Note** that [1,3] is a **different** solution than [3,1].\\n\\n- **Constraints:**\\n    - 1 <= nums.length <= 200\\n    - 1 <= nums[i] <= 1000\\n    - 1 <= target <= 1000\\n    - All the elements of nums are unique.\\n\\n\\n---\\n\\n\\n# Proposed Solutions\\n## 1. Recursive Approach (Top-Down)\\n### Intuation\\nWe can think of Recursive Approach as **breaking** hard bricks into **small** rocks. but, how this apply to our problem ?\\nWe can **break** our **complex problem** into **easier** ones and instead of finding the number of combinations for out **large target** we can find the solution for **(target - num)**, since we only need to add num to this smaller number then a **part** of our solution for target number is the solution for **(target - num)**.\\n\\n**As an example**, if we have target = 3 and nums = [1, 2]\\nan obvious solution is equal to 3\\n(1, 1, 1) , (1, 2) , (2, 1)\\nlet\\'s start breaking, we can think of 3 as sum of:\\n- (3 - 2) -> 1 which has 1 solution.\\n- (3 - 1) -> 2 which has 2 solutions.\\n\\nthen 3 has total of 3 solutions. \\n\\n### Approach\\n1. Create an array **dp** to **cache** computed results for target values.\\n\\n2. Define a **recursive** function **countCombinations** that calculates combinations to reach a target sum:\\n    - **Base case**: If the target is 0, return 1.\\n    - **Base case**: If the target is negative, return 0.\\n    - **Check** if the result for the current remainingTarget is cached and **not equal to -1** ; if     yes, return the cached result.\\n    - Initialize **currentCombinations** to 0.\\n    - **Iterate** through the numbers, recursively **calculate combinations** for   the new target, and **add** them to currentCombinations.\\n    - **Cache** the result in the dp array for the current remainingTarget  and **return currentCombinations**.\\n\\n3. In the **combinationSum4** function:\\n    - **Initialize** the dp array with **-1** for all possible target values.\\n    - Begin the combination count calculation by calling    countCombinations with the given nums and target.\\n\\n### Complexity\\n- **Time complexity:** $$O(N * T)$$\\nSince, for each remaining number we have we try all the available numbers. so, time complexity is `O(N * T)` where `N` is `length` of nums and `T` is the value of `target`.\\n\\n- **Space complexity:** $$O(T)$$\\nWe store only the `dp array` which has size of target then space complexity is `O(T)` where `T` is the value of `target`.\\n\\n\\n## 2. Iterative Approach (Bottom-Up)\\n### Intuation\\nWe can think of Iterative Approach as **building** high building from small bricks. but, how this also apply to our problem ?\\nWe can **solve** our **complex problem** by solving **easier** ones first and buil until we reach our complex problem and instead of finding the number of combinations for out **large target** we can **start** from 0 then 1 then 2 3 4 .... until we reach our large number.\\n\\n**As an example**, if we have target = 3 and nums = [1, 2]\\nthe solution is equal to 3\\n(1, 1, 1) , (1, 2) , (2, 1)\\nlet\\'s start building:\\n- 0 -> **one** solution (empty)\\n- 1 -> **one** solution (by adding num=1 to 0) => (solution of 0)\\n- 2 -> **two** solutions (by adding num=1 to 1 / adding num=2 to 0) => (solution of 1 + solution of 0)\\n- 3 -> **three** solutions (by adding num=1 to 2 / adding num=2 to 1) => (solution of 2 + solution of 1)\\n\\nthen 3 has total of 3 solutions.  \\n\\n### Approach\\n1. **Initialize** a **vector dp** where dp[i] represents the number of combinations to make the sum \\'i\\'. **Set all values to 0 initially**.\\n\\n2. Set **dp[0] to 1** because there is **one way to make a sum of 0**, which is by not selecting any number.\\n \\n3. **Iterate** through the possible target sums from 1 to target:\\n    - For **each target** sum currentSum, iterate through the given numbers     in nums.\\n    - **Calculate currentNum** as the current number being considered from  nums.\\n    - **Check if subtracting currentNum** from currentSum results in a  non-negative value.\\n    - If yes, add the combination count at dp[currentSum - currentNum] to dp[currentSum]. This represents the number of combinations for the current sum using the current number.\\n    \\n4. The final result, which represents the number of combinations to make the target sum, is stored in **dp[target]**.\\n\\n\\n### Complexity\\n- **Time complexity:** $$O(N * T)$$\\nSince, for each number we reached have we try all the available numbers. so, time complexity is `O(N * T)` where `N` is `length` of nums and `T` is the value of `target`.\\n\\n- **Space complexity:** $$O(T)$$\\nWe store only the `dp array` which has size of target then space complexity is `O(T)` where `T` is the value of `target`.\\n\\n---\\n\\n\\n# Code\\n## 1. Recursive Approach (Top-Down)\\n```C++ []\\nclass Solution {\\npublic:\\n    static const int MAX_TARGET = 1010; // Maximum possible target value\\n    int dp[MAX_TARGET]; // Array to store computed results\\n\\n    int countCombinations(vector<int> nums, int remainingTarget) {\\n        // If the remaining target is 0, there\\'s one valid combination.\\n        if (remainingTarget == 0)\\n            return 1;\\n        \\n        // If the remaining target becomes negative, it\\'s not possible to reach it.\\n        if (remainingTarget < 0)\\n            return 0;\\n        \\n        // If the result for \\'remainingTarget\\' is already computed, return it.\\n        if (~dp[remainingTarget])\\n            return dp[remainingTarget];\\n        \\n        int currentCombinations = 0;\\n        \\n        // Iterate through the numbers in \\'nums\\'.\\n        for (int i = 0; i < nums.size(); i++) {\\n            int currentNum = nums[i];\\n            // recursively calculate combinations for the new target.\\n            currentCombinations += countCombinations(nums, remainingTarget - currentNum);\\n        }\\n        \\n        // Store and return the computed result.\\n        return dp[remainingTarget] = currentCombinations;\\n    }\\n\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // Initialize the \\'dp\\' array with -1 to indicate uncomputed results.\\n        for (int i = 0; i < MAX_TARGET; i++) {\\n            dp[i] = -1;\\n        }\\n        \\n        // Start the combination count calculation.\\n        return countCombinations(nums, target);\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    private static final int MAX_TARGET = 1010; // Maximum possible target value\\n    private int[] dp = new int[MAX_TARGET]; // Array to store computed results\\n\\n    private int countCombinations(int[] nums, int remainingTarget) {\\n        // If the remaining target is 0, there\\'s one valid combination.\\n        if (remainingTarget == 0)\\n            return 1;\\n        \\n        // If the remaining target becomes negative, it\\'s not possible to reach it.\\n        if (remainingTarget < 0)\\n            return 0;\\n        \\n        // If the result for \\'remainingTarget\\' is already computed, return it.\\n        if (dp[remainingTarget] != -1)\\n            return dp[remainingTarget];\\n        \\n        int currentCombinations = 0;\\n        \\n        // Iterate through the numbers in \\'nums\\'.\\n        for (int i = 0; i < nums.length; i++) {\\n            int currentNum = nums[i];\\n            // Recursively calculate combinations for the new target.\\n            currentCombinations += countCombinations(nums, remainingTarget - currentNum);\\n        }\\n        \\n        // Store and return the computed result.\\n        return dp[remainingTarget] = currentCombinations;\\n    }\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        // Initialize the \\'dp\\' array with -1 to indicate uncomputed results.\\n        for (int i = 0; i < MAX_TARGET; i++) {\\n            dp[i] = -1;\\n        }\\n        \\n        // Start the combination count calculation.\\n        return countCombinations(nums, target);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    MAX_TARGET = 1010  # Maximum possible target value\\n\\n    def __init__(self):\\n        self.dp = [-1] * Solution.MAX_TARGET  # Array to store computed results\\n\\n    def countCombinations(self, nums, remainingTarget):\\n        # If the remaining target is 0, there\\'s one valid combination.\\n        if remainingTarget == 0:\\n            return 1\\n        \\n        # If the remaining target becomes negative, it\\'s not possible to reach it.\\n        if remainingTarget < 0:\\n            return 0\\n        \\n        # If the result for \\'remainingTarget\\' is already computed, return it.\\n        if self.dp[remainingTarget] != -1:\\n            return self.dp[remainingTarget]\\n        \\n        currentCombinations = 0\\n        \\n        # Iterate through the numbers in \\'nums\\'.\\n        for currentNum in nums:\\n            # Recursively calculate combinations for the new target.\\n            currentCombinations += self.countCombinations(nums, remainingTarget - currentNum)\\n        \\n        # Store and return the computed result.\\n        self.dp[remainingTarget] = currentCombinations\\n        return currentCombinations\\n\\n    def combinationSum4(self, nums, target):\\n        # Start the combination count calculation.\\n        return self.countCombinations(nums, target)\\n```\\n\\n## 2. Iterative Approach (Bottom-Up) \\n```C++ []\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // dp[i] represents the number of combinations to make sum \\'i\\'\\n        vector<unsigned long long> dp(target + 1, 0);\\n        \\n        // There is one way to make sum 0, which is by not selecting any number.\\n        dp[0] = 1;\\n        \\n        for(int currentSum = 1; currentSum <= target; currentSum++) {\\n            for(int numIndex = 0; numIndex < nums.size(); numIndex++) {\\n                int currentNum = nums[numIndex];\\n                if(currentSum - currentNum >= 0) {\\n                    // dp[i] can be achieved by adding the combination count at dp[i - currentNum]\\n                    dp[currentSum] += dp[currentSum - currentNum];\\n                }\\n            }\\n        }\\n        \\n        // The final result is stored in dp[target]\\n        return dp[target];\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        // dp[i] represents the number of combinations to make sum \\'i\\'\\n        long[] dp = new long[target + 1];\\n        \\n        // There is one way to make sum 0, which is by not selecting any number.\\n        dp[0] = 1;\\n        \\n        for (int currentSum = 1; currentSum <= target; currentSum++) {\\n            for (int numIndex = 0; numIndex < nums.length; numIndex++) {\\n                int currentNum = nums[numIndex];\\n                if (currentSum - currentNum >= 0) {\\n                    // dp[i] can be achieved by adding the combination count at dp[i - currentNum]\\n                    dp[currentSum] += dp[currentSum - currentNum];\\n                }\\n            }\\n        }\\n        \\n        // The final result is stored in dp[target]\\n        return (int)dp[target];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        # Initialize an array dp where dp[i] represents the number of combinations to make sum \\'i\\'.\\n        dp = [0] * (target + 1)\\n        \\n        # There is one way to make sum 0, which is by not selecting any number.\\n        dp[0] = 1\\n        \\n        # Iterate through the possible target sums from 1 to target.\\n        for currentSum in range(1, target + 1):\\n            # Iterate through the given numbers in nums.\\n            for numIndex in range(0, len(nums)):\\n                currentNum = nums[numIndex]\\n                # Check if subtracting currentNum from currentSum results in a non-negative value.\\n                if currentSum - currentNum >= 0:\\n                    # dp[i] can be achieved by adding the combination count at dp[i - currentNum].\\n                    dp[currentSum] += dp[currentSum - currentNum]\\n            \\n        # The final result is stored in dp[target].\\n        return dp[target]\\n```\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/5f6aee89-454b-47ff-93c9-7030eb5d3673_1694227000.9068315.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    static const int MAX_TARGET = 1010; // Maximum possible target value\\n    int dp[MAX_TARGET]; // Array to store computed results\\n\\n    int countCombinations(vector<int> nums, int remainingTarget) {\\n        // If the remaining target is 0, there\\'s one valid combination.\\n        if (remainingTarget == 0)\\n            return 1;\\n        \\n        // If the remaining target becomes negative, it\\'s not possible to reach it.\\n        if (remainingTarget < 0)\\n            return 0;\\n        \\n        // If the result for \\'remainingTarget\\' is already computed, return it.\\n        if (~dp[remainingTarget])\\n            return dp[remainingTarget];\\n        \\n        int currentCombinations = 0;\\n        \\n        // Iterate through the numbers in \\'nums\\'.\\n        for (int i = 0; i < nums.size(); i++) {\\n            int currentNum = nums[i];\\n            // recursively calculate combinations for the new target.\\n            currentCombinations += countCombinations(nums, remainingTarget - currentNum);\\n        }\\n        \\n        // Store and return the computed result.\\n        return dp[remainingTarget] = currentCombinations;\\n    }\\n\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // Initialize the \\'dp\\' array with -1 to indicate uncomputed results.\\n        for (int i = 0; i < MAX_TARGET; i++) {\\n            dp[i] = -1;\\n        }\\n        \\n        // Start the combination count calculation.\\n        return countCombinations(nums, target);\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    private static final int MAX_TARGET = 1010; // Maximum possible target value\\n    private int[] dp = new int[MAX_TARGET]; // Array to store computed results\\n\\n    private int countCombinations(int[] nums, int remainingTarget) {\\n        // If the remaining target is 0, there\\'s one valid combination.\\n        if (remainingTarget == 0)\\n            return 1;\\n        \\n        // If the remaining target becomes negative, it\\'s not possible to reach it.\\n        if (remainingTarget < 0)\\n            return 0;\\n        \\n        // If the result for \\'remainingTarget\\' is already computed, return it.\\n        if (dp[remainingTarget] != -1)\\n            return dp[remainingTarget];\\n        \\n        int currentCombinations = 0;\\n        \\n        // Iterate through the numbers in \\'nums\\'.\\n        for (int i = 0; i < nums.length; i++) {\\n            int currentNum = nums[i];\\n            // Recursively calculate combinations for the new target.\\n            currentCombinations += countCombinations(nums, remainingTarget - currentNum);\\n        }\\n        \\n        // Store and return the computed result.\\n        return dp[remainingTarget] = currentCombinations;\\n    }\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        // Initialize the \\'dp\\' array with -1 to indicate uncomputed results.\\n        for (int i = 0; i < MAX_TARGET; i++) {\\n            dp[i] = -1;\\n        }\\n        \\n        // Start the combination count calculation.\\n        return countCombinations(nums, target);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    MAX_TARGET = 1010  # Maximum possible target value\\n\\n    def __init__(self):\\n        self.dp = [-1] * Solution.MAX_TARGET  # Array to store computed results\\n\\n    def countCombinations(self, nums, remainingTarget):\\n        # If the remaining target is 0, there\\'s one valid combination.\\n        if remainingTarget == 0:\\n            return 1\\n        \\n        # If the remaining target becomes negative, it\\'s not possible to reach it.\\n        if remainingTarget < 0:\\n            return 0\\n        \\n        # If the result for \\'remainingTarget\\' is already computed, return it.\\n        if self.dp[remainingTarget] != -1:\\n            return self.dp[remainingTarget]\\n        \\n        currentCombinations = 0\\n        \\n        # Iterate through the numbers in \\'nums\\'.\\n        for currentNum in nums:\\n            # Recursively calculate combinations for the new target.\\n            currentCombinations += self.countCombinations(nums, remainingTarget - currentNum)\\n        \\n        # Store and return the computed result.\\n        self.dp[remainingTarget] = currentCombinations\\n        return currentCombinations\\n\\n    def combinationSum4(self, nums, target):\\n        # Start the combination count calculation.\\n        return self.countCombinations(nums, target)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // dp[i] represents the number of combinations to make sum \\'i\\'\\n        vector<unsigned long long> dp(target + 1, 0);\\n        \\n        // There is one way to make sum 0, which is by not selecting any number.\\n        dp[0] = 1;\\n        \\n        for(int currentSum = 1; currentSum <= target; currentSum++) {\\n            for(int numIndex = 0; numIndex < nums.size(); numIndex++) {\\n                int currentNum = nums[numIndex];\\n                if(currentSum - currentNum >= 0) {\\n                    // dp[i] can be achieved by adding the combination count at dp[i - currentNum]\\n                    dp[currentSum] += dp[currentSum - currentNum];\\n                }\\n            }\\n        }\\n        \\n        // The final result is stored in dp[target]\\n        return dp[target];\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        // dp[i] represents the number of combinations to make sum \\'i\\'\\n        long[] dp = new long[target + 1];\\n        \\n        // There is one way to make sum 0, which is by not selecting any number.\\n        dp[0] = 1;\\n        \\n        for (int currentSum = 1; currentSum <= target; currentSum++) {\\n            for (int numIndex = 0; numIndex < nums.length; numIndex++) {\\n                int currentNum = nums[numIndex];\\n                if (currentSum - currentNum >= 0) {\\n                    // dp[i] can be achieved by adding the combination count at dp[i - currentNum]\\n                    dp[currentSum] += dp[currentSum - currentNum];\\n                }\\n            }\\n        }\\n        \\n        // The final result is stored in dp[target]\\n        return (int)dp[target];\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        # Initialize an array dp where dp[i] represents the number of combinations to make sum \\'i\\'.\\n        dp = [0] * (target + 1)\\n        \\n        # There is one way to make sum 0, which is by not selecting any number.\\n        dp[0] = 1\\n        \\n        # Iterate through the possible target sums from 1 to target.\\n        for currentSum in range(1, target + 1):\\n            # Iterate through the given numbers in nums.\\n            for numIndex in range(0, len(nums)):\\n                currentNum = nums[numIndex]\\n                # Check if subtracting currentNum from currentSum results in a non-negative value.\\n                if currentSum - currentNum >= 0:\\n                    # dp[i] can be achieved by adding the combination count at dp[i - currentNum].\\n                    dp[currentSum] += dp[currentSum - currentNum]\\n            \\n        # The final result is stored in dp[target].\\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380780,
                "title": "java-simple-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        Integer[] memo = new Integer[target + 1];\\n        return recurse(nums, target, memo);\\n    }\\n    \\n    public int recurse(int[] nums, int remain, Integer[] memo){\\n        \\n        if(remain < 0) return 0;\\n        if(memo[remain] != null) return memo[remain];\\n        if(remain == 0) return 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            ans += recurse(nums, remain - nums[i], memo);\\n        }\\n        \\n        memo[remain] = ans;\\n        return memo[remain];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        Integer[] memo = new Integer[target + 1];\\n        return recurse(nums, target, memo);\\n    }\\n    \\n    public int recurse(int[] nums, int remain, Integer[] memo){\\n        \\n        if(remain < 0) return 0;\\n        if(memo[remain] != null) return memo[remain];\\n        if(remain == 0) return 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            ans += recurse(nums, remain - nums[i], memo);\\n        }\\n        \\n        memo[remain] = ans;\\n        return memo[remain];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372950,
                "title": "tle-to-100-beat-optimisation-step-by-step-7-solutions",
                "content": "Hi guys,\\nWould like to share how i achieve this solution from TLE to 100% beat in both time and memory. \\nI did it step by step by following a \"bottel neck\" rule. \\nSharing so that some one else can learn from it.\\n\\nP.S. This is going to be long post, but u\\'ll learn alot. \\n\\n**Algo: Backtracking**\\n---------\\n Extending the previous solutions of Combination Sum. [https://leetcode.com/problems/combination-sum/discuss/372414/100-beat-or-Two-variation-or-Full-explanation-or-DFS]\\nDifference here is: We need to try every possibility. A number from given candidate array can be placed anywhere in ths solution list.\\n\\n<details>\\n\\n```\\n  static class CombinationSumIVReverseBacktrackingDFS {\\n\\n        public int combinationSum4(int[] candidates, int target) {\\n\\n            if (candidates == null || candidates.length == 0)\\n                return 0;\\n\\n            return combinationSum4(candidates, 0, target);\\n        }\\n\\n        private int combinationSum4(int[] candidates, int i, int target) {\\n\\n            //Our constraints : We can\\'t go beyond target, we can take more element than available in array\\n            if (i >= candidates.length)\\n                return 0;\\n\\n\\n            //3. Our goal: when currentSum = target\\n            if (0 == target) {\\n\\n                return 1;\\n            }\\n\\n            int res = 0;\\n            //1. Our choices: We can choose a number from the list any number of times and all the numbers\\n            for (int s = 0; s < candidates.length; s++) {\\n\\n                //Our constraints : We can\\'t go beyond target, we can take more element than available in array\\n                if (target - candidates[s] >= 0) {\\n                    target -= candidates[s];\\n\\n                    res += combinationSum4(candidates, s, target);\\n\\n                    //backtrack\\n                    target += candidates[s];\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```\\n\\n</details>\\n\\nBottole neck: 2^n recursion trees. If you draw this tree, you\\'ll see many overlapping sub-problems\\nSolution: Cache it \\n\\n<details>\\n\\n```\\n /**\\n     * Repeated problems, cache it\\n     */\\n    static class CombinationSumIVBacktrackingMemo {\\n\\n        public int combinationSum4(int[] candidates, int target) {\\n\\n            if (candidates == null || candidates.length == 0)\\n                return 0;\\n\\n            int memo[] = new int[target + 1];\\n            Arrays.fill(memo, -1);\\n            return combinationSum4(candidates, 0, target, memo);\\n        }\\n\\n        private int combinationSum4(int[] candidates, int i, int target, int memo[]) {\\n\\n            //Our constraints : We can\\'t go beyond target, we can take more element than available in array\\n            if (i >= candidates.length)\\n                return 0;\\n\\n\\n            //3. Our goal: when currentSum = target\\n            if (0 == target) {\\n\\n                return 1;\\n            }\\n\\n            if (memo[target] != -1)\\n                return memo[target];\\n\\n            int res = 0;\\n            //1. Our choices: We can choose a number from the list any number of times and all the numbers\\n            for (int s = 0; s < candidates.length; s++) {\\n\\n                //Our constraints : We can\\'t go beyond target, we can take more element than available in array\\n                if (target - candidates[s] >= 0) {\\n                    target -= candidates[s];\\n\\n                    res += combinationSum4(candidates, s, target, memo);\\n\\n                    //backtrack\\n                    target += candidates[s];\\n                }\\n            }\\n            return memo[target] = res;\\n        }\\n    }\\n```\\n</details>\\n\\n**Algo: Relations based**\\n----------------\\nBig problem above is,\" backtracking\" step. How do we should avoid it?\\n\\nLets do analysis of the problem. \\nImportant facts:\\n1. A number from nums won\\'t be included if its greater than target; As it will never help us to reach the goal\\n2. We need to find, how many ways a number from nums <=target, can contribute in our total number of solutions\\nBy extending the 2nd fact, we can think in the direction that, if we somehow find, how many ways a number can be participent in our solution set then we can re-utilize that solution [this is what we did in above memo based solution]. \\nNow, take an example \\n[1,2,3]; target=4\\nelement =1 would be partiticipating in 4-1=3 ways in our solution at least\\n(1, 1, 1, 1) <- 1\\n(1, 1, 2) <- 2\\n(1, 2, 1) <-3\\n(1, 3) <-4\\n(2, 1, 1) <- 5\\n(2, 2)\\n(3, 1) <-6\\n\\nSimilarly element =2 would be partiticipating in 4-2=2 ways in our solution at least.\\nBut after reducing problem from 4 to 2 {using element 2 ; 4-2=2} then our problem again may utilize the previous tested numbers {in our case as of now element = 1 }.\\n\\nHence; \\n```\\ncombination[target] = Sum {combination[target-nums[i]] } where target>=nums[i]\\n\\nin our example:\\ncombination[4] = combination[4-1] + combination[4-2] + combination[4-3] = combination[3] + combination[2] + combination[1].\\n```\\nNow, what is the base case; When target = 0; in this case, if we simply choose no numbers from nums, then answer would be 1;\\ncombination[0] = 1\\n\\n\\nOur releationship is \\n\\n```\\n Recurrence relation\\n    combination[target] = {\\n        sum(combination[target - nums[i]]) target>=nums[i]\\n        1: when target=0,\\n    }\\n```\\n\\n\\n\\nRecursive implementation \\nSimilar to CoinChangeProblem https://leetcode.com/problems/coin-change-2/\\n-----------------\\n\\n<details>\\n\\n\\n```\\n/**\\n     * Recurrence relation\\n     * *     comb[target] = {\\n     * *         sum(comb[target - nums[i]]) target> 0\\n     * *         1: when target=0,\\n     * *     }\\n     * <p>\\n     * Complexity: O(n*2^n)\\n     */\\n    static class CombinationSumIVRecursive {\\n\\n\\n        public int combinationSum4(int[] nums, int target) {\\n\\n            if (nums == null || nums.length == 0)\\n                return 0;\\n\\n            //base case\\n            if (target == 0)\\n                return 1;\\n\\n            int res = 0;\\n            for (int i = 0; i < nums.length; i++)\\n                if (target >= nums[i])\\n                    res += combinationSum4(nums, target - nums[i]);\\n\\n            return res;\\n        }\\n\\n\\n    }\\n```\\n\\n</details>\\n\\n\\n**Top-Down:** Many sub-problem, cache it\\n\\n<details>\\n\\n```\\n /**\\n     * Recurrence relation\\n     * *     comb[target] = {\\n     * *         sum(comb[target - nums[i]]) target> 0\\n     * *         1: when target=0,\\n     * *     }\\n     * Overlapping sub-problems; cache it\\n     * Complexity: O(n*n)\\n     */\\n    static class CombinationSumIVTopDown {\\n\\n        public int combinationSum4(int[] nums, int target) {\\n            if (nums == null || nums.length == 0)\\n                return 0;\\n            int dp[] = new int[target + 1];\\n            Arrays.fill(dp, -1);\\n            return combinationSum4(nums, target, dp);\\n        }\\n\\n\\n        public int combinationSum4(int[] nums, int target, int dp[]) {\\n            if (target < 0)\\n                return 0;\\n\\n            //base case\\n            if (target == 0)\\n                return 1;\\n\\n            if (dp[target] != -1)\\n                return dp[target];\\n\\n            int res = 0;\\n            for (int i = 0; i < nums.length; i++) //O(n)\\n                if (target >= nums[i])\\n                    res += combinationSum4(nums, target - nums[i]); //O(n)\\n\\n            return dp[target] = res;\\n        }\\n\\n\\n    }\\n\\n```\\n\\n</details>\\n\\n**Bottom Up :** \\n\\n<details>\\n\\n```\\n /**\\n     * Recurrence relation\\n     * *     comb[target] = {\\n     * *         sum(comb[target - nums[i]]) target> 0\\n     * *         1: when target=0,\\n     * *     }\\n     * =>\\n     * dp[i] denotes number of ways to make sum=i using all nums\\n     * <p>\\n     * dp[i] = {\\n     * *        Sum { dp[target - nums[j] ; target>= nums[j] ; j<=0<=nums.length}\\n     * *        1: target = 0\\n     * * }\\n     * memory: dp[target+1]\\n     * Result: dp[target]\\n     * <p>\\n     * <p>\\n     * Complexity: O(n*n)\\n     * <p>\\n     * Runtime: 1 ms, faster than 84.17% of Java online submissions for Combination Sum IV.\\n     * Memory Usage: 34 MB, less than 100.00% of Java online submissions for Combination Sum IV.\\n     */\\n    static class CombinationSumIVBottomUp {\\n\\n        public int combinationSum4(int[] nums, final int Target) {\\n            if (nums == null || nums.length == 0)\\n                return 0;\\n\\n\\n            int dp[] = new int[Target + 1];\\n            //base case\\n            dp[0] = 1;\\n\\n            for (int target = 1; target <= Target; target++) {\\n\\n                for (int j = 0; j < nums.length; j++) {\\n\\n                    if (target >= nums[j])\\n                        dp[target] += dp[target - nums[j]];\\n                }\\n            }\\n\\n            return dp[Target];\\n        }\\n\\n\\n    }\\n```\\n\\n</details>\\n\\n\\nAfter above, i realized that it should be fastest. But you see its just 84.17%  beat. \\nThen, i thought instead of doing reverse (target -> 0), doing forward (sum -> target) would be fastest. \\nAs sum grows towards target faster than target shrink towards 0. \\n\\n* Runtime: 0 ms, faster than 100.00% of Java online submissions for Combination Sum IV.\\n* Memory Usage: 34.2 MB, less than 100.00% of Java online submissions for Combination Sum IV.\\n```\\n/**\\n     * Recurrence relation\\n     * *     comb[target] = {\\n     * *         sum(comb[target - nums[i]]) target> 0\\n     * *         1: when target=0,\\n     * *     }\\n     * Overlapping sub-problems; cache it\\n     * Complexity: O(n*n)\\n     * <p>\\n     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Combination Sum IV.\\n     * Memory Usage: 34.2 MB, less than 100.00% of Java online submissions for Combination Sum IV.\\n     */\\n    static class CombinationSumIVTopDownV2 {\\n\\n        public int combinationSum4(int[] nums, int target) {\\n            if (nums == null || nums.length == 0)\\n                return 0;\\n            int dp[] = new int[target + 1];\\n            Arrays.fill(dp, -1);\\n            return combinationSum4(nums, 0, target, dp);\\n        }\\n\\n\\n        public int combinationSum4(int[] nums, int currSum, int target, int dp[]) {\\n            if (currSum > target)\\n                return 0;\\n\\n            //base case\\n            if (target == currSum)\\n                return 1;\\n\\n            if (dp[currSum] != -1)\\n                return dp[currSum];\\n\\n            int res = 0;\\n            for (int i = 0; i < nums.length; i++) //O(n)\\n                res += combinationSum4(nums, currSum + nums[i], target, dp); //O(n)\\n\\n            return dp[currSum] = res;\\n        }\\n\\n\\n    }\\n```\\n\\nRef: \\nhttps://leetcode.com/problems/coin-change-2/\\n\\nCombination Sum I . [https://leetcode.com/problems/combination-sum/discuss/372414/100-beat-or-Two-variation-or-Full-explanation-or-DFS]\\n\\nCombinationalSum II: https://leetcode.com/problems/combination-sum-ii/discuss/372471/Various-solution-or-Java-or-DFS-or-Reverse-DFS-or-100-beat\\n\\nCombinationalSum III: https://leetcode.com/problems/combination-sum-iii/discuss/372491/Simple-or-clean-or-Easy-to-understand-or-100-beat\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n  static class CombinationSumIVReverseBacktrackingDFS {\\n\\n        public int combinationSum4(int[] candidates, int target) {\\n\\n            if (candidates == null || candidates.length == 0)\\n                return 0;\\n\\n            return combinationSum4(candidates, 0, target);\\n        }\\n\\n        private int combinationSum4(int[] candidates, int i, int target) {\\n\\n            //Our constraints : We can\\'t go beyond target, we can take more element than available in array\\n            if (i >= candidates.length)\\n                return 0;\\n\\n\\n            //3. Our goal: when currentSum = target\\n            if (0 == target) {\\n\\n                return 1;\\n            }\\n\\n            int res = 0;\\n            //1. Our choices: We can choose a number from the list any number of times and all the numbers\\n            for (int s = 0; s < candidates.length; s++) {\\n\\n                //Our constraints : We can\\'t go beyond target, we can take more element than available in array\\n                if (target - candidates[s] >= 0) {\\n                    target -= candidates[s];\\n\\n                    res += combinationSum4(candidates, s, target);\\n\\n                    //backtrack\\n                    target += candidates[s];\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```\n```\\n /**\\n     * Repeated problems, cache it\\n     */\\n    static class CombinationSumIVBacktrackingMemo {\\n\\n        public int combinationSum4(int[] candidates, int target) {\\n\\n            if (candidates == null || candidates.length == 0)\\n                return 0;\\n\\n            int memo[] = new int[target + 1];\\n            Arrays.fill(memo, -1);\\n            return combinationSum4(candidates, 0, target, memo);\\n        }\\n\\n        private int combinationSum4(int[] candidates, int i, int target, int memo[]) {\\n\\n            //Our constraints : We can\\'t go beyond target, we can take more element than available in array\\n            if (i >= candidates.length)\\n                return 0;\\n\\n\\n            //3. Our goal: when currentSum = target\\n            if (0 == target) {\\n\\n                return 1;\\n            }\\n\\n            if (memo[target] != -1)\\n                return memo[target];\\n\\n            int res = 0;\\n            //1. Our choices: We can choose a number from the list any number of times and all the numbers\\n            for (int s = 0; s < candidates.length; s++) {\\n\\n                //Our constraints : We can\\'t go beyond target, we can take more element than available in array\\n                if (target - candidates[s] >= 0) {\\n                    target -= candidates[s];\\n\\n                    res += combinationSum4(candidates, s, target, memo);\\n\\n                    //backtrack\\n                    target += candidates[s];\\n                }\\n            }\\n            return memo[target] = res;\\n        }\\n    }\\n```\n```\\ncombination[target] = Sum {combination[target-nums[i]] } where target>=nums[i]\\n\\nin our example:\\ncombination[4] = combination[4-1] + combination[4-2] + combination[4-3] = combination[3] + combination[2] + combination[1].\\n```\n```\\n Recurrence relation\\n    combination[target] = {\\n        sum(combination[target - nums[i]]) target>=nums[i]\\n        1: when target=0,\\n    }\\n```\n```\\n/**\\n     * Recurrence relation\\n     * *     comb[target] = {\\n     * *         sum(comb[target - nums[i]]) target> 0\\n     * *         1: when target=0,\\n     * *     }\\n     * <p>\\n     * Complexity: O(n*2^n)\\n     */\\n    static class CombinationSumIVRecursive {\\n\\n\\n        public int combinationSum4(int[] nums, int target) {\\n\\n            if (nums == null || nums.length == 0)\\n                return 0;\\n\\n            //base case\\n            if (target == 0)\\n                return 1;\\n\\n            int res = 0;\\n            for (int i = 0; i < nums.length; i++)\\n                if (target >= nums[i])\\n                    res += combinationSum4(nums, target - nums[i]);\\n\\n            return res;\\n        }\\n\\n\\n    }\\n```\n```\\n /**\\n     * Recurrence relation\\n     * *     comb[target] = {\\n     * *         sum(comb[target - nums[i]]) target> 0\\n     * *         1: when target=0,\\n     * *     }\\n     * Overlapping sub-problems; cache it\\n     * Complexity: O(n*n)\\n     */\\n    static class CombinationSumIVTopDown {\\n\\n        public int combinationSum4(int[] nums, int target) {\\n            if (nums == null || nums.length == 0)\\n                return 0;\\n            int dp[] = new int[target + 1];\\n            Arrays.fill(dp, -1);\\n            return combinationSum4(nums, target, dp);\\n        }\\n\\n\\n        public int combinationSum4(int[] nums, int target, int dp[]) {\\n            if (target < 0)\\n                return 0;\\n\\n            //base case\\n            if (target == 0)\\n                return 1;\\n\\n            if (dp[target] != -1)\\n                return dp[target];\\n\\n            int res = 0;\\n            for (int i = 0; i < nums.length; i++) //O(n)\\n                if (target >= nums[i])\\n                    res += combinationSum4(nums, target - nums[i]); //O(n)\\n\\n            return dp[target] = res;\\n        }\\n\\n\\n    }\\n\\n```\n```\\n /**\\n     * Recurrence relation\\n     * *     comb[target] = {\\n     * *         sum(comb[target - nums[i]]) target> 0\\n     * *         1: when target=0,\\n     * *     }\\n     * =>\\n     * dp[i] denotes number of ways to make sum=i using all nums\\n     * <p>\\n     * dp[i] = {\\n     * *        Sum { dp[target - nums[j] ; target>= nums[j] ; j<=0<=nums.length}\\n     * *        1: target = 0\\n     * * }\\n     * memory: dp[target+1]\\n     * Result: dp[target]\\n     * <p>\\n     * <p>\\n     * Complexity: O(n*n)\\n     * <p>\\n     * Runtime: 1 ms, faster than 84.17% of Java online submissions for Combination Sum IV.\\n     * Memory Usage: 34 MB, less than 100.00% of Java online submissions for Combination Sum IV.\\n     */\\n    static class CombinationSumIVBottomUp {\\n\\n        public int combinationSum4(int[] nums, final int Target) {\\n            if (nums == null || nums.length == 0)\\n                return 0;\\n\\n\\n            int dp[] = new int[Target + 1];\\n            //base case\\n            dp[0] = 1;\\n\\n            for (int target = 1; target <= Target; target++) {\\n\\n                for (int j = 0; j < nums.length; j++) {\\n\\n                    if (target >= nums[j])\\n                        dp[target] += dp[target - nums[j]];\\n                }\\n            }\\n\\n            return dp[Target];\\n        }\\n\\n\\n    }\\n```\n```\\n/**\\n     * Recurrence relation\\n     * *     comb[target] = {\\n     * *         sum(comb[target - nums[i]]) target> 0\\n     * *         1: when target=0,\\n     * *     }\\n     * Overlapping sub-problems; cache it\\n     * Complexity: O(n*n)\\n     * <p>\\n     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Combination Sum IV.\\n     * Memory Usage: 34.2 MB, less than 100.00% of Java online submissions for Combination Sum IV.\\n     */\\n    static class CombinationSumIVTopDownV2 {\\n\\n        public int combinationSum4(int[] nums, int target) {\\n            if (nums == null || nums.length == 0)\\n                return 0;\\n            int dp[] = new int[target + 1];\\n            Arrays.fill(dp, -1);\\n            return combinationSum4(nums, 0, target, dp);\\n        }\\n\\n\\n        public int combinationSum4(int[] nums, int currSum, int target, int dp[]) {\\n            if (currSum > target)\\n                return 0;\\n\\n            //base case\\n            if (target == currSum)\\n                return 1;\\n\\n            if (dp[currSum] != -1)\\n                return dp[currSum];\\n\\n            int res = 0;\\n            for (int i = 0; i < nums.length; i++) //O(n)\\n                res += combinationSum4(nums, currSum + nums[i], target, dp); //O(n)\\n\\n            return dp[currSum] = res;\\n        }\\n\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294990,
                "title": "python-dp-beats-97-speed-and-91-memory-with-explanation",
                "content": "**Explanation:** Take the example in the question, where nums is [1, 2, 3] and the target is 4. Here\\'s how you would build the solution bottom up by starting with the ways you can make a total of 1, then the number of ways you can make a total of 2, and so on up to 4:\\n\\n1 -> [1]\\n2 -> [1, 1], [2]\\n3 -> [1, 1, 1], [1, 2], [2, 1], [3]\\n4 -> [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\\n\\nSince we just need the counts, not the actual combinations, this can be simplified to the following DP algorithm:\\n\\n**Pre-Step**: Initialize the DP array to be 1 for each number in nums (since you can trivially make that total by just using that number itself) and 0 otherwise.\\nDP = [0, 1, 1, 1, 0]\\n\\nNow for each number on the way to our target, call that sub-target ***t_sub***. See how many ways we can make ***t_sub*** by taking each number ***n*** in nums and checking how many ways we were able to make ***t_sub*** -  ***n*** then adding that to the DP entry for ***t_sub***.\\n\\n**Step 1**:\\n\\t***t_sub*** = 1\\n\\t***t_sub*** - 1 = 0 so add nothing\\n\\t***t_sub*** - 2 < 0 so add nothing\\n\\t***t_sub*** - 3 < 0 so add nothing\\n\\tDP = [0, 1, 1, 1, 0]\\n\\t\\n**Step 2**:\\n\\t***t_sub*** = 2\\n\\t***t_sub*** - 1 = 1 so DP[2] += DP[1] and is now 2\\n\\t***t_sub*** - 2 = 0 so add nothing\\n\\t***t_sub*** - 3 < 0 so add nothing\\n\\tDP = [0, 1, 2, 1, 0]\\n\\t\\n**Step 3**:\\n\\t***t_sub*** = 3\\n\\t***t_sub*** - 1 = 2 so DP[3] += DP[2] and is now 3\\n\\t***t_sub*** - 2  = 1 so DP[3] += DP[1] and is now 4\\n\\t***t_sub*** - 3 = 0 so add nothing\\n\\tDP = [0, 1, 2, 4, 0]\\n\\t\\n**Step 4**:\\n\\t***t_sub*** = 4\\n\\t***t_sub*** - 1 = 3 so DP[4] += DP[3] and is now 4\\n\\t***t_sub*** - 2  = 2 so DP[4] += DP[2] and is now 6\\n\\t***t_sub*** - 3 = 1 so DP[4] += DP[1] and is now 7\\n\\tDP = [0, 1, 2, 4, 7]\\n\\t\\nNow we are finished, so return DP[-1], which is the number of ways we can make ***t_sub*** when ***t_sub*** is the target.\\n\\t\\n\\n\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (1+target)\\n        for num in nums:\\n            if num <= target:\\n                dp[num] = 1\\n        for i in range(target+1):\\n            for num in nums:\\n                if i - num > 0:\\n                    dp[i] += dp[i-num]\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (1+target)\\n        for num in nums:\\n            if num <= target:\\n                dp[num] = 1\\n        for i in range(target+1):\\n            for num in nums:\\n                if i - num > 0:\\n                    dp[i] += dp[i-num]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381170,
                "title": "3-ways-easy-to-understand-simple-code-recursion-recursion-memoization-tabulation",
                "content": "**//DO UPVOTE IF YOU LIKE THE SOLUTION :)**\\n\\n**RECURSION :(NOT ACCEPTED)**\\n```\\nclass Solution {\\npublic:\\n    int noOfWays(vector<int> &nums, int target, int index, int size)\\n    {\\n        if(target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        int ways = 0;   //NO. OF WAYS IN WHICH WE CAN FIND THE TARGET.\\n        for(int i = 0; i<size; i++)\\n        {\\n            ways += noOfWays(nums, target - nums[i], i, size);\\n        }\\n        return ways;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        return noOfWays(nums, target, 0, nums.size());\\n    }\\n};\\n```\\n**RECURSION + MEMOIZATION :**\\n```\\nclass Solution {\\npublic:\\n    int noOfWays(vector<int> &nums, int target, int size, vector<int> &dp)\\n    {\\n        if(target < 0) return 0; \\n        if(target == 0) return 1;\\n        if(dp[target] != -1) return dp[target]; //IF WE ALREADY CALCULATED THE TARGET\\n        \\n        int ways = 0;   //NO. OF WAYS IN WHICH WE CAN FIND THE TARGET.\\n        for(int i = 0; i<size; i++)\\n        {\\n            ways += noOfWays(nums, target - nums[i], size, dp);\\n        }\\n        dp[target] = ways;  //BEFORE RETURNING STORE THE WAYS IN THE dp[];\\n        return ways;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp (target+1, -1); //STORE THE NO OF WAYS IN WHICH WE GET ith INDEX SUM;\\n        return noOfWays(nums, target, nums.size(), dp);\\n    }\\n};\\n```\\n\\n**TABULATION :**\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp (target+1, 0); //STORE THE NO OF WAYS IN WHICH WE GET ith INDEX SUM;\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++)\\n        {\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(i - nums[j] >= 0) //IF INDEX IS PRESENT i.e. INDEX SHOULD BE GREATER THAN OR EQUAL TO 0.\\n                    dp[i] += dp[i - nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\\n**//DO UPVOTE IF YOU LIKE THE SOLUTION :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int noOfWays(vector<int> &nums, int target, int index, int size)\\n    {\\n        if(target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        int ways = 0;   //NO. OF WAYS IN WHICH WE CAN FIND THE TARGET.\\n        for(int i = 0; i<size; i++)\\n        {\\n            ways += noOfWays(nums, target - nums[i], i, size);\\n        }\\n        return ways;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        return noOfWays(nums, target, 0, nums.size());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int noOfWays(vector<int> &nums, int target, int size, vector<int> &dp)\\n    {\\n        if(target < 0) return 0; \\n        if(target == 0) return 1;\\n        if(dp[target] != -1) return dp[target]; //IF WE ALREADY CALCULATED THE TARGET\\n        \\n        int ways = 0;   //NO. OF WAYS IN WHICH WE CAN FIND THE TARGET.\\n        for(int i = 0; i<size; i++)\\n        {\\n            ways += noOfWays(nums, target - nums[i], size, dp);\\n        }\\n        dp[target] = ways;  //BEFORE RETURNING STORE THE WAYS IN THE dp[];\\n        return ways;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp (target+1, -1); //STORE THE NO OF WAYS IN WHICH WE GET ith INDEX SUM;\\n        return noOfWays(nums, target, nums.size(), dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp (target+1, 0); //STORE THE NO OF WAYS IN WHICH WE GET ith INDEX SUM;\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++)\\n        {\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(i - nums[j] >= 0) //IF INDEX IS PRESENT i.e. INDEX SHOULD BE GREATER THAN OR EQUAL TO 0.\\n                    dp[i] += dp[i - nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380899,
                "title": "c-0ms-better-than-100-comments-dp-solution",
                "content": "Please upvote if helpful\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int help(vector<int> &nums, int T, int n){\\n\\t\\t// base case: if target is 0, we found combination then return 1\\n        if(T==0) return 1;\\n        int ans=0; \\n\\t\\t\\n\\t\\t// memoisation\\n        if(dp[T]!=-1) return dp[T];\\n\\t\\t\\n\\t\\t// picking up each elements less than target and \\n\\t\\t// calling this function recursively\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=T){\\n                ans+=help(nums, T-nums[i], n);\\n            }\\n        }\\n        return dp[T]= ans;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\t\\t// resizing the dp array to store values from 0 to target\\n        dp.resize(target+1,-1);\\n        return help(nums, target, n);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/e3f5574c-d885-4075-80e1-c744a9937b71_1659665561.9926245.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int help(vector<int> &nums, int T, int n){\\n\\t\\t// base case: if target is 0, we found combination then return 1\\n        if(T==0) return 1;\\n        int ans=0; \\n\\t\\t\\n\\t\\t// memoisation\\n        if(dp[T]!=-1) return dp[T];\\n\\t\\t\\n\\t\\t// picking up each elements less than target and \\n\\t\\t// calling this function recursively\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=T){\\n                ans+=help(nums, T-nums[i], n);\\n            }\\n        }\\n        return dp[T]= ans;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\t\\t// resizing the dp array to store values from 0 to target\\n        dp.resize(target+1,-1);\\n        return help(nums, target, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020260,
                "title": "video-beats-97-25-python-javascript-java-and-c",
                "content": "# Intuition\\nUse Dynamic Programming. This Python solution beats 97.25% today.\\n\\n![Screen Shot 2023-09-09 at 16.24.58.png](https://assets.leetcode.com/users/images/1520e756-0b21-4cfe-af67-6d540c15186c_1694244381.575153.png)\\n\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 257 videos as of September 9th, 2023.\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/uRHHc6hunls\\nVolume of the video may be a little bit low. Please turn up the volume on your computer a bit. Thank you for your support.\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2263\\nThank you for your support!\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n**1. Initialize the Dynamic Programming (DP) array**\\n   - Create a DP array `dp` of size `(target + 1)` and initialize all elements to 0.\\n   - Set `dp[0]` to 1 to represent that there is one way to make a sum of 0, which is by not selecting any number from `nums`.\\n\\n**2. Iterate through numbers from 1 to target**\\n   - Start a loop from `1` to `target` (inclusive).\\n   \\n**3. Inner Loop through each number in the `nums` array**\\n   - Start another loop to iterate through each number `n` in the `nums` array.\\n\\n**4. Check if the current number `n` is less than or equal to the current target `i`**\\n   - Within the inner loop, check if the current number `n` is less than or equal to the current target `i`.\\n\\n**5. Update DP array**\\n   - If `n` is less than or equal to `i`, then update `dp[i]` by adding the value of `dp[i - n]`. This step accumulates the number of ways to reach the target `i` by considering the current number `n`.\\n\\n**6. Continue iterating**\\n   - Continue the outer loop, iterating through all possible target values from `1` to `target`, and for each target, iterate through the numbers in the `nums` array.\\n\\n**7. Return the result**\\n   - After completing both loops, return `dp[-1]`, which represents the total number of ways to make the target sum `target` using the numbers from the `nums` array.\\n\\nIn summary, this code uses dynamic programming to find the number of combinations that sum up to the target value using the given `nums` array. It builds up a DP array where each element represents the number of ways to reach a specific target value by considering all possible combinations of numbers from `nums`.\\n\\n# Complexity\\nThis is based on Python Code. Other languages might be differnt.\\n\\n- Time complexity: O(TN)\\nT is the target value and N is the length of the nums array. This is because we are iterating over all possible target values from 1 to T, and for each target value, we are iterating over all numbers in the nums array that are less than or equal to the current target value.\\n\\n- Space complexity: O(T)\\nWe are creating a DP array of size T+1 to store the number of ways to make each target value. The rest of the variables used in the function are constant space, as they do not depend on the input size.\\n\\n\\n```python []\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n\\n        for i in range(1, target + 1):\\n            for n in nums:\\n                if n <= i:\\n                    dp[i] += dp[i-n]\\n        \\n        return dp[-1]\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar combinationSum4 = function(nums, target) {\\n    const dp = new Array(target + 1).fill(0);\\n    dp[0] = 1;\\n\\n    for (let i = 1; i <= target; i++) {\\n        for (const n of nums) {\\n            if (n <= i) {\\n                dp[i] += dp[i - n];\\n            }\\n        }\\n    }\\n\\n    return dp[target];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n\\n        for (int i = 1; i <= target; i++) {\\n            for (int n : nums) {\\n                if (n <= i) {\\n                    dp[i] += dp[i - n];\\n                }\\n            }\\n        }\\n\\n        return dp[target];        \\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<long long int>dp(target + 1, 0);\\n        dp[0] = 1;\\n\\n        for(int i = 1; i <= target; i++){\\n            for(auto value : nums){\\n                if(i - value >= 0 && dp[i] <= INT_MAX)\\n                  dp[i] += (long long int)dp[i - value];   \\n            }\\n        }\\n        \\n        return  dp[target];        \\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\nI started creating basic programming course with Python. This is the first video I created yesterday. Please check if you like.\\n\\nhttps://youtu.be/yb3_1LV5A0U\\n\\n## Thank you for reading the article! Have a nice day!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n\\n        for i in range(1, target + 1):\\n            for n in nums:\\n                if n <= i:\\n                    dp[i] += dp[i-n]\\n        \\n        return dp[-1]\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar combinationSum4 = function(nums, target) {\\n    const dp = new Array(target + 1).fill(0);\\n    dp[0] = 1;\\n\\n    for (let i = 1; i <= target; i++) {\\n        for (const n of nums) {\\n            if (n <= i) {\\n                dp[i] += dp[i - n];\\n            }\\n        }\\n    }\\n\\n    return dp[target];    \\n};\\n```\n```java []\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n\\n        for (int i = 1; i <= target; i++) {\\n            for (int n : nums) {\\n                if (n <= i) {\\n                    dp[i] += dp[i - n];\\n                }\\n            }\\n        }\\n\\n        return dp[target];        \\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<long long int>dp(target + 1, 0);\\n        dp[0] = 1;\\n\\n        for(int i = 1; i <= target; i++){\\n            for(auto value : nums){\\n                if(i - value >= 0 && dp[i] <= INT_MAX)\\n                  dp[i] += (long long int)dp[i - value];   \\n            }\\n        }\\n        \\n        return  dp[target];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020358,
                "title": "python-dynamic-programming-98-87",
                "content": "# Python | Dynamic Programming | 98.87%\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i - num >= 0:\\n                    dp[i] += dp[i - num]\\n                    \\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i - num >= 0:\\n                    dp[i] += dp[i - num]\\n                    \\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701806,
                "title": "comparing-coin-change-2-and-combination-sum-4",
                "content": "First thing we need to understand is what is  permutation and combination ?\\nIn permutations - (1,1,2) ,(1,2,1),(2,,1,1) are treated as different and counted\\nwhere as in combinations all these are considered same.\\nThe question is combination sum 4 but we need to print the permutation count \\n\\nNow coming to the coin change 2 and this problem\\n\\nIn coin change 2 we are using combinations and combination sum 4 we are using permutations\\ncoin change 2 solution \\n```\\nclass Solution {\\n    public int change(int amount, int[] coins) {\\n        return fn(amount,coins,0,new HashMap<String,Integer>());\\n        \\n    }\\n    int fn(int amount,int[] coins,int ci,HashMap<String,Integer> memo)\\n    {\\n        if(ci>=coins.length||amount<=0)\\n           return (amount==0)?1:0;\\n        String currentKey = Integer.toString(ci)+\\'_\\'+Integer.toString(amount);\\n        if(memo.containsKey(currentKey))\\n            return memo.get(currentKey);\\n        int consider = fn(amount-coins[ci],coins,ci,memo);\\n        int notConsider = fn(amount,coins,ci+1,memo);\\n        memo.put(currentKey,consider+notConsider);\\n        return consider+notConsider;\\n    }\\n}\\n```\\nNow coming to combination sum 4 code\\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        return fn(nums,target,0,new HashMap<Integer,Integer>());\\n        \\n    }\\n   public int fn(int[] nums,int target,int ci,HashMap<Integer,Integer> memo)\\n    {\\n        if(ci>=nums.length||target<=0)\\n           return (target==0)?1:0;\\n        \\n        int currentKey = target;\\n        if(memo.containsKey(currentKey))\\n            return memo.get(currentKey);\\n        \\n       int consider = fn(nums,target-nums[ci],0,memo);\\n        int notConsider = fn(nums,target,ci+1,memo);\\n        \\n        memo.put(currentKey,consider+notConsider);\\n        return consider+notConsider;\\n    }\\n}\\n```\\nThe difference is in coin change 2 , currentKey is dependent on two values(2d DP)  on currentIndex and amount \\nwhereas in combinationSum 4 our currentKey is dependent on only target(1d DP)\\n and in the consider call we are passing zero instead of currentIndex\\n Let me explain you this with an example\\n[1,2,5] target = 5\\nIn coin change 2 the possible outcomes are\\n[1,1,1,1,1]\\n[1,2,2]\\n[1,1,1,2]\\n[5]\\nIn the above case the output is 4 (4 ways to make the required amount as 5)\\nNow in combination sum 4 the possible outcomes are\\n[1,1,1,1,1]\\n[1,2,2]\\n[2,2,1]\\n[1,1,1,2]\\n[1,2,1,1]\\n[1,1,2,1]\\n[2,1,1,1]\\n[5]\\nThese are the 9 cases\\nNow if you clearly once we selected 1 and moved to next index 2 as in combination [1,2,2]\\nnums =[1,2,5]\\nindex =0 1 2\\nin this case at the 0 index we didn\\'t consider and moved to index 1 that is element 2\\nagain we are coming back to index and considering the element 1 so the combination [2,2,1]\\nIf we start from currentIndex (ci) then we are always moving ahead but here we need to count all the rearrangements\\nthat\\'s why we are including 0 instead of currentIndex\\n\\nHope this clarifies\\n \\n Also you can use 2d array in coin change 2 and 1d array in this problem respectively\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int change(int amount, int[] coins) {\\n        return fn(amount,coins,0,new HashMap<String,Integer>());\\n        \\n    }\\n    int fn(int amount,int[] coins,int ci,HashMap<String,Integer> memo)\\n    {\\n        if(ci>=coins.length||amount<=0)\\n           return (amount==0)?1:0;\\n        String currentKey = Integer.toString(ci)+\\'_\\'+Integer.toString(amount);\\n        if(memo.containsKey(currentKey))\\n            return memo.get(currentKey);\\n        int consider = fn(amount-coins[ci],coins,ci,memo);\\n        int notConsider = fn(amount,coins,ci+1,memo);\\n        memo.put(currentKey,consider+notConsider);\\n        return consider+notConsider;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        return fn(nums,target,0,new HashMap<Integer,Integer>());\\n        \\n    }\\n   public int fn(int[] nums,int target,int ci,HashMap<Integer,Integer> memo)\\n    {\\n        if(ci>=nums.length||target<=0)\\n           return (target==0)?1:0;\\n        \\n        int currentKey = target;\\n        if(memo.containsKey(currentKey))\\n            return memo.get(currentKey);\\n        \\n       int consider = fn(nums,target-nums[ci],0,memo);\\n        int notConsider = fn(nums,target,ci+1,memo);\\n        \\n        memo.put(currentKey,consider+notConsider);\\n        return consider+notConsider;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122873,
                "title": "c-overflow-issue-explained",
                "content": "Many of you in the bottom up implementation, might have observed that the last testcase causes a runtime error due to integer overflow. Although the question states that the answer will always fit in the 32 bit integer range. \\n\\nRef: https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/5355\\n\\nThis is because the final answer dp[target] surely fits in the 32 bit range of the integer. But the intermediate results `dp[target-1]` or `dp[target-2]` .... or `dp[target-k]` could be greater than `INT_MAX` and would be causing the overflow. \\n\\nOne way to solve this could be to have a check before adding that if `dp[target-k]` is greater than `INT_MAX`.\\nThe easiest way is to use unsigned_int since it wraps around after the overflow.\\n\\n\\nC++ Code for handling overflow : \\n\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<unsigned int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int i=1; i<=target; ++i){\\n            for(int j=0; j<n; ++j){\\n                if(i >= nums[j])\\n                    dp[i] += dp[i-nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        vector<unsigned int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int i=1; i<=target; ++i){\\n            for(int j=0; j<n; ++j){\\n                if(i >= nums[j])\\n                    dp[i] += dp[i-nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380809,
                "title": "2-approaches-backtrack-and-dp-with-follow-up-analysis",
                "content": "[Leetcode](https://leetcode.com/) [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/).\\n\\nHere shows **2** Approaches to slove this problem: **Backtrack** and **Dynamic Programming**.\\n\\n# Backtrack\\n\\nThe Backtrack will be a complete search and its time complexity will be $O(2^n)$.\\n\\nSurely it will be **TLE**!\\n\\n```java\\nclass Solution {\\n    int total = 0;\\n    \\n    public int combinationSum4(int[] nums, int target) {\\n        total = 0;\\n        Arrays.sort(nums);\\n        backtrack(nums, target);\\n        return total;\\n    }\\n\\n    private void backtrack(int[] nums, int remain) {\\n        if (remain == 0) {\\n            total++;\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > remain) {\\n                break;\\n            }\\n\\n            backtrack(nums, remain - nums[i]);\\n        }\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(2^n)$\\n- **Space Complexity**: $O(\\\\textit{target})$\\n\\n# Dynamic Programming\\n\\n```java\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int x : nums) {\\n                if (x > i) {\\n                    continue;\\n                }\\n\\n                dp[i] += dp[i - x];\\n            }\\n        }\\n\\n        return dp[target];\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(\\\\textit{target} \\\\times n)$\\n- **Space Complexity**: $O(\\\\textit{target})$\\n\\n# Follow Up\\n\\n#### What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?\\n\\nIf the given array contains **negative** numbers, it will result in an infinite-length permutation.\\n\\nFor example, if the array $\\\\textit{nums}$ contains positive integers $A$ and negative integers $B$ (where $A \\\\gt 0$, $B \\\\lt 0$), so there is $A \\\\times B + A \\\\times (-B)=0$. Which means for any permutation whose sum of elements is equal to $\\\\textit{target}$, we can add $\\\\textit{target} + A \\\\times B + A \\\\times (-B)=\\\\textit{target}$.\\n\\nTherefore, as long as there is an arrangement whose sum of elements is equal to $\\\\textit{target}$, an arrangement of infinite length can be constructed.\\n\\nIf negative numbers are allowed, the maximum length of permutations must be limited to avoid infinite-length permutations before the number of permutations can be counted.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    int total = 0;\\n    \\n    public int combinationSum4(int[] nums, int target) {\\n        total = 0;\\n        Arrays.sort(nums);\\n        backtrack(nums, target);\\n        return total;\\n    }\\n\\n    private void backtrack(int[] nums, int remain) {\\n        if (remain == 0) {\\n            total++;\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > remain) {\\n                break;\\n            }\\n\\n            backtrack(nums, remain - nums[i]);\\n        }\\n    }\\n}\\n```\n```java\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int x : nums) {\\n                if (x > i) {\\n                    continue;\\n                }\\n\\n                dp[i] += dp[i - x];\\n            }\\n        }\\n\\n        return dp[target];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020368,
                "title": "c-3ms-easy-to-understand-fast",
                "content": "# C++ | 3ms | Easy to Understand | Fast\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned> dp(target+1, 0);//Must be unsigned\\n        dp[0]=1;\\n        for(int i=1; i<=target; i++){\\n            for (int x: nums){\\n                if (i>=x)\\n                    dp[i]+=dp[i-x];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned> dp(target+1, 0);//Must be unsigned\\n        dp[0]=1;\\n        for(int i=1; i<=target; i++){\\n            for (int x: nums){\\n                if (i>=x)\\n                    dp[i]+=dp[i-x];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585719,
                "title": "java-3-approaches-100-faster-recurssion-memoization-tabulation",
                "content": "```\\n//1 Simple Recursion Approach - Time Limit Exceeded \\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n        return permutations(nums, target);\\n        \\n    }\\n    \\n    public int permutations(int[] nums, int target){\\n        \\n        if(target == 0){\\n            return 1;\\n        }\\n        if(target<0){\\n            return 0;\\n        }\\n        \\n        int count = 0 ;\\n        for(int i=0; i<nums.length; i++){\\n           count+= permutations(nums, target-nums[i]);\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n// 2 Dp - memoization Approach - 100% faster\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n        return permutations(nums, target, new Integer[target+1]);\\n        \\n    }\\n    \\n    public int permutations(int[] nums, int target, Integer[] qb){\\n        \\n        if(target == 0){\\n            return 1;\\n        }\\n        if(target<0){\\n            return 0;\\n        }\\n        if(qb[target]!=null){\\n            return qb[target];\\n        }\\n        int count = 0 ;\\n        for(int i=0; i<nums.length; i++){\\n           count+= permutations(nums, target-nums[i], qb);\\n        }\\n        return qb[target] = count;\\n    }\\n}\\n\\n\\n// 3 Dp - Tabulation Approach\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n    \\n        int[] dp = new int[target+1];\\n        dp[0] = 1;\\n        \\n        for(int c=1; c<dp.length; c++){\\n            for(int n=0; n<nums.length; n++){\\n                if(c-nums[n]>=0){\\n                dp[c]+=dp[c-nums[n]];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//1 Simple Recursion Approach - Time Limit Exceeded \\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n        return permutations(nums, target);\\n        \\n    }\\n    \\n    public int permutations(int[] nums, int target){\\n        \\n        if(target == 0){\\n            return 1;\\n        }\\n        if(target<0){\\n            return 0;\\n        }\\n        \\n        int count = 0 ;\\n        for(int i=0; i<nums.length; i++){\\n           count+= permutations(nums, target-nums[i]);\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n// 2 Dp - memoization Approach - 100% faster\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n        return permutations(nums, target, new Integer[target+1]);\\n        \\n    }\\n    \\n    public int permutations(int[] nums, int target, Integer[] qb){\\n        \\n        if(target == 0){\\n            return 1;\\n        }\\n        if(target<0){\\n            return 0;\\n        }\\n        if(qb[target]!=null){\\n            return qb[target];\\n        }\\n        int count = 0 ;\\n        for(int i=0; i<nums.length; i++){\\n           count+= permutations(nums, target-nums[i], qb);\\n        }\\n        return qb[target] = count;\\n    }\\n}\\n\\n\\n// 3 Dp - Tabulation Approach\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n    \\n        int[] dp = new int[target+1];\\n        dp[0] = 1;\\n        \\n        for(int c=1; c<dp.length; c++){\\n            for(int n=0; n<nums.length; n++){\\n                if(c-nums[n]>=0){\\n                dp[c]+=dp[c-nums[n]];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166176,
                "title": "combination-sum-iv-short-easy-w-explanation-brute-force-to-dp",
                "content": "The problem asks us to find the number of possible combinations(and all permutations of that combination as well) of elements from *`nums`* that add up to *`target`*\\n\\n---\\n\\n\\u274C ***Solution - I (Brute Force)***\\n\\nLet\\'s start with the most basic approach. At each index, if the element is less than target, then we can always form a combination by picking the current element. The brute force is just based on this idea -\\n\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tif(target == 0) return 1;\\n\\tint ans = 0;\\n\\tfor(auto& num : nums)\\n\\t\\t// pick an element if it is less than target to be achieved and recurse for remaining amount.\\n\\t\\tif(num <= target) ans += combinationSum4(nums, target - num);\\n\\treturn ans;  \\n}\\n```\\n\\n***Time Complexity :*** **`O(N^T)`**. Please comment below if there\\'s a tighter upper bound.\\n\\n***Space Complexity :*** **`O(T)`**. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Top-Down Dynamic Programming)***\\n\\nBy drawing the recursion tree, we can see that for a target, we do the same calculations over and over again. This could be avoided by storing the number of combination obtained for a given target so that we don\\'t waste time recalculating it at each recursion.\\n\\nThis can be done by maintain a dp array where **`dp[i]`** will denote the number of combinations possible with `target = i`. Initially, all elements in `dp` will be initialized to -1 denoting that the number of combinations for those target aren\\'t calculated yet. \\n\\nOnce the number of combinations for subtarget = *`i`* (where `0<i<=target`) is calculated, it will be stored in *`dp[i]`* and the next time any recursive call asks for the same value, *`dp[i]`* will be returned directly instead of doing recomputation.\\n\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tvector<int> dp(target + 1, -1);  // at start, none of the values are computed\\n\\treturn helper(nums, target, dp);\\n}\\nint helper(vector<int>& nums, int target, vector<int>& dp){\\n\\tif(target == 0) return 1;  // base condition\\n\\tif(dp[target] != -1) return dp[target];  // if already computed for this value\\n\\t// recursive code starts -\\n\\tdp[target] = 0;\\n\\t// check for every element of nums. An element can only be taken if it is less than target.\\n\\t// If an element is chosen, recurse for remaining value.\\n\\tfor(auto& num : nums) \\n\\t\\tif(num <= target) dp[target] += helper(nums, target - num, dp);\\n\\treturn dp[target];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N * T)`**, where *`N`* is the number of elements in `nums` and *`T`* is equal to the given `target` value.\\n\\n***Space Complexity :*** **`O(T)`**. We need `O(T)` to maintain the dp array and in the worst case, we would have to do *`T`* numbers of recursive calls of helper. So, the overall space complexity becomes `O(T)`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Bottom-up Dynamic Programming)***\\n\\nThe idea in this approach is also the same. We just start filling dp from *`curTarget = 1`* all the way up to *`curTarget = target`*. At each `curTarget`, an element will be chosen if its value is less that target needed. \\n\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tvector<uint> dp(target + 1); dp[0] = 1;\\n\\t// start filling the dp array from bottom, i.e curTarget = 1 till target.\\n\\tfor (int curTarget = 1; curTarget <= target; curTarget++) \\n        for (auto& num : nums)     // check for all elements from nums\\n            if (num <= curTarget)  // an element will only be taken if it is less than target to be achieved\\n                // the optimal answer(no. of combination) of remaining value is added to dp[curTarget]\\n\\t\\t\\t\\tdp[curTarget] += dp[curTarget - num];   \\n    return dp[target];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N * T)`**\\n\\n***Space Complexity :*** **`O(T)`**. Although the space complexity remains the same, we are saving the space requried by implicit recursive stack.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution IV (Slightly efficient version of Solution - III)***\\n\\nThe above solution will always loop for `N` times for each *`curtarget`* from *`1`* to *`target`*. We could achieve slightly better performance if we sort the array at start and break as soon as `nums[i]` becomes greater than `curTarget` in the inner loop. The same optimization can be done for Top-Down approach of Solution - II as well.\\n\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tsort(begin(nums), end(nums));\\n    vector<uint> dp(target + 1); dp[0] = 1;\\n\\tfor (int curTarget = 1; curTarget <= target; curTarget++) \\n        for (auto& num : nums) \\n            if (num <= curTarget)  dp[curTarget] += dp[curTarget - num];\\n            else break;\\n    return dp[target];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N*T)`**. Although the time complexity remains same, the performance would be better in most cases since we wouldn\\'t need to loop *`N`* times for every *`curTarget`*\\n\\n***Space Complexity :*** **`O(T)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tif(target == 0) return 1;\\n\\tint ans = 0;\\n\\tfor(auto& num : nums)\\n\\t\\t// pick an element if it is less than target to be achieved and recurse for remaining amount.\\n\\t\\tif(num <= target) ans += combinationSum4(nums, target - num);\\n\\treturn ans;  \\n}\\n```\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tvector<int> dp(target + 1, -1);  // at start, none of the values are computed\\n\\treturn helper(nums, target, dp);\\n}\\nint helper(vector<int>& nums, int target, vector<int>& dp){\\n\\tif(target == 0) return 1;  // base condition\\n\\tif(dp[target] != -1) return dp[target];  // if already computed for this value\\n\\t// recursive code starts -\\n\\tdp[target] = 0;\\n\\t// check for every element of nums. An element can only be taken if it is less than target.\\n\\t// If an element is chosen, recurse for remaining value.\\n\\tfor(auto& num : nums) \\n\\t\\tif(num <= target) dp[target] += helper(nums, target - num, dp);\\n\\treturn dp[target];\\n}\\n```\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tvector<uint> dp(target + 1); dp[0] = 1;\\n\\t// start filling the dp array from bottom, i.e curTarget = 1 till target.\\n\\tfor (int curTarget = 1; curTarget <= target; curTarget++) \\n        for (auto& num : nums)     // check for all elements from nums\\n            if (num <= curTarget)  // an element will only be taken if it is less than target to be achieved\\n                // the optimal answer(no. of combination) of remaining value is added to dp[curTarget]\\n\\t\\t\\t\\tdp[curTarget] += dp[curTarget - num];   \\n    return dp[target];\\n}\\n```\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tsort(begin(nums), end(nums));\\n    vector<uint> dp(target + 1); dp[0] = 1;\\n\\tfor (int curTarget = 1; curTarget <= target; curTarget++) \\n        for (auto& num : nums) \\n            if (num <= curTarget)  dp[curTarget] += dp[curTarget - num];\\n            else break;\\n    return dp[target];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699778,
                "title": "python-very-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        ## RC ## \\n        ## APPROACH : DP ##\\n        # 1. Base case : Number of combinations to make 0 is 0.\\n        # 2. consider nums= {1,2,3}\\n        # 3. target = 1, combinations = {1}\\n        # 4. target = 2, combinations = {1,1}, {2}\\n        # 5. target = 3, combinations = {1,1,1} , {1,2}, {2,1}, {3}\\n        # 6. If number is in the list, you can directly count it as one combination\\n        # 7. else include all the combinations of target - nums[i]\\n        \\n\\t\\t## TIME COMPLEXITY : O(N^2) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        dp = [0] * (target+1) \\n        for i in range(1, target+1):            # offset from 1 to skip base case (first element)\\n            for n in nums:\\n                if( n == i):                    # If number is in the list, you can directly count it as one combination\\n                        dp[i] += 1\\n                if n < i:                       \\n                        dp[i] += dp[i-n]        # include all the combinations of target i-n.\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        ## RC ## \\n        ## APPROACH : DP ##\\n        # 1. Base case : Number of combinations to make 0 is 0.\\n        # 2. consider nums= {1,2,3}\\n        # 3. target = 1, combinations = {1}\\n        # 4. target = 2, combinations = {1,1}, {2}\\n        # 5. target = 3, combinations = {1,1,1} , {1,2}, {2,1}, {3}\\n        # 6. If number is in the list, you can directly count it as one combination\\n        # 7. else include all the combinations of target - nums[i]\\n        \\n\\t\\t## TIME COMPLEXITY : O(N^2) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        dp = [0] * (target+1) \\n        for i in range(1, target+1):            # offset from 1 to skip base case (first element)\\n            for n in nums:\\n                if( n == i):                    # If number is in the list, you can directly count it as one combination\\n                        dp[i] += 1\\n                if n < i:                       \\n                        dp[i] += dp[i-n]        # include all the combinations of target i-n.\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381079,
                "title": "java-1ms-dp-top-down-memoization-easy",
                "content": "# Please Upvote\\n\\nHere we can break the problem into smaller pieces.\\nFirst we have to make a Dp array of size equal to (target + 1) and initialize 0 index with 1.\\nNow, we will iterate through the array and update the value at every index with the number of ways to reach the target.\\n\\n![image](https://assets.leetcode.com/users/images/3bf95ec1-d238-4878-9499-bf6f2dd3464b_1659670756.2406218.png)\\n\\n\\n**Java\\nTop Down**\\n```\\n\\tint[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++)\\n            for (int num : nums)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[target];\\n```\\n\\n# Hope you find this helpful",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\tint[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++)\\n            for (int num : nums)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[target];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702432,
                "title": "java-1d-2d-bottom-up-top-down",
                "content": "**Top down repeating elements and double counting\\nOnce computation for a particular amount is done it is stored in dp table.**\\n```\\npublic int combinationSum4(int[] nums, int target) {\\n\\tInteger[] dp = new Integer[target + 1];\\n\\treturn helper(nums, target, dp);\\n}\\n\\npublic int helper(int[] coins, int amt, Integer[] dp) {\\n\\tif (amt == 0)\\n\\t\\treturn 1;\\n\\tif (amt < 0)\\n\\t\\treturn 0;\\n\\n\\tif (dp[amt] != null)\\n\\t\\treturn dp[amt];\\n\\tint res = 0;\\n\\tfor (int j = 0; j < coins.length; j++) {\\n\\t\\tres += helper(coins, amt - coins[j],dp);\\n\\t}\\n\\tdp[amt] = res;\\n\\treturn res;\\n}\\n```\\n**Bottom Up**\\n\\nAs bottom up are meant to be start with the base cases and the fill the transition table.\\nHere the base case is if the amount is 0, however many nums given only 1 way to make 0 (no way)\\nIn 2D bottom up last col of each row contains the number of ways to make the \\'row\\' amount.\\nUnderstand this transition for top down to bottom up.\\n```\\npublic int combinationSum44(int[] nums, int target) {\\n\\t// dp[i] : ways to make i amount using all the coins\\n\\tint[] dp = new int[target + 1];\\n\\tdp[0] = 1;\\n\\n\\t// Double counting\\n\\t// this replicates the below recursion\\n\\t// because for each target we tend to use the first coin coin[0]\\n\\t// and ech coin can be used repeatedly\\n\\tfor (int i = 1; i <= target; i++) {\\n\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\tif (i >= nums[j])\\n\\t\\t\\t\\tdp[i] = dp[i] + dp[i - nums[j]]; // ways are added for for each sum \"i\"\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[target];\\n}\\n\\n/* Example for amount = 5 and 1, 2, 3\\n * 1\\n * 11 | 2\\n * 111, 21 | 12 | 3\\n * 1111, 211, 121, 31 | 112, 22 | 13\\n * 11111, 2111, 1211, 311, 1121, 221, 131 | 1112, 212, 122, 32 | 113, 23\\n * */\\n \\npublic static int combinationSum412s(int[] coins, int amount) {\\n\\tint[][] dp = new int[amount + 1][coins.length + 1];\\n\\tif (coins.length == 0) return 0;\\n\\tfor (int i = 0; i <= coins.length; i++)\\n\\t\\tdp[0][i] = 1;\\n\\tfor (int i = 1; i <= amount; i++) {\\n\\t\\tfor (int j = 1; j <= coins.length; j++) { // using each coin\\n\\t\\t\\tdp[i][j] = dp[i][j - 1];\\n\\t\\t\\tif (i >= coins[j - 1])\\n\\t\\t\\t\\tdp[i][j] = dp[i][j] + dp[i - coins[j - 1]][coins.length];\\n\\t\\t}\\n\\t}\\n\\treturn dp[amount][coins.length];\\n}\\n```\\nEach doubt 5 why\\'s ? You\\'ll have your answer.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int combinationSum4(int[] nums, int target) {\\n\\tInteger[] dp = new Integer[target + 1];\\n\\treturn helper(nums, target, dp);\\n}\\n\\npublic int helper(int[] coins, int amt, Integer[] dp) {\\n\\tif (amt == 0)\\n\\t\\treturn 1;\\n\\tif (amt < 0)\\n\\t\\treturn 0;\\n\\n\\tif (dp[amt] != null)\\n\\t\\treturn dp[amt];\\n\\tint res = 0;\\n\\tfor (int j = 0; j < coins.length; j++) {\\n\\t\\tres += helper(coins, amt - coins[j],dp);\\n\\t}\\n\\tdp[amt] = res;\\n\\treturn res;\\n}\\n```\n```\\npublic int combinationSum44(int[] nums, int target) {\\n\\t// dp[i] : ways to make i amount using all the coins\\n\\tint[] dp = new int[target + 1];\\n\\tdp[0] = 1;\\n\\n\\t// Double counting\\n\\t// this replicates the below recursion\\n\\t// because for each target we tend to use the first coin coin[0]\\n\\t// and ech coin can be used repeatedly\\n\\tfor (int i = 1; i <= target; i++) {\\n\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\tif (i >= nums[j])\\n\\t\\t\\t\\tdp[i] = dp[i] + dp[i - nums[j]]; // ways are added for for each sum \"i\"\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[target];\\n}\\n\\n/* Example for amount = 5 and 1, 2, 3\\n * 1\\n * 11 | 2\\n * 111, 21 | 12 | 3\\n * 1111, 211, 121, 31 | 112, 22 | 13\\n * 11111, 2111, 1211, 311, 1121, 221, 131 | 1112, 212, 122, 32 | 113, 23\\n * */\\n \\npublic static int combinationSum412s(int[] coins, int amount) {\\n\\tint[][] dp = new int[amount + 1][coins.length + 1];\\n\\tif (coins.length == 0) return 0;\\n\\tfor (int i = 0; i <= coins.length; i++)\\n\\t\\tdp[0][i] = 1;\\n\\tfor (int i = 1; i <= amount; i++) {\\n\\t\\tfor (int j = 1; j <= coins.length; j++) { // using each coin\\n\\t\\t\\tdp[i][j] = dp[i][j - 1];\\n\\t\\t\\tif (i >= coins[j - 1])\\n\\t\\t\\t\\tdp[i][j] = dp[i][j] + dp[i - coins[j - 1]][coins.length];\\n\\t\\t}\\n\\t}\\n\\treturn dp[amount][coins.length];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85106,
                "title": "a-summary-of-all-combination-sum-problem-in-lc-c",
                "content": "\\n### Solutions\\n\\n#### Primitive\\n\\n[test](https://leetcode.com/problems/combination-sum/)\\n\\n- try each number and then to the next level with target `chopped off` by the number;\\n- since we can use the number unlimited times, which means as long as we don't traverse back, it will be okay;\\n- once the target is equal to zero, we get it and we can collect the `stack`.\\n```\\nclass Solution {\\nprivate:\\n    int size;\\n    void search(vector<int>& candidates, int pos, int target, vector<int>& v, vector<vector<int>>& vv) {\\n        if(target < 0) return;\\n        if(target == 0) { vv.push_back(v); return ; }\\n        for(int i = pos; i < size; ++i) {\\n            v.push_back(candidates[i]);\\n            search(candidates, pos, target-candidates[i], v, vv);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        size = candidates.size();  \\n        vector<int> v;\\n        vector<vector<int>> vv;\\n        search(candidates, 0, target, v, vv);\\n        return vv;\\n    }\\n};\\n```\\n\\n#### Follow-up 1\\n[test](https://leetcode.com/problems/combination-sum-iii/)\\n- each number can only be used once, so label the position and move forward one step each time;\\n- there are only k numbers in a combination, so update the k properly each time;\\n\\n```\\nclass Solution {\\nprivate:\\n    void search(int n, int pos, int k, vector<int>& v, vector<vector<int>>& vv) {\\n        if(n < 0) return ;\\n        if(k == 0) { if(n == 0) vv.push_back(v); return ;}\\n        for(int i = pos; i < 10; ++i) {\\n            v.push_back(i);\\n            search(n-i, i+1, k-1, v, vv);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        vector<vector<int>> vv;\\n        search(n, 1, k, v, vv);\\n        return vv;\\n    }\\n};\\n```\\n\\n#### Follow-up 2\\n[test](https://leetcode.com/problems/combination-sum-ii/)\\n- since we can use the number only once, so we have to move forward by one each time;\\n- to avoid duplicate set, we have to avoid try the same number in the same recursive level;\\n\\n```\\nclass Solution {\\nprivate:\\n    int size;\\n    vector<vector<int>> vv;\\n    void search(vector<int>& candidates, int pos, int target, vector<int>& v, vector<vector<int>>& vv) {\\n        if(target < 0) return;\\n        if(target == 0) { vv.push_back(v); return ; }\\n        for(int i = pos; i < size; ++i) {\\n            if(i==pos || candidates[i]!=candidates[i-1]) {\\n                v.push_back(candidates[i]);\\n                search(candidates, i+1, target-candidates[i], v, vv);\\n                v.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        size = candidates.size();  \\n        vector<int> v;\\n        search(candidates, 0, target, v);\\n        return vv;\\n    }\\n};\\n```\\n\\n#### Follow-up 3\\n[test](https://leetcode.com/problems/combination-sum-iv/)\\n- recursive backtracking is okay but inefficient, so we have to adopt `Memoization`;\\n- using map is for better robustness, while an array also does and can be more efficient.\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> map;\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(nums.empty() || target<0) return 0;\\n        if(target == 0) return 1;\\n        if(map.count(target)) return map[target];\\n        long count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n            count += combinationSum4(nums, target-nums[i]);\\n        return map[target] = count;\\n    }\\n};\\n```\\n\\n- actually we can do better using DP.\\n\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int arr[target+1]{1, 0};\\n        for(int i = 1, size = nums.size(); i <= target; ++i)\\n            for(int j = 0; j < size; ++j)\\n                if(i>=nums[j]) arr[i] += arr[i-nums[j]];\\n        return arr[target];\\n    }\\n};\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int size;\\n    void search(vector<int>& candidates, int pos, int target, vector<int>& v, vector<vector<int>>& vv) {\\n        if(target < 0) return;\\n        if(target == 0) { vv.push_back(v); return ; }\\n        for(int i = pos; i < size; ++i) {\\n            v.push_back(candidates[i]);\\n            search(candidates, pos, target-candidates[i], v, vv);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        size = candidates.size();  \\n        vector<int> v;\\n        vector<vector<int>> vv;\\n        search(candidates, 0, target, v, vv);\\n        return vv;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void search(int n, int pos, int k, vector<int>& v, vector<vector<int>>& vv) {\\n        if(n < 0) return ;\\n        if(k == 0) { if(n == 0) vv.push_back(v); return ;}\\n        for(int i = pos; i < 10; ++i) {\\n            v.push_back(i);\\n            search(n-i, i+1, k-1, v, vv);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        vector<vector<int>> vv;\\n        search(n, 1, k, v, vv);\\n        return vv;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int size;\\n    vector<vector<int>> vv;\\n    void search(vector<int>& candidates, int pos, int target, vector<int>& v, vector<vector<int>>& vv) {\\n        if(target < 0) return;\\n        if(target == 0) { vv.push_back(v); return ; }\\n        for(int i = pos; i < size; ++i) {\\n            if(i==pos || candidates[i]!=candidates[i-1]) {\\n                v.push_back(candidates[i]);\\n                search(candidates, i+1, target-candidates[i], v, vv);\\n                v.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        size = candidates.size();  \\n        vector<int> v;\\n        search(candidates, 0, target, v);\\n        return vv;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> map;\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(nums.empty() || target<0) return 0;\\n        if(target == 0) return 1;\\n        if(map.count(target)) return map[target];\\n        long count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n            count += combinationSum4(nums, target-nums[i]);\\n        return map[target] = count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int arr[target+1]{1, 0};\\n        for(int i = 1, size = nums.size(); i <= target; ++i)\\n            for(int j = 0; j < size; ++j)\\n                if(i>=nums[j]) arr[i] += arr[i-nums[j]];\\n        return arr[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332763,
                "title": "easy-to-understand-python-3-beats-90-commented",
                "content": "Where `n` is length of nums and `m` is target,\\nTime complexity: `O(nm)` \\nSpace complexity: `O(m)`\\n```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\t# in our dp table, element i represents if target = i\\n\\tdp = [0] * (target+1) # create table that is 1 larger than target \\n\\tdp[0] = 1 # the reason why we want +1 is because the first element is the \"base case\"\\n\\n\\tfor i in range(1, target+1): # offset from 1 to skip base case (first element)\\n\\t\\tfor n in nums:\\n\\t\\t\\tif n <= i: # if n > i, then i-n < 0, leading to index out of bounds\\n\\t\\t\\t\\tdp[i] += dp[i-n] # sum all entries that are n (elements of nums) distance away\\n\\n\\t# return the last element of dp table, since it represents the target passed in\\n\\treturn dp[-1]\\n```\\n\\nIf you don\\'t understand it by looking at it, walk through the solution using an example like `nums = [1, 2, 3], target = 4`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\t# in our dp table, element i represents if target = i\\n\\tdp = [0] * (target+1) # create table that is 1 larger than target \\n\\tdp[0] = 1 # the reason why we want +1 is because the first element is the \"base case\"\\n\\n\\tfor i in range(1, target+1): # offset from 1 to skip base case (first element)\\n\\t\\tfor n in nums:\\n\\t\\t\\tif n <= i: # if n > i, then i-n < 0, leading to index out of bounds\\n\\t\\t\\t\\tdp[i] += dp[i-n] # sum all entries that are n (elements of nums) distance away\\n\\n\\t# return the last element of dp table, since it represents the target passed in\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1166255,
                "title": "python-generating-function-solution-explained",
                "content": "You probably saw a lot of different solutions for this problem, but I can guess, that you did not saw this one. The idea is here is to use generating functions. Imagine, that we have coins `1, 2, 5`. Let us create polynomial `(x^1 + x^2 + x^5)`. Now, let us consider powers of this polynom. For example:\\n1. `(x^1 + x^2 + x^5)^ 1 = (x^1 + x^2 + x^5)`, nothing very intersting here.\\n2. `(x^1 + x^2 + x^5)^2 = x^2 + x^3 + x^6 + x^3 + x^4 + x^8 + x^6 + x^7 + x^10`. What we have here. For example we can see that there is only one way to get target `2`, because coefficient will be equal to `1` before `x^2`, there is `2` ways to get `6` and so on.\\n3. In general if we have  `(x^1 + x^2 + x^5)^k`, then coefficients will show us how many ways we can get one or another target, using exactly **k** coins.\\n\\nNow, we can use problem restrictions: that is that answer will always be less than `2^32`, so if we use `x = 2^32` and will work with operations in `2^32` base system, everything will be fine. Also we use python long numbers, which is very helpful here.\\n\\n1. Create `T` is our polynomial with `x = 2^32`.\\n2. Define `S = 1` and `ans = 0`.\\n3. Iterate over powers of `T`. Each time we multiply `S` by `T`. However we do not want to have too big numbers, so we use `& (1<<(32*t+32)) - 1`, trick, which will give us last `t + 1` digits in `2^32` base system.\\n4. Update our answer: this is value `S >> (32*t)`, that is value of `t`-th digit in our `2^32` base system.\\n\\n#### Complexity\\nIt is a bit difficult to estimate it like this, but on each operation and we have `t` of them we will work with number which have no more than `O(32m)` bits, where `m` is the biggest number among `nums.` So, total time complexity will be `O(32*m*t)`, space complexity is `O(32*m)`. However in practice it works quite fast.\\n\\n#### Code\\n```\\nclass Solution:\\n    def combinationSum4(self, nums, t):\\n        T = sum([1<<(32*n) for n in nums])\\n        S, ans = 1, 0\\n        for i in range(t):\\n            S = (S*T) & (1<<(32*t+32)) - 1\\n            ans += S >> (32*t)\\n            \\n        return ans\\n```\\n\\n#### Remark\\nIf you will write it as oneliner, I will be happy.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums, t):\\n        T = sum([1<<(32*n) for n in nums])\\n        S, ans = 1, 0\\n        for i in range(t):\\n            S = (S*T) & (1<<(32*t+32)) - 1\\n            ans += S >> (32*t)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736395,
                "title": "javascript-solution-top-down-with-memoization",
                "content": "```\\nvar combinationSum4 = function(nums, target) {\\n    const n = nums.length;\\n    const memo = new Map();\\n    \\n    return topDown(target);\\n    \\n    function topDown(target) {\\n        // base cases\\n        if (target == 0) return 1;\\n        if (target < 0) return 0;\\n        if (memo.has(target)) return memo.get(target);\\n         \\n        let count = 0;\\n        \\n        for (let i = 0; i < n; i++) {\\n            const num = nums[i];\\n            if (num <= target) {\\n                const amountLeft = target - num;\\n                count += topDown(amountLeft);\\n            }\\n        }\\n        \\n        memo.set(target, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar combinationSum4 = function(nums, target) {\\n    const n = nums.length;\\n    const memo = new Map();\\n    \\n    return topDown(target);\\n    \\n    function topDown(target) {\\n        // base cases\\n        if (target == 0) return 1;\\n        if (target < 0) return 0;\\n        if (memo.has(target)) return memo.get(target);\\n         \\n        let count = 0;\\n        \\n        for (let i = 0; i < n; i++) {\\n            const num = nums[i];\\n            if (num <= target) {\\n                const amountLeft = target - num;\\n                count += topDown(amountLeft);\\n            }\\n        }\\n        \\n        memo.set(target, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166232,
                "title": "combination-sum-iv-js-python-java-c-easy-dp-solutions-t-d-b-u-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWith this problem, we can easily imagine breaking up the solution into smaller pieces that we can use as stepping stones towards the overall answer. For example, if we\\'re searching for a way to get from **0** to our target number (**T**), and if **0 < x < y < T**, then we can see that finding out how many ways we can get from **y** to **T** will help us figure out how many ways we can get from **x** to **T**, all the way down to **0** to **T**. This is a classic example of a **top-down** (**memoization**) **dyanamic programming** (DP) solution.\\n\\nOf course, the reverse is also true, and we could instead choose to use a **bottom-up** (**tabulation**) DP solution with the same result.\\n\\n***Top-Down DP Approach***: Our DP array (**dp**) will contain cells (**dp[i]**) where **i** will represent the remaining space left before **T** and **dp[i]** will represent the number of ways the solution (**dp[T]**) can be reached from **i**.\\n\\nAt each value of **i** as we build out **dp** we\\'ll iterate through the different **num**s in our number array (**N**) and consider the cell that can be reached with each **num** (**dp[i-num]**). The value of **dp[i]** will therefore be the sum of the results of each of those possible moves.\\n\\nWe\\'ll need to seed **dp[0]** with a value of **1** to represent the value of the completed combination, then once the iteration is complete, we can **return dp[T]** as our final answer.\\n\\n***Bottom-Up DP Approach***: Our DP array (**dp**) will contain cells (**dp[i]**) where **i** will represent the current count as we head towards **T** and **dp[i]** will represent the number of ways we can reach **i** from the starting point (**dp[0]**). This means that **dp[T]** will represent our final solution.\\n\\nAt each value of **i** as we build out **dp** we\\'ll iterate through the different **num**s in our number array (**N**) and update the value of the cell that can be reached with each num (**dp[i+num]**) by adding the result of the current cell (**dp[i]**). If the current cell has no value, then we can **continue** without needing to iterate through **N**.\\n\\nWe\\'ll need to seed **dp[0]** with a value of **1** to represent the value of the common starting point, then once the iteration is complete, we can **return dp[T]** as our final answer.\\n\\nIn both the top-down and bottom-up DP solutions, the **time complexity** is **O(N * T)** and the **space complexity** is **O(T)**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor C++ we\\'ll have to make sure to use unsigned ints in our **dp** vector, otherwise we\\'ll get int overflow errors.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n##### ***w/ Top-Down DP:***\\n```javascript\\nvar combinationSum4 = function(N, T) {\\n    let dp = new Uint32Array(T+1)\\n    dp[0] = 1\\n    for (let i = 1; i <= T; i++)\\n        for (let num of N)\\n            if (num <= i) dp[i] += dp[i-num]\\n    return dp[T]\\n};\\n```\\n\\n##### ***w/ Bottom-Up DP:***\\n```javascript\\nvar combinationSum4 = function(N, T) {\\n    let dp = new Uint32Array(T+1)\\n    dp[0] = 1\\n    for (let i = 0; i < T; i++) {\\n        if (!dp[i]) continue\\n        for (let num of N)\\n            if (num + i <= T) dp[i+num] += dp[i]\\n    }\\n    return dp[T]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n##### ***w/ Top-Down DP:***\\n```python\\nclass Solution:\\n    def combinationSum4(self, N: List[int], T: int) -> int:\\n        dp = [0] * (T + 1)\\n        dp[0] = 1\\n        for i in range(1, T+1):\\n            for num in N:\\n                if num <= i: dp[i] += dp[i-num]\\n        return dp[T]\\n```\\n\\n##### ***w/ Bottom-Up DP:***\\n```python\\nclass Solution:\\n    def combinationSum4(self, N: List[int], T: int) -> int:\\n        dp = [0] * (T + 1)\\n        dp[0] = 1\\n        for i in range(T):\\n            if not dp[i]: continue\\n            for num in N:\\n                if num + i <= T: dp[i+num] += dp[i]\\n        return dp[T]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n##### ***w/ Top-Down DP:***\\n```java\\nclass Solution {\\n    public int combinationSum4(int[] N, int T) {\\n        int[] dp = new int[T+1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= T; i++)\\n            for (int num : N)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[T];\\n    }\\n}\\n```\\n\\n##### ***w/ Bottom-Up DP:***\\n```java\\nclass Solution {\\n    public int combinationSum4(int[] N, int T) {\\n        int[] dp = new int[T+1];\\n        dp[0] = 1;\\n        for (int i = 0; i < T; i++) {\\n            if (dp[i] == 0) continue;\\n            for (int num : N)\\n                if (num + i <= T) dp[i+num] += dp[i];\\n        }\\n        return dp[T];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ Top-Down DP:***\\n```c++\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& N, int T) {\\n        vector<unsigned int> dp(T+1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= T; i++)\\n            for (int num : N)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[T];\\n    }\\n};\\n```\\n\\n##### ***w/ Bottom-Up DP:***\\n```c++\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& N, int T) {\\n        vector<unsigned int> dp(T+1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < T; i++) {\\n            if (!dp[i]) continue;\\n            for (int num : N)\\n                if (num + i <= T) dp[i+num] += dp[i];\\n        }\\n        return dp[T];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar combinationSum4 = function(N, T) {\\n    let dp = new Uint32Array(T+1)\\n    dp[0] = 1\\n    for (let i = 1; i <= T; i++)\\n        for (let num of N)\\n            if (num <= i) dp[i] += dp[i-num]\\n    return dp[T]\\n};\\n```\n```javascript\\nvar combinationSum4 = function(N, T) {\\n    let dp = new Uint32Array(T+1)\\n    dp[0] = 1\\n    for (let i = 0; i < T; i++) {\\n        if (!dp[i]) continue\\n        for (let num of N)\\n            if (num + i <= T) dp[i+num] += dp[i]\\n    }\\n    return dp[T]\\n};\\n```\n```python\\nclass Solution:\\n    def combinationSum4(self, N: List[int], T: int) -> int:\\n        dp = [0] * (T + 1)\\n        dp[0] = 1\\n        for i in range(1, T+1):\\n            for num in N:\\n                if num <= i: dp[i] += dp[i-num]\\n        return dp[T]\\n```\n```python\\nclass Solution:\\n    def combinationSum4(self, N: List[int], T: int) -> int:\\n        dp = [0] * (T + 1)\\n        dp[0] = 1\\n        for i in range(T):\\n            if not dp[i]: continue\\n            for num in N:\\n                if num + i <= T: dp[i+num] += dp[i]\\n        return dp[T]\\n```\n```java\\nclass Solution {\\n    public int combinationSum4(int[] N, int T) {\\n        int[] dp = new int[T+1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= T; i++)\\n            for (int num : N)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[T];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int combinationSum4(int[] N, int T) {\\n        int[] dp = new int[T+1];\\n        dp[0] = 1;\\n        for (int i = 0; i < T; i++) {\\n            if (dp[i] == 0) continue;\\n            for (int num : N)\\n                if (num + i <= T) dp[i+num] += dp[i];\\n        }\\n        return dp[T];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& N, int T) {\\n        vector<unsigned int> dp(T+1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= T; i++)\\n            for (int num : N)\\n                if (num <= i) dp[i] += dp[i-num];\\n        return dp[T];\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& N, int T) {\\n        vector<unsigned int> dp(T+1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < T; i++) {\\n            if (!dp[i]) continue;\\n            for (int num : N)\\n                if (num + i <= T) dp[i+num] += dp[i];\\n        }\\n        return dp[T];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166107,
                "title": "combination-sum-iv-simple-solution-easy-to-understand",
                "content": "This problem is almost similar to `coin change`, The main idea is to calculate all possible combinations with the given nums by creating a DP array to make use by storing previously computed values.\\nwhere `dp[i] `represents number of combinations with `sum = i`. \\nFinally, we return` dp[k] `because we need number of combinations with `sum =k. `\\n\\n**For example:** `nums =[1,2,3], target = 4`. \\n->Initially we set `dp[0] =1`.\\n->`dp[1] = 1`. because only one combination gives `sum =1 i.e, {1}`\\n->`dp[2] = dp[2-1]+dp[2-2] = 2` we donot process `nums[j] = 3` because, we need sum for` i=2`, so we process for `nums[j] <=i` and two combinations are `{1,1},{2}`\\n->`dp[3] = dp[3-1]+dp[3-2]+d[3-3] = 4`.\\n->`dp[4] = dp[4-1]+dp[4-2]+dp[4-3]` which gives us `dp[4] = 7`.\\n\\n**Do Upvote if you find it helpful!!**\\n```\\nint combinationSum4(vector<int>& nums, int k) {\\n        vector<unsigned int>dp(k+1);\\n        dp[0]=1;\\n        for(int i=1;i<=k;i++){\\n            for(int n:nums){\\n                if(n<=i)\\n                    dp[i] += dp[i-n];\\n            }\\n        }\\n        return dp[k];\\n    }\\n```\\n**Time Complexity**: O(n*k)  where n = nums.size(), k=target\\n**Space complexity**: O(k).",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint combinationSum4(vector<int>& nums, int k) {\\n        vector<unsigned int>dp(k+1);\\n        dp[0]=1;\\n        for(int i=1;i<=k;i++){\\n            for(int n:nums){\\n                if(n<=i)\\n                    dp[i] += dp[i-n];\\n            }\\n        }\\n        return dp[k];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144739,
                "title": "how-signed-integer-overflow-happened",
                "content": "I made the following code:\\n\\n```c++\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tint dp[target + 1];\\n\\tdp[0] = 1;\\n\\n\\tfor (int i = 1; i <= target; ++i) {\\n\\t\\tdp[i] = 0;\\n\\t\\tfor (auto v : nums) {\\n\\t\\t\\tif (i >= v) {\\n\\t\\t\\t\\tdp[i] = dp[i] + dp[i - v];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[target];\\n}\\n```\\n\\nHowever, it can\\'t pass this testcase:\\n\\n```\\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,\\n170,180,190,200,210,220,230,240,250,260,270,280,290,300,\\n310,320,330,340,350,360,370,380,390,400,410,420,430,440,\\n450,460,470,480,490,500,510,520,530,540,550,560,570,580,\\n590,600,610,620,630,640,650,660,670,680,690,700,710,720,\\n730,740,750,760,770,780,790,800,810,820,830,840,850,860,\\n870,880,890,900,910,920,930,940,950,960,970,980,990,111]\\n999\\n```\\n\\nsince signed integer overflow. Change `int dp` to `long long dp[target + 1]` will still get integer overflow.\\nChange it to `unsigned dp[target + 1]` will finally pass it.\\n\\nBut why? I modify my code as follows:\\n\\n```c++\\n// ...\\nfor (int i = 1; i <= target; ++i) {\\n\\tdp[i] = 0;\\n\\tfor (auto v : nums) {\\n\\t\\tif (i >= v) {\\n\\t\\t\\tdp[i] = dp[i] + dp[i - v];\\n\\t\\t}\\n\\t}\\n\\tif (dp[i] != 0) {\\n\\t\\tcout << \"dp[\" << i << \"] = \" << dp[i] << \\'\\\\n\\';\\n\\t}\\n}\\n// ...\\n```\\n\\nThen get output (partial):\\n\\n```c++\\ndp[10] = 1\\ndp[20] = 2\\ndp[30] = 4\\ndp[40] = 8\\ndp[50] = 16\\ndp[60] = 32\\ndp[70] = 64\\ndp[80] = 128\\ndp[90] = 256\\ndp[100] = 512\\ndp[110] = 1024\\ndp[120] = 2048\\ndp[130] = 4096\\ndp[140] = 8192\\ndp[150] = 16384\\ndp[160] = 32768\\ndp[170] = 65536\\ndp[180] = 131072\\ndp[190] = 262144\\ndp[200] = 524288\\n// ...\\ndp[300] = 536870912\\n// ...\\ndp[400] = 549755813888\\n// ...\\ndp[500] = 562949953421312\\n// ...\\ndp[600] = 576460752303423488\\n```\\n\\nExponential growth! For `dp[600]`, we can dive in its computation:\\n\\n```c++\\ndp[600] = + dp[0] + dp[10] + dp[20] + dp[30] + ... + dp[590]\\n= dp[0] + (dp[0] + dp[0]) + (dp[0] + dp[10] + dp[0]) + ... + (dp[0] + ... dp[580] + dp[0])\\n= 2 ^ 59\\n```\\n\\nFinally, we need 99 bits to save `dp[990]` while `unsigned long long` have just 64 bits!\\n\\nIf they use this testcase:\\n\\n```\\n[1,2]\\n1000\\n```\\n\\nWe need 100 bits to save `dp[1000]`! Of course, Leetcode guaranteed the answer to fit in a 32-bit integer.\\nSo we just drop these too large numbers.\\n\\nThe reason `unsigned` works is Leetcode doesn\\'t detect unsigned integer overflow.\\nIf they use `-fsanitize=unsigned-integer-overflow`, `unsigned` solution would not pass.\\n\\nHere is my AC solution:\\n\\n```c++\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tint dp[target + 1];\\n\\tdp[0] = 1;\\n\\n\\tfor (int i = 1; i <= target; ++i) {\\n\\t\\tdp[i] = 0;\\n\\t\\tfor (auto v : nums) {\\n\\t\\t\\tif (i >= v && numeric_limits<int>::max() - dp[i - v] >= dp[i]) {\\n\\t\\t\\t\\tdp[i] += dp[i - v];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[target];\\n}\\n```\\n\\n**Fatal Misunderstanding**\\n\\nRecently I learnt about [VLA](https://en.wikipedia.org/wiki/Variable-length_array). VLA is variable length array. It is supported in C99 but not in C++! so\\n\\n```c++\\nint dp[target + 1];\\n```\\n\\nis never right in C++. It is not stdandard C++! This code can be compiled by GCC and Clang but MSVC.\\n\\nWe should use\\n\\n```c++\\nvector<int> dp(target + 1);\\n```\\n\\nI have this misunderstanding for a long time. It makes me ashamed.",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tint dp[target + 1];\\n\\tdp[0] = 1;\\n\\n\\tfor (int i = 1; i <= target; ++i) {\\n\\t\\tdp[i] = 0;\\n\\t\\tfor (auto v : nums) {\\n\\t\\t\\tif (i >= v) {\\n\\t\\t\\t\\tdp[i] = dp[i] + dp[i - v];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[target];\\n}\\n```\n```\\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,\\n170,180,190,200,210,220,230,240,250,260,270,280,290,300,\\n310,320,330,340,350,360,370,380,390,400,410,420,430,440,\\n450,460,470,480,490,500,510,520,530,540,550,560,570,580,\\n590,600,610,620,630,640,650,660,670,680,690,700,710,720,\\n730,740,750,760,770,780,790,800,810,820,830,840,850,860,\\n870,880,890,900,910,920,930,940,950,960,970,980,990,111]\\n999\\n```\n```c++\\n// ...\\nfor (int i = 1; i <= target; ++i) {\\n\\tdp[i] = 0;\\n\\tfor (auto v : nums) {\\n\\t\\tif (i >= v) {\\n\\t\\t\\tdp[i] = dp[i] + dp[i - v];\\n\\t\\t}\\n\\t}\\n\\tif (dp[i] != 0) {\\n\\t\\tcout << \"dp[\" << i << \"] = \" << dp[i] << \\'\\\\n\\';\\n\\t}\\n}\\n// ...\\n```\n```c++\\ndp[10] = 1\\ndp[20] = 2\\ndp[30] = 4\\ndp[40] = 8\\ndp[50] = 16\\ndp[60] = 32\\ndp[70] = 64\\ndp[80] = 128\\ndp[90] = 256\\ndp[100] = 512\\ndp[110] = 1024\\ndp[120] = 2048\\ndp[130] = 4096\\ndp[140] = 8192\\ndp[150] = 16384\\ndp[160] = 32768\\ndp[170] = 65536\\ndp[180] = 131072\\ndp[190] = 262144\\ndp[200] = 524288\\n// ...\\ndp[300] = 536870912\\n// ...\\ndp[400] = 549755813888\\n// ...\\ndp[500] = 562949953421312\\n// ...\\ndp[600] = 576460752303423488\\n```\n```c++\\ndp[600] = + dp[0] + dp[10] + dp[20] + dp[30] + ... + dp[590]\\n= dp[0] + (dp[0] + dp[0]) + (dp[0] + dp[10] + dp[0]) + ... + (dp[0] + ... dp[580] + dp[0])\\n= 2 ^ 59\\n```\n```\\n[1,2]\\n1000\\n```\n```c++\\nint combinationSum4(vector<int>& nums, int target) {\\n\\tint dp[target + 1];\\n\\tdp[0] = 1;\\n\\n\\tfor (int i = 1; i <= target; ++i) {\\n\\t\\tdp[i] = 0;\\n\\t\\tfor (auto v : nums) {\\n\\t\\t\\tif (i >= v && numeric_limits<int>::max() - dp[i - v] >= dp[i]) {\\n\\t\\t\\t\\tdp[i] += dp[i - v];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[target];\\n}\\n```\n```c++\\nint dp[target + 1];\\n```\n```c++\\nvector<int> dp(target + 1);\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2383298,
                "title": "easy-c-solution-3-approaches-recursion-dp",
                "content": "#  -> Recursion (TLE)\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(target<0)\\n            return 0;\\n        if(target == 0)\\n            return 1;\\n        \\n        int res=0;\\n        for(int i=0; i<nums.size(); i++)\\n            res+= combinationSum4(nums, target-nums[i]);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n#  -> Top-Down (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target+1, -1);\\n        dp[0]=1;\\n        \\n        func(nums, target, dp);\\n        return dp[target];\\n    }\\n    \\n    int func(vector<int> &nums, int target, vector<int> &dp){\\n        if(target<0)\\n            return 0;\\n    \\n        if(dp[target] != -1)\\n            return dp[target];\\n        \\n        int res=0;\\n        for(int i=0; i<nums.size(); i++)\\n            res+= func(nums, target-nums[i], dp);\\n        \\n        return dp[target] = res;\\n    }\\n};\\n```\\n\\n#  -> Bottom-Up (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector< unsigned int> dp(target+1);\\n        dp[0]=1;\\n        \\n        for(int i=1; i<target+1; i++)\\n            for(int j=0; j<nums.size(); j++)\\n                if(nums[j]<=i)\\n                    dp[i] += dp[i-nums[j]];\\n        \\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(target<0)\\n            return 0;\\n        if(target == 0)\\n            return 1;\\n        \\n        int res=0;\\n        for(int i=0; i<nums.size(); i++)\\n            res+= combinationSum4(nums, target-nums[i]);\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target+1, -1);\\n        dp[0]=1;\\n        \\n        func(nums, target, dp);\\n        return dp[target];\\n    }\\n    \\n    int func(vector<int> &nums, int target, vector<int> &dp){\\n        if(target<0)\\n            return 0;\\n    \\n        if(dp[target] != -1)\\n            return dp[target];\\n        \\n        int res=0;\\n        for(int i=0; i<nums.size(); i++)\\n            res+= func(nums, target-nums[i], dp);\\n        \\n        return dp[target] = res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector< unsigned int> dp(target+1);\\n        dp[0]=1;\\n        \\n        for(int i=1; i<target+1; i++)\\n            for(int j=0; j<nums.size(); j++)\\n                if(nums[j]<=i)\\n                    dp[i] += dp[i-nums[j]];\\n        \\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560814,
                "title": "allocation-tree-no-code-pure-in-depth-explanation",
                "content": "There is a misunderstanding that people think it is not a `combination` problem, but rather a problem about `permutations`.\\nI\\'d say, this problem is about neither of those.\\nThere are 3 major combinatorial objects/functions: \\n1. Combination: `C(n, k)`\\n2. Permutation: `P(n)`\\n3. Allocation: `A(n, k)`\\n\\nEach one of them has a corresponding tree that represents all of the objects that are distinguished from each other.\\nWe could retrieve each particular object by traversing a tree going from the root to a leaf.\\n\\n\\nI don\\'t know whether it would be helpful for anyone, but I gained understanding by pondering at an image of an Allocation Tree for the sample input: `nums = [1,2,3], target = 4`.\\nEach node represents the sum of the edges on a path from the particular node that we\\'re looking at to a root node.\\nEach edge represents a choice that we made to take a number from `nums[]` array. Because of that each node has `len(nums)` children.\\n![image](https://assets.leetcode.com/users/images/8cb365a9-46c3-4d90-b8f2-aafaed760f2a_1636109282.1701035.png)\\n\\nHere is a better quality image: https://imgur.com/1c4wOhH\\nOr you could insert the code from here https://disk.yandex.ru/d/vRVVTVreaxJLHQ to here http://www.webgraphviz.com/ and see the graph in its full glory.\\n\\nThe depth of the tree is determined by the smallest number in the `num[]` array. On each level of a tree the sums increase from left to right.\\nThe leftmost leaf contains the smallest sum that we could make by choosing 4 numbers  `(nums[0], nums[0], nums[0], nums[0])`.\\nThe rightmost leaf contains the largest sum that we could make by choosing 4 numbers  `(nums[2], nums[2], nums[2], nums[2])`.\\n\\nOur tree shows us all of the possible sums that we could make by choosing 4 numbers or less from array `nums[]`.\\nIf we have to choose exactly 4 numbers from `nums[]` array, then we have to look at the leafs of the tree as they represent all of the possible sums that could be attained by choosing exactly 4 numbers. We could notice that there is only one leaf with sum `4` (the leftmost leaf).\\n\\nIf we have to choose exactly 3 numbers from `nums[]` array. Then we have to look at the 3\\'rd level of the tree (the root is at level `0`).\\nThe 3\\'rd level of the tree contains 3 nodes with sum `4` and it shows the paths that lead us to these sums: `(1, 1, 2)`, `(1, 2, 1)`, `(2, 1, 1)`. All of the other nodes on 3\\'rd level have a sum which is larger than `4` (except for node `(1, 1, 1)`).\\n\\nEach new level in this tree grows by a factor of `3` (by a factor of `len(nums)` to be precise).\\nThat is, the number of nodes on level `i` is `3 x ` the number of nodes on level `i - 1`, or mathematically: `num_nodes(level) = 3 * num_nodes(level - 1)`. If we expand this recursion we see `num_nodes(level) = 3 * num_nodes(level - 1) = 3 * 3 * num_nodes(level - 2) = 3 * 3 * 3 * num_nodes(level - 3) = 3 ^ {tree height}`.\\n\\nThat is the fastest growing tree among all combinatorial objects: combinations, permutations, allocations. Permutation tree grows slower than allocation tree, because with each new level of the tree the number of child nodes is chopped off by `1`, so instead of the following progression: `3 * 3 * 3` we get `3 * 2 * 1`.\\n\\nHere is graphviz code for the tree if anyone wants to tinker with it: https://disk.yandex.ru/d/vRVVTVreaxJLHQ\\n\\n---\\n\\nIntuition for dynamic programming solution comes from the following drawing:\\n![image](https://assets.leetcode.com/users/images/1cdf9624-d5a7-45e7-9357-7ff7dfb6d238_1636190594.6089683.png)\\nhttps://imgur.com/pwxeivC\\n\\nThere are 4 ways to come to node with sum `4` from parent node with sum `3`:\\n1. (1 + 1 + 1) + 1 = `3` + 1 = `4`.\\n2. (1 + 2) + 1 = `3` + 1 = `4`.\\n3. (2 + 1) + 1 = `3` + 1 = `4`.\\n4. (3) + 1 = `3` + 1 = `4`.\\n\\nThere are 2 ways to come to node with sum `4` from parent node with sum `2`:\\n1. (1 + 1) + 2 = `2` + 2 = `4`.\\n2. (2) + 2 = `2` + 2 = `4`.\\n\\nThere is 1 way to come to node with sum `4` from parent node with sum `1`:\\n1. (1) + 3 = `1` + 3 = `4`.\\n\\nSo, if we have already stored in `cnt[]` array the number of nodes with sum `1` in `cnt[1] = 1`, the number of nodes with sum `2` in `cnt[2] = 2`, the number of nodes with sum `3` in `cnt[3] = 4`, then we can calculate the number of nodes with sum `4` by reusing `cnt[1], cnt[2], cnt[3]`:\\n```\\ncnt[4] = cnt[1] + cnt[2] + cnt[3] = 1 + 2 + 4 = 7\\n```\\n\\nBy the way, this picture also gives us an intuition why `cnt[0] = 1` and it is not `cnt[0] = 0`. The reason is that we have a single node with sum `0` - the root of the tree.\\n\\n---\\n\\nNow let\\'s look at how dynamic programming computation looks like on a tree from one level to the next.\\n\\nThe node which is already computed will be surrounded by a red square.\\nAt the start  `cnt[0]` is already computed and is equal to `1`, so it is surrounded by the red square from the very beginning.\\n\\nThe next stage is to compute `cnt[1]` from `cnt[0]`. There is only one node with `cnt[0]`, and it is the only parent node which could be accessed from `cnt[1]`, so we essentially copy `cnt[1] = cnt[0] = 1`:\\n![image](https://assets.leetcode.com/users/images/7391887c-a748-4b92-9d4c-042a2536648f_1636200245.828562.png)\\nhttps://imgur.com/23hUVvT\\n\\nAfter we have processed `cnt[0]` and `cnt[1]` now we have all the neccessary ingredients to compute `cnt[2]`.\\n![image](https://assets.leetcode.com/users/images/f860bd59-8aac-4e32-a0b3-b6ba308e19fb_1636201330.6628573.png)\\nhttps://imgur.com/L0xSpbH\\n\\nComputaton of `cnt[2]` is more interesting, because we need values from 2 different nodes to compute it:\\n```\\ncnt[2] = 0;\\ncnt[2] += cnt[1]; // The number of nodes with sum `1`\\ncnt[2] += cnt[0]; // The number of nodes with sum `0` \\n```\\n\\nNow the real secret souce is revieled when we look at computation of `cnt[3]`. We continue reusing previous `cnt[0], cnt[1], cnt[2]` for computation of `cnt[3]`, but this time we will notice something special.\\n![image](https://assets.leetcode.com/users/images/2c6f5dc6-b69e-4853-a370-3fac24eb708b_1636202045.1286323.png)\\nhttps://imgur.com/5qveboj\\n\\nThis image doesn\\'t contain all the arrows to show the computation, because the image becomes messy. It only shows the most essential part needed for understanding: `cnt[3] += cnt[2];`.\\n\\nThe whole computation of `cnt[3]` looks like this:\\n```\\ncnt[3] = 0;\\ncnt[3] += cnt[0];  // Just adds `1`.\\ncnt[3] += cnt[1];  // Also simply adds `1`.\\ncnt[3] += cnt[2]; // Adds `2`! This is key to understanding how and why dynamic programming works!\\n```\\n\\nAs we can see from an image when we add `cnt[3] += cnt[2]` we do something special. There are two different nodes with sum `2` and we are adding both of these nodes simultaneously with a single operation! That is two different combinations (allocations!) that give sum `2`: `(1, 1)` and `(2)` are already stored in `cnt[2]`. By doing the operation `cnt[3] += cnt[2]` we can imagine like we extend both of these two combinations: `{(1, 1), (2)}` by adding `1` to the end of each of them. So `cnt[3] += cnt[2]` is like transformation of `{(1, 1), (2)}` to `{(1, 1, 1), (2, 1)}`!!!!\\n\\nSo we can look at computation of `cnt[3] = cnt[0] + cnt[1] + cnt[2]` like extention of paths by adding `1` in the end:\\n```\\ncnt[3] = 0;\\ncnt[3] += cnt[0];  // Single path is extended by appending `3` in the end: from (0) to (0, 3)\\ncnt[3] += cnt[1];  // Single path is extended by appending `2` in the end: from (0, 1) to (0, 1, 2).\\ncnt[3] += cnt[2]; // Two paths are extended by appending `1` in the end: from (0, 1, 1) to (0, 1, 1, 1) and from (0, 2) to (0, 2, 1)\\n```\\n\\nProbably you have noticed that I have used `0` in the beginning of all the paths `(0)`, `(0, 1)`, `(0, 1, 1)`, `(0, 1, 1, 1)`. This way we can really see that we form each path by traversing from root node (which is `0`) and it\\'s easier to see how we transform these paths and compare them with each other:\\n(0) + (**3**) \\u27F6 (0, **3**) // cnt[3 - **3**]\\n(0, 1) + (**2**) \\u27F6 (0, 1, **2**) // cnt[3 - **2**]\\n(0, 1, 1) + (**1**) \\u27F6 (0, 1, 1, **1**) // cnt[3 - **1**]\\n(0, 2) + (**1**) \\u27F6 (0, 2, **1**) // cnt[3 - **1**]",
                "solutionTags": [],
                "code": "```\\ncnt[4] = cnt[1] + cnt[2] + cnt[3] = 1 + 2 + 4 = 7\\n```\n```\\ncnt[2] = 0;\\ncnt[2] += cnt[1]; // The number of nodes with sum `1`\\ncnt[2] += cnt[0]; // The number of nodes with sum `0` \\n```\n```\\ncnt[3] = 0;\\ncnt[3] += cnt[0];  // Just adds `1`.\\ncnt[3] += cnt[1];  // Also simply adds `1`.\\ncnt[3] += cnt[2]; // Adds `2`! This is key to understanding how and why dynamic programming works!\\n```\n```\\ncnt[3] = 0;\\ncnt[3] += cnt[0];  // Single path is extended by appending `3` in the end: from (0) to (0, 3)\\ncnt[3] += cnt[1];  // Single path is extended by appending `2` in the end: from (0, 1) to (0, 1, 2).\\ncnt[3] += cnt[2]; // Two paths are extended by appending `1` in the end: from (0, 1, 1) to (0, 1, 1, 1) and from (0, 2) to (0, 2, 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475192,
                "title": "c-all-possible-solutions",
                "content": "1) Brute force solution : Using recursion\\n\\n```\\nvoid bt(vector<int> nums,int target,int total,int &count)\\n    {\\n        if(target==total)\\n        {   count++;\\n            return;\\n        }\\n        \\n        if(total>target)\\n            return;\\n        \\n        for(int i:nums)\\n        {\\n            bt(nums,target,total+i,count);\\n        }\\n        \\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        \\n        int count=0;\\n        bt(nums,target,0,count);\\n        \\n        return count;\\n        \\n    }\\n```\\n\\n\\n2) Memoizing the recursion: DP- Top down approach\\n\\n```\\nint bt(vector<int> nums,int target,vector<int>&cache) \\n    {\\n        if(target==0)\\n            return 1;\\n        if(target<0)\\n            return 0;\\n        \\n        if(cache[target]!=-1)\\n            return cache[target];\\n        int res=0;\\n        for(int i:nums)\\n        {\\n            res+=bt(nums,target-i,cache);\\n        }\\n        return cache[target]=res;\\n    }\\n    \\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> cache(target+1,-1);\\n        \\n        return bt(nums,target,cache);\\n        \\n    }\\n```\\n\\n\\n3) DP-Bottom up approach\\n```\\n\\n int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<unsigned int> dp(target+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++)\\n        {\\n            for(int j:nums)\\n            {\\n                if(i>=j)\\n                    dp[i]+=dp[i-j];\\n            }\\n        }\\n        \\n        return dp[target];\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvoid bt(vector<int> nums,int target,int total,int &count)\\n    {\\n        if(target==total)\\n        {   count++;\\n            return;\\n        }\\n        \\n        if(total>target)\\n            return;\\n        \\n        for(int i:nums)\\n        {\\n            bt(nums,target,total+i,count);\\n        }\\n        \\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        \\n        int count=0;\\n        bt(nums,target,0,count);\\n        \\n        return count;\\n        \\n    }\\n```\n```\\nint bt(vector<int> nums,int target,vector<int>&cache) \\n    {\\n        if(target==0)\\n            return 1;\\n        if(target<0)\\n            return 0;\\n        \\n        if(cache[target]!=-1)\\n            return cache[target];\\n        int res=0;\\n        for(int i:nums)\\n        {\\n            res+=bt(nums,target-i,cache);\\n        }\\n        return cache[target]=res;\\n    }\\n    \\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> cache(target+1,-1);\\n        \\n        return bt(nums,target,cache);\\n        \\n    }\\n```\n```\\n\\n int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<unsigned int> dp(target+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++)\\n        {\\n            for(int j:nums)\\n            {\\n                if(i>=j)\\n                    dp[i]+=dp[i-j];\\n            }\\n        }\\n        \\n        return dp[target];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020261,
                "title": "90-00-beats-c-dp-memoization-easy-to-understand-beginner",
                "content": "# Problem Understanding:\\n- The code aims to solve the \"Combination Sum IV\" problem using dynamic programming. The problem statement can be summarized as follows:\\n\\n**Given:**\\n\\n- An array `nums` containing distinct positive integers.\\n- A target integer `target`.\\n\\n**Task:**\\nFind and return the number of possible combinations of numbers from the `nums` array that sum up to the given `target`. Each number from the `nums` array can be used an unlimited number of times.\\n\\n\\n# Intuition\\n- The code aims to solve the \"Combination Sum IV\" problem** using a recursive ****approach with memoization (dynamic programming). **\\n- The problem is about finding the number of combinations that sum up to a given `target` using elements from the `nums` array, where elements from `nums` can be used an unlimited number of times.\\n\\n# Approach\\n**1. Recursive Function (f):**\\n- The recursive function `f` is designed to find the number of combinations to reach a specific `target` using elements from the `nums` array.\\n- If the `target` becomes 0, it means we\\'ve found a valid combination. In this case, the function returns 1.\\n- If the `target` becomes negative, it means the current combination is not valid, so the function returns 0.\\n- Memoization is used to store and reuse previously calculated results. If `dp[target]` is not equal to -1 (indicating it has already been computed), the function returns the cached `result`.\\n- The `take` variable is used to accumulate the number of valid combinations for the current `target` value by considering all possible choices from the `nums` array.\\n- The function recursively calls itself for each element in `nums`, subtracting the current element from the `target` and adding the result to `take`.\\n\\n1. **combinationSum4 Function:**\\n\\n- **This function serve**s as the entry point to the solution.\\n- It initializes a vector `dp` of size `target+1` with all elements set to -1. This `dp` vector will be used for memoization to avoid redundant calculations.\\n- It then calls the `f` function with the following arguments:\\n     - **`n:`** The size of the `nums` array (`nums.size()`).\\n     - **`nums:`** The array of positive integers.\\n    - **`target:`** The target value.\\n     - **`dp:`** The memoization vector.\\n- Finally, it returns the result obtained from the `f` function, which represents the total number of combinations to reach the `target` using elements from the `nums` array.\\n\\n**In summary, this code solves the problem by recursively exploring** all possible combinations using elements from the `nums` array and memoizing the results to avoid redundant calculations. The final result is the number of valid combinations that sum up to the given `target`.\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n     **O(n^target)**\\n\\n- Space complexity:\\n   **O(target)**.\\n\\n# PLEASE UPVOTE\\u2763\\uD83D\\uDE0D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Recursive function to count combinations\\n    int f(int n, vector<int>& nums, int target, vector<int>& dp) {\\n\\n        // If the target is reached, return 1 (one valid combination found)\\n        if (target == 0) {\\n            return 1;\\n        }\\n        // If the target becomes negative, it\\'s not a valid combination\\n        if (target < 0) {\\n            return 0;\\n        }\\n        // If the result for the current target is already calculated, return it\\n        if (dp[target] != -1) {\\n            return dp[target];\\n        }\\n        int take = 0;\\n\\n        // Iterate through the numbers and try taking each one to reach the target\\n        for (int j = 0; j < n; ++j) {\\n            take += f(n, nums, target - nums[j], dp); // Recursively count combinations\\n        }\\n\\n        // Store the result in the DP table and return it\\n        return dp[target] = take;\\n    }\\n \\n    int combinationSum4(vector<int>& nums, int target) {\\n \\n        vector<int>dp(target+1,-1);\\n       return f(nums.size(),nums,target,dp);\\n             \\n \\n    }\\n};\\n```\\n# JAVA\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int f(int n, int[] nums, int target, int[] dp) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n\\n        if (dp[target] != -1) {\\n            return dp[target];\\n        }\\n\\n        int take = 0;\\n\\n        for (int j = 0; j < n; ++j) {\\n            take += f(n, nums, target - nums[j], dp);\\n        }\\n\\n        return dp[target] = take;\\n    }\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        Arrays.fill(dp, -1);\\n        return f(nums.length, nums, target, dp);\\n    }\\n\\n    public static void main(String[] args) {\\n        Solution solution = new Solution();\\n        int[] nums = {1, 2, 3};\\n        int target = 4;\\n        int result = solution.combinationSum4(nums, target);\\n        System.out.println(\"Number of combinations: \" + result);\\n    }\\n}\\n\\n```\\n# PYTHON\\n```\\nclass Solution:\\n    def f(self, n, nums, target, dp):\\n        if target == 0:\\n            return 1\\n        if target < 0:\\n            return 0\\n\\n        if dp[target] != -1:\\n            return dp[target]\\n\\n        take = 0\\n\\n        for j in range(n):\\n            take += self.f(n, nums, target - nums[j], dp)\\n\\n        dp[target] = take\\n        return take\\n\\n    def combinationSum4(self, nums, target):\\n        dp = [-1] * (target + 1)\\n        return self.f(len(nums), nums, target, dp)\\n\\n# Example usage:\\nsolution = Solution()\\nnums = [1, 2, 3]\\ntarget = 4\\nresult = solution.combinationSum4(nums, target)\\nprint(\"Number of combinations:\", result)\\n\\n```\\n# JAVASCRIPT\\n```\\nclass Solution {\\n    f(n, nums, target, dp) {\\n        if (target === 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n\\n        if (dp[target] !== -1) {\\n            return dp[target];\\n        }\\n\\n        let take = 0;\\n\\n        for (let j = 0; j < n; ++j) {\\n            take += this.f(n, nums, target - nums[j], dp);\\n        }\\n\\n        dp[target] = take;\\n        return take;\\n    }\\n\\n    combinationSum4(nums, target) {\\n        const dp = Array(target + 1).fill(-1);\\n        return this.f(nums.length, nums, target, dp);\\n    }\\n}\\n\\n// Example usage:\\nconst solution = new Solution();\\nconst nums = [1, 2, 3];\\nconst target = 4;\\nconst result = solution.combinationSum4(nums, target);\\nconsole.log(\"Number of combinations:\", result);\\n\\n```\\n# GO\\n```\\npackage main\\n\\nimport \"fmt\"\\n\\ntype Solution struct{}\\n\\nfunc (s Solution) f(n int, nums []int, target int, dp []int) int {\\n\\tif target == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tif target < 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif dp[target] != -1 {\\n\\t\\treturn dp[target]\\n\\t}\\n\\n\\ttake := 0\\n\\n\\tfor j := 0; j < n; j++ {\\n\\t\\ttake += s.f(n, nums, target-nums[j], dp)\\n\\t}\\n\\n\\tdp[target] = take\\n\\treturn take\\n}\\n\\nfunc (s Solution) combinationSum4(nums []int, target int) int {\\n\\tdp := make([]int, target+1)\\n\\tfor i := 0; i <= target; i++ {\\n\\t\\tdp[i] = -1\\n\\t}\\n\\treturn s.f(len(nums), nums, target, dp)\\n}\\n\\nfunc main() {\\n\\tsolution := Solution{}\\n\\tnums := []int{1, 2, 3}\\n\\ttarget := 4\\n\\tresult := solution.combinationSum4(nums, target)\\n\\tfmt.Println(\"Number of combinations:\", result)\\n}\\n\\n```\\n# PLEASE UPVOTE\\u2763\\uD83D\\uDE0D\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Recursive function to count combinations\\n    int f(int n, vector<int>& nums, int target, vector<int>& dp) {\\n\\n        // If the target is reached, return 1 (one valid combination found)\\n        if (target == 0) {\\n            return 1;\\n        }\\n        // If the target becomes negative, it\\'s not a valid combination\\n        if (target < 0) {\\n            return 0;\\n        }\\n        // If the result for the current target is already calculated, return it\\n        if (dp[target] != -1) {\\n            return dp[target];\\n        }\\n        int take = 0;\\n\\n        // Iterate through the numbers and try taking each one to reach the target\\n        for (int j = 0; j < n; ++j) {\\n            take += f(n, nums, target - nums[j], dp); // Recursively count combinations\\n        }\\n\\n        // Store the result in the DP table and return it\\n        return dp[target] = take;\\n    }\\n \\n    int combinationSum4(vector<int>& nums, int target) {\\n \\n        vector<int>dp(target+1,-1);\\n       return f(nums.size(),nums,target,dp);\\n             \\n \\n    }\\n};\\n```\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int f(int n, int[] nums, int target, int[] dp) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n\\n        if (dp[target] != -1) {\\n            return dp[target];\\n        }\\n\\n        int take = 0;\\n\\n        for (int j = 0; j < n; ++j) {\\n            take += f(n, nums, target - nums[j], dp);\\n        }\\n\\n        return dp[target] = take;\\n    }\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        Arrays.fill(dp, -1);\\n        return f(nums.length, nums, target, dp);\\n    }\\n\\n    public static void main(String[] args) {\\n        Solution solution = new Solution();\\n        int[] nums = {1, 2, 3};\\n        int target = 4;\\n        int result = solution.combinationSum4(nums, target);\\n        System.out.println(\"Number of combinations: \" + result);\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def f(self, n, nums, target, dp):\\n        if target == 0:\\n            return 1\\n        if target < 0:\\n            return 0\\n\\n        if dp[target] != -1:\\n            return dp[target]\\n\\n        take = 0\\n\\n        for j in range(n):\\n            take += self.f(n, nums, target - nums[j], dp)\\n\\n        dp[target] = take\\n        return take\\n\\n    def combinationSum4(self, nums, target):\\n        dp = [-1] * (target + 1)\\n        return self.f(len(nums), nums, target, dp)\\n\\n# Example usage:\\nsolution = Solution()\\nnums = [1, 2, 3]\\ntarget = 4\\nresult = solution.combinationSum4(nums, target)\\nprint(\"Number of combinations:\", result)\\n\\n```\n```\\nclass Solution {\\n    f(n, nums, target, dp) {\\n        if (target === 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n\\n        if (dp[target] !== -1) {\\n            return dp[target];\\n        }\\n\\n        let take = 0;\\n\\n        for (let j = 0; j < n; ++j) {\\n            take += this.f(n, nums, target - nums[j], dp);\\n        }\\n\\n        dp[target] = take;\\n        return take;\\n    }\\n\\n    combinationSum4(nums, target) {\\n        const dp = Array(target + 1).fill(-1);\\n        return this.f(nums.length, nums, target, dp);\\n    }\\n}\\n\\n// Example usage:\\nconst solution = new Solution();\\nconst nums = [1, 2, 3];\\nconst target = 4;\\nconst result = solution.combinationSum4(nums, target);\\nconsole.log(\"Number of combinations:\", result);\\n\\n```\n```\\npackage main\\n\\nimport \"fmt\"\\n\\ntype Solution struct{}\\n\\nfunc (s Solution) f(n int, nums []int, target int, dp []int) int {\\n\\tif target == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tif target < 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif dp[target] != -1 {\\n\\t\\treturn dp[target]\\n\\t}\\n\\n\\ttake := 0\\n\\n\\tfor j := 0; j < n; j++ {\\n\\t\\ttake += s.f(n, nums, target-nums[j], dp)\\n\\t}\\n\\n\\tdp[target] = take\\n\\treturn take\\n}\\n\\nfunc (s Solution) combinationSum4(nums []int, target int) int {\\n\\tdp := make([]int, target+1)\\n\\tfor i := 0; i <= target; i++ {\\n\\t\\tdp[i] = -1\\n\\t}\\n\\treturn s.f(len(nums), nums, target, dp)\\n}\\n\\nfunc main() {\\n\\tsolution := Solution{}\\n\\tnums := []int{1, 2, 3}\\n\\ttarget := 4\\n\\tresult := solution.combinationSum4(nums, target)\\n\\tfmt.Println(\"Number of combinations:\", result)\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546467,
                "title": "java-tc-o-n-t-sc-o-t-dp-bottomup-topdown-w-followup",
                "content": "**Dynamic Programming Bottom Up - Iterative Approach**\\n\\n```java\\n/**\\n * Dynamic Programming Bottom Up - Iterative Approach\\n *\\n * DP[i] = Number of ways to achieve target i using all possible numbers in the nums array.\\n * DP[i] = (j = 0 -> N-1) \\u2211 DP[i-nums[j]]. Where, i-nums[j] >= 0 & DP[0] = 1\\n *\\n * Time Complexity: O(N * T)\\n *\\n * Space Complexity: O(T)\\n *\\n * N = Length of input array. T = Input target.\\n */\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        if (nums == null || nums.length == 0 || target <= 0) {\\n            return 0;\\n        }\\n\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n\\n        for (int i = 1; i <= target; i++) {\\n            for (int n : nums) {\\n                if (i >= n) {\\n                    dp[i] += dp[i - n];\\n                }\\n            }\\n        }\\n\\n        return dp[target];\\n    }\\n}\\n```\\n\\n---\\n**Dynamic Programming Top Down - Recursive Approach**\\n\\n```java\\n/**\\n * Dynamic Programming Top Down - Recursive Approach\\n *\\n * Time Complexity: O(N * T)\\n *\\n * Space Complexity: O(T)\\n *\\n * N = Length of input array. T = Input target.\\n */\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        if (nums == null || nums.length == 0 || target <= 0) {\\n            return 0;\\n        }\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        return combinationSum4Helper(nums, target, map);\\n    }\\n\\n    private int combinationSum4Helper(int[] nums, int target, HashMap<Integer, Integer> map) {\\n        if (map.containsKey(target)) {\\n            return map.get(target);\\n        }\\n\\n        int count = 0;\\n        for (int n : nums) {\\n            if (target >= n) {\\n                count += combinationSum4Helper(nums, target - n, map);\\n            }\\n        }\\n\\n        map.put(target, count);\\n        return count;\\n    }\\n}\\n```\\n\\n---\\n**Follow-Up: Both Negative & Positive numbers can be present in input `nums` array**\\n```java\\n/**\\n * This solution is for Follow-Up where both Negative And Positive Numbers can\\n * be given in the input nums array. Since we can have infinite length\\n * combinations, we will restrict the search by setting a maximum length of the\\n * combinations.\\n *\\n * Dynamic Programming Top Down - Recursive Approach\\n *\\n * DP(T,l) = Maximum number of ways T can be achieved in length from 1 to l\\n *\\n * Time Complexity: O(N * M * T)\\n *\\n * Space Complexity: O(T * M)\\n *\\n * N = Length of input array. T = Input target. M = Max Length of the permutation\\n */\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int min = nums[0];\\n        for (int n : nums) {\\n            min = Math.min(min, n);\\n        }\\n        return combinationSum4NegativePositiveNums(nums, target, target / min);\\n    }\\n\\n    public int combinationSum4NegativePositiveNums(int[] nums, int target, int maxLen) {\\n        if (nums == null || nums.length == 0 || maxLen <= 0) {\\n            return 0;\\n        }\\n        HashMap<Integer, HashMap<Integer, Integer>> map = new HashMap<>();\\n        return combinationSum4NegativePositiveNumsHelper(target, map, nums, maxLen, maxLen);\\n    }\\n\\n    private int combinationSum4NegativePositiveNumsHelper(int target, HashMap<Integer, HashMap<Integer, Integer>> map, int[] nums, int length, int maxLen) {\\n        if (length < 0) {\\n            return 0;\\n        }\\n        if (length == 0) {\\n            return target == 0 ? 1 : 0;\\n        }\\n        if (map.containsKey(target) && map.get(target).containsKey(length)) {\\n            return map.get(target).get(length);\\n        }\\n\\n        int count = 0;\\n        if (target == 0 && length != maxLen) {\\n            count++;\\n        }\\n        for (int n : nums) {\\n            count += combinationSum4NegativePositiveNumsHelper(target - n, map, nums, length - 1, maxLen);\\n        }\\n\\n        if (!map.containsKey(target)) {\\n            map.put(target, new HashMap<>());\\n        }\\n        map.get(target).put(length, count);\\n        return count;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1546400/Java-or-Backtracking-w-Early-Exit-(Detailed-Time-Complexity-explanation-added))\\n- [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/1546439/Java-or-Backtracking-optimized-for-duplicate-candidates-(Detailed-TC-explanation-added))\\n- [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/1546449/Java-or-Optimized-Backtracking-w-Detailed-Time-Complexity-explanation)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n * Dynamic Programming Bottom Up - Iterative Approach\\n *\\n * DP[i] = Number of ways to achieve target i using all possible numbers in the nums array.\\n * DP[i] = (j = 0 -> N-1) \\u2211 DP[i-nums[j]]. Where, i-nums[j] >= 0 & DP[0] = 1\\n *\\n * Time Complexity: O(N * T)\\n *\\n * Space Complexity: O(T)\\n *\\n * N = Length of input array. T = Input target.\\n */\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        if (nums == null || nums.length == 0 || target <= 0) {\\n            return 0;\\n        }\\n\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n\\n        for (int i = 1; i <= target; i++) {\\n            for (int n : nums) {\\n                if (i >= n) {\\n                    dp[i] += dp[i - n];\\n                }\\n            }\\n        }\\n\\n        return dp[target];\\n    }\\n}\\n```\n```java\\n/**\\n * Dynamic Programming Top Down - Recursive Approach\\n *\\n * Time Complexity: O(N * T)\\n *\\n * Space Complexity: O(T)\\n *\\n * N = Length of input array. T = Input target.\\n */\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        if (nums == null || nums.length == 0 || target <= 0) {\\n            return 0;\\n        }\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        return combinationSum4Helper(nums, target, map);\\n    }\\n\\n    private int combinationSum4Helper(int[] nums, int target, HashMap<Integer, Integer> map) {\\n        if (map.containsKey(target)) {\\n            return map.get(target);\\n        }\\n\\n        int count = 0;\\n        for (int n : nums) {\\n            if (target >= n) {\\n                count += combinationSum4Helper(nums, target - n, map);\\n            }\\n        }\\n\\n        map.put(target, count);\\n        return count;\\n    }\\n}\\n```\n```java\\n/**\\n * This solution is for Follow-Up where both Negative And Positive Numbers can\\n * be given in the input nums array. Since we can have infinite length\\n * combinations, we will restrict the search by setting a maximum length of the\\n * combinations.\\n *\\n * Dynamic Programming Top Down - Recursive Approach\\n *\\n * DP(T,l) = Maximum number of ways T can be achieved in length from 1 to l\\n *\\n * Time Complexity: O(N * M * T)\\n *\\n * Space Complexity: O(T * M)\\n *\\n * N = Length of input array. T = Input target. M = Max Length of the permutation\\n */\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int min = nums[0];\\n        for (int n : nums) {\\n            min = Math.min(min, n);\\n        }\\n        return combinationSum4NegativePositiveNums(nums, target, target / min);\\n    }\\n\\n    public int combinationSum4NegativePositiveNums(int[] nums, int target, int maxLen) {\\n        if (nums == null || nums.length == 0 || maxLen <= 0) {\\n            return 0;\\n        }\\n        HashMap<Integer, HashMap<Integer, Integer>> map = new HashMap<>();\\n        return combinationSum4NegativePositiveNumsHelper(target, map, nums, maxLen, maxLen);\\n    }\\n\\n    private int combinationSum4NegativePositiveNumsHelper(int target, HashMap<Integer, HashMap<Integer, Integer>> map, int[] nums, int length, int maxLen) {\\n        if (length < 0) {\\n            return 0;\\n        }\\n        if (length == 0) {\\n            return target == 0 ? 1 : 0;\\n        }\\n        if (map.containsKey(target) && map.get(target).containsKey(length)) {\\n            return map.get(target).get(length);\\n        }\\n\\n        int count = 0;\\n        if (target == 0 && length != maxLen) {\\n            count++;\\n        }\\n        for (int n : nums) {\\n            count += combinationSum4NegativePositiveNumsHelper(target - n, map, nums, length - 1, maxLen);\\n        }\\n\\n        if (!map.containsKey(target)) {\\n            map.put(target, new HashMap<>());\\n        }\\n        map.get(target).put(length, count);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835673,
                "title": "c-solution-well-commented",
                "content": "\\n\\t\\tThink about climbing stairs question.\\n\\t\\tThe difference is we can only step 1 or 2 in the climbing stair problem. \\n\\t\\tHere, we have multiple size of steps to reach to the target. \\n\\t\\tTherefore, we need to iterate the nums vector and check the smaller number\\n\\t\\tas the corner stone to reach the final target.\\n```\\n\\tint combinationSum4(vector<int>& nums, int target) {\\n        /* sorting is used to minimize the run time for iterating through the nums.\\n            Once we reach number greater than the target we are looking for, there\\'s no need to search for the rest.\\n        */\\n        sort(nums.begin(), nums.end());\\n        // use unsigned long to prevent integer overflow\\n        vector<unsigned long> dp(target + 1, 0);\\n        // standing on the ground also count as one way.\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; ++i){\\n            int ways = 0;\\n            for (int j = 0; j < nums.size(); ++j){\\n                int remain = i - nums[j];\\n                if (remain < 0) break;\\n                // the way it can reach the point are always start from the smaller number\\n                ways += dp[remain];\\n            }\\n            dp[i] = ways;\\n        }\\n        return dp[target];\\n    }\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\t\\tThink about climbing stairs question.\\n\\t\\tThe difference is we can only step 1 or 2 in the climbing stair problem. \\n\\t\\tHere, we have multiple size of steps to reach to the target. \\n\\t\\tTherefore, we need to iterate the nums vector and check the smaller number\\n\\t\\tas the corner stone to reach the final target.\\n```\\n\\tint combinationSum4(vector<int>& nums, int target) {\\n        /* sorting is used to minimize the run time for iterating through the nums.\\n            Once we reach number greater than the target we are looking for, there\\'s no need to search for the rest.\\n        */\\n        sort(nums.begin(), nums.end());\\n        // use unsigned long to prevent integer overflow\\n        vector<unsigned long> dp(target + 1, 0);\\n        // standing on the ground also count as one way.\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; ++i){\\n            int ways = 0;\\n            for (int j = 0; j < nums.size(); ++j){\\n                int remain = i - nums[j];\\n                if (remain < 0) break;\\n                // the way it can reach the point are always start from the smaller number\\n                ways += dp[remain];\\n            }\\n            dp[i] = ways;\\n        }\\n        return dp[target];\\n    }\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2381323,
                "title": "python-dynamic-programming-explained",
                "content": "We\\'re gonna be **solving** this by making a **DP array** here and building up target; meaning\\nif the input is \\n- **nums = [1,2,3], target = 4**\\n\\nOur dp array would initially look like \\u2193\\n- **dp = [0,0,0,0,0]**\\nindex-0 1 2 3 4 \\n\\t\\t \\n**dp[0] = 1**, because there\\'s only one way to form the target 0, which is 1\\n- **dp = [1,0,0,0,0]**\\nindex-0 1 2 3 4 \\n\\nNow in the nested loop we take every target starting from 1 and we also take every num and check if our\\n**target >= num**, then we update **dp[t] = dp[t] + dp[t-num].**\\n\\n**Eventually** we\\'ll have the value of dp[target] and so **return dp[target]**.\\n\\n`TIME:` **O(n) * O(t) = O(n*t)**\\n`SPACE`: **O(t)**\\n\\n`FOLLOW UP:` If we had negative numbers allowed here, how does that change the program?\\n- Well that changes a lot because now we could\\'ve infinite possible number of solutions.\\nIf we had [-1 -1], target = 0, we could have (-1, -1, 1, 1, -1, -1, 1); it\\'s infinite!\\nSo then we need some sort of limitation for maximum number we can use to build up target.\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        # dp\\n        dp = [0] * (target+1)   # target+1 because we need dp[0]\\n        dp[0] = 1\\n        \\n        for t in range(1, target+1):\\n            for num in nums:\\n                if t>=num:\\n                    dp[t] += dp[t-num]\\n                    \\n        return dp[target]\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        # dp\\n        dp = [0] * (target+1)   # target+1 because we need dp[0]\\n        dp[0] = 1\\n        \\n        for t in range(1, target+1):\\n            for num in nums:\\n                if t>=num:\\n                    dp[t] += dp[t-num]\\n                    \\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380973,
                "title": "dp-explain-with-a-picture",
                "content": "![image](https://assets.leetcode.com/users/images/5fe80e73-4aa2-4f51-b5fa-f7fda094e81c_1659667427.4814506.png)\\n\\n```python\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n\\t\\n\\t\\t# Sort the nums to break the loop when total - num becomes negative.\\n        nums.sort()\\n\\n\\t\\t# Allocates the dp table\\n        dp = [0] * (target + 1)\\n\\n        # The case total becomes 0 is only 1 (nothing add)\\n        dp[0] = 1\\n\\n\\t\\t# Try the all cases the total from 1 to target\\n        for total in range(1, target + 1):\\n\\t\\t\\n\\t\\t\\t# Try all possible numbers.\\n            for num in nums:\\n\\t\\t\\t\\n                if total - num >= 0:\\n\\t\\t\\t\\t\\t# Uses the previous information\\n                    dp[total] += dp[total - num]\\n                else:\\n                    break\\n        return dp[target]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n\\t\\n\\t\\t# Sort the nums to break the loop when total - num becomes negative.\\n        nums.sort()\\n\\n\\t\\t# Allocates the dp table\\n        dp = [0] * (target + 1)\\n\\n        # The case total becomes 0 is only 1 (nothing add)\\n        dp[0] = 1\\n\\n\\t\\t# Try the all cases the total from 1 to target\\n        for total in range(1, target + 1):\\n\\t\\t\\n\\t\\t\\t# Try all possible numbers.\\n            for num in nums:\\n\\t\\t\\t\\n                if total - num >= 0:\\n\\t\\t\\t\\t\\t# Uses the previous information\\n                    dp[total] += dp[total - num]\\n                else:\\n                    break\\n        return dp[target]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166181,
                "title": "python-go-by-dfs-memo-w-comment",
                "content": "Python by DFS + Memo\\n\\n---\\n\\n**Implementation** by DFS in Python:\\n\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n    \\n        # look-up table\\n        combination_count = {}\\n        \\n        # --------------------------------\\n        \\n        def dfs(wanted):\\n            \\n            ## base cases:\\n            \\n            if wanted < 0:\\n                # stop condition for negative number\\n                return 0\\n            \\n            elif wanted == 0:\\n                # stop condition for perfect match\\n                return 1\\n            \\n            if wanted in combination_count:\\n                # quick resposne by look-up table\\n                return combination_count[wanted]\\n            \\n            ## general cases\\n            count = 0\\n            \\n            for number in nums:\\n                \\n                next_wanted = wanted - number\\n\\n                count += dfs(next_wanted)\\n            \\n            combination_count[wanted] = count\\n            return count\\n        \\n        # --------------------------------\\n        \\n        return dfs(wanted=target)\\n```\\n\\n---\\n\\n**Implementation** by DFS in Go:\\n\\n```\\nfunc combinationSum4(nums []int, target int) int {\\n    \\n    // look-up table\\n    combinationCount := make(map[int]int)\\n    \\n    // --------------------------------------------------\\n    \\n    // function variable\\n    var dfs func(int)int\\n    \\n    dfs = func(wanted int) int{\\n        \\n        // base cases:\\n        if wanted < 0{\\n            // stop condition for negative number\\n            return 0\\n        }else if wanted == 0{\\n            // stop condition for perfect match\\n            return 1\\n        }\\n        \\n        if count, exist := combinationCount[wanted]; exist == true{\\n            // quick response by look-up table\\n            return count\\n        }\\n        \\n        // general cases\\n        count := 0\\n        \\n        for _, number := range nums{\\n            \\n            nextWanted := wanted - number\\n            \\n            count += dfs( nextWanted )\\n            \\n        }\\n        \\n        combinationCount[wanted] = count\\n        return count\\n    }\\n    // --------------------------------------------------\\n    \\n    \\n    return dfs(target)\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n    \\n        # look-up table\\n        combination_count = {}\\n        \\n        # --------------------------------\\n        \\n        def dfs(wanted):\\n            \\n            ## base cases:\\n            \\n            if wanted < 0:\\n                # stop condition for negative number\\n                return 0\\n            \\n            elif wanted == 0:\\n                # stop condition for perfect match\\n                return 1\\n            \\n            if wanted in combination_count:\\n                # quick resposne by look-up table\\n                return combination_count[wanted]\\n            \\n            ## general cases\\n            count = 0\\n            \\n            for number in nums:\\n                \\n                next_wanted = wanted - number\\n\\n                count += dfs(next_wanted)\\n            \\n            combination_count[wanted] = count\\n            return count\\n        \\n        # --------------------------------\\n        \\n        return dfs(wanted=target)\\n```\n```\\nfunc combinationSum4(nums []int, target int) int {\\n    \\n    // look-up table\\n    combinationCount := make(map[int]int)\\n    \\n    // --------------------------------------------------\\n    \\n    // function variable\\n    var dfs func(int)int\\n    \\n    dfs = func(wanted int) int{\\n        \\n        // base cases:\\n        if wanted < 0{\\n            // stop condition for negative number\\n            return 0\\n        }else if wanted == 0{\\n            // stop condition for perfect match\\n            return 1\\n        }\\n        \\n        if count, exist := combinationCount[wanted]; exist == true{\\n            // quick response by look-up table\\n            return count\\n        }\\n        \\n        // general cases\\n        count := 0\\n        \\n        for _, number := range nums{\\n            \\n            nextWanted := wanted - number\\n            \\n            count += dfs( nextWanted )\\n            \\n        }\\n        \\n        combinationCount[wanted] = count\\n        return count\\n    }\\n    // --------------------------------------------------\\n    \\n    \\n    return dfs(target)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475901,
                "title": "python-top-down-dp-clean-concise",
                "content": "**Solution 1: Top down DP**\\n- Seem same with problem **[518. Coin Change 2](https://leetcode.com/problems/coin-change-2/)**, except the node that different sequences are counted as different combinations.\\n```python\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        @lru_cache(None)\\n        def dp(target):\\n            if target == 0:\\n                return 1\\n            \\n            ans = 0\\n            for num in nums:\\n                if target >= num:\\n                    ans += dp(target - num)\\n            return ans\\n        \\n        return dp(target)\\n```\\n**Complexity**\\n- Time: `O(target * N)`, where `target <= 1000`, `N <= 200` is number of elements in `nums` array.\\n- Space: `O(target)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        @lru_cache(None)\\n        def dp(target):\\n            if target == 0:\\n                return 1\\n            \\n            ans = 0\\n            for num in nums:\\n                if target >= num:\\n                    ans += dp(target - num)\\n            return ans\\n        \\n        return dp(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166087,
                "title": "3-java-solutions-recursion-dp-memoization-dp-iterative-bottom-up",
                "content": "*------Please **upvote!** if you like the solution.  Please put your queries/doubts in the comments section below.  I will try my best to answer them.------*\\n\\n**RECURSIVE Code (will give TLE for large testcases):**\\n```\\npublic int combinationSum4(int[] nums, int target) {\\n    if (target == 0) {\\n        return 1;\\n    }\\n    int count = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums [i] <= target)\\n            count += combinationSum4 (nums, target - nums [i]);\\n    }\\n    return count;\\n}\\n```\\n\\n**DP (MEMOIZATION) of the above Recursive Code:**\\n```\\nclass Solution {\\n    public int dp [];\\n    \\n    public int combinationSum4 (int[] nums, int target) {\\n        dp = new int [target + 1];\\n        Arrays.fill (dp, -1);\\n        return Solve (nums, target);\\n    }\\n    \\n    public int Solve (int nums [], int sum) {\\n        if (sum == 0)\\n            return 1;\\n        if (sum < 0)\\n            return 0;\\n        if (dp [sum] != -1)\\n            return dp [sum];\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums [i] <= sum)\\n                count += Solve (nums, sum - nums [i]);\\n        }\\n        return dp [sum] = count;\\n    }\\n}\\n```\\n\\n**Iterative DP (Bottom - up) Approach:**\\n\\n```\\nclass Solution {    \\n    public int combinationSum4(int[] nums, int target) {\\n        int dp [] = new int [target + 1];\\n        dp [0] = 1;\\n        for (int tar = 1; tar < target + 1; tar++) {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums [i] <= tar)\\n                    dp [tar] += dp [tar - nums [i]];\\n            }\\n        }\\n        return dp [target];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int combinationSum4(int[] nums, int target) {\\n    if (target == 0) {\\n        return 1;\\n    }\\n    int count = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums [i] <= target)\\n            count += combinationSum4 (nums, target - nums [i]);\\n    }\\n    return count;\\n}\\n```\n```\\nclass Solution {\\n    public int dp [];\\n    \\n    public int combinationSum4 (int[] nums, int target) {\\n        dp = new int [target + 1];\\n        Arrays.fill (dp, -1);\\n        return Solve (nums, target);\\n    }\\n    \\n    public int Solve (int nums [], int sum) {\\n        if (sum == 0)\\n            return 1;\\n        if (sum < 0)\\n            return 0;\\n        if (dp [sum] != -1)\\n            return dp [sum];\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums [i] <= sum)\\n                count += Solve (nums, sum - nums [i]);\\n        }\\n        return dp [sum] = count;\\n    }\\n}\\n```\n```\\nclass Solution {    \\n    public int combinationSum4(int[] nums, int target) {\\n        int dp [] = new int [target + 1];\\n        dp [0] = 1;\\n        for (int tar = 1; tar < target + 1; tar++) {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums [i] <= tar)\\n                    dp [tar] += dp [tar - nums [i]];\\n            }\\n        }\\n        return dp [target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372732,
                "title": "python-permutation-vs-combinations-one-line-change-with-tracing",
                "content": "The solution below passes and finds all permutations. I\\'ve found that if you swap F1 and F2, you get all combiantions.\\n\\nIntuively, if the number is in the outer loop, we are aiming for find how to create all targets using that number (no duplicates). If the target is in the outer loop, we are repeatedly trying to reuse that number on every iteration.\\n\\nHowever, even with the intuition above, and the tracing below, it\\'s still a little hard for me to wrap my head around so I thought I\\'d share with the community.\\n\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        combs = [0] * (target + 1)\\n        combs[0] = 1\\n        for t in range(1, target + 1): # F1\\n            for n in nums: # F2\\n                if t >= n:\\n                    combs[t] += combs[t-n]\\n        return combs[target]\\n```\\n\\n# Permutations:\\n```\\ntarget: 3\\nnums: [1,2]\\n```\\n\\n```\\n# No iteration of F1\\ncombs[0] # ()\\n\\n# First Iteration of F1: t = 1, n = [1,2]\\ncombs[1] += combs[1-1] # (1)\\n\\ncombs[1] = 1 # [(1)]\\n\\n# Second Iteration of F1: t = 2, n = [1,2]\\ncombs[2] += combs[2-1] # (1, 1)\\ncombs[2] += combs[2-2] # (2)\\n\\ncombs[2] = 2 # [(1, 1), (2)]\\n\\n# Third Iteration of F1: t = 3, n = [1,2]\\ncombs[3] += combs[3-1] # (1, 1, 1), (2, 1)\\ncombs[3] += combs[3-2] # (1, 2)\\n\\ncombs[3] = 2 # [(1, 1, 1), (2, 1), (1, 2)]\\n```\\n\\n*Assume that F1 and F2 are swapped places for this\\n# Combinations:\\n```\\ntarget: 3\\nnums: [1,2]\\n```\\n\\n```\\n# No iteration\\ncombs[0] # ()\\n\\n# First Iteration of F2: n = 1, t = [1,2,3]\\ncombs[1] += combs[1-1] # (1)\\ncombs[2] += combs[2-1] # (1, 1)\\ncombs[3] += combs[3-1] # (1, 1, 1)\\n\\ncombs[1] = 1 # [(1)]\\ncombs[2] = 0 # [(1, 1)]\\ncombs[3] = 0 # [(0)]\\n\\n# First Iteration of F2: n = 2, t = [1,2,3]\\ncombs[2] += combs[2-2] # (2)\\ncombs[3] += combs[3-2] # (1, 2)\\n\\ncombs[1] = 1 # [(1)]\\ncombs[2] = 0 # [(1,1), (2)]\\ncombs[3] = 0 # [(1, 1, 1), (1, 2)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        combs = [0] * (target + 1)\\n        combs[0] = 1\\n        for t in range(1, target + 1): # F1\\n            for n in nums: # F2\\n                if t >= n:\\n                    combs[t] += combs[t-n]\\n        return combs[target]\\n```\n```\\ntarget: 3\\nnums: [1,2]\\n```\n```\\n# No iteration of F1\\ncombs[0] # ()\\n\\n# First Iteration of F1: t = 1, n = [1,2]\\ncombs[1] += combs[1-1] # (1)\\n\\ncombs[1] = 1 # [(1)]\\n\\n# Second Iteration of F1: t = 2, n = [1,2]\\ncombs[2] += combs[2-1] # (1, 1)\\ncombs[2] += combs[2-2] # (2)\\n\\ncombs[2] = 2 # [(1, 1), (2)]\\n\\n# Third Iteration of F1: t = 3, n = [1,2]\\ncombs[3] += combs[3-1] # (1, 1, 1), (2, 1)\\ncombs[3] += combs[3-2] # (1, 2)\\n\\ncombs[3] = 2 # [(1, 1, 1), (2, 1), (1, 2)]\\n```\n```\\ntarget: 3\\nnums: [1,2]\\n```\n```\\n# No iteration\\ncombs[0] # ()\\n\\n# First Iteration of F2: n = 1, t = [1,2,3]\\ncombs[1] += combs[1-1] # (1)\\ncombs[2] += combs[2-1] # (1, 1)\\ncombs[3] += combs[3-1] # (1, 1, 1)\\n\\ncombs[1] = 1 # [(1)]\\ncombs[2] = 0 # [(1, 1)]\\ncombs[3] = 0 # [(0)]\\n\\n# First Iteration of F2: n = 2, t = [1,2,3]\\ncombs[2] += combs[2-2] # (2)\\ncombs[3] += combs[3-2] # (1, 2)\\n\\ncombs[1] = 1 # [(1)]\\ncombs[2] = 0 # [(1,1), (2)]\\ncombs[3] = 0 # [(1, 1, 1), (1, 2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162264,
                "title": "python-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def combinationSum4(self, nums, target):\\n        dp = [0 for i in range(target + 1)]\\n        dp[0] = 1\\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        return dp[target]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum4(self, nums, target):\\n        dp = [0 for i in range(target + 1)]\\n        dp[0] = 1\\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021846,
                "title": "recursion-memoization-tabulation-code-in-cpp",
                "content": "This will give Time Limit Exceeded\\nRecursion code\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&nums, int target){\\n        if(target < 0) return 0;\\n        if(target == 0)return 1;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans+=solve(nums, target-nums[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int combinationSum4(vector<int>& nums, int target) {\\n        return solve(nums, target);\\n    }\\n};\\n```\\nMemoization Code\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&nums, int target, vector<int>& dp){\\n        if(target < 0) return 0;\\n        if(target == 0)return 1;\\n        if(dp[target]!=-1) return dp[target];\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans+=solve(nums, target-nums[i], dp);\\n        }\\n        dp[target] = ans;\\n        return dp[target];\\n    }\\n\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target+1, -1);\\n        return solve(nums, target, dp);\\n    }\\n};\\n```\\nTabulation Code\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target+1, 0);\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(i-nums[j]>=0)\\n                    dp[i]+=dp[i-nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&nums, int target){\\n        if(target < 0) return 0;\\n        if(target == 0)return 1;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans+=solve(nums, target-nums[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int combinationSum4(vector<int>& nums, int target) {\\n        return solve(nums, target);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&nums, int target, vector<int>& dp){\\n        if(target < 0) return 0;\\n        if(target == 0)return 1;\\n        if(dp[target]!=-1) return dp[target];\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans+=solve(nums, target-nums[i], dp);\\n        }\\n        dp[target] = ans;\\n        return dp[target];\\n    }\\n\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target+1, -1);\\n        return solve(nums, target, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target+1, 0);\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(i-nums[j]>=0)\\n                    dp[i]+=dp[i-nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568199,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=0OSfSOGAesU\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        //We store the sum that is remaining to reach target in dp vector\\n        //-1 denotes that the we have not encountered that sub problem before\\n        //the size of dp is target+1 because the remaining sum to reach target could range from 0 to target\\n        vector<int>dp(target+1,-1);\\n        \\n        return helper(nums,target,dp);\\n    }\\n    int helper(vector<int>& nums, int target,vector<int>&dp)\\n    {\\n        if(target<0)\\n        {\\n            return 0;//This recursion path contributes 0 combinations of numbers that sum to target\\n\\t\\t\\t\\t\\t\\t //target<0 cannot be reached because numbers are +ve\\n        }\\n\\t\\t//if target is 0, it means we have reached target, because we were subtracting each selected number from\\n\\t\\t//target\\n        if(target==0)\\n        {\\n            return 1; //Since we are finding total number of combinations, adding 1 would indicate 1 combination\\n                      //for this recursion path\\n        }\\n        if(dp[target]!=-1)\\n        {\\n            return dp[target];\\n        }\\n        \\n        //We try to select each and every number in each step to try and reach the target because \\n        //Repetition of numbers is allowed and different order in which the same set of numbers appear are \\n        //considered different combinations\\n        int count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            count=count+helper(nums,target-nums[j],dp);\\n        }\\n        return dp[target]=count;\\n    }\\n};\\n```\\n**JAVA**\\n```\\nRecursive + Memoization :\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        for(int i=0;i<target+1;i++) dp[i]=-1;\\n        return recur(nums, target, dp);\\n    }\\n    \\n    public int recur(int[] nums, int target, int[] dp) {\\n        if(target == 0) {\\n            return 1;\\n        } else if(target < 0) {\\n            return 0;\\n        }\\n        if(dp[target]!=-1) return dp[target];\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] > target) continue;\\n            ans += recur(nums, target-nums[i], dp);\\n        }\\n        dp[target] = ans;\\n        return dp[target];\\n    }\\n}\\n```\\n**PYTHON**\\n```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n    if not nums or target < 0:\\n        return 0\\n    nums = sorted(nums)\\n    dp = [0] * (target + 1)\\n    dp[0] = 1\\n    for i in range(1, target + 1):\\n        for num in nums:\\n            if num <= i:\\n                dp[i] = dp[i] + dp[i - num]\\n            else:\\n                break\\n    return dp[target]\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        //We store the sum that is remaining to reach target in dp vector\\n        //-1 denotes that the we have not encountered that sub problem before\\n        //the size of dp is target+1 because the remaining sum to reach target could range from 0 to target\\n        vector<int>dp(target+1,-1);\\n        \\n        return helper(nums,target,dp);\\n    }\\n    int helper(vector<int>& nums, int target,vector<int>&dp)\\n    {\\n        if(target<0)\\n        {\\n            return 0;//This recursion path contributes 0 combinations of numbers that sum to target\\n\\t\\t\\t\\t\\t\\t //target<0 cannot be reached because numbers are +ve\\n        }\\n\\t\\t//if target is 0, it means we have reached target, because we were subtracting each selected number from\\n\\t\\t//target\\n        if(target==0)\\n        {\\n            return 1; //Since we are finding total number of combinations, adding 1 would indicate 1 combination\\n                      //for this recursion path\\n        }\\n        if(dp[target]!=-1)\\n        {\\n            return dp[target];\\n        }\\n        \\n        //We try to select each and every number in each step to try and reach the target because \\n        //Repetition of numbers is allowed and different order in which the same set of numbers appear are \\n        //considered different combinations\\n        int count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            count=count+helper(nums,target-nums[j],dp);\\n        }\\n        return dp[target]=count;\\n    }\\n};\\n```\n```\\nRecursive + Memoization :\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        for(int i=0;i<target+1;i++) dp[i]=-1;\\n        return recur(nums, target, dp);\\n    }\\n    \\n    public int recur(int[] nums, int target, int[] dp) {\\n        if(target == 0) {\\n            return 1;\\n        } else if(target < 0) {\\n            return 0;\\n        }\\n        if(dp[target]!=-1) return dp[target];\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] > target) continue;\\n            ans += recur(nums, target-nums[i], dp);\\n        }\\n        dp[target] = ans;\\n        return dp[target];\\n    }\\n}\\n```\n```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n    if not nums or target < 0:\\n        return 0\\n    nums = sorted(nums)\\n    dp = [0] * (target + 1)\\n    dp[0] = 1\\n    for i in range(1, target + 1):\\n        for num in nums:\\n            if num <= i:\\n                dp[i] = dp[i] + dp[i - num]\\n            else:\\n                break\\n    return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380819,
                "title": "c-top-down-dp",
                "content": "Knapsack-style solution\\n\\n**Solved LIVE ON TWITCH.  Tune in everyday at 6pm PT.  Link in profile.**\\n\\n```\\nclass Solution {  \\n    int dfs(vector<int>& nums, int k, vector<int>& cacheMoney) {\\n        if(k == 0) \\n            return 1;   \\n        \\n        if(cacheMoney[k] != -1) \\n            return cacheMoney[k];\\n        \\n        int howManyWays = 0;\\n        for(int x : nums) {\\n            if(k >= x) {\\n                howManyWays += dfs(nums, k-x, cacheMoney);\\n            }\\n        }    \\n        return cacheMoney[k] = howManyWays; \\n    }\\n    \\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> cacheMoney(target+1, -1);      \\n        return dfs(nums, target, cacheMoney);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\n    int dfs(vector<int>& nums, int k, vector<int>& cacheMoney) {\\n        if(k == 0) \\n            return 1;   \\n        \\n        if(cacheMoney[k] != -1) \\n            return cacheMoney[k];\\n        \\n        int howManyWays = 0;\\n        for(int x : nums) {\\n            if(k >= x) {\\n                howManyWays += dfs(nums, k-x, cacheMoney);\\n            }\\n        }    \\n        return cacheMoney[k] = howManyWays; \\n    }\\n    \\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> cacheMoney(target+1, -1);      \\n        return dfs(nums, target, cacheMoney);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376043,
                "title": "striver-standard-approach-recursion-memoization-tabulation-0-ms",
                "content": "**If Anyone able to code Space optimaization Approach, Please Comment, And Upvote this post.**\\n**1. Recursion**\\n```\\n    public int combinationSum4(int[] nums, int target) {\\n        int n = nums.length;\\n        int dp[] = new int[target+1];\\n        Arrays.fill(dp,-1);\\n        return helper(nums,target,dp);\\n    }\\n    \\n    public int helper(int[] nums, int target,int[]dp){\\n        if(target==0) return 1;\\n        if(target<0) return 0;\\n        if(dp[target]!=-1) return dp[target];\\n        int comb=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=target){\\n                comb+=helper(nums,target-nums[i],dp);\\n            }\\n        }\\n        return dp[target]=comb;\\n    }\\n```\\n-----------------------------------------------------------------------------------------\\n**2. Memoization**\\n```\\n    public int combinationSum4(int[] nums, int target) {\\n        int n = nums.length;\\n        int dp[] = new int[target+1];\\n        Arrays.fill(dp,-1);\\n        return helper(nums,target,dp);\\n    }\\n    \\n    public int helper(int[] nums, int target,int[]dp){\\n        if(target==0) return 1;\\n        if(target<0) return 0;\\n        if(dp[target]!=-1) return dp[target];\\n        int comb=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=target){\\n                comb+=helper(nums,target-nums[i],dp);\\n            }\\n        }\\n        return dp[target]=comb;\\n    }\\n```\\n---------------------------------------------------------------------------------------------\\n**3.Tabulation**\\n```\\npublic int combinationSum4(int[] nums, int target) {\\n        int n = nums.length;\\n        int dp[] = new int[target+1];\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++){\\n            int comb=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]<=i){\\n                    comb+=dp[i-nums[j]];\\n                }\\n            }\\n            dp[i]=comb;\\n        }\\n        return dp[target];\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public int combinationSum4(int[] nums, int target) {\\n        int n = nums.length;\\n        int dp[] = new int[target+1];\\n        Arrays.fill(dp,-1);\\n        return helper(nums,target,dp);\\n    }\\n    \\n    public int helper(int[] nums, int target,int[]dp){\\n        if(target==0) return 1;\\n        if(target<0) return 0;\\n        if(dp[target]!=-1) return dp[target];\\n        int comb=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=target){\\n                comb+=helper(nums,target-nums[i],dp);\\n            }\\n        }\\n        return dp[target]=comb;\\n    }\\n```\n```\\n    public int combinationSum4(int[] nums, int target) {\\n        int n = nums.length;\\n        int dp[] = new int[target+1];\\n        Arrays.fill(dp,-1);\\n        return helper(nums,target,dp);\\n    }\\n    \\n    public int helper(int[] nums, int target,int[]dp){\\n        if(target==0) return 1;\\n        if(target<0) return 0;\\n        if(dp[target]!=-1) return dp[target];\\n        int comb=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=target){\\n                comb+=helper(nums,target-nums[i],dp);\\n            }\\n        }\\n        return dp[target]=comb;\\n    }\\n```\n```\\npublic int combinationSum4(int[] nums, int target) {\\n        int n = nums.length;\\n        int dp[] = new int[target+1];\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++){\\n            int comb=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]<=i){\\n                    comb+=dp[i-nums[j]];\\n                }\\n            }\\n            dp[i]=comb;\\n        }\\n        return dp[target];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167162,
                "title": "c-dp-solution-explained-100-time-80-space",
                "content": "This problem is basically a clone of [coin change 2](https://leetcode.com/problems/coin-change-2/); and since the order matters, it is also more about permutations than combinations.\\n\\nThat said, it can be solved in a similar fashion: since a DFS or BFS approach to find all the viable permutations would be too expensive, we will resort to good old DP.\\n\\nTo do so, we will declare a `dp` variable as an array of `long` with length `target + 1` since we will use up to the index `target` of it.\\n\\nWe will set the very first cell to `1` and then loop with `i` from `1` to `target` (incuded) and:\\n* set `dp[i]` to `0` (no need to go for an expensive isolated initialisation loop otherwise);\\n* loop through all the elements `n` in `nums` and:\\n\\t* if `i >= n` add `dp[i - n]` to `dp[i]` (meaning we can reach that place from adding `n` to all the `dp[i - n]` solutions we computed before);\\n\\t* if `dp[i]` overflows the limits of a 32bit, we can just `break`, since we are told that is not a viable solution.\\n\\nOnce done, we can just return `dp[target]` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // support variables\\n        long dp[target + 1];\\n        dp[0] = 1;\\n        // populating dp\\n        for (int i = 1; i <= target; i++) {\\n            // setting the initial value of a cell to 0\\n            dp[i] = 0;\\n            // updating dp[i] with all the previous combinations we can reach from there\\n            for (int n: nums) {\\n                if (i >= n) dp[i] += dp[i - n];\\n                if (dp[i] > INT_MAX) break;\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\\n\\nVariant marking overflowing cells with `-1`, which probably does not help much, if not for the case with `target == 999`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // support variables\\n        long dp[target + 1];\\n        dp[0] = 1;\\n        // populating dp\\n        for (int i = 1, tmp; i <= target; i++) {\\n            // setting the initial value of a cell to 0\\n            dp[i] = 0;\\n            // updating dp[i] with all the previous combinations we can reach from there\\n            for (int n: nums) {\\n                if (i >= n) {\\n                    tmp = dp[i - n];\\n                    if (tmp == -1) {\\n                        dp[i] = -1;\\n                        break;\\n                    }\\n                    dp[i] += dp[i - n];\\n                }\\n                if (dp[i] > INT_MAX) {\\n                    dp[i] = -1;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // support variables\\n        long dp[target + 1];\\n        dp[0] = 1;\\n        // populating dp\\n        for (int i = 1; i <= target; i++) {\\n            // setting the initial value of a cell to 0\\n            dp[i] = 0;\\n            // updating dp[i] with all the previous combinations we can reach from there\\n            for (int n: nums) {\\n                if (i >= n) dp[i] += dp[i - n];\\n                if (dp[i] > INT_MAX) break;\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // support variables\\n        long dp[target + 1];\\n        dp[0] = 1;\\n        // populating dp\\n        for (int i = 1, tmp; i <= target; i++) {\\n            // setting the initial value of a cell to 0\\n            dp[i] = 0;\\n            // updating dp[i] with all the previous combinations we can reach from there\\n            for (int n: nums) {\\n                if (i >= n) {\\n                    tmp = dp[i - n];\\n                    if (tmp == -1) {\\n                        dp[i] = -1;\\n                        break;\\n                    }\\n                    dp[i] += dp[i - n];\\n                }\\n                if (dp[i] > INT_MAX) {\\n                    dp[i] = -1;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430879,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=0OSfSOGAesU\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        //We store the sum that is remaining to reach target in dp vector\\n        //-1 denotes that the we have not encountered that sub problem before\\n        //the size of dp is target+1 because the remaining sum to reach target could range from 0 to target\\n        vector<int>dp(target+1,-1);\\n        \\n        return helper(nums,target,dp);\\n    }\\n    int helper(vector<int>& nums, int target,vector<int>&dp)\\n    {\\n        if(target<0)\\n        {\\n            return 0;//This recursion path contributes 0 combinations of numbers that sum to target\\n\\t\\t\\t\\t\\t\\t //target<0 cannot be reached because numbers are +ve\\n        }\\n\\t\\t//if target is 0, it means we have reached target, because we were subtracting each selected number from\\n\\t\\t//target\\n        if(target==0)\\n        {\\n            return 1; //Since we are finding total number of combinations, adding 1 would indicate 1 combination\\n                      //for this recursion path\\n        }\\n        if(dp[target]!=-1)\\n        {\\n            return dp[target];\\n        }\\n        \\n        //We try to select each and every number in each step to try and reach the target because \\n        //Repetition of numbers is allowed and different order in which the same set of numbers appear are \\n        //considered different combinations\\n        int count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            count=count+helper(nums,target-nums[j],dp);\\n        }\\n        return dp[target]=count;\\n    }\\n};\\n```\\n**JAVA**\\n```\\nRecursive + Memoization :\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        for(int i=0;i<target+1;i++) dp[i]=-1;\\n        return recur(nums, target, dp);\\n    }\\n    \\n    public int recur(int[] nums, int target, int[] dp) {\\n        if(target == 0) {\\n            return 1;\\n        } else if(target < 0) {\\n            return 0;\\n        }\\n        if(dp[target]!=-1) return dp[target];\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] > target) continue;\\n            ans += recur(nums, target-nums[i], dp);\\n        }\\n        dp[target] = ans;\\n        return dp[target];\\n    }\\n}\\n```\\n**PYTHON**\\n```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n    if not nums or target < 0:\\n        return 0\\n    nums = sorted(nums)\\n    dp = [0] * (target + 1)\\n    dp[0] = 1\\n    for i in range(1, target + 1):\\n        for num in nums:\\n            if num <= i:\\n                dp[i] = dp[i] + dp[i - num]\\n            else:\\n                break\\n    return dp[target]\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        //We store the sum that is remaining to reach target in dp vector\\n        //-1 denotes that the we have not encountered that sub problem before\\n        //the size of dp is target+1 because the remaining sum to reach target could range from 0 to target\\n        vector<int>dp(target+1,-1);\\n        \\n        return helper(nums,target,dp);\\n    }\\n    int helper(vector<int>& nums, int target,vector<int>&dp)\\n    {\\n        if(target<0)\\n        {\\n            return 0;//This recursion path contributes 0 combinations of numbers that sum to target\\n\\t\\t\\t\\t\\t\\t //target<0 cannot be reached because numbers are +ve\\n        }\\n\\t\\t//if target is 0, it means we have reached target, because we were subtracting each selected number from\\n\\t\\t//target\\n        if(target==0)\\n        {\\n            return 1; //Since we are finding total number of combinations, adding 1 would indicate 1 combination\\n                      //for this recursion path\\n        }\\n        if(dp[target]!=-1)\\n        {\\n            return dp[target];\\n        }\\n        \\n        //We try to select each and every number in each step to try and reach the target because \\n        //Repetition of numbers is allowed and different order in which the same set of numbers appear are \\n        //considered different combinations\\n        int count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            count=count+helper(nums,target-nums[j],dp);\\n        }\\n        return dp[target]=count;\\n    }\\n};\\n```\n```\\nRecursive + Memoization :\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        for(int i=0;i<target+1;i++) dp[i]=-1;\\n        return recur(nums, target, dp);\\n    }\\n    \\n    public int recur(int[] nums, int target, int[] dp) {\\n        if(target == 0) {\\n            return 1;\\n        } else if(target < 0) {\\n            return 0;\\n        }\\n        if(dp[target]!=-1) return dp[target];\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] > target) continue;\\n            ans += recur(nums, target-nums[i], dp);\\n        }\\n        dp[target] = ans;\\n        return dp[target];\\n    }\\n}\\n```\n```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n    if not nums or target < 0:\\n        return 0\\n    nums = sorted(nums)\\n    dp = [0] * (target + 1)\\n    dp[0] = 1\\n    for i in range(1, target + 1):\\n        for num in nums:\\n            if num <= i:\\n                dp[i] = dp[i] + dp[i - num]\\n            else:\\n                break\\n    return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414721,
                "title": "dp-easy-explanation-sign-integer-overflow",
                "content": "I attempted this question with the Top down approach with the following code and it got accepted in first go. Then I tried to go for the bottom up approach as it is quite straight forward after this. \\n```\\nclass Solution {\\n    unordered_map<int, int> dp;\\npublic:\\n    int combinationSum4(vector<int>& arr, int target) {\\n        if(target == 0) return 1;\\n        if(dp.find(target) != dp.end()) return dp[target];\\n        \\n        int ans = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            if(target >= arr[i]) {\\n                ans += combinationSum4(arr, target-arr[i]);\\n            }\\n        }\\n        \\n        dp[target] = ans;\\n        return ans;\\n   }\\n};\\n```\\nI wrote down the code as below and submitted it\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& arr, int target) {\\n        vector<int> dp(target+1, 0); \\n        \\n        dp[0] = 1; \\n        \\n        for(int i=1; i<=target; i++) {\\n            for(int j=0; j<arr.size(); j++) {\\n                if(i >= arr[j]) {\\n                    dp[i] += dp[i-arr[j]];\\n                }\\n            }  \\n        }\\n        return dp[target];\\n    }\\n};\\n```\\nAnd then the learning begains :), \\n```\\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,\\n170,180,190,200,210,220,230,240,250,260,270,280,290,300,\\n310,320,330,340,350,360,370,380,390,400,410,420,430,440,\\n450,460,470,480,490,500,510,520,530,540,550,560,570,580,\\n590,600,610,620,630,640,650,660,670,680,690,700,710,720,\\n730,740,750,760,770,780,790,800,810,820,830,840,850,860,\\n870,880,890,900,910,920,930,940,950,960,970,980,990,111]\\n999\\n```\\nThis test case is failing continously. As I read out the question it is saying that **answer will fit in 32-bit signed integer**, then **what is happening? why it is overflowing?**\\nThen I tried to calculate the answer manually and find out that it is growing exponentially.\\n```\\ndp[300] = dp[290] /*if I picked 10 in last*/ + dp[280] /*if I picked 20 last*/ +  .... + dp[0] /*if I picked 300 last*/  \\n```\\nThen I noticied the target `999` and last number in the array `111`, and there is only 1 way I can reach to this target. \\nSo the problem is only guaranteeing that the answer should fit in 32-bit interger with given `target` not with any possible target.\\nSo all the intermediate `targets`(**we can call them useful targets**) which are used to compute final `target` are alway fit in 32-bit integer but we cannot gurantee about other `targets`(**non-useful targets**).\\n\\n## Top-Down Explanation \\nTop Down approach is only calculating the `useful targets`, so they are alway fit in 32-bit integer. So our solution got accpeted and never got overflowed.\\n\\n## Bottom-Up Explanation\\nWe are calculating all the possible intermediate `targets`, so some of them are overflowing due to which Runtime error is generated.\\n\\n### Solution of overflow\\n1. `unsigned int` is working fine becase leetcode is not checking `unsigned int` overflow and these overflow targets are not contributing to our final answer, so it got accepted, but it is not full proof solution.\\n2. Only compute intermediate targets which are not overflowing, if any target is overflowing then skip it\\'s computation as it is not contributing in our final answer.\\n```\\nint combinationSum4(vector<int>& arr, int target) {\\n        vector<int> dp(target+1, 0); //\\n        dp[0] = 1; \\n\\t\\t\\n        for(int i=1; i<=target; i++) {\\n            for(int j=0; j<arr.size(); j++) {\\n                if(i >= arr[j] && INT_MAX - dp[i-arr[j]] >= dp[i]) { /* dp[i] + dp[i-arr[i]] <= INT_MAX */\\n                    dp[i] += dp[i-arr[j]];\\n                }\\n            }  \\n        }\\n        return dp[target];\\n    }\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> dp;\\npublic:\\n    int combinationSum4(vector<int>& arr, int target) {\\n        if(target == 0) return 1;\\n        if(dp.find(target) != dp.end()) return dp[target];\\n        \\n        int ans = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            if(target >= arr[i]) {\\n                ans += combinationSum4(arr, target-arr[i]);\\n            }\\n        }\\n        \\n        dp[target] = ans;\\n        return ans;\\n   }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& arr, int target) {\\n        vector<int> dp(target+1, 0); \\n        \\n        dp[0] = 1; \\n        \\n        for(int i=1; i<=target; i++) {\\n            for(int j=0; j<arr.size(); j++) {\\n                if(i >= arr[j]) {\\n                    dp[i] += dp[i-arr[j]];\\n                }\\n            }  \\n        }\\n        return dp[target];\\n    }\\n};\\n```\n```\\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,\\n170,180,190,200,210,220,230,240,250,260,270,280,290,300,\\n310,320,330,340,350,360,370,380,390,400,410,420,430,440,\\n450,460,470,480,490,500,510,520,530,540,550,560,570,580,\\n590,600,610,620,630,640,650,660,670,680,690,700,710,720,\\n730,740,750,760,770,780,790,800,810,820,830,840,850,860,\\n870,880,890,900,910,920,930,940,950,960,970,980,990,111]\\n999\\n```\n```\\ndp[300] = dp[290] /*if I picked 10 in last*/ + dp[280] /*if I picked 20 last*/ +  .... + dp[0] /*if I picked 300 last*/  \\n```\n```\\nint combinationSum4(vector<int>& arr, int target) {\\n        vector<int> dp(target+1, 0); //\\n        dp[0] = 1; \\n\\t\\t\\n        for(int i=1; i<=target; i++) {\\n            for(int j=0; j<arr.size(); j++) {\\n                if(i >= arr[j] && INT_MAX - dp[i-arr[j]] >= dp[i]) { /* dp[i] + dp[i-arr[i]] <= INT_MAX */\\n                    dp[i] += dp[i-arr[j]];\\n                }\\n            }  \\n        }\\n        return dp[target];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381541,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-combination-sum-iv-watch-it",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE \\n## Refer YouTube Channel -\\nCombination Sum IV\\n\\n[![Mirror Reflection](https://i.ytimg.com/vi/zgk4LlPCQpc/hqdefault.jpg?sqp=-oaymwEcCPYBEIoBSFbyq4qpAw4IARUAAIhCGAFwAcABBg==&rs=AOn4CLDjZucu_3J8I5mjnVHOZarEUDE13w)](https://www.youtube.com/watch?v=zgk4LlPCQpc)\\n\\n# CODE :\\n```\\nint combinationSum4(vector<int>& nums, int target) {\\n        vector<int> sumArray(target+1, -1);\\n        sumArray[0]=1;\\n        countSum(nums, target, sumArray);\\n        return sumArray[target];\\n    }\\n    int countSum(vector<int>& nums, int target, vector<int>& sumArray) {\\n        if(sumArray[target]>-1)\\n            return sumArray[target];\\n        int sum=0;\\n        for(int i=0 ; i<nums.size(); i++) {\\n            if(nums[i] <= target)\\n                sum += countSum(nums, target-nums[i], sumArray);\\n                // 4 -> (1, [3])\\n                // 3 -> (2, [2])\\n                // 2 -> (1, [1])\\n        }\\n        sumArray[target] = sum;\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint combinationSum4(vector<int>& nums, int target) {\\n        vector<int> sumArray(target+1, -1);\\n        sumArray[0]=1;\\n        countSum(nums, target, sumArray);\\n        return sumArray[target];\\n    }\\n    int countSum(vector<int>& nums, int target, vector<int>& sumArray) {\\n        if(sumArray[target]>-1)\\n            return sumArray[target];\\n        int sum=0;\\n        for(int i=0 ; i<nums.size(); i++) {\\n            if(nums[i] <= target)\\n                sum += countSum(nums, target-nums[i], sumArray);\\n                // 4 -> (1, [3])\\n                // 3 -> (2, [2])\\n                // 2 -> (1, [1])\\n        }\\n        sumArray[target] = sum;\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1528267,
                "title": "c-recursion-memoization-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n  int helper(vector<int>&nums,int target,int n,int sum)\\n  {    if(sum>target) return 0 ;\\n       if(sum==target){\\n        return 1 ;\\n       }\\n   if(dp[sum]!=-1){\\n       return dp[sum];\\n   }\\n      int ans=0;\\n       for(int i=0;i<n;i++)\\n       {  if(sum+nums[i]<=target)\\n           ans+=helper(nums,target,n,sum+nums[i]);\\n       }\\n      return dp[sum]=ans;\\n  }\\n    int combinationSum4(vector<int>& nums, int target) {\\n       memset(dp,-1,sizeof(dp));\\n        int n=nums.size();\\n      return  helper(nums,target,n,0);\\n     \\n    }\\n};\\n```\\n**Please consider to upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n  int helper(vector<int>&nums,int target,int n,int sum)\\n  {    if(sum>target) return 0 ;\\n       if(sum==target){\\n        return 1 ;\\n       }\\n   if(dp[sum]!=-1){\\n       return dp[sum];\\n   }\\n      int ans=0;\\n       for(int i=0;i<n;i++)\\n       {  if(sum+nums[i]<=target)\\n           ans+=helper(nums,target,n,sum+nums[i]);\\n       }\\n      return dp[sum]=ans;\\n  }\\n    int combinationSum4(vector<int>& nums, int target) {\\n       memset(dp,-1,sizeof(dp));\\n        int n=nums.size();\\n      return  helper(nums,target,n,0);\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167453,
                "title": "java-simple-and-easy-to-understand-solution-0-ms-faster-than-100-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n\\n    int[] cache;\\n    public int combinationSum4(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        \\n        //Use memoisation techniques,\\n        cache = new int[target + 1];\\n        Arrays.fill(cache, -1);\\n        \\n        \\n        return findCombination(nums, target);\\n    }\\n    \\n    private int findCombination(int[] nums, int target){\\n        //base case\\n        if(target ==  0) return 1;\\n        \\n        //retrieve from cache\\n        if(cache[target] != -1) return cache[target];\\n        \\n        \\n        int count = 0;\\n        for(int num : nums){\\n            //remaining target sum is less than 0, \\n            //no need to check further, as we already sorted the nums array\\n            //in increasing order. further Remaining  target will be more -ve\\n            if(target - num < 0) \\n                break;\\n            //find the  permutation for remaining target sum,\\n            //and append th count\\n            count += findCombination(nums, target - num);\\n        }\\n        \\n        //store in cache\\n        cache[target] = count;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] cache;\\n    public int combinationSum4(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        \\n        //Use memoisation techniques,\\n        cache = new int[target + 1];\\n        Arrays.fill(cache, -1);\\n        \\n        \\n        return findCombination(nums, target);\\n    }\\n    \\n    private int findCombination(int[] nums, int target){\\n        //base case\\n        if(target ==  0) return 1;\\n        \\n        //retrieve from cache\\n        if(cache[target] != -1) return cache[target];\\n        \\n        \\n        int count = 0;\\n        for(int num : nums){\\n            //remaining target sum is less than 0, \\n            //no need to check further, as we already sorted the nums array\\n            //in increasing order. further Remaining  target will be more -ve\\n            if(target - num < 0) \\n                break;\\n            //find the  permutation for remaining target sum,\\n            //and append th count\\n            count += findCombination(nums, target - num);\\n        }\\n        \\n        //store in cache\\n        cache[target] = count;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228568,
                "title": "c-0ms-100-dp-solution-w-explanation-answers-for-follow-up-questions",
                "content": "The idea is to use DP of size target+1 to store number of ways of adding up to i, where 0 < i <= target. This way, for each new i, we iterate through the nums vector, and add the number of ways to get to i - nums[j], where 0 <= j < size. This is because if i - nums[j] is reachable, then we can simply add nums[j] to make i reachable.\\n\\nTo speed up the loop, I first sort the nums vector, and then set an upper bound on size so I only consider elements less than target. In the DP loop, I can break whenever element is greater than i, without considering future elements since vector is sorted. \\n\\nThe run time is O(n^2), and space complexity is O(n).\\n\\nAnswer to follow up questions:\\n\\nNegative numbers will cause problems. For example:\\nsum of 0, and we have 1 and -1. Can have {1, -1}, {1, 1, -1, -1}, etc. There would be infinite count.\\nThat might seem like an obvious case, but consider this case: {-3, 5}. Doesn\\'t seem obvious if it will cause problems, but if you simply do 5 * -3 + 3 * 5, boom there goes the computer. This basically means given *ANY* two numbers a, and b, one positive and one negative,  you will get infinite combinations  by simply adding multiple of \"a\" number of \"b\"s and \"b\" number of \"a\"s ( ! ).\\n\\nThis changes the problem because the DP vector will not work. Updating negative numbers will require information on positive numbers that might not be updated, and vice versa. This can only be solved using recursion (DFS), with pre-defined max recursion depth. When the depth is limited, we limit them max size of a the numbers count that makes up the solution, so we can stop the above from happening. The algorithm will be O(2^n), where n is the max recursion depth. Very cool.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    static int combinationSum4(vector<int>& nums, const int target) {\\n        sort(nums.begin(), nums.end());\\n        if(target == 0) return 1;\\n        vector<int> dp(target+1, 0);\\n        int size_ = nums.size(), size;\\n        for(size = 0; size < size_; ++size) {\\n            if(nums[size] <= target) ++dp[nums[size]];\\n            else break;\\n        }\\n\\n        for(int i = 1; i <= target; ++i) {\\n            for(int j = 0; j < size; ++j) {\\n                if(i >= nums[j]) dp[i] += dp[i - nums[j]];\\n                else break;\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    static int combinationSum4(vector<int>& nums, const int target) {\\n        sort(nums.begin(), nums.end());\\n        if(target == 0) return 1;\\n        vector<int> dp(target+1, 0);\\n        int size_ = nums.size(), size;\\n        for(size = 0; size < size_; ++size) {\\n            if(nums[size] <= target) ++dp[nums[size]];\\n            else break;\\n        }\\n\\n        for(int i = 1; i <= target; ++i) {\\n            for(int j = 0; j < size; ++j) {\\n                if(i >= nums[j]) dp[i] += dp[i - nums[j]];\\n                else break;\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4021487,
                "title": "java-solution-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++) {\\n            for(int j : nums) {\\n                if(i - j >= 0) {\\n                    dp[i] += dp[i-j];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++) {\\n            for(int j : nums) {\\n                if(i - j >= 0) {\\n                    dp[i] += dp[i-j];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020273,
                "title": "c-python-recursive-iterative-dp-beats-100-why-signed-not-long-long",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DP to solve the problem, both of recursive version & iterative version.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\"different sequences are counted as different combinations.\"\\nIt \\'s not combination problem, but a problem for permutations.\\n\\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\\n\\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\\n\\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" It has no guarantees for intermediate values.\\n\\nOne useful testcase\\n```\\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\\n999\\n```\\nUse unsigned, print the dp state array:\\n \\n![combSum4.png](https://assets.leetcode.com/users/images/746077e1-d22c-48c8-ba74-8aace25a898a_1694227249.3956625.png)\\n\\nA negative value is shown, strange! it overflows. Some of the intermediate values after that could be wrong. Using unsigned long long solves this problem.\\n![combSum4ULL.png](https://assets.leetcode.com/users/images/bf83d4dd-2eba-4151-8274-2ecf32bf32b4_1694227412.07925.png)\\n\\n# why signed not long long\\nDifferent type has different behavior. Signed integer (int or long long) in GCC will break as an error when overflowing. But unsigned integers will do the arithmetic as an modular operation (mod 4294967296=2^32) when overflowing. Since  LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" the final is correct whereas the intermediate values can be treated as the computed values modulo 4294967296=2^32!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\times target)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(target)$$ & stack need for recursive version at most $$O(n)$$\\n# Code \\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned> dp(target+1, UINT_MAX);\\n\\n        function<unsigned(unsigned)> f=[&](unsigned i)->unsigned\\n        {\\n            if (i==0) return 1;//base case\\n            if (dp[i]!=UINT_MAX) return dp[i];//Computed before\\n            unsigned ans=0;\\n        //Everything can be chosen, for permutations with repetition\\n            for(int x: nums)\\n                if (i>=x)\\n                    ans+=f(i-x);//Recursion\\n            return dp[i]=ans; //Copy to dp array & return ans\\n\\n        };\\n        \\n        return f(target);\\n    }\\n};\\n```\\n# Code for iterative version Runtime 0 ms Beats 100%\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned> dp(target+1, 0);//Must be unsigned\\n        dp[0]=1;\\n        for(int i=1; i<=target; i++){\\n            for (int x: nums){\\n                if (i>=x)\\n                    dp[i]+=dp[i-x];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\\n# Python Code \\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp=[0]*(target+1)\\n        dp[0]=1\\n        for i in range(1, target+1):\\n            for x in nums:\\n                if i>=x:\\n                    dp[i]+=dp[i-x]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\\n999\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned> dp(target+1, UINT_MAX);\\n\\n        function<unsigned(unsigned)> f=[&](unsigned i)->unsigned\\n        {\\n            if (i==0) return 1;//base case\\n            if (dp[i]!=UINT_MAX) return dp[i];//Computed before\\n            unsigned ans=0;\\n        //Everything can be chosen, for permutations with repetition\\n            for(int x: nums)\\n                if (i>=x)\\n                    ans+=f(i-x);//Recursion\\n            return dp[i]=ans; //Copy to dp array & return ans\\n\\n        };\\n        \\n        return f(target);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned> dp(target+1, 0);//Must be unsigned\\n        dp[0]=1;\\n        for(int i=1; i<=target; i++){\\n            for (int x: nums){\\n                if (i>=x)\\n                    dp[i]+=dp[i-x];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp=[0]*(target+1)\\n        dp[0]=1\\n        for i in range(1, target+1):\\n            for x in nums:\\n                if i>=x:\\n                    dp[i]+=dp[i-x]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450809,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=0OSfSOGAesU\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        //We store the sum that is remaining to reach target in dp vector\\n        //-1 denotes that the we have not encountered that sub problem before\\n        //the size of dp is target+1 because the remaining sum to reach target could range from 0 to target\\n        vector<int>dp(target+1,-1);\\n        \\n        return helper(nums,target,dp);\\n    }\\n    int helper(vector<int>& nums, int target,vector<int>&dp)\\n    {\\n        if(target<0)\\n        {\\n            return 0;//This recursion path contributes 0 combinations of numbers that sum to target\\n\\t\\t\\t\\t\\t\\t //target<0 cannot be reached because numbers are +ve\\n        }\\n\\t\\t//if target is 0, it means we have reached target, because we were subtracting each selected number from\\n\\t\\t//target\\n        if(target==0)\\n        {\\n            return 1; //Since we are finding total number of combinations, adding 1 would indicate 1 combination\\n                      //for this recursion path\\n        }\\n        if(dp[target]!=-1)\\n        {\\n            return dp[target];\\n        }\\n        \\n        //We try to select each and every number in each step to try and reach the target because \\n        //Repetition of numbers is allowed and different order in which the same set of numbers appear are \\n        //considered different combinations\\n        int count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            count=count+helper(nums,target-nums[j],dp);\\n        }\\n        return dp[target]=count;\\n    }\\n};\\n```\\n**JAVA**\\n```\\nRecursive + Memoization :\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        for(int i=0;i<target+1;i++) dp[i]=-1;\\n        return recur(nums, target, dp);\\n    }\\n    \\n    public int recur(int[] nums, int target, int[] dp) {\\n        if(target == 0) {\\n            return 1;\\n        } else if(target < 0) {\\n            return 0;\\n        }\\n        if(dp[target]!=-1) return dp[target];\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] > target) continue;\\n            ans += recur(nums, target-nums[i], dp);\\n        }\\n        dp[target] = ans;\\n        return dp[target];\\n    }\\n}\\n```\\n**PYTHON**\\n```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n    if not nums or target < 0:\\n        return 0\\n    nums = sorted(nums)\\n    dp = [0] * (target + 1)\\n    dp[0] = 1\\n    for i in range(1, target + 1):\\n        for num in nums:\\n            if num <= i:\\n                dp[i] = dp[i] + dp[i - num]\\n            else:\\n                break\\n    return dp[target]\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        //We store the sum that is remaining to reach target in dp vector\\n        //-1 denotes that the we have not encountered that sub problem before\\n        //the size of dp is target+1 because the remaining sum to reach target could range from 0 to target\\n        vector<int>dp(target+1,-1);\\n        \\n        return helper(nums,target,dp);\\n    }\\n    int helper(vector<int>& nums, int target,vector<int>&dp)\\n    {\\n        if(target<0)\\n        {\\n            return 0;//This recursion path contributes 0 combinations of numbers that sum to target\\n\\t\\t\\t\\t\\t\\t //target<0 cannot be reached because numbers are +ve\\n        }\\n\\t\\t//if target is 0, it means we have reached target, because we were subtracting each selected number from\\n\\t\\t//target\\n        if(target==0)\\n        {\\n            return 1; //Since we are finding total number of combinations, adding 1 would indicate 1 combination\\n                      //for this recursion path\\n        }\\n        if(dp[target]!=-1)\\n        {\\n            return dp[target];\\n        }\\n        \\n        //We try to select each and every number in each step to try and reach the target because \\n        //Repetition of numbers is allowed and different order in which the same set of numbers appear are \\n        //considered different combinations\\n        int count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            count=count+helper(nums,target-nums[j],dp);\\n        }\\n        return dp[target]=count;\\n    }\\n};\\n```\n```\\nRecursive + Memoization :\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        for(int i=0;i<target+1;i++) dp[i]=-1;\\n        return recur(nums, target, dp);\\n    }\\n    \\n    public int recur(int[] nums, int target, int[] dp) {\\n        if(target == 0) {\\n            return 1;\\n        } else if(target < 0) {\\n            return 0;\\n        }\\n        if(dp[target]!=-1) return dp[target];\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] > target) continue;\\n            ans += recur(nums, target-nums[i], dp);\\n        }\\n        dp[target] = ans;\\n        return dp[target];\\n    }\\n}\\n```\n```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n    if not nums or target < 0:\\n        return 0\\n    nums = sorted(nums)\\n    dp = [0] * (target + 1)\\n    dp[0] = 1\\n    for i in range(1, target + 1):\\n        for num in nums:\\n            if num <= i:\\n                dp[i] = dp[i] + dp[i - num]\\n            else:\\n                break\\n    return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383204,
                "title": "python-elegant-short-98-55-faster-top-down-dp",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$, where $$m$$ - target\\n- Space complexity: $$O(m)$$, where $$m$$ - target\\n\\n# Code\\n```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n    @cache\\n    def dp(left: int) -> int:\\n        if left == 0:\\n            return 1\\n        if left < 0:\\n            return 0\\n        return sum(dp(left - num) for num in nums)\\n\\n    return dp(target)\\n```\\n\\n# Result\\n![image](https://assets.leetcode.com/users/images/0af7e635-d603-40fe-87a6-625e1f9d69e3_1659706891.5823839.png)\\n\\n# Important\\nIf you like this solution remember to **upvote it** to let me know)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n    @cache\\n    def dp(left: int) -> int:\\n        if left == 0:\\n            return 1\\n        if left < 0:\\n            return 0\\n        return sum(dp(left - num) for num in nums)\\n\\n    return dp(target)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1166675,
                "title": "c-recursion-with-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m;\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(m.count(target))return m[target];\\n        if(target == 0)return 1;\\n        if(target < 0)return 0;\\n        for(int i=0; i<nums.size(); i++){\\n            m[target] += combinationSum4(nums, target-nums[i]);\\n        }\\n        return m[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m;\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(m.count(target))return m[target];\\n        if(target == 0)return 1;\\n        if(target < 0)return 0;\\n        for(int i=0; i<nums.size(); i++){\\n            m[target] += combinationSum4(nums, target-nums[i]);\\n        }\\n        return m[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166081,
                "title": "c-simple-and-short-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic: \\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (i >= nums[j]) dp[i] += dp[i - nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (i >= nums[j]) dp[i] += dp[i - nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077567,
                "title": "detailed-solution-with-an-example-iterative-solution-beginner-friendly",
                "content": "Hi, Everyone this is my first detailed solution in Leetcode. So pardon me if I\\'m unable to teach the topic. \\n\\n**What problem wants from us?**\\n*We\\'ve to find the number of  possible combinations(Elements can be repeated) of coins in nums array such that there sum is target*. The point to be noted is that we can have a coin more than one time. OK?\\n\\nEg. We\\'ve to create a target of 2 by using coins from nums=[1, 2].\\n\\nNow, Let\\'s give a dive into the solution. What we\\'ll do **we\\'ll create an array(dp) of length target+1**. So now you\\'ll say what\\'s the significance of creating this? Which is obvious everytime we create a dp we\\'ve to first understand the significance of that dp. So, what\\'s the significance?\\n\\nHere in our dp ith index will store the number of combinations having sumOfElements = i by using any coin any number of times from nums. So where the hell our answer of creating target is stored in our dp? It should be in dp[target] since dp[target] will store no of combinations having sumOfElements = target, Right? \\n\\n**What about i=0?**\\nWe\\'ll store number of combinations having sumOfElements=0 by using any coin any number of times from nums. Now you\\'ll say that we can\\'t have a combination with sum=0 and hence we should set dp[0] = 0, Right? No you\\'re wrong because *I can create sum = 0 by choosing no element as I\\'ve said, any coin any no of times.* You can give me any array irrespective of it\\'s elements, *I can create sumOfElements = 0 by choosing no element.* Got it?\\n\\nSo what should we store at dp[0]? Yes, *we should set dp[0] = 1*. Right?\\nCurrent Condition **dp = [1, null, null, null]**\\n\\n**What about i=1?**\\nSo first think what\\'s the significance of dp[1]. dp[1] will store no of ways of creating combinations with sumOfElements = 1. So how many ways? We\\'ve to take each and every coin of our nums and check if we can use that coin to create a combination with sumOfElements = 1. Shouldn\\'t we? Let\\'s iterate through our nums array. We\\'ve nums = [1, 2, 3].\\n\\n1. What if we choose current val = 1(0th index). How much more sum we need to get target=1. Isn\\'t it target-1? Yes, so if in general we choose a coin x from nums then we need target-x more to add up to target. Right? So if we choose 1 then we need 1(Current Target)-1 = 0 more to get target, Right? *But we know number of ways of getting sumOfElements=0 as target(look at our beautiful dp)*. This will happen everytime since we\\'re following bottom up approach. Why it\\'s happening? Becase target - x < target (x >0). So if we\\'re solving for i=target target-x was solved previously Hence we\\'ve number of ways of getting target = 1. We\\'ll add val=1 to those bags which in previous contains 0 as target and we\\'ll get target=1.\\n\\n2. What if we choose current val = 2(1th index). How much more sum we need to approach target = 1. We need 1(Current Target) - 2 more. But wait 1-2 = -1. Since our array contains only positive elements hence we\\'ll be unable to create a combination with sumOfElements = -1. Can we? So there is no way of getting target=1 by adding 2(1th index element) to any bag. \\n\\n3. Same story will be for val = 3(2th index). We can\\'t get target = 1 by adding 3 to any bag since we have no bag which contains -2 as sum of it\\'s elements. You get it, Right?\\n\\n\\tConcluding all the above point we found out that we can get target = 1 by the following points\\n\\t1.  Choose 1 from nums and a bag which in previous contains sumOfElements = 1-1=0 => dp[0].\\n\\t2.  Choose 2 from nums and a bag which in previous contains sumOfElements  = 1-2=-1 => No way since negative.\\n\\t3.  Choose 3 from nums and a bag which in previous contains sumOfElements  = 1-3=-2 => No way since negative.\\n\\n\\tdp[1] = dp[0](Point=1) + 0(Point=2) + 0(Point=3);\\n\\tdp[1] = 1;\\n\\n**What about i=2?**\\n1.  Choose 1 from nums and a bag which in previous contains sumOfElements  = 2-1=1 => dp[1].\\n2.  Choose 2 from nums and a bag which in previous contains sumOfElements  = 2-2=0 => dp[0].\\n3.  Choose 3 from nums and a bag which in previous contains sumOfElements  = 2-3=-1 => No way since negative.\\n\\ndp[2] = dp[1](Point=1) + dp[0](Point=2) + 0(Point=3);\\ndp[2] = 2;\\n\\nWhat are the combinations in real to get sum = 2?\\n[1, 1], [2]. You can see 1 is repeated.\\n\\t\\n\\t\\n\\tclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n\\t\\t/* This is our dp*/\\n        Integer[] dp = new Integer[target + 1];\\n\\t\\t/* I told you dp[0] = 1*/\\n\\t\\tdp[0] = 1;\\n        for(int i=1; i<dp.length; i++) {\\n\\t\\t\\t/* There is no of way of getting target = i(i!=0) without choosing any element. Hence we initialised our dp[i] with 0*/\\n\\t\\t\\tdp[i] = 0;\\n            for(int val : nums) {\\n\\t\\t\\t\\t/* There is no way of getting a way if current target - val becomes negative, I told you, Right?*/\\n                if(i-val>=0) {\\n                    dp[i]+=dp[i-val];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\t}\\n\\t\\nFollowing is another solution which is similar to above solution but it\\'ll have a good Acceptance rate, Can you tell me why?\\n\\n\\tclass Solution {\\n\\t\\tpublic int combinationSum4(int[] nums, int target) {\\n\\t\\t\\tint[] dp = new int[target + 1];\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i=1; i<dp.length; i++) {\\n\\t\\t\\t\\tfor(int val : nums) {\\n\\t\\t\\t\\t\\tif(i-val>=0) {\\n\\t\\t\\t\\t\\t\\tdp[i]+=dp[i-val];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[target];\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n\\t\\t/* This is our dp*/\\n        Integer[] dp = new Integer[target + 1];\\n\\t\\t/* I told you dp[0] = 1*/\\n\\t\\tdp[0] = 1;\\n        for(int i=1; i<dp.length; i++) {\\n\\t\\t\\t/* There is no of way of getting target = i(i!=0) without choosing any element. Hence we initialised our dp[i] with 0*/\\n\\t\\t\\tdp[i] = 0;\\n            for(int val : nums) {\\n\\t\\t\\t\\t/* There is no way of getting a way if current target - val becomes negative, I told you, Right?*/\\n                if(i-val>=0) {\\n                    dp[i]+=dp[i-val];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 868288,
                "title": "python-dp-solution-with-explanation-and-comments",
                "content": "I was so used to the DFS/recursive solution for the previous combination sum questions, and went straight to that solution. Only later find out how slow it was. I got TLE at test case nums=[1,2,4] target=32. This seems not that complicated but as the target increases, the time complexity will increase expotentially. \\n\\nThen I finally realized, with the help of the \"related topic\" of this problem, this is a dp quesiton.\\nAssuming dp[i] is the number of combinations(or permutations) when target is i\\nBy observing test case [1,2,3], 4:\\nNums         Target            #\\n[1,2,3]       1                    1\\n[1,2,3]       2                    2\\n[1,2,3]       3                    4\\n\\nIt seems dp[4] = dp[1] + dp[2] + dp[3].\\nEven at this point I didn\\'t firgure out how to proceed. After watching some youtube videos, \\nI start to understand it\\'s actually dp[4] = dp[4-1] + dp[4-2] + dp[4-3].\\nFor example, the permuations [1,1,1,1], [1,2,1],[2,1,1] all have 1 as the last number. That means the number of permuations like this(1 as the last numer) is dp[4-1]\\n\\nFinally with above, I write the codes and couldn\\'t believe how short the dp solution is.\\n\\nAlso, just to take this chance to review some high level rules for dp. DP algorithm is best for:\\n1. Min/Max questions\\n2. True/False questions\\n3. Number of ways questions\\n\\nThis one obviously falls under Number of ways questions.\\n\\n\\tdef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\t\\t\\tdp = [0]*(target+1)\\n\\t\\t\\tdp[0]=0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif num<=target:\\n\\t\\t\\t\\t\\tdp[num] += 1\\n\\n\\t\\t\\tfor i in range(1, len(dp)):\\n\\t\\t\\t\\tfor j in nums:\\n\\t\\t\\t\\t\\tif i>j:\\n\\t\\t\\t\\t\\t\\tdp[i]+=dp[i-j]\\n\\n\\t\\t\\treturn dp[target]\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "I was so used to the DFS/recursive solution for the previous combination sum questions, and went straight to that solution. Only later find out how slow it was. I got TLE at test case nums=[1,2,4] target=32. This seems not that complicated but as the target increases, the time complexity will increase expotentially. \\n\\nThen I finally realized, with the help of the \"related topic\" of this problem, this is a dp quesiton.\\nAssuming dp[i] is the number of combinations(or permutations) when target is i\\nBy observing test case [1,2,3], 4:\\nNums         Target            #\\n[1,2,3]       1                    1\\n[1,2,3]       2                    2\\n[1,2,3]       3                    4\\n\\nIt seems dp[4] = dp[1] + dp[2] + dp[3].\\nEven at this point I didn\\'t firgure out how to proceed. After watching some youtube videos, \\nI start to understand it\\'s actually dp[4] = dp[4-1] + dp[4-2] + dp[4-3].\\nFor example, the permuations [1,1,1,1], [1,2,1],[2,1,1] all have 1 as the last number. That means the number of permuations like this(1 as the last numer) is dp[4-1]\\n\\nFinally with above, I write the codes and couldn\\'t believe how short the dp solution is.\\n\\nAlso, just to take this chance to review some high level rules for dp. DP algorithm is best for:\\n1. Min/Max questions\\n2. True/False questions\\n3. Number of ways questions\\n\\nThis one obviously falls under Number of ways questions.\\n\\n\\tdef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\t\\t\\tdp = [0]*(target+1)\\n\\t\\t\\tdp[0]=0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif num<=target:\\n\\t\\t\\t\\t\\tdp[num] += 1\\n\\n\\t\\t\\tfor i in range(1, len(dp)):\\n\\t\\t\\t\\tfor j in nums:\\n\\t\\t\\t\\t\\tif i>j:\\n\\t\\t\\t\\t\\t\\tdp[i]+=dp[i-j]\\n\\n\\t\\t\\treturn dp[target]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 468221,
                "title": "c-solution-explaining-significance-of-loop-order-speed-100-mem-100",
                "content": "```\\n/*\\n    https://leetcode.com/problems/combination-sum-iv\\n*/\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1, 0);\\n        // zero sum is always possible\\n        dp[0] = 1;\\n        \\n\\t\\t// finds all permutations\\n        for(int i = 1; i <= target; i++)\\n            for(const int& num : nums)\\n                dp[i] += (i >= num) ? dp[i - num] : 0;\\n        \\n        return dp[target];\\n    }\\n};\\n```\\n\\nBelow is the code snippet for the permutation and combination case.\\n\\n```\\n // gives combination(without repeatition, [1,2])\\n    for(auto coin: coins):\\n        for(int i = 1; i <= total; i++)\\n            dp[i] += (i >= coin) ? dp[i - coin] : 0;\\n\\n    // gives permutation ([1,2], [2,1])\\n    for(int i = 1; i <= total; i++)\\n        for(auto coin: coins)\\n            dp[i] += i >= coin ? dp[i -coin] : 0;\\n```\\t\\t\\t\\n   **In 2nd code:**\\n    In each outer iteration, inner loop is just adding all possible combinations of previous with current coin: [coin, other_prev_cmb]\\n    So whenever we have coin pairs that exists, then they give the same combination of numbers but with different pos.\\n    Eg: [1,2,5], amount : 3\\n    For coin 1: [1, 2], [1,1,1]\\n    For coin 2: [2, 1]\\n    [1,2] and [2,1] are using same numbers in diff order\\n\\n    Eg: how interchanging the loop afffects the solution\\n    https://leetcode.com/problems/coin-change-2/discuss/141076/Logical-Thinking-with-Clear-Java-Code/260611\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/combination-sum-iv\\n*/\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1, 0);\\n        // zero sum is always possible\\n        dp[0] = 1;\\n        \\n\\t\\t// finds all permutations\\n        for(int i = 1; i <= target; i++)\\n            for(const int& num : nums)\\n                dp[i] += (i >= num) ? dp[i - num] : 0;\\n        \\n        return dp[target];\\n    }\\n};\\n```\n```\\n // gives combination(without repeatition, [1,2])\\n    for(auto coin: coins):\\n        for(int i = 1; i <= total; i++)\\n            dp[i] += (i >= coin) ? dp[i - coin] : 0;\\n\\n    // gives permutation ([1,2], [2,1])\\n    for(int i = 1; i <= total; i++)\\n        for(auto coin: coins)\\n            dp[i] += i >= coin ? dp[i -coin] : 0;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316667,
                "title": "permutation-vs-combination-study-together-with-coin-change2",
                "content": "the order of nested loops decides different result, this question is brother of #518 coin change2, this one is to count permutation number, while in coin change2, we count combination number, notice the difference of these two loops.\\n\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [1] + [0] * target\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        \\n        return dp[-1]\\n```\\n\\n\\n\\nfor coin change2:\\n```\\nclass Solution(object):\\n    def change(self, amount, coins):\\n        dp = [1] + [0] * amount\\n        \\n        for coin in coins:\\n            for i in range(coin, amount+1):\\n                dp[i] += dp[i - coin]\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [1] + [0] * target\\n        \\n        for i in range(1, target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        \\n        return dp[-1]\\n```\n```\\nclass Solution(object):\\n    def change(self, amount, coins):\\n        dp = [1] + [0] * amount\\n        \\n        for coin in coins:\\n            for i in range(coin, amount+1):\\n                dp[i] += dp[i - coin]\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85135,
                "title": "clean-three-solutions-in-c",
                "content": "Along with Further optimised `Memoization` solution\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> map;\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(nums.empty() || target<0) return 0;\\n        if(target == 0) return 1;\\n        if(map.count(target)) return map[target];\\n        long count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n            count += combinationSum4(nums, target-nums[i]);\\n        return map[target] = count;\\n    }\\n};\\n```\\n\\nUsing array instead of map accelerating the time from 20ms to 8ms.\\n\\n```\\nclass Solution {\\nprivate:\\n    int arr[100000];\\npublic:\\n    Solution() \\n    { \\n        arr[0] = 1;\\n        for(int i = 1; i < 100000; ++i) arr[i] = -1;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(nums.empty() || target<0) return 0;\\n        if(target == 0) return 1;\\n        if(arr[target] != -1) return arr[target];\\n        long count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n            count += combinationSum4(nums, target-nums[i]);\\n        return arr[target] = count;\\n    }\\n};\\n```\\n\\n\\n\\nFurther optimised DP solution \\n\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) \\n    {\\n        int arr[target+1]{1, 0};\\n        for(int i = 1, size = nums.size(); i <= target; ++i)\\n            for(int j = 0; j < size; ++j)\\n                if(i>=nums[j]) arr[i] += arr[i-nums[j]];\\n        return arr[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> map;\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(nums.empty() || target<0) return 0;\\n        if(target == 0) return 1;\\n        if(map.count(target)) return map[target];\\n        long count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n            count += combinationSum4(nums, target-nums[i]);\\n        return map[target] = count;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int arr[100000];\\npublic:\\n    Solution() \\n    { \\n        arr[0] = 1;\\n        for(int i = 1; i < 100000; ++i) arr[i] = -1;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(nums.empty() || target<0) return 0;\\n        if(target == 0) return 1;\\n        if(arr[target] != -1) return arr[target];\\n        long count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n            count += combinationSum4(nums, target-nums[i]);\\n        return arr[target] = count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) \\n    {\\n        int arr[target+1]{1, 0};\\n        for(int i = 1, size = nums.size(); i <= target; ++i)\\n            for(int j = 0; j < size; ++j)\\n                if(i>=nums[j]) arr[i] += arr[i-nums[j]];\\n        return arr[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386647,
                "title": "follow-up-answer",
                "content": "The approach to the solution is using Dynamic Programming\\nBoth Top-down and Bottom-Up  paradigm can be used.\\n\\n**The follow up answer**\\nHowever, how does the question change if there exists negative numbers??\\n\\nsuppose we have the following numbers \\n[1,2,3, -1] and target=4\\n\\nwe know following groups are valid -  \\n(1, 1, 1, 1)\\n(1, 1, 2)\\n(1, 2, 1)\\n(1, 3)\\n(2, 1, 1)\\n(2, 2)\\n(3, 1)\\n\\nHowever, now with negative numbers we can form more valid pairs \\nthey are -\\n(1,3) + (2, -1, -1) = 4\\n(1,3) + (2, -1, -1, 2, -1, -1) = 4\\n(1,3) + (2, -1, -1, 2, -1, -1, 2,-1,-1) = 4\\n(1,3) + (2, -1, -1, 2, -1, -1, 2,-1,-1, ... ...........) = 4\\n...\\n...\\n..\\n\\nThis can go on!!\\nHence there are actually infinite numbers of pairs which can be formed using negative pairs.\\nIts more like a cycle exists among the numbers. Which makes the question invalid with negative numbers.\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The approach to the solution is using Dynamic Programming\\nBoth Top-down and Bottom-Up  paradigm can be used.\\n\\n**The follow up answer**\\nHowever, how does the question change if there exists negative numbers??\\n\\nsuppose we have the following numbers \\n[1,2,3, -1] and target=4\\n\\nwe know following groups are valid -  \\n(1, 1, 1, 1)\\n(1, 1, 2)\\n(1, 2, 1)\\n(1, 3)\\n(2, 1, 1)\\n(2, 2)\\n(3, 1)\\n\\nHowever, now with negative numbers we can form more valid pairs \\nthey are -\\n(1,3) + (2, -1, -1) = 4\\n(1,3) + (2, -1, -1, 2, -1, -1) = 4\\n(1,3) + (2, -1, -1, 2, -1, -1, 2,-1,-1) = 4\\n(1,3) + (2, -1, -1, 2, -1, -1, 2,-1,-1, ... ...........) = 4\\n...\\n...\\n..\\n\\nThis can go on!!\\nHence there are actually infinite numbers of pairs which can be formed using negative pairs.\\nIts more like a cycle exists among the numbers. Which makes the question invalid with negative numbers.\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2383169,
                "title": "c-recursive-dp-memoized-solution-2ms-solution",
                "content": "**1. Recursive Brute force solution**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int> &nums, int target, int cur_sum){\\n        \\n        if(cur_sum==target)\\n            return 1;\\n        \\n        if(cur_sum > target) return 0;\\n            \\n        int sum = 0;\\n        \\n        for(auto i:nums){\\n            sum += f(nums, target, cur_sum+i);\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        return f(nums, target, 0);\\n        \\n    }\\n};\\n```\\n\\n**2. Memoized DP solution**\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int> &nums, int target, int cur_sum, vector<int> &dp){\\n        \\n        if(cur_sum==target)\\n            return 1;\\n        \\n        if(cur_sum > target) return 0;\\n        \\n        if(dp[cur_sum]!=-1) return dp[cur_sum];\\n    \\n        int sum = 0;\\n        \\n        for(auto i:nums){\\n            sum += f(nums, target, cur_sum+i, dp);\\n        }\\n        \\n        return dp[cur_sum] = sum;\\n        \\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp(target+1, -1);\\n        return f(nums, target, 0, dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int> &nums, int target, int cur_sum){\\n        \\n        if(cur_sum==target)\\n            return 1;\\n        \\n        if(cur_sum > target) return 0;\\n            \\n        int sum = 0;\\n        \\n        for(auto i:nums){\\n            sum += f(nums, target, cur_sum+i);\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        return f(nums, target, 0);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int> &nums, int target, int cur_sum, vector<int> &dp){\\n        \\n        if(cur_sum==target)\\n            return 1;\\n        \\n        if(cur_sum > target) return 0;\\n        \\n        if(dp[cur_sum]!=-1) return dp[cur_sum];\\n    \\n        int sum = 0;\\n        \\n        for(auto i:nums){\\n            sum += f(nums, target, cur_sum+i, dp);\\n        }\\n        \\n        return dp[cur_sum] = sum;\\n        \\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp(target+1, -1);\\n        return f(nums, target, 0, dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381211,
                "title": "combination-sum-iv-using-dp-daily-leetcoding-day5-aug-2022",
                "content": "## **Dynammic Programming Appoarch:**\\n**step1**: Creating a vector of size equal to target+1 as given in params and initialising the values with -1;\\n**step2**:Sorting the nums vector;\\n**step3**:Using helper function , recursivily calling each possibilities and if we have the value != -1 in v[target] then returning it there else summing all every possibilities associated with the target and corresponding nums values by subtracting the target value with the nums[i] if nums[i]<=target and calling out the function for the changed target and this goes on & on until we get target==0 then returning 1;\\n**step4**:Returning v[target] as out current ans for the target;\\n\\n### **Code Section:**\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int target,vector<int>& v)\\n    {\\n        if(target==0)\\n            return v[target]=1;\\n        \\n        if(v[target]!=-1)\\n            return v[target];\\n        \\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=target)\\n                count+=helper(nums,target-nums[i],v);\\n            else break;\\n        }\\n        return v[target]=count;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> v(target+1,-1);\\n        sort(nums.begin(),nums.end());\\n        return helper(nums,target,v);\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(vector<int>& nums, int target,vector<int>& v)\\n    {\\n        if(target==0)\\n            return v[target]=1;\\n        \\n        if(v[target]!=-1)\\n            return v[target];\\n        \\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=target)\\n                count+=helper(nums,target-nums[i],v);\\n            else break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2019295,
                "title": "python-dp-memoization-simple-solution",
                "content": "```\\nclass Solution:\\n    def combinations(self, nums, target, combination, lookup):\\n        if target == 0:\\n            return 1\\n        if target < 0:\\n            return 0\\n        if target not in lookup:\\n            ans = 0\\n            for num in nums:\\n                ans += self.combinations(nums, target-num, combination+[num], lookup)\\n            lookup[target] = ans\\n        return lookup[target]\\n    \\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.combinations(nums, target, [], {})\\n```\\n\\n***If you liked the above solution then kindly upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def combinations(self, nums, target, combination, lookup):\\n        if target == 0:\\n            return 1\\n        if target < 0:\\n            return 0\\n        if target not in lookup:\\n            ans = 0\\n            for num in nums:\\n                ans += self.combinations(nums, target-num, combination+[num], lookup)\\n            lookup[target] = ans\\n        return lookup[target]\\n    \\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.combinations(nums, target, [], {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218032,
                "title": "java-memoization-tabulation-faster-than-100",
                "content": "**Do upvote if you like it :)**\\n```\\n//Memoization\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        Arrays.fill(dp, -1);\\n        return Util(nums, target, dp);\\n    }\\n    \\n    public static int Util(int[] nums, int target, int[] dp) {\\n        if(target == 0) {\\n            return dp[target] = 1;\\n        }\\n        if(dp[target] != -1) {\\n            return dp[target];\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(target - nums[i] >= 0){\\n                count += Util(nums, target - nums[i], dp);\\n            }\\n        }\\n        return dp[target] = count;\\n    }\\n}\\n--------------------------------------------------------\\n//Tabulation\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n\\n        for(target = 0; target < dp.length; target++) {\\n            if(target == 0) {\\n                dp[target] = 1;\\n                continue;\\n            }\\n\\n            int count = 0;\\n            for(int i = 0; i < nums.length; i++) {\\n                if(target - nums[i] >= 0) {\\n                    count += dp[target - nums[i]];\\n                }\\n            }\\n            dp[target] = count;\\n        }\\n        return dp[dp.length - 1];\\n    }\\n}\\n--------------------------------------------------------\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Memoization\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        Arrays.fill(dp, -1);\\n        return Util(nums, target, dp);\\n    }\\n    \\n    public static int Util(int[] nums, int target, int[] dp) {\\n        if(target == 0) {\\n            return dp[target] = 1;\\n        }\\n        if(dp[target] != -1) {\\n            return dp[target];\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(target - nums[i] >= 0){\\n                count += Util(nums, target - nums[i], dp);\\n            }\\n        }\\n        return dp[target] = count;\\n    }\\n}\\n--------------------------------------------------------\\n//Tabulation\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n\\n        for(target = 0; target < dp.length; target++) {\\n            if(target == 0) {\\n                dp[target] = 1;\\n                continue;\\n            }\\n\\n            int count = 0;\\n            for(int i = 0; i < nums.length; i++) {\\n                if(target - nums[i] >= 0) {\\n                    count += dp[target - nums[i]];\\n                }\\n            }\\n            dp[target] = count;\\n        }\\n        return dp[dp.length - 1];\\n    }\\n}\\n--------------------------------------------------------\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129545,
                "title": "python3-top-down-dp-solution",
                "content": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        memo = {}\\n        def dfs(nums, t, memo):\\n            if t in memo:\\n                return memo[t]\\n            if t == 0:\\n                return 1\\n            if t < 0:\\n                return 0\\n            res = 0\\n            for i in nums:\\n                res += dfs(nums, t-i, memo)\\n            memo[t] = res\\n            return res\\n        return (dfs(nums, target, memo))",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        memo = {}",
                "codeTag": "Java"
            },
            {
                "id": 479229,
                "title": "is-there-a-2d-dp-solution",
                "content": "It seems that everyone is giving a 1D Dp solution. However, to my understanding, for most cases, 1D is reduced from 2D for space consideration. I tried to come up with one but it does not work. It only prints out number of ways without duplicates. Please help me out. Thank you.\\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<vector<int>> dp(target+1,vector<int>(nums.size()+1,0));\\n        for(int i=0;i<nums.size()+1;i++)\\n            dp[0][i] = 1;\\n        for(int i=1;i<target+1;i++)\\n        {\\n            for(int j=1;j<nums.size()+1;j++)\\n            {\\n                dp[i][j] += dp[i][j-1];\\n                if(i>=nums[j-1])\\n                    dp[i][j] += dp[i-nums[j-1]][j];\\n            }\\n        }\\n        for(auto& it:dp) {\\n            for (auto& itt:it)\\n                cout << itt <<\\' \\';\\n            cout << endl;\\n        }\\n        return dp[target][nums.size()];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<vector<int>> dp(target+1,vector<int>(nums.size()+1,0));\\n        for(int i=0;i<nums.size()+1;i++)\\n            dp[0][i] = 1;\\n        for(int i=1;i<target+1;i++)\\n        {\\n            for(int j=1;j<nums.size()+1;j++)\\n            {\\n                dp[i][j] += dp[i][j-1];\\n                if(i>=nums[j-1])\\n                    dp[i][j] += dp[i-nums[j-1]][j];\\n            }\\n        }\\n        for(auto& it:dp) {\\n            for (auto& itt:it)\\n                cout << itt <<\\' \\';\\n            cout << endl;\\n        }\\n        return dp[target][nums.size()];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 456122,
                "title": "python-from-back-tracking-to-iterative-dp-with-clear-explanation",
                "content": "DP is much easier if -\\n\\n1. We first come up with back-tracking algorithm\\n2. Memoise the algorithm in #1\\n3. Use #2 as reference for iterative DP solution\\n\\nSo first, the back-tracking algorithm:\\n\\n```\\ndef combinationSumTopDown(self, nums, target, cache):\\n        \"\"\"        \\n\\t\\tComplexity: O(target ^ n) times    \\n        \"\"\"\\n        if target < 0:\\n            return 0 # correct?\\n        \\n        if target == 0:\\n            return 1\\n        \\n        count = 0    \\n        for i in range(len(nums)):\\n            count += self.combinationSumTopDown(nums, target-nums[i], cache) \\n     \\n        return count\\n```\\n\\n\\nNow we introduce cache to store already computed values. This is a slight modification to the above problem. Remarkably the complexity reduces from exponential to polynomial. \\n\\nBelow can further be optimized by short circuiting at the for loop.\\n```\\n    def combinationSumTopDownWithDP(self, nums, target, cache):\\n        \"\"\"        \\n        DP Complexity: O(target * n) times\\n\\t\\tWhy O(target * n)?\\n\\t\\t\\t- The parameter \\'target\\' takes values from \\'target\\' until \\'0\\'. \\n\\t\\t\\t- For each of these values, we invoke the same function \\'n\\' times\\n        \"\"\"\\n        if target < 0:\\n            return 0 \\n        \\n        if target == 0:\\n            return 1\\n        \\n        if cache[target] != -1:\\n            return cache[target]\\n        \\n        count = 0    \\n        for i in range(len(nums)):\\n            count += self.combinationSumTopDownWithDP(nums, target-nums[i], cache) \\n            \\n        cache[target] = count\\n        return cache[target]\\n    \\n    \\n    def combinationSum4(self, nums, target):        \\n        cache = [-1] * (target+1)\\n        return self.combinationSum(nums, target, cache)   \\n```\\n\\nNow, if we observe the above solution, the cache is being built up from \\'0\\' to \\'target\\'. We take this idea and build the bottom-up solution. The complexity remains the same.\\n\\n    def combinationSumBottomUp(self, nums, target):\\n\\t\\t\"\"\"\\n\\t\\tDP Complexity: O(target * n) times\\n\\t\\t\"\"\"\\n                \\n        cache = [0] * (target+1)\\n\\t\\t\\n\\t\\t#  This helps in the cases where num = target, as there is 1 way to choose here.\\n        cache[0] = 1\\n        \\n        for t in range(1, target+1):            \\n            count = 0\\n            for num in nums:\\n                \\n                # Below condition is implicit\\n                # if t-num < 0:\\n                #     continue   \\n                \\n                if t-num >= 0:\\n                    count += cache[t-num]\\n                                                                                     \\n            cache[t] = count\\n            \\n        return cache[target]",
                "solutionTags": [],
                "code": "```\\ndef combinationSumTopDown(self, nums, target, cache):\\n        \"\"\"        \\n\\t\\tComplexity: O(target ^ n) times    \\n        \"\"\"\\n        if target < 0:\\n            return 0 # correct?\\n        \\n        if target == 0:\\n            return 1\\n        \\n        count = 0    \\n        for i in range(len(nums)):\\n            count += self.combinationSumTopDown(nums, target-nums[i], cache) \\n     \\n        return count\\n```\n```\\n    def combinationSumTopDownWithDP(self, nums, target, cache):\\n        \"\"\"        \\n        DP Complexity: O(target * n) times\\n\\t\\tWhy O(target * n)?\\n\\t\\t\\t- The parameter \\'target\\' takes values from \\'target\\' until \\'0\\'. \\n\\t\\t\\t- For each of these values, we invoke the same function \\'n\\' times\\n        \"\"\"\\n        if target < 0:\\n            return 0 \\n        \\n        if target == 0:\\n            return 1\\n        \\n        if cache[target] != -1:\\n            return cache[target]\\n        \\n        count = 0    \\n        for i in range(len(nums)):\\n            count += self.combinationSumTopDownWithDP(nums, target-nums[i], cache) \\n            \\n        cache[target] = count\\n        return cache[target]\\n    \\n    \\n    def combinationSum4(self, nums, target):        \\n        cache = [-1] * (target+1)\\n        return self.combinationSum(nums, target, cache)   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 85062,
                "title": "evolve-from-recursion-to-dp",
                "content": "1. Recursion O(n^(target/min(nums))\\n* c++\\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(target<=0) return !target?1:0;\\n        int ct=0;\\n        for(int i=0;i<nums.size();i++) ct+=combinationSum4(nums, target-nums[i]);\\n        return ct;\\n    }\\n```\\n* java\\n```\\n\\tpublic int combinationSum4(int[] nums, int target) {\\n        if(target<0) return 0;\\n        if(target==0) return 1;\\n        int sum=0;\\n        for(int num:nums)\\n            sum+=combinationSum4(nums,target-num);\\n        return sum;    \\n    }\\n```\\n2. memoization O(n*target)\\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> mem(target+1,-1);\\n        return dfs(target,mem,nums);\\n    }\\n    int dfs(int target, vector<int>& mem, vector<int>& nums) {\\n        if(target<=0) return !target?1:0;\\n        if(mem[target]!=-1) return mem[target];\\n        int ct=0;\\n        for(int i=0;i<nums.size();i++) ct+=dfs(target-nums[i],mem,nums);\\n        return mem[target] = ct;\\n    }\\n```\\n3. dp O(n*target), This is slower than memoization because memorization does not compute all from 1 to target.\\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target+1);\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++) \\n            for(int j=0;j<nums.size();j++) \\n                if(i >= nums[j]) dp[i] += dp[i-nums[j]];\\n        return dp[target];\\n    }\\n```\\n4. dp O(n*target), early termination \\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target+1);\\n        dp[0]=1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<=target;i++) \\n            for(int j=0;j<nums.size();j++) \\n                if(i >= nums[j]) dp[i] += dp[i-nums[j]];\\n                else break;\\n        return dp[target];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if(target<=0) return !target?1:0;\\n        int ct=0;\\n        for(int i=0;i<nums.size();i++) ct+=combinationSum4(nums, target-nums[i]);\\n        return ct;\\n    }\\n```\n```\\n\\tpublic int combinationSum4(int[] nums, int target) {\\n        if(target<0) return 0;\\n        if(target==0) return 1;\\n        int sum=0;\\n        for(int num:nums)\\n            sum+=combinationSum4(nums,target-num);\\n        return sum;    \\n    }\\n```\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> mem(target+1,-1);\\n        return dfs(target,mem,nums);\\n    }\\n    int dfs(int target, vector<int>& mem, vector<int>& nums) {\\n        if(target<=0) return !target?1:0;\\n        if(mem[target]!=-1) return mem[target];\\n        int ct=0;\\n        for(int i=0;i<nums.size();i++) ct+=dfs(target-nums[i],mem,nums);\\n        return mem[target] = ct;\\n    }\\n```\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target+1);\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++) \\n            for(int j=0;j<nums.size();j++) \\n                if(i >= nums[j]) dp[i] += dp[i-nums[j]];\\n        return dp[target];\\n    }\\n```\n```\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target+1);\\n        dp[0]=1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<=target;i++) \\n            for(int j=0;j<nums.size();j++) \\n                if(i >= nums[j]) dp[i] += dp[i-nums[j]];\\n                else break;\\n        return dp[target];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021012,
                "title": "dp-memoization-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shanthi(vector<int>& nums, int tar, vector<int>& dp) {\\n        if (tar < 0) {\\n            return 0;\\n        }\\n        if (tar == 0) {\\n            return 1;\\n        }\\n        if (dp[tar] != -1) {\\n            return dp[tar];\\n        }\\n        int take = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            take += shanthi(nums, tar - nums[i], dp);\\n        }\\n        return dp[tar] = take;  \\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1, -1);\\n        return shanthi(nums, target, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shanthi(vector<int>& nums, int tar, vector<int>& dp) {\\n        if (tar < 0) {\\n            return 0;\\n        }\\n        if (tar == 0) {\\n            return 1;\\n        }\\n        if (dp[tar] != -1) {\\n            return dp[tar];\\n        }\\n        int take = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            take += shanthi(nums, tar - nums[i], dp);\\n        }\\n        return dp[tar] = take;  \\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1, -1);\\n        return shanthi(nums, target, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020213,
                "title": "daily-leetcoding-challenge-september-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3444254,
                "title": "easy-solution-bottom-up-approach-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(TARGET * N);\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<long long int>dp(target+1,0);\\n        dp[0] = 1;\\n        for(int i = 1; i<= target;i++){\\n            for(auto value : nums){\\n                if( i - value  >= 0 && dp[i] <= INT_MAX)\\n                  dp[i] += (long long int)dp[i - value];   \\n            }\\n        }\\n       return  dp[target];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<long long int>dp(target+1,0);\\n        dp[0] = 1;\\n        for(int i = 1; i<= target;i++){\\n            for(auto value : nums){\\n                if( i - value  >= 0 && dp[i] <= INT_MAX)\\n                  dp[i] += (long long int)dp[i - value];   \\n            }\\n        }\\n       return  dp[target];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320757,
                "title": "dynamic-programming-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   int f(int ind, int target, vector<int> &nums, vector<vector<int>> &dp){\\n        if(ind > nums.size()) return 0;\\n       \\n        if(ind == nums.size()) return (target == 0);\\n        if(dp[ind][target] != -1) return dp[ind][target];\\n\\n        int np = f(ind+1,target,nums,dp);\\n        int p = 0;\\n        if(nums[ind] <= target) p = f(0,target-nums[ind],nums,dp);\\n\\n        return (dp[ind][target] = p + np);\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<vector<int>> dp(nums.size(), vector<int> (target+1,-1));\\n        return f(0,target,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   int f(int ind, int target, vector<int> &nums, vector<vector<int>> &dp){\\n        if(ind > nums.size()) return 0;\\n       \\n        if(ind == nums.size()) return (target == 0);\\n        if(dp[ind][target] != -1) return dp[ind][target];\\n\\n        int np = f(ind+1,target,nums,dp);\\n        int p = 0;\\n        if(nums[ind] <= target) p = f(0,target-nums[ind],nums,dp);\\n\\n        return (dp[ind][target] = p + np);\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<vector<int>> dp(nums.size(), vector<int> (target+1,-1));\\n        return f(0,target,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252862,
                "title": "377-time-96-50-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We start by creating an array dp to store the number of combinations that add up to each index up to the target. We initialize the first element to 1, since there is 1 way to add up to 0.\\n- We sort the input array nums to make sure we consider combinations in the correct order.\\n- We iterate through each index up to the target using a for loop. For each index i, we iterate through each number num in the input array nums using another for loop.\\n- If the current number num is greater than the current index i, we break out of the inner loop. This is because we have already considered all numbers that are smaller than num.\\n- Otherwise, we add the number of combinations that add up to the current index minus the current number (dp[i - num]) to the current number of combinations that add up to the current index (dp[i]). This is because we can obtain a new combination that adds up to i by adding num to an existing combination that adds up to i - num.\\n- After we have considered all numbers in nums for the current index i, we move on to the next index in the outer loop and repeat the process.\\n- Finally, we return the number of combinations that add up to the target, which is stored in dp[target].\\n\\n# Complexity\\n- Time complexity:\\n96.50%\\n\\n- Space complexity:\\n43.10%\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        # Create an array to store the number of combinations that add up to each index up to the target\\n        # Initialize the first element to 1, since there is 1 way to add up to 0\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        # Sort the input array to make sure we consider combinations in the correct order\\n        nums.sort()\\n        \\n        # Iterate through each index up to the target\\n        for i in range(1, target + 1):\\n            # Iterate through each number in the input array\\n            for num in nums:\\n                # If the number is greater than the current index, break out of the inner loop\\n                if num > i:\\n                    break\\n                # Otherwise, add the number of combinations that add up to the current index minus the current number\\n                # to the current number of combinations that add up to the current index\\n                dp[i] += dp[i - num]\\n        \\n        # Return the number of combinations that add up to the target\\n        return dp[target]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        # Create an array to store the number of combinations that add up to each index up to the target\\n        # Initialize the first element to 1, since there is 1 way to add up to 0\\n        dp = [0] * (target + 1)\\n        dp[0] = 1\\n        \\n        # Sort the input array to make sure we consider combinations in the correct order\\n        nums.sort()\\n        \\n        # Iterate through each index up to the target\\n        for i in range(1, target + 1):\\n            # Iterate through each number in the input array\\n            for num in nums:\\n                # If the number is greater than the current index, break out of the inner loop\\n                if num > i:\\n                    break\\n                # Otherwise, add the number of combinations that add up to the current index minus the current number\\n                # to the current number of combinations that add up to the current index\\n                dp[i] += dp[i - num]\\n        \\n        # Return the number of combinations that add up to the target\\n        return dp[target]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084567,
                "title": "traditional-approach-c-beats-100-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    int dp[1001];\\n    int solve(vector<int>& nums, int sum, int ans){\\n        if(sum==0){\\n          return 1;\\n        }\\n        if(sum<0) return 0;\\n        if(dp[sum] != -1){\\n            return dp[sum];\\n        }\\n        int cnt=0;\\n        for(int i=0; i<nums.size(); i++){\\n           cnt+=solve(nums, sum-nums[i],ans);\\n        }\\n           dp[sum]=cnt; ans+=cnt;\\n        return ans;\\n    }\\npublic:\\n    int combinationSum4(vector<int>& nums, int n) {\\n        memset(dp, -1, sizeof(dp));\\n       return solve(nums, n, 0);\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1001];\\n    int solve(vector<int>& nums, int sum, int ans){\\n        if(sum==0){\\n          return 1;\\n        }\\n        if(sum<0) return 0;\\n        if(dp[sum] != -1){\\n            return dp[sum];\\n        }\\n        int cnt=0;\\n        for(int i=0; i<nums.size(); i++){\\n           cnt+=solve(nums, sum-nums[i],ans);\\n        }\\n           dp[sum]=cnt; ans+=cnt;\\n        return ans;\\n    }\\npublic:\\n    int combinationSum4(vector<int>& nums, int n) {\\n        memset(dp, -1, sizeof(dp));\\n       return solve(nums, n, 0);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383387,
                "title": "memoization-tabulation-2-approaches-java",
                "content": "Solution 1: **MEMOIZATION**\\n```\\nclass Solution { // Memoization - Top Down (0ms - 100% Faster)\\n    Integer[] dp; int target,nums[];\\n    public int combinationSum4(int[] nums, int target) {\\n        dp = new Integer[target+1];\\n        dp[target]=1;\\n        this.target=target;\\n        this.nums=nums;\\n        return recurse(0);\\n    }\\n    private int recurse(int done_till){\\n        if(dp[done_till]!=null)\\n            return dp[done_till];\\n        int res=0;\\n        for(int val : nums)\\n            if((done_till+val)<=target)\\n                res+=recurse(done_till+val);\\n        return dp[done_till]=res;\\n    }\\n}\\n```\\nSolution 2: **TABULATION**\\n```\\nclass Solution { // Tabulation - Bottom Up (1ms - 93% Faster)\\n    public int combinationSum4(int[] nums, int target) {\\n        int i,dp[] = new int[target+1];\\n        for(i=dp[0]=1;i<=target;i++)\\n            for(int val : nums)\\n                if((i-val)>=0) \\n\\t\\t\\t\\t\\tdp[i]+=dp[i-val];\\n        return dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution { // Memoization - Top Down (0ms - 100% Faster)\\n    Integer[] dp; int target,nums[];\\n    public int combinationSum4(int[] nums, int target) {\\n        dp = new Integer[target+1];\\n        dp[target]=1;\\n        this.target=target;\\n        this.nums=nums;\\n        return recurse(0);\\n    }\\n    private int recurse(int done_till){\\n        if(dp[done_till]!=null)\\n            return dp[done_till];\\n        int res=0;\\n        for(int val : nums)\\n            if((done_till+val)<=target)\\n                res+=recurse(done_till+val);\\n        return dp[done_till]=res;\\n    }\\n}\\n```\n```\\nclass Solution { // Tabulation - Bottom Up (1ms - 93% Faster)\\n    public int combinationSum4(int[] nums, int target) {\\n        int i,dp[] = new int[target+1];\\n        for(i=dp[0]=1;i<=target;i++)\\n            for(int val : nums)\\n                if((i-val)>=0) \\n\\t\\t\\t\\t\\tdp[i]+=dp[i-val];\\n        return dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381606,
                "title": "c-easy-solution-memoization",
                "content": "class Solution {\\npublic:\\n\\n    int func(vector<int>& nums,int n,vector<int>& dp){\\n        if(n==0)\\n          {\\n    return 1;\\n    }\\n    if(n<0) return 0;\\n    \\n        if(dp[n]!=-1)\\n          {\\n        return dp[n];\\n        }\\n        int ans=0;\\n    for(int i=0;i<nums.size();i++)\\n        {\\n        if(n-nums[i]<0)\\n            break;\\n       ans+= func(nums,n-nums[i],dp);\\n        \\n    }\\n        return dp[n]=ans;\\n        }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> dp(target+1,-1);\\n       int cnt = func(nums,target,dp);\\n        return cnt;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int func(vector<int>& nums,int n,vector<int>& dp){\\n        if(n==0)\\n          {\\n    return 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2380904,
                "title": "c-java-recursion-memoisation-explained-with-comments",
                "content": "**Java**\\n\\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n        int n = nums.length;\\n        \\n        return findCombination(nums, 0, n, target, new Integer[target + 1]);\\n    }\\n    \\n    int findCombination(int[] nums, int idx, int n, int target, Integer dp[])\\n    {\\n        // base case\\n        if(idx == n)\\n        {\\n            // if target is 0, we found combination then return 1\\n            // else return 0\\n            return (target == 0) ? 1 : 0;\\n        }\\n        \\n        // memoisation\\n        if(dp[target] != null)\\n            return dp[target];\\n        \\n        // if we are not picking, go to next idx\\n        int notPick = findCombination(nums, idx+1, n, target, dp);\\n        \\n        // if picking means, reduce the target and again start iteration from zero\\n        int pick = 0;\\n        if(target >= nums[idx])\\n            pick = findCombination(nums, 0, n, target - nums[idx], dp);\\n        \\n        \\n        // finally, add the total possible combination\\n        return dp[target] = pick + notPick;\\n    }\\n}\\n```\\n\\n\\n**C++**\\n\\n```\\nclass Solution {\\nprivate:\\n    int findCombination(vector<int> &nums, int idx, int n, int target, vector<int> &dp)\\n    {\\n        // base case\\n        if(idx == n)\\n        {\\n            // if target is 0, we found combination then return 1\\n            // else return 0\\n            return (target == 0);\\n        }\\n        \\n        // memoisation\\n        if(dp[target] != -1)\\n            return dp[target];\\n        \\n        // if we are not picking, go to next idx\\n        int notPick = findCombination(nums, idx+1, n, target, dp);\\n        \\n        // if picking means, reduce the target and again start iteration from zero\\n        int pick = 0;\\n        if(target >= nums[idx])\\n            pick = findCombination(nums, 0, n, target - nums[idx], dp);\\n        \\n        \\n        // finally, add the total possible combination\\n        return dp[target] = pick + notPick;\\n    }\\n    \\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(target + 1, -1);\\n        \\n        return findCombination(nums, 0, n, target, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n        int n = nums.length;\\n        \\n        return findCombination(nums, 0, n, target, new Integer[target + 1]);\\n    }\\n    \\n    int findCombination(int[] nums, int idx, int n, int target, Integer dp[])\\n    {\\n        // base case\\n        if(idx == n)\\n        {\\n            // if target is 0, we found combination then return 1\\n            // else return 0\\n            return (target == 0) ? 1 : 0;\\n        }\\n        \\n        // memoisation\\n        if(dp[target] != null)\\n            return dp[target];\\n        \\n        // if we are not picking, go to next idx\\n        int notPick = findCombination(nums, idx+1, n, target, dp);\\n        \\n        // if picking means, reduce the target and again start iteration from zero\\n        int pick = 0;\\n        if(target >= nums[idx])\\n            pick = findCombination(nums, 0, n, target - nums[idx], dp);\\n        \\n        \\n        // finally, add the total possible combination\\n        return dp[target] = pick + notPick;\\n    }\\n}\\n```\n```\\nclass Solution {\\nprivate:\\n    int findCombination(vector<int> &nums, int idx, int n, int target, vector<int> &dp)\\n    {\\n        // base case\\n        if(idx == n)\\n        {\\n            // if target is 0, we found combination then return 1\\n            // else return 0\\n            return (target == 0);\\n        }\\n        \\n        // memoisation\\n        if(dp[target] != -1)\\n            return dp[target];\\n        \\n        // if we are not picking, go to next idx\\n        int notPick = findCombination(nums, idx+1, n, target, dp);\\n        \\n        // if picking means, reduce the target and again start iteration from zero\\n        int pick = 0;\\n        if(target >= nums[idx])\\n            pick = findCombination(nums, 0, n, target - nums[idx], dp);\\n        \\n        \\n        // finally, add the total possible combination\\n        return dp[target] = pick + notPick;\\n    }\\n    \\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(target + 1, -1);\\n        \\n        return findCombination(nums, 0, n, target, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159330,
                "title": "java-solution-for-follow-up",
                "content": "considering [-1,1] and target N, it can generate infinite conbinations for N. i.e,` [-1,1, 1(N times)]` and `[-1,1,-1,1,1(N times)]`.  we need to restrict the length of combinations.\\nhere is my Java solution:\\n```\\npublic int combinationSumFour2(int[] nums, int target,\\n                                    int length,\\n                                   Map<Integer, Integer> map,\\n                                   int maxLen) {\\n        if(length > maxLen) return 0;\\n        int count = 0;\\n        if(target == 0) count++;\\n        for(int num: nums){\\n            count += combinationSumFour2(nums, target - num, length+1, map, maxLen);\\n        }\\n        if(count == 0)\\n            return count;\\n        map.put(target, count);\\n        return count;\\n    }\\n```\\n\\ntested with such input:\\n```\\nint[] nums = {-1,1,2,3};\\nMap<Integer, Integer> map = new HashMap<>();\\ncombinationSumFour2(nums, 3, 0, map, 2);\\n```\\n\\nthe map output is: `{0=1, 1=1, 2=1, 3=3}`.   `3=3` means target is 3 and there are 3 of combinations within length of 2.\\n\\nI also checked this code: https://leetcode.com/problems/combination-sum-iv/discuss/85038/JAVA%3A-follow-up-using-recursion-and-memorization. but I think the output is not correct.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int combinationSumFour2(int[] nums, int target,\\n                                    int length,\\n                                   Map<Integer, Integer> map,\\n                                   int maxLen) {\\n        if(length > maxLen) return 0;\\n        int count = 0;\\n        if(target == 0) count++;\\n        for(int num: nums){\\n            count += combinationSumFour2(nums, target - num, length+1, map, maxLen);\\n        }\\n        if(count == 0)\\n            return count;\\n        map.put(target, count);\\n        return count;\\n    }\\n```\n```\\nint[] nums = {-1,1,2,3};\\nMap<Integer, Integer> map = new HashMap<>();\\ncombinationSumFour2(nums, 3, 0, map, 2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673417,
                "title": "c-easy-o-understand-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i < dp.size(); i++) {\\n          for (int j = 0; j < nums.size(); j++) {\\n            if (nums[j] <= i)\\n              dp[i] += dp[i - nums[j]];\\n          }\\n        }\\n\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i < dp.size(); i++) {\\n          for (int j = 0; j < nums.size(); j++) {\\n            if (nums[j] <= i)\\n              dp[i] += dp[i - nums[j]];\\n          }\\n        }\\n\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670279,
                "title": "easy-dynamic-programming-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<double> dp(target+1,0);\\n        \\n        dp[0] = 1;\\n        \\n        for(double amt=1;amt<=target;amt++)\\n        {\\n            for(double x : nums)\\n            {\\n                if(x <= amt)\\n                {\\n                    double ramt = amt - x;\\n                    dp[amt] += dp[ramt];\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<double> dp(target+1,0);\\n        \\n        dp[0] = 1;\\n        \\n        for(double amt=1;amt<=target;amt++)\\n        {\\n            for(double x : nums)\\n            {\\n                if(x <= amt)\\n                {\\n                    double ramt = amt - x;\\n                    dp[amt] += dp[ramt];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1166120,
                "title": "java-dp-runtime-1ms",
                "content": "**Iterative Approach**\\n*This problem is similar to Coin Change*\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        int dp[]=new int[target+1];\\n        \\n        dp[0]=1;\\n        for(int i=0;i<=target;i++){\\n            for(int num:nums){\\n                if(i+num<=target){\\n                    dp[i+num]+=dp[i];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\n***Please upvote if you like***\\n*feel free to discuss your approach*",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "**Iterative Approach**\\n*This problem is similar to Coin Change*\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        int dp[]=new int[target+1];\\n        \\n        dp[0]=1;\\n        for(int i=0;i<=target;i++){\\n            for(int num:nums){\\n                if(i+num<=target){\\n                    dp[i+num]+=dp[i];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\n***Please upvote if you like***\\n*feel free to discuss your approach*",
                "codeTag": "Unknown"
            },
            {
                "id": 746665,
                "title": "swift-minimal-solution-top-down-bottom-up-with-complexity",
                "content": "# Approach 1: Top down\\n# \\nTime: O(mn), Space: O(n)\\nwhere m in the nums.count, n is target\\n```\\nfunc combinationSum4(_ nums: [Int], _ target: Int) -> Int {\\n\\tvar dict = [Int : Int]()\\n\\tdict[0] = 1\\n\\treturn helper(nums, target, &dict)\\n}\\n\\nfunc helper(_ nums: [Int], _ target: Int, _ dict: inout [Int : Int]) -> Int {\\n\\tif target < 0 { return 0 }\\n\\tif let saved = dict[target] { return saved }\\n\\n\\tvar result = 0\\n\\tfor num in nums {\\n\\t\\tresult += helper(nums, target - num, &dict)\\n\\t}\\n\\n\\tdict[target] = result\\n\\treturn result\\n}\\n```\\n\\n# Approach 2: Bottom-up \\nTime: O(mn), Space: O(n)\\nwhere m in the nums.count, n is target\\n```\\nfunc combinationSum4(_ nums: [Int], _ target: Int) -> Int {\\n\\tvar combos = Array(repeating: 0, count: target + 1)\\n\\tcombos[0] = 1\\n\\n\\tfor i in 1..<combos.count {\\n\\t\\tfor num in nums {\\n\\t\\t\\tlet sum = i - num\\n\\t\\t\\tif sum >= 0 {\\n\\t\\t\\t\\tcombos[i] = (combos[i] + combos[sum]) % 2147483647\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn combos[target]\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc combinationSum4(_ nums: [Int], _ target: Int) -> Int {\\n\\tvar dict = [Int : Int]()\\n\\tdict[0] = 1\\n\\treturn helper(nums, target, &dict)\\n}\\n\\nfunc helper(_ nums: [Int], _ target: Int, _ dict: inout [Int : Int]) -> Int {\\n\\tif target < 0 { return 0 }\\n\\tif let saved = dict[target] { return saved }\\n\\n\\tvar result = 0\\n\\tfor num in nums {\\n\\t\\tresult += helper(nums, target - num, &dict)\\n\\t}\\n\\n\\tdict[target] = result\\n\\treturn result\\n}\\n```\n```\\nfunc combinationSum4(_ nums: [Int], _ target: Int) -> Int {\\n\\tvar combos = Array(repeating: 0, count: target + 1)\\n\\tcombos[0] = 1\\n\\n\\tfor i in 1..<combos.count {\\n\\t\\tfor num in nums {\\n\\t\\t\\tlet sum = i - num\\n\\t\\t\\tif sum >= 0 {\\n\\t\\t\\t\\tcombos[i] = (combos[i] + combos[sum]) % 2147483647\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn combos[target]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 613592,
                "title": "javascript-dp-with-formula-explanation-runtime-74-memory-100",
                "content": "Once you get the trick of these recursive problems, it becomes very easy.\\n\\n1) figure out if it\\'s recursive (sub problems, which are the same)\\n2) figure out the base case & recursive steps\\n3) add the memoization part to not repeat the same sub problem if it\\'s already been done before.\\n\\n```\\nvar combinationSum4 = function(nums, target, memo={}) {\\n  if (target ==0) return 1; \\n  if (typeof memo[target] != \"undefined\") return memo[target];\\n   let ret = 0;\\n    \\n    for (let i = 0; i<nums.length; i++) {\\n        if (target >= nums[i])\\n            ret += combinationSum4(nums, target - nums[i], memo);\\n    }\\n    memo[target] = ret;\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar combinationSum4 = function(nums, target, memo={}) {\\n  if (target ==0) return 1; \\n  if (typeof memo[target] != \"undefined\") return memo[target];\\n   let ret = 0;\\n    \\n    for (let i = 0; i<nums.length; i++) {\\n        if (target >= nums[i])\\n            ret += combinationSum4(nums, target - nums[i], memo);\\n    }\\n    memo[target] = ret;\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 352262,
                "title": "c-fixed-overflow-cannot-pass-new-corner-case-3-33-333-1000",
                "content": "Like many other people, my original solution was to construct a dp array and bult it from 1 to target. However, it overflowed when new corner case [3,33,333], 1000 was added. \\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int m = nums.size();\\n        vector<long long> dp(target+1, 0);\\n        dp[0] = 1;\\n        for (int j = 1 ; j <= target ; ++j) {\\n            for (int i = 0 ; i < m ; ++i) {                \\n                if (j - nums[i] >= 0)\\n                    dp[j] += dp[j - nums[i]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\\n\\nThe answer is 0, because [3,33,333] cannot form 10000. It overflows at dp[792] which is actually cannot form 10000 with [3,33,333]. That tells us we should only care about those elements which can form the target. For example, for case nums = [3], target = 14, we only care about dp[14], dp[11], dp[8], dp[5], dp[2]. We don\\'t need to calculate the others.\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> M;\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if (target == 0) return 1;\\n        if (target < 0) return 0;\\n        if (M.count(target)) return M[target];\\n        int rtn = 0;\\n        for (int n : nums)\\n            rtn += combinationSum4(nums, target - n);\\n        M[target] = rtn;\\n        return rtn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int m = nums.size();\\n        vector<long long> dp(target+1, 0);\\n        dp[0] = 1;\\n        for (int j = 1 ; j <= target ; ++j) {\\n            for (int i = 0 ; i < m ; ++i) {                \\n                if (j - nums[i] >= 0)\\n                    dp[j] += dp[j - nums[i]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> M;\\n    int combinationSum4(vector<int>& nums, int target) {\\n        if (target == 0) return 1;\\n        if (target < 0) return 0;\\n        if (M.count(target)) return M[target];\\n        int rtn = 0;\\n        for (int n : nums)\\n            rtn += combinationSum4(nums, target - n);\\n        M[target] = rtn;\\n        return rtn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351717,
                "title": "java-3-progressive-methods",
                "content": "**Method 1:** Brute force\\n> **T/S:** O(n^t)/O(t), where n = size(nums) and t = target\\n```\\npublic int combinationSum(int[] nums, int target) {\\n\\treturn combinationSum(nums, target, 0);\\n}\\n\\nprivate int combinationSum(int[] nums, int target, int sum) {\\n\\tif (sum > target)\\n\\t\\treturn 0;\\n\\tif (sum == target)\\n\\t\\treturn 1;\\n\\t\\t\\n\\tvar count = 0;\\n\\tfor (var num : nums)\\n\\t\\tcount += combinationSum(nums, target, sum + num);\\n\\treturn count;\\n}\\n```\\n\\n**Method 2:** Inject memoization in method 1\\n> **T/S:** O(t)/O(t).\\nBecause of memoization, no node in the decision tree will be calculated more than once. Each node will correspond to a number less than T that can be reached using options in nums. Using these 2 statements, time complexity would be O(T).\\n```\\npublic int combinationSum(int[] nums, int target) {\\n\\tvar dp = new int[target + 1];\\n\\tArrays.fill(dp, -1);\\n\\treturn combinationSum(nums, target, dp, 0);\\n}\\n\\nprivate int combinationSum(int[] nums, int target, int[] dp, int sum) {\\n\\tif (sum > target)\\n\\t\\treturn 0;\\n\\tif (sum == target)\\n\\t\\treturn 1;\\n\\tif (dp[sum] != -1)\\n\\t\\treturn dp[sum];\\n\\t\\t\\n\\tvar count = 0;\\n\\tfor (var num : nums)\\n\\t\\tcount += combinationSum(nums, target, dp, sum + num);\\n\\treturn dp[sum] = count;\\n}\\n```\\n\\n**Method 3:** Tabulation\\n> **T/S:** O(nT)/O(T)\\n```\\npublic int combinationSum4(int[] nums, int target) {\\n\\tvar dp = new int[target + 1];\\n\\tdp[0] = 1;\\n\\tvar n = dp.length;\\n\\t\\n\\tfor (var i = 0; i < n - 1; i++)\\n\\t\\tfor (var num : nums)\\n\\t\\t\\tif (i + num < n)\\n\\t\\t\\t\\tdp[i + num] += dp[i];\\n\\treturn dp[n - 1];\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\npublic int combinationSum(int[] nums, int target) {\\n\\treturn combinationSum(nums, target, 0);\\n}\\n\\nprivate int combinationSum(int[] nums, int target, int sum) {\\n\\tif (sum > target)\\n\\t\\treturn 0;\\n\\tif (sum == target)\\n\\t\\treturn 1;\\n\\t\\t\\n\\tvar count = 0;\\n\\tfor (var num : nums)\\n\\t\\tcount += combinationSum(nums, target, sum + num);\\n\\treturn count;\\n}\\n```\n```\\npublic int combinationSum(int[] nums, int target) {\\n\\tvar dp = new int[target + 1];\\n\\tArrays.fill(dp, -1);\\n\\treturn combinationSum(nums, target, dp, 0);\\n}\\n\\nprivate int combinationSum(int[] nums, int target, int[] dp, int sum) {\\n\\tif (sum > target)\\n\\t\\treturn 0;\\n\\tif (sum == target)\\n\\t\\treturn 1;\\n\\tif (dp[sum] != -1)\\n\\t\\treturn dp[sum];\\n\\t\\t\\n\\tvar count = 0;\\n\\tfor (var num : nums)\\n\\t\\tcount += combinationSum(nums, target, dp, sum + num);\\n\\treturn dp[sum] = count;\\n}\\n```\n```\\npublic int combinationSum4(int[] nums, int target) {\\n\\tvar dp = new int[target + 1];\\n\\tdp[0] = 1;\\n\\tvar n = dp.length;\\n\\t\\n\\tfor (var i = 0; i < n - 1; i++)\\n\\t\\tfor (var num : nums)\\n\\t\\t\\tif (i + num < n)\\n\\t\\t\\t\\tdp[i + num] += dp[i];\\n\\treturn dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85081,
                "title": "python-dp",
                "content": "    class Solution(object):\\n        def combinationSum4(self, nums, target):\\n            f = [1] + [0] * target\\n            for i in range(1,len(f)):\\n                for x in nums:\\n                    if x <= i:\\n                         f[i] += f[i-x]\\n            return f[-1]",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def combinationSum4(self, nums, target):\\n            f = [1] + [0] * target\\n            for i in range(1,len(f)):\\n                for x in nums:\\n                    if x <= i:\\n                         f[i] += f[i-x]\\n            return f[-1]",
                "codeTag": "Java"
            },
            {
                "id": 85099,
                "title": "cpp-solution-for-follow-up-based-on-memorization-search",
                "content": "In order to allow negative numbers, the size of the sequence must have a upperbound. Otherwise the result will INF.\\n\\nMy solution used dp idea but since we don't know the exact max sum and min sum can be reached, I can't create a real 2D dptable, I use the memorization search from top down. The cons of this solution is that if the len is too high, stackoverflow might happen.\\n\\n    class Solution {\\n    public:\\n        int combinationSum4(vector<int>& nums, int target,int len) {\\n        dptable[0][0]=1;\\n        //sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int l=0;l<=len;l++) sum+=dp(nums,target,l);\\n        return sum;\\n    }\\n\\n    int dp(vector<int>& nums,int target,int len){\\n        //first check if this has been searched before\\n        if(dptable.find(len)!=dptable.end() && dptable[len].find(target)!=dptable[len].end()){\\n            return dptable[len][target];\\n        }\\n        else{\\n            if(len==0){\\n                auto entry = dptable[0];\\n                if(entry.find(target)==entry.end()) entry[target]=0;\\n                return entry[target];\\n            }\\n            dptable[len][target]=0;\\n\\n            for(int num:nums){\\n                dptable[len][target]+= dp(nums,target-num,len-1);\\n                //cout<<dptable[len][target]<<endl;\\n            }\\n\\n            return dptable[len][target];\\n        }\\n\\n    }\\n    private:\\n    unordered_map<int,unordered_map<int,int>> dptable;\\n\\n    };\\n    int main() {\\n    std::cout << \"Hello, World!\" << std::endl;\\n    vector<int> nums{1,2,3,-1};\\n    Solution s;\\n    cout<< s.combinationSum4(nums,4,4);\\n    return 0;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public:\\n        int combinationSum4(vector<int>& nums, int target,int len) {\\n        dptable[0][0]=1;\\n        //sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int l=0;l<=len;l++) sum+=dp(nums,target,l);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 85129,
                "title": "my-0ms-c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int f[target + 1] = {0};\\n        f[0] = 1;\\n        for (int i = 0; i <= target; ++i) {\\n            if (f[i] == 0) {\\n                continue;\\n            }\\n            for (int j = 0; j < n; ++j) {\\n                int t = i + nums[j];\\n                if (t <= target) {\\n                    f[t] += f[i];\\n                }\\n            }\\n        }\\n        return f[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int f[target + 1] = {0};\\n        f[0] = 1;\\n        for (int i = 0; i <= target; ++i) {\\n            if (f[i] == 0) {\\n                continue;\\n            }\\n            for (int j = 0; j < n; ++j) {\\n                int t = i + nums[j];\\n                if (t <= target) {\\n                    f[t] += f[i];\\n                }\\n            }\\n        }\\n        return f[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022275,
                "title": "100-easy-to-understand-solution-using-dynamic-programming",
                "content": "# Intuition\\nwhile solving a problen using dynamic programming always try to figur out a relation between the answer to previous ittration and current position.\\n\\nfor example; \\nif nums = [1,2,3] and target = 4\\nways(4) = ways(4-1)+ways(4-2)+ways(4-3)\\n\\n# Approach\\nwill make an array dp of size **target+1** and initialise it with 0 and the 0th index with 1.\\n\\nnow for every **i**th element in dp we will sum upp the value of every **(i-nums[j])** element of array dp.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector< unsigned int> dp(target+1, 0);\\n        dp[0]=1;\\n        for(int i=1; i<=target; i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(i-nums[j]>=0){\\n                    dp[i]+=dp[i-nums[j]];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\\nDo up vote my solution if it helped you :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector< unsigned int> dp(target+1, 0);\\n        dp[0]=1;\\n        for(int i=1; i<=target; i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(i-nums[j]>=0){\\n                    dp[i]+=dp[i-nums[j]];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021376,
                "title": "100-java-dp-recursive-iterative-commented-code",
                "content": "# Kindly upvote if you find my solution helpful. \\uD83D\\uDE0A\\uD83D\\uDE0A\\n# Problem Description\\n- You are given an array of **distinct integers**, nums, and an integer **target**.\\n\\n- The **objective** is to determine the number of **possible combinations** that can be formed using elements from nums such that they add up to the given target.\\n\\n- Each element in nums can be **used multiple times in a combination**.\\n\\n- **Note** that [1,3] is a **different** solution than [3,1].\\n\\n- **Constraints:**\\n\\n1 <= nums.length <= 200\\n1 <= nums[i] <= 1000\\n1 <= target <= 1000\\nAll the elements of nums are unique.\\n\\n# Proposed Solutions\\n# 1. Recursive Approach (Top Down) \\n# Intuation\\nWe can think of Recursive Approach as **breaking** hard bricks into **small** rocks. but, how this apply to our problem ?\\nWe can **break** our **complex problem** into **easier** ones and instead of finding the number of combinations for out **large target** we can find the solution for **(target - num)**, since we only need to add num to this smaller number then a **part** of our solution for target number is the solution for **(target - num)**.\\n\\n**As an example**, if we have target = 3 and nums = [1, 2]\\nan obvious solution is equal to 3\\n(1, 1, 1) , (1, 2) , (2, 1)\\nlet\\'s start breaking, we can think of 3 as sum of:\\n\\n- (3 - 2) -> 1 which has 1 solution.\\n- (3 - 1) -> 2 which has 2 solutions.\\nthen 3 has total of 3 solutions.\\n\\n# Approach\\n1. Create an array **dp** to **cache** computed results for target values.\\n\\n2. Define a **recursive** function **countCombinations** that calculates combinations to reach a target sum:\\n\\n - **Base case**: If the target is 0, return 1.\\n - **Base case**: If the target is negative, return 0.\\n - **Check** if the result for the current remainingTarget is cached and **not equal to -1** ; if yes, return the cached result.\\n - Initialize **currentCombinations** to 0.\\n - **Iterate** through the numbers, recursively **calculate combinations** for the new target, and **add** them to currentCombinations.\\n - **Cache** the result in the dp array for the current remainingTarget and **return currentCombinations**.\\n3. In the **combinationSum4** function:\\n\\n - **Initialize** the dp array with **-1** for all possible target values.\\n - Begin the combination count calculation by calling countCombinations with the given nums and target.\\n# Complexity\\n- **Time complexity**: O(N\\u2217T)O(N * T)O(N\\u2217T)\\nSince, for each remaining number we have we try all the available numbers. so, time complexity is O(N * T) where N is length of nums and T is the value of target.\\n\\n- **Space complexity**: O(T)O(T)O(T)\\nWe store only the dp array which has size of target then space complexity is O(T) where T is the value of target.\\n\\n# 2. Iterative Approach (Bottom-Up)\\n# Intuation\\nWe can think of Iterative Approach as **building** high building from small bricks. but, how this also apply to our problem ?\\nWe can **solve** our **complex problem** by solving **easier** ones first and buil until we reach our complex problem and instead of finding the number of combinations for out **large target** we can **start** from 0 then 1 then 2 3 4 .... until we reach our large number.\\n\\n**As an example**, if we have target = 3 and nums = [1, 2]\\nthe solution is equal to 3\\n(1, 1, 1) , (1, 2) , (2, 1)\\nlet\\'s start building:\\n\\n - 0 -> one solution (empty)\\n - 1 -> one solution (by adding num=1 to 0) => (solution of 0)\\n - 2 -> two solutions (by adding num=1 to 1 / adding num=2 to 0) => (solution of 1 + solution of 0)\\n - 3 -> three solutions (by adding num=1 to 2 / adding num=2 to 1) => (solution of 2 + solution of 1)\\nthen 3 has total of 3 solutions.\\n\\n# Approach\\n1. **Initialize** a **vector dp** where dp[i] represents the number of combinations to make the sum \\'i\\'. **Set all values to 0 initially**.\\n\\n2. Set **dp[0] to 1** because there is **one way to make a sum of 0**, which is by not selecting any number.\\n\\n3. **Iterate** through the possible target sums from 1 to target:\\n\\n - For **each target** sum currentSum, iterate through the given numbers in nums.\\n - **Calculate currentNum** as the current number being considered from nums.\\n - **Check if subtracting currentNum** from currentSum results in a non-negative value.\\n - If yes, add the combination count at dp[currentSum - currentNum] to dp[currentSum]. This represents the number of combinations for the current sum using the current number.\\nThe final result, which represents the number of combinations to make the target sum, is stored in **dp[target]**.\\n\\n# Complexity\\n- **Time complexity**: *O(N\\u2217T)*\\nSince, for each number we reached have we try all the available numbers. so, time complexity is `O(N * T)` where `N` is `length` of nums and `T` is the value of `target`.\\n\\n\\n- **Space complexity**: *O(T)*\\nWe store only the `dp array` which has size of target then space complexity is `O(T)` where `T` is the value of `target`.\\n\\n# Code\\n# 1. Recursive Approach (Top-Down)\\n```\\npublic class Solution {\\n    private static final int MAX_TARGET = 1010; // Maximum possible target value\\n    private int[] dp = new int[MAX_TARGET]; // Array to store computed results\\n\\n    private int countCombinations(int[] nums, int remainingTarget) {\\n        // If the remaining target is 0, there\\'s one valid combination.\\n        if (remainingTarget == 0)\\n            return 1;\\n        \\n        // If the remaining target becomes negative, it\\'s not possible to reach it.\\n        if (remainingTarget < 0)\\n            return 0;\\n        \\n        // If the result for \\'remainingTarget\\' is already computed, return it.\\n        if (dp[remainingTarget] != -1)\\n            return dp[remainingTarget];\\n        \\n        int currentCombinations = 0;\\n        \\n        // Iterate through the numbers in \\'nums\\'.\\n        for (int i = 0; i < nums.length; i++) {\\n            int currentNum = nums[i];\\n            // Recursively calculate combinations for the new target.\\n            currentCombinations += countCombinations(nums, remainingTarget - currentNum);\\n        }\\n        \\n        // Store and return the computed result.\\n        return dp[remainingTarget] = currentCombinations;\\n    }\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        // Initialize the \\'dp\\' array with -1 to indicate uncomputed results.\\n        for (int i = 0; i < MAX_TARGET; i++) {\\n            dp[i] = -1;\\n        }\\n        \\n        // Start the combination count calculation.\\n        return countCombinations(nums, target);\\n    }\\n}\\n```\\n# 2. Iterative Approach (Bottom-Up)\\n```\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        // dp[i] represents the number of combinations to make sum \\'i\\'\\n        long[] dp = new long[target + 1];\\n        \\n        // There is one way to make sum 0, which is by not selecting any number.\\n        dp[0] = 1;\\n        \\n        for (int currentSum = 1; currentSum <= target; currentSum++) {\\n            for (int numIndex = 0; numIndex < nums.length; numIndex++) {\\n                int currentNum = nums[numIndex];\\n                if (currentSum - currentNum >= 0) {\\n                    // dp[i] can be achieved by adding the combination count at dp[i - currentNum]\\n                    dp[currentSum] += dp[currentSum - currentNum];\\n                }\\n            }\\n        }\\n        \\n        // The final result is stored in dp[target]\\n        return (int)dp[target];\\n    }\\n}\\n```\\n# Thank you.\\n![5f6aee89-454b-47ff-93c9-7030eb5d3673_1694227000.9068315.jpg](https://assets.leetcode.com/users/images/80cd82bb-5b62-4e2c-a9dc-4735f68d2e9c_1694246705.7644064.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    private static final int MAX_TARGET = 1010; // Maximum possible target value\\n    private int[] dp = new int[MAX_TARGET]; // Array to store computed results\\n\\n    private int countCombinations(int[] nums, int remainingTarget) {\\n        // If the remaining target is 0, there\\'s one valid combination.\\n        if (remainingTarget == 0)\\n            return 1;\\n        \\n        // If the remaining target becomes negative, it\\'s not possible to reach it.\\n        if (remainingTarget < 0)\\n            return 0;\\n        \\n        // If the result for \\'remainingTarget\\' is already computed, return it.\\n        if (dp[remainingTarget] != -1)\\n            return dp[remainingTarget];\\n        \\n        int currentCombinations = 0;\\n        \\n        // Iterate through the numbers in \\'nums\\'.\\n        for (int i = 0; i < nums.length; i++) {\\n            int currentNum = nums[i];\\n            // Recursively calculate combinations for the new target.\\n            currentCombinations += countCombinations(nums, remainingTarget - currentNum);\\n        }\\n        \\n        // Store and return the computed result.\\n        return dp[remainingTarget] = currentCombinations;\\n    }\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        // Initialize the \\'dp\\' array with -1 to indicate uncomputed results.\\n        for (int i = 0; i < MAX_TARGET; i++) {\\n            dp[i] = -1;\\n        }\\n        \\n        // Start the combination count calculation.\\n        return countCombinations(nums, target);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        // dp[i] represents the number of combinations to make sum \\'i\\'\\n        long[] dp = new long[target + 1];\\n        \\n        // There is one way to make sum 0, which is by not selecting any number.\\n        dp[0] = 1;\\n        \\n        for (int currentSum = 1; currentSum <= target; currentSum++) {\\n            for (int numIndex = 0; numIndex < nums.length; numIndex++) {\\n                int currentNum = nums[numIndex];\\n                if (currentSum - currentNum >= 0) {\\n                    // dp[i] can be achieved by adding the combination count at dp[i - currentNum]\\n                    dp[currentSum] += dp[currentSum - currentNum];\\n                }\\n            }\\n        }\\n        \\n        // The final result is stored in dp[target]\\n        return (int)dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020314,
                "title": "python-3-7-lines-recursion-t-s-97-100",
                "content": "```\\nclass Solution:\\n    def combinationSum4(self, nums: list[int], target: int) -> int:\\n    \\n        @lru_cache(None)\\n        def dp(target: int, res = 0)->int:\\n       \\n            for n in nums:\\n            \\n                if n == target: res+= 1\\n                if n <  target: res+= dp(target-n)\\n\\n            return res    \\n\\n        return  dp(target)\\n```\\n[https://leetcode.com/problems/combination-sum-iv/submissions/682887145/?envType=daily-question&envId=2023-09-09](http://)\\n\\nPython 3   ||   5 lines,  recursion   ||   T/S: 97% / 100%\\n\\nI could be wrong, but I think that time complexity is *O*(*T*) and space complexity is *O*(*T*), in which *T* ~ `target`. (However, based on how the caching goes, both could be worst-case  *O*(*NT*), in which *N* ~ `nums`.)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: list[int], target: int) -> int:\\n    \\n        @lru_cache(None)\\n        def dp(target: int, res = 0)->int:\\n       \\n            for n in nums:\\n            \\n                if n == target: res+= 1\\n                if n <  target: res+= dp(target-n)\\n\\n            return res    \\n\\n        return  dp(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020220,
                "title": "java-dp-6-lines-clean-code",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int combinationSum4(int[] nums, int target) {\\n    var dp = new int[target + 1];\\n    dp[0] = 1;\\n    \\n    for (var i=1; i <= target; i++)\\n      for (var num : nums)\\n        dp[i] += i - num >= 0 ? dp[i - num] : 0;\\n\\n    return dp[target];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  public int combinationSum4(int[] nums, int target) {\\n    var dp = new int[target + 1];\\n    dp[0] = 1;\\n    \\n    for (var i=1; i <= target; i++)\\n      for (var num : nums)\\n        dp[i] += i - num >= 0 ? dp[i - num] : 0;\\n\\n    return dp[target];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730456,
                "title": "easy-dp-solution-using-memoization",
                "content": "\\n\\n# Approach\\nThe function solve is a helper function that takes three parameters: nums (the input vector of numbers), target (the current target sum), and dp (a memoization array to store previously computed results).\\n\\nThe base cases of the recursion are handled as follows:\\n\\nIf the target sum becomes 0, it means we have found a valid combination that adds up to the target. So, the function returns 1.\\nIf the target sum becomes negative, it means the current combination exceeds the target. So, the function returns 0.\\nIf the dp array already contains a precomputed value for the current target, the function directly returns that value.\\nIf none of the base cases match, the function enters a loop to iterate over the numbers in the nums vector.\\n\\nFor each number nums[i], the function recursively calls solve with the updated target, target - nums[i], to find combinations that include nums[i].\\n\\nThe result of each recursive call is accumulated in the ans variable.\\n\\nFinally, the ans value is stored in the dp array at the index corresponding to the current target, dp[target] = ans, to avoid redundant calculations in future recursive calls.\\n\\nThe function returns the final result stored in dp[target].\\n\\nThe combinationSum4 function serves as the entry point to the solution. It initializes the dp array with -1 values and calls the solve function with the provided nums and target values.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(target)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(target) SIZE OF THE ARRAY USED \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums, int target , vector<int>& dp)\\n{\\n    if(target==0)\\n    return 1;\\n    if(target<0)\\n    return 0;\\n    if(dp[target]!=-1)\\n    return dp[target];\\n\\n    int ans =0;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        ans+=solve(nums,target-nums[i],dp);\\n    }\\n    dp[target]=ans;\\n    return dp[target];\\n\\n}\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int>dp(target+1,-1);\\n        return solve(nums,target,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums, int target , vector<int>& dp)\\n{\\n    if(target==0)\\n    return 1;\\n    if(target<0)\\n    return 0;\\n    if(dp[target]!=-1)\\n    return dp[target];\\n\\n    int ans =0;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        ans+=solve(nums,target-nums[i],dp);\\n    }\\n    dp[target]=ans;\\n    return dp[target];\\n\\n}\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int>dp(target+1,-1);\\n        return solve(nums,target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440200,
                "title": "dp-recursion-memoization-tabulation-solutions-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        // return helper(nums, target);\\n\\n        // int[] dp = new int[target+1];\\n        // Arrays.fill(dp, -1);\\n        // return helperMem(nums, target, dp);\\n\\n        return helperTab(nums, target);\\n    }\\n    // public int helper(int[] nums, int target){\\n    //     if(target < 0) return 0;\\n    //     if(target == 0) return 1;\\n    //     int ans = 0;\\n    //     for(int i = 0; i < nums.length; i++){\\n    //         ans += helper(nums, target - nums[i]);\\n    //     }\\n    //     return ans;\\n    // }\\n\\n    // public int helperMem(int[] nums, int target, int[] dp){\\n    //     if(target < 0) return 0;\\n    //     if(target == 0) return 1;\\n    //     if(dp[target] != -1) return dp[target];\\n    //     int ans = 0;\\n    //     for(int i = 0; i < nums.length; i++){\\n    //         ans += helperMem(nums, target - nums[i], dp);\\n    //     }\\n    //     return dp[target] = ans;\\n    // }\\n\\n    public int helperTab(int[] nums, int target){\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        //traversing from one to target\\n        for(int i = 1; i <= target; i++){\\n            //traversing on num vector\\n            for(int j = 0; j < nums.length; j++){\\n                if(i - nums[j] >= 0) dp[i] += dp[i - nums[j]];  \\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        // return helper(nums, target);\\n\\n        // int[] dp = new int[target+1];\\n        // Arrays.fill(dp, -1);\\n        // return helperMem(nums, target, dp);\\n\\n        return helperTab(nums, target);\\n    }\\n    // public int helper(int[] nums, int target){\\n    //     if(target < 0) return 0;\\n    //     if(target == 0) return 1;\\n    //     int ans = 0;\\n    //     for(int i = 0; i < nums.length; i++){\\n    //         ans += helper(nums, target - nums[i]);\\n    //     }\\n    //     return ans;\\n    // }\\n\\n    // public int helperMem(int[] nums, int target, int[] dp){\\n    //     if(target < 0) return 0;\\n    //     if(target == 0) return 1;\\n    //     if(dp[target] != -1) return dp[target];\\n    //     int ans = 0;\\n    //     for(int i = 0; i < nums.length; i++){\\n    //         ans += helperMem(nums, target - nums[i], dp);\\n    //     }\\n    //     return dp[target] = ans;\\n    // }\\n\\n    public int helperTab(int[] nums, int target){\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        //traversing from one to target\\n        for(int i = 1; i <= target; i++){\\n            //traversing on num vector\\n            for(int j = 0; j < nums.length; j++){\\n                if(i - nums[j] >= 0) dp[i] += dp[i - nums[j]];  \\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373713,
                "title": "recursive-1-d-dp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int helper(int target, vector< int > &nums, vector< int > &dp) {\\n        if(target == 0) return 1;\\n        if(dp[target] != -1) return dp[target];\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= target) {\\n                ans += helper(target - nums[i], nums, dp);\\n            }else break;\\n        }\\n        return dp[target] = ans;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector< int > dp(target+1, -1);\\n        return helper(target, nums, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int helper(int target, vector< int > &nums, vector< int > &dp) {\\n        if(target == 0) return 1;\\n        if(dp[target] != -1) return dp[target];\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= target) {\\n                ans += helper(target - nums[i], nums, dp);\\n            }else break;\\n        }\\n        return dp[target] = ans;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector< int > dp(target+1, -1);\\n        return helper(target, nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879247,
                "title": "c-dynamic-programming-unbounded-knapsack-100-faster",
                "content": "```\\nclass Solution {\\n   int check(vector<int>&nums,int target,vector<int>&dp,int n)\\n    {\\n        if(target==0)\\n            return 1;\\n       \\n       if(n==0||target<0)\\n           return 0;\\n       \\n        if(dp[target]!=-1)\\n            return dp[target];\\n        \\n      if(nums[n-1]<=target)\\n      {\\n          return dp[target]=check(nums,target-nums[n-1],dp,nums.size())+check(nums,target,dp,n-1);\\n      }\\n       else\\n       {\\n         return dp[target]=check(nums,target,dp,n-1);\\n       }\\n    }\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>dp(target+1,-1);\\n        return check(nums,target,dp,n);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n   int check(vector<int>&nums,int target,vector<int>&dp,int n)\\n    {\\n        if(target==0)\\n            return 1;\\n       \\n       if(n==0||target<0)\\n           return 0;\\n       \\n        if(dp[target]!=-1)\\n            return dp[target];\\n        \\n      if(nums[n-1]<=target)\\n      {\\n          return dp[target]=check(nums,target-nums[n-1],dp,nums.size())+check(nums,target,dp,n-1);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2545065,
                "title": "combination-sum-iv-v-s-coins-change-2-100-concept-clarity-clear-explaination",
                "content": "\\nClear Explaination alongwith helpful Links to refer to understand the difference\\n\\n\\nIn this problem, we are required to count the duplicate results. However, in coin change, 1 + 1 + 2 is the same with 1 + 2 + 1. The order of the for loop actually makes these two different problems.\\n\\nThis solution will not work because the recurrence relation will not allow elements at the same index to be considered over and over again. Something like this needs to be considered.\\n\\n    int notTake=combsum(nums, ind-1, t, dp), take=0;\\n    if(nums[ind]<=t)\\n         take = combsum(nums, ind, t-nums[ind], dp);\\n    return dp[ind][t]=notTake+take;\\nBut again, finding permutations here will be a tedious task.\\n\\n Approach- Why do we use 1D DP here?\\n1D dp works here because we are supposed to find the no of permutations and not combinations. So instead of going the traditional way, we have to find the same for each and every no less than the target. And then ultimately we can use it to find the required answer.\\n\\nIf you accidentally remember the code in Coin Change 2, you may find the solution to this problem is basically the same with that, except the order of for loop.\\n\\n```\\n\\n\\nclass Solution { // Coin Change 2\\n    public int change(int amount, int[] coins) {\\n        int[] dp = new int[amount + 1];\\n        dp[0] = 1;\\n        for (int coin : coins) {\\n            for (int i = 1; i <= amount; i++) {\\n                if (i >= coin) {\\n                    dp[i] += dp[i - coin];    \\n                }\\n            }\\n        }\\n        return dp[amount];\\n    }\\n}\\n\\nclass Solution { // this problem\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int n : nums) {\\n                if (i >= n) {\\n                    dp[i] += dp[i - n];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n\\n\\n```\\n\\nUsefull Links for Understanding 1D implementation -\\nhttps://leetcode.com/problems/combination-sum-iv/discuss/2383298/Easy-C%2B%2B-Solution-or-3-approaches-or-Recursion-%2B-DP\\n\\nTo Understand Overflow Issue https://leetcode.com/problems/combination-sum-iv/discuss/2122873/C%2B%2B-Overflow-Issue-Explained\\n\\n\\n```\\nRECURSION :(NOT ACCEPTED)\\n\\nclass Solution {\\npublic:\\n    int noOfWays(vector<int> &nums, int target, int index, int size)\\n    {\\n        if(target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        int ways = 0;   //NO. OF WAYS IN WHICH WE CAN FIND THE TARGET.\\n        for(int i = 0; i<size; i++)\\n        {\\n            ways += noOfWays(nums, target - nums[i], i, size);\\n        }\\n        return ways;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        return noOfWays(nums, target, 0, nums.size());\\n    }\\n};\\nRECURSION + MEMOIZATION :\\n\\nclass Solution {\\npublic:\\n    int noOfWays(vector<int> &nums, int target, int size, vector<int> &dp)\\n    {\\n        if(target < 0) return 0; \\n        if(target == 0) return 1;\\n        if(dp[target] != -1) return dp[target]; //IF WE ALREADY CALCULATED THE TARGET\\n        \\n        int ways = 0;   //NO. OF WAYS IN WHICH WE CAN FIND THE TARGET.\\n        for(int i = 0; i<size; i++)\\n        {\\n            ways += noOfWays(nums, target - nums[i], size, dp);\\n        }\\n        dp[target] = ways;  //BEFORE RETURNING STORE THE WAYS IN THE dp[];\\n        return ways;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp (target+1, -1); //STORE THE NO OF WAYS IN WHICH WE GET ith INDEX SUM;\\n        return noOfWays(nums, target, nums.size(), dp);\\n    }\\n};\\nTABULATION :\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp (target+1, 0); //STORE THE NO OF WAYS IN WHICH WE GET ith INDEX SUM;\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++)\\n        {\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(i - nums[j] >= 0) //IF INDEX IS PRESENT i.e. INDEX SHOULD BE GREATER THAN OR EQUAL TO 0.\\n                    dp[i] += dp[i - nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\\n\\nThank You.\\nDo Please Upvote.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nclass Solution { // Coin Change 2\\n    public int change(int amount, int[] coins) {\\n        int[] dp = new int[amount + 1];\\n        dp[0] = 1;\\n        for (int coin : coins) {\\n            for (int i = 1; i <= amount; i++) {\\n                if (i >= coin) {\\n                    dp[i] += dp[i - coin];    \\n                }\\n            }\\n        }\\n        return dp[amount];\\n    }\\n}\\n\\nclass Solution { // this problem\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int n : nums) {\\n                if (i >= n) {\\n                    dp[i] += dp[i - n];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n\\n\\n```\n```\\nRECURSION :(NOT ACCEPTED)\\n\\nclass Solution {\\npublic:\\n    int noOfWays(vector<int> &nums, int target, int index, int size)\\n    {\\n        if(target < 0) return 0;\\n        if(target == 0) return 1;\\n        \\n        int ways = 0;   //NO. OF WAYS IN WHICH WE CAN FIND THE TARGET.\\n        for(int i = 0; i<size; i++)\\n        {\\n            ways += noOfWays(nums, target - nums[i], i, size);\\n        }\\n        return ways;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        return noOfWays(nums, target, 0, nums.size());\\n    }\\n};\\nRECURSION + MEMOIZATION :\\n\\nclass Solution {\\npublic:\\n    int noOfWays(vector<int> &nums, int target, int size, vector<int> &dp)\\n    {\\n        if(target < 0) return 0; \\n        if(target == 0) return 1;\\n        if(dp[target] != -1) return dp[target]; //IF WE ALREADY CALCULATED THE TARGET\\n        \\n        int ways = 0;   //NO. OF WAYS IN WHICH WE CAN FIND THE TARGET.\\n        for(int i = 0; i<size; i++)\\n        {\\n            ways += noOfWays(nums, target - nums[i], size, dp);\\n        }\\n        dp[target] = ways;  //BEFORE RETURNING STORE THE WAYS IN THE dp[];\\n        return ways;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp (target+1, -1); //STORE THE NO OF WAYS IN WHICH WE GET ith INDEX SUM;\\n        return noOfWays(nums, target, nums.size(), dp);\\n    }\\n};\\nTABULATION :\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        \\n        vector<int> dp (target+1, 0); //STORE THE NO OF WAYS IN WHICH WE GET ith INDEX SUM;\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++)\\n        {\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(i - nums[j] >= 0) //IF INDEX IS PRESENT i.e. INDEX SHOULD BE GREATER THAN OR EQUAL TO 0.\\n                    dp[i] += dp[i - nums[j]];\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436993,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7 ;\\n    int dp[201][1001] ;\\n    vector<int>nums ;\\n    int solve(int pos , int target){\\n        if(target < 0) return 0 ;\\n        if(pos >= nums.size()) return !target ? 1 : 0 ;\\n        if(dp[pos][target] != -1) return dp[pos][target] ;\\n        \\n        int ans = 0 ;\\n        ans += solve(0,target-nums[pos]) ;\\n        ans += solve(pos + 1 , target) ;\\n        \\n        return dp[pos][target] = ans ;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        this->nums = nums ;\\n        return solve(0,target) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7 ;\\n    int dp[201][1001] ;\\n    vector<int>nums ;\\n    int solve(int pos , int target){\\n        if(target < 0) return 0 ;\\n        if(pos >= nums.size()) return !target ? 1 : 0 ;\\n        if(dp[pos][target] != -1) return dp[pos][target] ;\\n        \\n        int ans = 0 ;\\n        ans += solve(0,target-nums[pos]) ;\\n        ans += solve(pos + 1 , target) ;\\n        \\n        return dp[pos][target] = ans ;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        this->nums = nums ;\\n        return solve(0,target) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386080,
                "title": "combinationsum4-using-dp-and-recursion-faster-than-92-94-of-java-online-submissions",
                "content": "```\\n\\n\\nclass Solution {\\n    public int result(int target,int nums[], Integer res[]){\\n        \\n        if(target == 0){\\n            return 1;\\n        }\\n        \\n        if(target <0){\\n            return 0;\\n        }\\n        if(res[target] != null)\\n            return res[target];\\n        int count = 0;\\n        for(int i =0;i<nums.length;i++){\\n            count+= result(target - nums[i],nums,res);\\n        }\\n        return res[target] = count;\\n        \\n        \\n        \\n    }\\n    public int combinationSum4(int[] nums, int target) {\\n        Integer[] res = new Integer[target+1];\\n        return result(target,nums, res);\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int result(int target,int nums[], Integer res[]){\\n        \\n        if(target == 0){\\n            return 1;\\n        }\\n        \\n        if(target <0){\\n            return 0;\\n        }\\n        if(res[target] != null)\\n            return res[target];\\n        int count = 0;\\n        for(int i =0;i<nums.length;i++){\\n            count+= result(target - nums[i],nums,res);\\n        }\\n        return res[target] = count;\\n        \\n        \\n        \\n    }\\n    public int combinationSum4(int[] nums, int target) {\\n        Integer[] res = new Integer[target+1];\\n        return result(target,nums, res);\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382190,
                "title": "beats-100-other-s-solutions-16ms",
                "content": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        \\n        if not nums or target <= 0:\\n            return 0\\n\\n        ans = 0\\n        memo = dict()\\n        def bt(rem):\\n            if rem == 0:\\n                return 1\\n            if rem in memo:\\n                return memo[rem]\\n            count = 0\\n            for num in nums:\\n                if num <= rem:\\n                    this_count = bt(rem-num)\\n                    count += this_count\\n            memo[rem] = count\\n            return count\\n        \\n        return bt(target)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        \\n        if not nums or target <= 0:\\n            return 0\\n\\n        ans = 0\\n        memo = dict()\\n        def bt(rem):\\n            if rem == 0:\\n                return 1\\n            if rem in memo:\\n                return memo[rem]\\n            count = 0\\n            for num in nums:\\n                if num <= rem:\\n                    this_count = bt(rem-num)\\n                    count += this_count\\n            memo[rem] = count\\n            return count\\n        \\n        return bt(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381253,
                "title": "python-simple-dp-solution",
                "content": "With this problem, we can easily imagine breaking up the solution into smaller pieces that we can use as stepping stones towards the overall answer. For example, if we\\'re searching for a way to get from 0 to our target number (T), and if 0 < x < y < T, then we can see that finding out how many ways we can get from y to T will help us figure out how many ways we can get from x to T, all the way down to 0 to T. This is a classic example of a top-down (memoization) dyanamic programming (DP) solution.\\n\\nTop-Down DP Approach: Our DP array (dp) will contain cells (dp[i]) where i will represent the remaining space left before T and dp[i] will represent the number of ways the solution (dp[T]) can be reached from i.\\nAt each value of i as we build out dp we\\'ll iterate through the different nums in our number array (N) and consider the cell that can be reached with each num (dp[i-num]). The value of dp[i] will therefore be the sum of the results of each of those possible moves.\\nWe\\'ll need to seed dp[0] with a value of 1 to represent the value of the completed combination, then once the iteration is complete, we can return dp[T] as our final answer.\\n\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp=[0]*(target+1)\\n        dp[0]=1\\n        for i in range(1,target+1):\\n            for num in nums:\\n                if num<=i:\\n                    dp[i]+=dp[i-num]\\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "With this problem, we can easily imagine breaking up the solution into smaller pieces that we can use as stepping stones towards the overall answer. For example, if we\\'re searching for a way to get from 0 to our target number (T), and if 0 < x < y < T, then we can see that finding out how many ways we can get from y to T will help us figure out how many ways we can get from x to T, all the way down to 0 to T. This is a classic example of a top-down (memoization) dyanamic programming (DP) solution.\\n\\nTop-Down DP Approach: Our DP array (dp) will contain cells (dp[i]) where i will represent the remaining space left before T and dp[i] will represent the number of ways the solution (dp[T]) can be reached from i.\\nAt each value of i as we build out dp we\\'ll iterate through the different nums in our number array (N) and consider the cell that can be reached with each num (dp[i-num]). The value of dp[i] will therefore be the sum of the results of each of those possible moves.\\nWe\\'ll need to seed dp[0] with a value of 1 to represent the value of the completed combination, then once the iteration is complete, we can return dp[T] as our final answer.\\n\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp=[0]*(target+1)\\n        dp[0]=1\\n        for i in range(1,target+1):\\n            for num in nums:\\n                if num<=i:\\n                    dp[i]+=dp[i-num]\\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 2349172,
                "title": "100-faster-solution-dp-c",
                "content": "**AP UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int t) {\\n        vector<long long> a(t+1,0);\\n        a[0]=1;\\n        for(int i=0;i<=t;i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]>i) continue;\\n                a[i]=(a[i]+a[i-nums[j]])%2000000006;\\n                \\n            }\\n        }return a[t];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int t) {\\n        vector<long long> a(t+1,0);\\n        a[0]=1;\\n        for(int i=0;i<=t;i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]>i) continue;\\n                a[i]=(a[i]+a[i-nums[j]])%2000000006;\\n                \\n            }\\n        }return a[t];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951928,
                "title": "c-recursion-memoization-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int recur(vector<int>&nums,int idx,int target){\\n        if(target == 0){\\n            return 1;\\n        }\\n        if(idx == -1){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][target] != -1){\\n            return dp[idx][target];\\n        }\\n        \\n        // Left the element at idx\\n        int ans = recur(nums,idx-1,target);\\n        \\n        // we took the element at idx & recur again\\n        // for all the numbers again, thus passing the idx of last element\\n        if(target >= nums[idx]){\\n            ans += recur(nums,nums.size()-1,target-nums[idx]);\\n        }\\n        \\n        return dp[idx][target] = ans;\\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n     \\n        int n = nums.size();\\n        dp.resize(n,vector<int>(target+1,-1));\\n        \\n        return recur(nums,n-1,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int recur(vector<int>&nums,int idx,int target){\\n        if(target == 0){\\n            return 1;\\n        }\\n        if(idx == -1){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][target] != -1){\\n            return dp[idx][target];\\n        }\\n        \\n        // Left the element at idx\\n        int ans = recur(nums,idx-1,target);\\n        \\n        // we took the element at idx & recur again\\n        // for all the numbers again, thus passing the idx of last element\\n        if(target >= nums[idx]){\\n            ans += recur(nums,nums.size()-1,target-nums[idx]);\\n        }\\n        \\n        return dp[idx][target] = ans;\\n    }\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n     \\n        int n = nums.size();\\n        dp.resize(n,vector<int>(target+1,-1));\\n        \\n        return recur(nums,n-1,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899151,
                "title": "c-dp-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n\\t//a test case had a problem with an intermediate value (not final total)\\n\\t//overflowing int and long long -- but unsigned long long works\\n        vector<unsigned long long> ways(target+1, 0); \\n        ways[0] = 1;\\n        for(int i = 1; i < ways.size(); i++){\\n            for(int j = 0; j < nums.size(); j++){\\n                int val = nums[j];\\n                if(val <= i)\\n                    ways[i] += ways[i-val];\\n            }\\n        }\\n        return (int)ways[target]; //The Answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n\\t//a test case had a problem with an intermediate value (not final total)\\n\\t//overflowing int and long long -- but unsigned long long works\\n        vector<unsigned long long> ways(target+1, 0); \\n        ways[0] = 1;\\n        for(int i = 1; i < ways.size(); i++){\\n            for(int j = 0; j < nums.size(); j++){\\n                int val = nums[j];\\n                if(val <= i)\\n                    ways[i] += ways[i-val];\\n            }\\n        }\\n        return (int)ways[target]; //The Answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857609,
                "title": "with-memoization-tree-visualization-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\n    int solve(vector<int> &nums, int target, vector<int> &memo)\\n    {\\n        if (target == 0)\\n        {\\n            return 1;\\n        }\\n        if (target < 0)\\n        {\\n            return 0;\\n        }\\n\\n        if (memo[target] != -1)\\n        {\\n            return memo[target];\\n        }\\n\\n        int ans = 0;\\n\\n        for (int &num : nums)\\n        {\\n            ans += solve(nums, target - num, memo);\\n        }\\n\\n        return memo[target] = ans;\\n    }\\n    int combinationSum4(vector<int> &nums, int target)\\n    {\\n        vector<int> memo(target + 1, -1);\\n        return solve(nums, target, memo);\\n    }\\n};\\n\\n```\\ntree visualization \\nhttps://drive.google.com/file/d/1kHOQf8P1wf02zvEMtRSjvlzfeN7q5Az1/view?usp=sharing\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\n    int solve(vector<int> &nums, int target, vector<int> &memo)\\n    {\\n        if (target == 0)\\n        {\\n            return 1;\\n        }\\n        if (target < 0)\\n        {\\n            return 0;\\n        }\\n\\n        if (memo[target] != -1)\\n        {\\n            return memo[target];\\n        }\\n\\n        int ans = 0;\\n\\n        for (int &num : nums)\\n        {\\n            ans += solve(nums, target - num, memo);\\n        }\\n\\n        return memo[target] = ans;\\n    }\\n    int combinationSum4(vector<int> &nums, int target)\\n    {\\n        vector<int> memo(target + 1, -1);\\n        return solve(nums, target, memo);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575263,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int dp[] = new int[target+1];\\n        dp[0] = 1;\\n        for(int i=1; i<dp.length; i++){\\n            for(int num: nums){\\n                if(num <= i)    dp[i] += dp[i-num];\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar combinationSum4 = function(nums, target) {\\n    let dp = Array(target+1).fill(0)\\n    dp[0] = 1\\n    for (let i = 1; i <= target; i++){\\n        for (let num of nums){\\n            if (num <= i) dp[i] += dp[i-num]\\n        }\\n    }\\n    return dp[target]\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def combinationSum4(self, nums, target):\\n        dp = [0]*(target+1)\\n        dp[0] = 1\\n        for i in range(target+1):\\n            for num in nums:\\n                if num <= i:\\n                    dp[i] += dp[i-num]\\n        return dp[target]\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int dp[] = new int[target+1];\\n        dp[0] = 1;\\n        for(int i=1; i<dp.length; i++){\\n            for(int num: nums){\\n                if(num <= i)    dp[i] += dp[i-num];\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```\n```\\nvar combinationSum4 = function(nums, target) {\\n    let dp = Array(target+1).fill(0)\\n    dp[0] = 1\\n    for (let i = 1; i <= target; i++){\\n        for (let num of nums){\\n            if (num <= i) dp[i] += dp[i-num]\\n        }\\n    }\\n    return dp[target]\\n};\\n```\n```\\nclass Solution(object):\\n    def combinationSum4(self, nums, target):\\n        dp = [0]*(target+1)\\n        dp[0] = 1\\n        for i in range(target+1):\\n            for num in nums:\\n                if num <= i:\\n                    dp[i] += dp[i-num]\\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272869,
                "title": "python-3-faster-than-96-super-simple",
                "content": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        waysToAdd = [0 for x in range(target+1)]\\n        waysToAdd[0] = 1\\n        \\n        for i in range(min(nums), target+1):\\n            waysToAdd[i] = sum(waysToAdd[i-num] for num in nums if i-num >= 0)\\n        \\n        return waysToAdd[-1]\\n            \\n        \\n```\\n\\nThink of it inductively. The intuition behind the solution is to assume that for any given number \\'i\\', we\\'ve got the number of permutations for all preceding numbers. The only way we can add up to \\'i\\' is from (i - num) for each num in nums. \\n\\nE.g. if i = 12 and nums = [1,2,4], then we have these possibilities:\\n(insert all the ways to sum to 12-1=11 here) + 1\\n(insert all the ways to sum to 12-2=10 here) + 2\\n(insert all the ways to sum to 12-4=8 here) + 4\\n\\nSo how many permutations will there be for i = 12? It\\'s the # of ways to add to 11, to add to 10, and to add to 8.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        waysToAdd = [0 for x in range(target+1)]\\n        waysToAdd[0] = 1\\n        \\n        for i in range(min(nums), target+1):\\n            waysToAdd[i] = sum(waysToAdd[i-num] for num in nums if i-num >= 0)\\n        \\n        return waysToAdd[-1]\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261618,
                "title": "combination-sum-i-ii-iii-iv-c-with-same-approach",
                "content": "**Combination Sum**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n         vector<vector<int>>res;\\n         sort(candidates.begin(),candidates.end());\\n        vector<int>v;\\n        helper(res,candidates,0,v,target);\\n        return res;\\n    }\\n    \\n      void helper( vector<vector<int>> &res ,vector<int>& cand,int start,\\n               vector<int>&v , int target){   \\n        if(target==0)res.push_back(v);\\n        else if(target>0){\\n            for(int i=start;i<cand.size();i++){\\n                if(target-cand[i]<0) break;\\n                v.push_back(cand[i]);\\n                helper(res,cand,i,v,target-cand[i]);\\n                v.pop_back();\\n            }\\n        }\\n        \\n        return ;\\n    }\\n};\\n```\\n\\n**Combination Sum II**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n         vector<vector<int>>res;\\n         sort(candidates.begin(),candidates.end());\\n        vector<int>v;\\n        helper(res,candidates,0,v,target);\\n        return res;\\n    }\\n    \\n    void helper( vector<vector<int>> &res ,vector<int>& cand,int start,\\n               vector<int>&v , int target){\\n        \\n        if(target==0)res.push_back(v);\\n        else if(target>0){\\n            \\n            for(int i=start;i<cand.size();i++){\\n                if(i!=start&&cand[i]==cand[i-1]) continue;  \\n                // 1 1 2 5 target =8 (1,2,5) needed only\\n                if(target-cand[i]<0) break;\\n                v.push_back(cand[i]);\\n                helper(res,cand,i+1,v,target-cand[i]);\\n                v.pop_back();\\n            }\\n        }\\n        \\n        return ;\\n    }\\n};\\n```\\n\\n**Combination Sum |||**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>>res;\\n        vector<int>v;\\n        helper(res,v,k,n,1);\\n        return res;\\n    }\\n    \\n    void helper(vector<vector<int>>& res , vector<int>&v , int k , int n , int start){\\n        if(n==0&&k==0){\\n            res.push_back(v);\\n        }else if(n>0&&k>0){\\n            for(int i=start;i<=9;i++){\\n                if(n-i<0) break;\\n                v.push_back(i);\\n                helper(res,v,k-1,n-i,i+1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    \\n};\\n```\\n\\n**Combination Sum IV**\\n```\\nclass Solution {\\npublic:\\n      unordered_map<int,int>dp;\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n         sort(nums.begin(),nums.end());\\n        // dp[0]=1;\\n         return helper(nums,target);\\n    }\\n    \\n    int helper( vector<int>& nums,int target){\\n        if(dp.count(target)) return dp[target];\\n        int ans=0;\\n        if(target==0) return 1;\\n        else if(target>0){\\n            for(int i=0;i<nums.size();i++){\\n                if(target-nums[i]<0) break;\\n                int cnt=helper(nums,target-nums[i]);\\n                ans+=cnt;\\n            }\\n             return dp[target]=ans;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\n \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n         vector<vector<int>>res;\\n         sort(candidates.begin(),candidates.end());\\n        vector<int>v;\\n        helper(res,candidates,0,v,target);\\n        return res;\\n    }\\n    \\n      void helper( vector<vector<int>> &res ,vector<int>& cand,int start,\\n               vector<int>&v , int target){   \\n        if(target==0)res.push_back(v);\\n        else if(target>0){\\n            for(int i=start;i<cand.size();i++){\\n                if(target-cand[i]<0) break;\\n                v.push_back(cand[i]);\\n                helper(res,cand,i,v,target-cand[i]);\\n                v.pop_back();\\n            }\\n        }\\n        \\n        return ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n         vector<vector<int>>res;\\n         sort(candidates.begin(),candidates.end());\\n        vector<int>v;\\n        helper(res,candidates,0,v,target);\\n        return res;\\n    }\\n    \\n    void helper( vector<vector<int>> &res ,vector<int>& cand,int start,\\n               vector<int>&v , int target){\\n        \\n        if(target==0)res.push_back(v);\\n        else if(target>0){\\n            \\n            for(int i=start;i<cand.size();i++){\\n                if(i!=start&&cand[i]==cand[i-1]) continue;  \\n                // 1 1 2 5 target =8 (1,2,5) needed only\\n                if(target-cand[i]<0) break;\\n                v.push_back(cand[i]);\\n                helper(res,cand,i+1,v,target-cand[i]);\\n                v.pop_back();\\n            }\\n        }\\n        \\n        return ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>>res;\\n        vector<int>v;\\n        helper(res,v,k,n,1);\\n        return res;\\n    }\\n    \\n    void helper(vector<vector<int>>& res , vector<int>&v , int k , int n , int start){\\n        if(n==0&&k==0){\\n            res.push_back(v);\\n        }else if(n>0&&k>0){\\n            for(int i=start;i<=9;i++){\\n                if(n-i<0) break;\\n                v.push_back(i);\\n                helper(res,v,k-1,n-i,i+1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n      unordered_map<int,int>dp;\\n    \\n    int combinationSum4(vector<int>& nums, int target) {\\n         sort(nums.begin(),nums.end());\\n        // dp[0]=1;\\n         return helper(nums,target);\\n    }\\n    \\n    int helper( vector<int>& nums,int target){\\n        if(dp.count(target)) return dp[target];\\n        int ans=0;\\n        if(target==0) return 1;\\n        else if(target>0){\\n            for(int i=0;i<nums.size();i++){\\n                if(target-nums[i]<0) break;\\n                int cnt=helper(nums,target-nums[i]);\\n                ans+=cnt;\\n            }\\n             return dp[target]=ans;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229985,
                "title": "python-backtracking-memoization",
                "content": "```\\n@cache\\ndef backTracking(target):\\n\\n\\tif target <= 0:\\n\\t\\tif target == 0:\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\n\\n\\tres = 0\\n\\tfor i in range(len(nums)):\\n\\t\\tif target - nums[i] >= 0:\\n\\t\\t\\tres += backTracking(target - nums[i])\\n\\n\\treturn res\\n\\nreturn backTracking(target)\\n```",
                "solutionTags": [],
                "code": "```\\n@cache\\ndef backTracking(target):\\n\\n\\tif target <= 0:\\n\\t\\tif target == 0:\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\n\\n\\tres = 0\\n\\tfor i in range(len(nums)):\\n\\t\\tif target - nums[i] >= 0:\\n\\t\\t\\tres += backTracking(target - nums[i])\\n\\n\\treturn res\\n\\nreturn backTracking(target)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1190211,
                "title": "python-3-recursive-with-array-hashmap-iterative-derived-illustrated",
                "content": "Let\\'s start with recursion.\\n**Derive the state space tree:**\\nIllustraion of the example nums, target = [1, 2, 3], 4. The basic idea is to do the DFS. Below tree draws 2 possibles: 4-3-2-1-0, and 4-3-2-0.\\n```\\n                                                4\\n                           -1/                -2|                \\\\-3\\n                           3\\n                  -1/     -2|      \\\\-3\\n                  2\\n          -1/   -2|      \\\\-3\\n          1       0       -1\\n    -1/ -2|  \\\\-3\\n     0   -1   -2\\n```\\n\\n\\n**Attempt #1**: Recursion with memorization using array\\nResult: \\nRuntime: 44 ms\\nMemory Usage: 14.6 MB\\n~~~\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        def helper(t, memo): # Base case\\n            if t == 0:\\n                return 1\\n            if memo[t] != -float(\"inf\"): # memorization kicks in\\n                return memo[t]\\n            else:\\n                res = 0\\n                for i in range(len(nums)):\\n                    if t - nums[i] >= 0: # discard the negative states\\n                        res += helper(t - nums[i], memo)\\n                memo[t] = res # memorize the total number off this branch\\n                return memo[t]\\n\\n        memo = [-float(\"inf\") for _ in range(target+1)]\\n        memo[0] = 1\\n        return helper(target, memo)\\n~~~\\n\\n**Attempt #2**: Recursion with memorization using dictionary\\nResult:\\nRuntime: 40 ms\\nMemory Usage: 14.2 MB\\n~~~\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        def helper(t, memo):\\n            if t == 0: # Base case\\n                return 1\\n            if t in memo: # memorization kicks in\\n                return memo[t]\\n            else:\\n                res = 0\\n                for i in range(len(nums)):\\n                    if t - nums[i] >= 0: # discard the negative states\\n                        res += helper(t - nums[i], memo)\\n                memo[t] = res\\n                return memo[t]\\n\\n        memo = {}\\n        return helper(target, memo)\\n~~~\\n\\n\\nThen we move on to DP iteration.\\n**Derive the DP formula:**\\nIllustraion of the example nums, target = [1, 2, 3], 4\\n```\\nPatterns:\\ndp[0] = 1 # indicating there is 1 way to have target = 0, and 1 way is to not use any of the numbers in the nums array.\\ndp[1] = dp[0]\\ndp[2] = dp[1] + dp[0]\\ndp[3] = dp[2] + dp[1] + dp[0]\\ndp[4] = dp[3] + dp[2] + dp[1]\\nFormula:\\ndp[i] = sum(dp[i-j]) where i is the current target, and j is in range(nums)\\n```\\n\\n\\n**Attempt #3**: DP iteratively\\nResult: \\nRuntime: 36 ms\\nMemory Usage: 14.1 MB\\n~~~\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        dp = [0]*(target+1)\\n        dp[0] = 1\\n        for i in range(1, target+1):\\n            for x in nums:\\n                if x <= i: # discard the negative states\\n                    dp[i] += dp[i-x]\\n        return dp[target]\\n~~~\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n                                                4\\n                           -1/                -2|                \\\\-3\\n                           3\\n                  -1/     -2|      \\\\-3\\n                  2\\n          -1/   -2|      \\\\-3\\n          1       0       -1\\n    -1/ -2|  \\\\-3\\n     0   -1   -2\\n```\n```\\nPatterns:\\ndp[0] = 1 # indicating there is 1 way to have target = 0, and 1 way is to not use any of the numbers in the nums array.\\ndp[1] = dp[0]\\ndp[2] = dp[1] + dp[0]\\ndp[3] = dp[2] + dp[1] + dp[0]\\ndp[4] = dp[3] + dp[2] + dp[1]\\nFormula:\\ndp[i] = sum(dp[i-j]) where i is the current target, and j is in range(nums)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167507,
                "title": "java-simple-and-easy-to-understand-solution-bottom-up-approach-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n\\n    \\n    public int combinationSum4(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        \\n\\n        int[] cache = new int[target + 1];\\n        cache[0] = 1;\\n\\n        //bottom up approach\\n        \\n        //solve for each sum\\n        //start with 1 to target\\n        for(int currTargetSum = 1; currTargetSum <= target; currTargetSum++){\\n            \\n            //append all the permuataion count for this current target sum\\n            for(int num : nums){\\n                \\n                int remainingSum  = currTargetSum - num;\\n                \\n                //as nums in sorted in increasing order,\\n                //remainging sum will be more -ve\\n                if(remainingSum < 0) break;\\n                \\n                cache[currTargetSum] += cache[remainingSum];\\n            }\\n            \\n        }\\n        \\n        return cache[target];\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    \\n    public int combinationSum4(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        \\n\\n        int[] cache = new int[target + 1];\\n        cache[0] = 1;\\n\\n        //bottom up approach\\n        \\n        //solve for each sum\\n        //start with 1 to target\\n        for(int currTargetSum = 1; currTargetSum <= target; currTargetSum++){\\n            \\n            //append all the permuataion count for this current target sum\\n            for(int num : nums){\\n                \\n                int remainingSum  = currTargetSum - num;\\n                \\n                //as nums in sorted in increasing order,\\n                //remainging sum will be more -ve\\n                if(remainingSum < 0) break;\\n                \\n                cache[currTargetSum] += cache[remainingSum];\\n            }\\n            \\n        }\\n        \\n        return cache[target];\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166541,
                "title": "c-the-reason-of-long-long-gets-re-while-unsigned-int-gets-ac",
                "content": "**The following discussion is based on the bottom-up method, and I suppose memoization may not have this problem.**\\n\\nI try to figure out why data type `long long` gets RE while `unsigned int` gets AC.\\nWell, actually the test cases provided still have the overflow issue on some elements, and the reason that we gets AC is just because the `target` does not need these overflow elements. Following is my test code,\\n\\n``` C++\\n#ifdef LL\\n  #define type long long\\n#else\\n  #ifdef UI\\n    #define type unsigned int\\n  #else\\n    #define type int\\n  #endif\\n#endif\\n\\nint combinationSum4(vector<int>& nums, int target) {\\n  vector<type> dp(target + 1);\\n  dp[0] = 1;\\n  for (int i = 1; i <= target; ++i) {\\n    for (auto n : nums)\\n      if (i - n >= 0) {\\n        if (dp[i] + dp[i - n] < dp[i])\\n          cerr << \"of @ \" << dp[i] << \" + \" << dp[i - n] << \" = \" << dp[i] + dp[i - n] << endl;\\n        dp[i] += dp[i - n];\\n      }\\n  }\\n  return dp[target];\\n}\\n\\nint main() {\\n  // Case I, 1\\n  vector<int> nums;\\n  for (int i = 10; i <= 990; i += 10)\\n    nums.push_back(i);\\n  nums.push_back(111);\\n  cout << \"Case I: \" << combinationSum4(nums, 999) << endl;\\n\\n  // Case II, 0\\n  vector<int> nums2({3, 33, 333});\\n  cout << \"Case II: \" << combinationSum4(nums2, 1000) << endl;\\n}\\n```\\nIn both Case I and Case II, the answer is simple but we still gets several overflows before reaching the answer. Since the problem states **\"The answer is guaranteed to fit in a 32-bit integer\"**, we can still get correct answer by using bottom-up method.\\n\\nBack to my original question, first we know that there may exist several overflow elements. The judge system detects **signed integer overflow** them via `UndefinedBehaviorSanitizer` in `clang++` (see [here](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)).\\n\\nTry to compile the above program by\\n1. `g++`\\n\\t``` bash\\n\\t$ g++ test.cc && ./a.out       # no runtime error\\n\\t$ g++ -DLL test.cc && ./a.out  # no runtime error\\n\\t$ g++ -DUI test.cc && ./a.out  # no runtime error\\n\\t```\\n2. `clang++` without `UndefinedBehaviorSanitizer`\\n    ``` bash\\n\\t$ clang++ test.cc && ./a.out       # no runtime error\\n\\t$ clang++ -DLL test.cc && ./a.out  # no runtime error\\n\\t$ clang++ -DUI test.cc && ./a.out  # no runtime error\\n\\t```\\n3. `clang++` with `fsanitize=signed-integer-overflow` option\\n    ``` bash\\n\\t$ clang++ -fsanitize=signed-integer-overflow test.cc && ./a.out\\n\\truntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\t$ clang++ -fsanitize=signed-integer-overflow -DLL test.cc && ./a.out\\n\\truntime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long\\'\\n\\t$ clang++ -fsanitize=signed-integer-overflow -DUI test.cc && ./a.out  # no runtime error\\n\\t```\\n\\t> -fsanitize=signed-integer-overflow: Signed integer overflow, where the result of a signed integer computation cannot be represented in its type. This includes all the checks covered by -ftrapv, as well as checks for signed division overflow (INT_MIN/-1), but not checks for lossy implicit conversions performed before the computation (see -fsanitize=implicit-conversion). Both of these two issues are handled by -fsanitize=implicit-conversion group of checks.\\n4. `clang++` with `-fsanitize=unsigned-integer-overflow` option\\n    ``` bash\\n\\t$ clang++ -fsanitize=unsigned-integer-overflow test.cc && ./a.out       # no runtime error\\n\\t$ clang++ -fsanitize=unsigned-integer-overflow -DLL test.cc && ./a.out  # no runtime error\\n\\t$ clang++ -fsanitize=unsigned-integer-overflow -DUI test.cc && ./a.out\\n\\truntime error: unsigned integer overflow: 4294967295 + 1 cannot be represented in type \\'unsigned int\\'\\n\\t```\\n\\t> -fsanitize=unsigned-integer-overflow: Unsigned integer overflow, where the result of an unsigned integer computation cannot be represented in its type. Unlike signed integer overflow, this is not undefined behavior, but it is often unintentional. This sanitizer does not check for lossy implicit conversions performed before such a computation (see -fsanitize=implicit-conversion).\\n\\nIn conclusion, the reason `unsigned int` gets AC is because we **intentionally know the flags** contain `-fsanitize=signed-integer-overflow` and do not contain `-fsanitize=unsigned-integer-overflow` (actually flag `-fsanitize=undefined` does this, it may be the actual flag, I don\\'t know).",
                "solutionTags": [],
                "code": "``` C++\\n#ifdef LL\\n  #define type long long\\n#else\\n  #ifdef UI\\n    #define type unsigned int\\n  #else\\n    #define type int\\n  #endif\\n#endif\\n\\nint combinationSum4(vector<int>& nums, int target) {\\n  vector<type> dp(target + 1);\\n  dp[0] = 1;\\n  for (int i = 1; i <= target; ++i) {\\n    for (auto n : nums)\\n      if (i - n >= 0) {\\n        if (dp[i] + dp[i - n] < dp[i])\\n          cerr << \"of @ \" << dp[i] << \" + \" << dp[i - n] << \" = \" << dp[i] + dp[i - n] << endl;\\n        dp[i] += dp[i - n];\\n      }\\n  }\\n  return dp[target];\\n}\\n\\nint main() {\\n  // Case I, 1\\n  vector<int> nums;\\n  for (int i = 10; i <= 990; i += 10)\\n    nums.push_back(i);\\n  nums.push_back(111);\\n  cout << \"Case I: \" << combinationSum4(nums, 999) << endl;\\n\\n  // Case II, 0\\n  vector<int> nums2({3, 33, 333});\\n  cout << \"Case II: \" << combinationSum4(nums2, 1000) << endl;\\n}\\n```\n``` bash\\n\\t$ g++ test.cc && ./a.out       # no runtime error\\n\\t$ g++ -DLL test.cc && ./a.out  # no runtime error\\n\\t$ g++ -DUI test.cc && ./a.out  # no runtime error\\n\\t```\n``` bash\\n\\t$ clang++ test.cc && ./a.out       # no runtime error\\n\\t$ clang++ -DLL test.cc && ./a.out  # no runtime error\\n\\t$ clang++ -DUI test.cc && ./a.out  # no runtime error\\n\\t```\n``` bash\\n\\t$ clang++ -fsanitize=signed-integer-overflow test.cc && ./a.out\\n\\truntime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\t$ clang++ -fsanitize=signed-integer-overflow -DLL test.cc && ./a.out\\n\\truntime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long\\'\\n\\t$ clang++ -fsanitize=signed-integer-overflow -DUI test.cc && ./a.out  # no runtime error\\n\\t```\n``` bash\\n\\t$ clang++ -fsanitize=unsigned-integer-overflow test.cc && ./a.out       # no runtime error\\n\\t$ clang++ -fsanitize=unsigned-integer-overflow -DLL test.cc && ./a.out  # no runtime error\\n\\t$ clang++ -fsanitize=unsigned-integer-overflow -DUI test.cc && ./a.out\\n\\truntime error: unsigned integer overflow: 4294967295 + 1 cannot be represented in type \\'unsigned int\\'\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1166142,
                "title": "combination-sum-iv-top-down-approach-easy-explanation",
                "content": "Approach:-\\nThe question is very similar to the famous staircase question. \\nLink:- https://leetcode.com/problems/climbing-stairs/. The only difference is that in the staircase question we are given the no. of possible steps beforehand only and we can use them directly, but in this question all possible steps or numbers are given in a nums vector. We can here use the nums vector to call for all possible steps as shown in the solution below.\\nNormal recursive implementation as usual gives TLE , it can be optimized by adding a temporary array and saving the values in it 0R by using Memoization.\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target, int dp[]) {\\n        if(target <0) return 0;\\n        if(target==0) return 1;\\n        if(dp[target]!=-1) return dp[target];\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=combinationSum4(nums,target-nums[i], dp);\\n        }\\n        dp[target]=ans;\\n        return ans;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int dp[1001];\\n        for(int i=0;i<1001;i++) dp[i]=-1;    \\n        return combinationSum4(nums,target,dp);\\n        }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target, int dp[]) {\\n        if(target <0) return 0;\\n        if(target==0) return 1;\\n        if(dp[target]!=-1) return dp[target];\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=combinationSum4(nums,target-nums[i], dp);\\n        }\\n        dp[target]=ans;\\n        return ans;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        int dp[1001];\\n        for(int i=0;i<1001;i++) dp[i]=-1;    \\n        return combinationSum4(nums,target,dp);\\n        }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158138,
                "title": "best-ever-solution-0ms-100-fast-using-1-d-dp",
                "content": "**Intuition:**\\nNo. of combinations required for reaching target depends on the number of combinations required to reach sub targets.\\n\\n**Time Complexity: O(mn)**, where m is the number of elements in nums vector and n is the target\\n**Space Complexity: O(n**)\\n\\nPlease feel free to share your thoughts. Happy Leetcoding!\\n\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++)\\n            for(int j=0;j<nums.size();j++)\\n                if(nums[j]<=i)\\n                    dp[i]+=dp[i-nums[j]];\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=target;i++)\\n            for(int j=0;j<nums.size();j++)\\n                if(nums[j]<=i)\\n                    dp[i]+=dp[i-nums[j]];\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071237,
                "title": "simple-c-recursive-dp-solution-easy-to-understand-with-comments",
                "content": "**C++ recursive DP with memoisation**\\n```\\nclass Solution {\\npublic:\\n    int dp[10001];    //Initialise DP\\n    int solve(vector<int> &ar, int start, int target)\\n    {\\n        if(target==0)   //If the target becomes 0, we got a combination that sums to the target , so we return 1.\\n        return 1;            \\n\\n        if(start>=ar.size() || target<0)    //If the start pointer goes beyond array border or target becomes negative, return 0 as this is not a possible combination \\n        return 0;\\n\\n        if(dp[target]!=-1)   //DP check\\n        return dp[target];\\n\\n        if(ar[start]>target)    \\n        return dp[target]=solve(ar,start+1,target);  //If the current element is greater than the target, we have to skip this element.\\n        else    \\n        return dp[target]=solve(ar,0,target-ar[start]) + solve(ar,start+1,target);  //Else we have two options, to choose the current element or to skip it. If we choose, we must reduce it from target and set start pointer back to 0. Otherwise we can skip the element. We need sum of these recursive calls to find the count of all possible combs.\\n    }\\n    \\n    int combinationSum4(vector<int>& ar, int target) {        \\n        memset(dp, -1 ,sizeof dp);\\n        return solve(ar,0,target);        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001];    //Initialise DP\\n    int solve(vector<int> &ar, int start, int target)\\n    {\\n        if(target==0)   //If the target becomes 0, we got a combination that sums to the target , so we return 1.\\n        return 1;            \\n\\n        if(start>=ar.size() || target<0)    //If the start pointer goes beyond array border or target becomes negative, return 0 as this is not a possible combination \\n        return 0;\\n\\n        if(dp[target]!=-1)   //DP check\\n        return dp[target];\\n\\n        if(ar[start]>target)    \\n        return dp[target]=solve(ar,start+1,target);  //If the current element is greater than the target, we have to skip this element.\\n        else    \\n        return dp[target]=solve(ar,0,target-ar[start]) + solve(ar,start+1,target);  //Else we have two options, to choose the current element or to skip it. If we choose, we must reduce it from target and set start pointer back to 0. Otherwise we can skip the element. We need sum of these recursive calls to find the count of all possible combs.\\n    }\\n    \\n    int combinationSum4(vector<int>& ar, int target) {        \\n        memset(dp, -1 ,sizeof dp);\\n        return solve(ar,0,target);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012790,
                "title": "java-simple-1ms-with-explanation",
                "content": "```\\n//             4\\n//         1. 2   3\\n//     ->. 3. 2.  1 \\n//      1 2 3 \\n// ->   2 1 0                 \\n// https://www.youtube.com/watch?v=PomVtsn7ZoM\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n\\n        if (target == 0) {\\n            return 0;\\n        }\\n        int[] dp = new int[target + 1];\\n        \\n        // One possible way to make sum as 0 by not selecting any\\n        dp[0] = 1;\\n        \\n        // dp for all targets of sum\\n        for (int i = 1; i <= target; i++) {\\n            \\n            // all given numbers process the state space tree\\n            for (int j = 0; j < nums.length; j++) { \\n                \\n                // only if its lesser than sum\\n                if (nums[j] <= i) {\\n                    \\n                    // current value + remaining target sum combinations\\n                    dp[i] = dp[i] + dp[i - nums[j]]; // i-nums[j] gives new target eg (4-1) = 3\\n                }\\n            }\\n        }\\n    \\n        return dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//             4\\n//         1. 2   3\\n//     ->. 3. 2.  1 \\n//      1 2 3 \\n// ->   2 1 0                 \\n// https://www.youtube.com/watch?v=PomVtsn7ZoM\\n\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n\\n        if (target == 0) {\\n            return 0;\\n        }\\n        int[] dp = new int[target + 1];\\n        \\n        // One possible way to make sum as 0 by not selecting any\\n        dp[0] = 1;\\n        \\n        // dp for all targets of sum\\n        for (int i = 1; i <= target; i++) {\\n            \\n            // all given numbers process the state space tree\\n            for (int j = 0; j < nums.length; j++) { \\n                \\n                // only if its lesser than sum\\n                if (nums[j] <= i) {\\n                    \\n                    // current value + remaining target sum combinations\\n                    dp[i] = dp[i] + dp[i - nums[j]]; // i-nums[j] gives new target eg (4-1) = 3\\n                }\\n            }\\n        }\\n    \\n        return dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947528,
                "title": "python-3-dp-with-explanation",
                "content": "**Algorithm**\\n* First create a dp table of size `target+1`\\n* Update `dp[0]`  to `1`\\n* For `nums=[1,2,3]` and `target=4` , the initial `dp` would look like the following:\\n\\t* `dp=[1,0,0,0,0]`\\n* for a given number, `i`, where `i` is between 1 and `len(dp)`:\\n\\t* if `i-num >= 0`, then `dp[i] += dp[i-num]`\\n* In the end our `dp` becomes:\\n\\t* `dp = [1,1,2,4,7]`\\n\\n**Explanation**\\n\\nThis is what is called a bottom up dynamic programming. For each number between `0`  and `target` we are asking how many ways can we get a combination sum of `i`. How many ways are there to have a sum of 1, 2, 3... and finally we ask how many ways are there to have a sum for `target`?\\nOur combination sum at `dp[i]` equals `dp[i-nums[0]] + dp[i-nums[1]] + dp[i - nums[2]]` for `nums[1,2,3]`.\\n\\nIn `dp=[1,1,2,4,7]` , each number represents the number of ways we can sum to `i`. \\n\\nFor example, we found `dp[3] = 4` when `nums=[1,2,3]` by doing the following:\\n* `3 - nums[0]` or  `3-1 = 2`, then we did `dp[3] = dp[3] + dp[2] = 0 + 2 = 2`\\n* `3 - nums[1]` or `3-2 = 1` then we did `dp[3] = dp[3] + dp[1] = 2 + 1 = 3`\\n* `3 - nums[2]` or `3-3 = 0` then we did `dp[3] = dp[3] + dp[0] = 3 + 1 = 4`\\n\\n**Code**\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        cache = [0]*(target+1)\\n        cache[0] = 1\\n        \\n        for i in range(1,len(cache)):\\n            for num in nums:\\n                if i - num >= 0:\\n                    cache[i] += cache[i-num]\\n                    \\n        return cache[-1]\\n```\\n\\n**Similar Problem**\\nYou can take a very similar approach to solve Coin Change: https://leetcode.com/problems/coin-change/",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        cache = [0]*(target+1)\\n        cache[0] = 1\\n        \\n        for i in range(1,len(cache)):\\n            for num in nums:\\n                if i - num >= 0:\\n                    cache[i] += cache[i-num]\\n                    \\n        return cache[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915971,
                "title": "python-five-stages-of-dynamic-programming",
                "content": "First off, the name of this problem is a misnomer. The example shows counting permutations, not combinations - so that is what we will do.  \\n\\nHere are five stages - in order - for building a bottom up DP solution for this problem.  Generally you can start at the top down solution and skip the recursive solutions completely.  \\n\\n1. (TLE) Recursive solution\\n2. (TLE) Better Recursive solution\\n3. (72 ms) Top Down Solution\\n4. (48 ms) Bottom Up Solution\\n5. (44 ms) Optimized Bottom Up Solution\\n\\n**Recursive Solution: TLE**\\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\tdef helper(t):\\n\\t\\tnonlocal target, res\\n\\n\\t\\tif t >= target:\\n\\t\\t\\tres += t == target\\n\\t\\t\\treturn None\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\thelper(t + num)\\n\\n\\tres = 0\\n\\thelper(0)\\n\\treturn res\\n```\\n\\n<br>\\n\\n**Better Recursion: TLE**\\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\tdef helper(t):\\n\\t\\tnonlocal target\\n\\n\\t\\tif t >= target:\\n\\t\\t\\treturn t == target\\n\\n\\t\\treturn sum(helper(t + num) for num in nums)\\n\\n\\treturn helper(0)\\n```\\n<br>\\n\\n**Top Down DP: 72 ms**\\nAdded memoization.\\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\t@functools.lru_cache(None)        \\n\\tdef helper(t):\\n\\t\\tnonlocal target\\n\\n\\t\\tif t >= target:\\n\\t\\t\\treturn t == target\\n\\n\\t\\treturn sum(helper(t + num) for num in nums)\\n\\n\\treturn helper(0)\\n```\\n\\n<br>\\n\\n**Bottom Up DP: 48 ms**\\nReplace **@functools.lru_cache** wrapper with a **dp** array.  \\nIterate over the argument(s) - which is **t** in this case - in reverse order (target to 0 not 0 to target).  \\nStore the result that helper(t) would have returned in **dp[t]**.  \\nReturn dp[0] instead of helper(0).\\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\tdp = [0 for _ in range(target+1)]\\n\\tdp[target] = 1\\n\\tfor t in range(target-1, -1, -1):\\n\\t\\tdp[t] = sum(dp[t+num] for num in nums if (t + num <= target))\\n\\treturn dp[0]\\n```\\n\\n<br>\\n\\n**Optimized Bottom Up DP: 44 ms**\\nSort numbers so that we can break early when t + num is greater than target.  \\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\tnums.sort()\\n\\tdp = [0 for _ in range(target+1)]\\n\\tdp[target] = 1\\n\\tfor t in range(target-1, -1, -1):\\n\\t\\tfor num in nums:\\n\\t\\t\\tif t + num > target:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tdp[t] += dp[t+num]\\n\\treturn dp[0]\\n```",
                "solutionTags": [],
                "code": "```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\tdef helper(t):\\n\\t\\tnonlocal target, res\\n\\n\\t\\tif t >= target:\\n\\t\\t\\tres += t == target\\n\\t\\t\\treturn None\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\thelper(t + num)\\n\\n\\tres = 0\\n\\thelper(0)\\n\\treturn res\\n```\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\tdef helper(t):\\n\\t\\tnonlocal target\\n\\n\\t\\tif t >= target:\\n\\t\\t\\treturn t == target\\n\\n\\t\\treturn sum(helper(t + num) for num in nums)\\n\\n\\treturn helper(0)\\n```\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\t@functools.lru_cache(None)        \\n\\tdef helper(t):\\n\\t\\tnonlocal target\\n\\n\\t\\tif t >= target:\\n\\t\\t\\treturn t == target\\n\\n\\t\\treturn sum(helper(t + num) for num in nums)\\n\\n\\treturn helper(0)\\n```\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\tdp = [0 for _ in range(target+1)]\\n\\tdp[target] = 1\\n\\tfor t in range(target-1, -1, -1):\\n\\t\\tdp[t] = sum(dp[t+num] for num in nums if (t + num <= target))\\n\\treturn dp[0]\\n```\n```python\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\n\\tnums.sort()\\n\\tdp = [0 for _ in range(target+1)]\\n\\tdp[target] = 1\\n\\tfor t in range(target-1, -1, -1):\\n\\t\\tfor num in nums:\\n\\t\\t\\tif t + num > target:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tdp[t] += dp[t+num]\\n\\treturn dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 835234,
                "title": "simple-bottom-up-dp",
                "content": "```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] m = new int[target + 1];\\n        m[0] = 1;\\n        for (int i=1; i <= target; i++) {\\n            int temp = 0;\\n            for (int j=0; j < nums.length; j++) {\\n                \\n                if (nums[j] <= i) {\\n                    temp += m[i - nums[j]];\\n                }\\n            }\\n            m[i] = temp;\\n        }\\n        return m[target];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] m = new int[target + 1];\\n        m[0] = 1;\\n        for (int i=1; i <= target; i++) {\\n            int temp = 0;\\n            for (int j=0; j < nums.length; j++) {\\n                \\n                if (nums[j] <= i) {\\n                    temp += m[i - nums[j]];\\n                }\\n            }\\n            m[i] = temp;\\n        }\\n        return m[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811662,
                "title": "c-dp-100-short-and-fastest",
                "content": "````\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<size_t>dp(target+1,0);  \\n        dp[0]=1;\\n        for(size_t i=1;i<=target;i++)\\n        {\\n            for(auto &num:nums)\\n            {\\n                if(num<=i)\\n                {\\n                    dp[i]+=dp[i-num];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<size_t>dp(target+1,0);  \\n        dp[0]=1;\\n        for(size_t i=1;i<=target;i++)\\n        {\\n            for(auto &num:nums)\\n            {\\n                if(num<=i)\\n                {\\n                    dp[i]+=dp[i-num];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 680643,
                "title": "easy-recursive-and-dp-solution-with-video-explanation",
                "content": "//Top Down recursive:\\n\\npublic class SubsetsSum {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tint nums[] = { 1, 2, 3 };\\n\\t\\tint target = 4;\\n\\t\\tSystem.out.println(getSubsetSum(nums, target));\\n\\n\\t}\\n\\n\\tstatic int getSubsetSum(int[] nums, int target) {\\n\\n\\t\\tif (target == 0) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint result = 0;\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (target >= nums[i])\\n\\t\\t\\t\\tresult = result + getSubsetSum(nums, target - nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\n\\t}\\n\\n}\\n\\n//DP solution:\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n        return getSubsetSum(nums,target);\\n    }\\n    \\n     int getSubsetSum(int[] nums, int target) {\\n\\n\\t\\tint[] dp = new int[target + 1];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (i - nums[j] >= 0) {\\n\\t\\t\\t\\t\\tdp[i] += dp[i - nums[j]];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[target];\\n\\n\\t}\\n}\\n\\nVideo : Explanation:\\nhttps://www.youtube.com/watch?v=PomVtsn7ZoM&t\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n        return getSubsetSum(nums,target);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 598052,
                "title": "0msec-c-with-explanation",
                "content": "There is a definite substructure to the problem. \\n\\nFor example, for the set {**1, 2, 3**}, and target = 4:\\n\\nNumCombination(4) =\\nNumCombination(3) (Because adding **1** to each such combination would give sum 4) +\\nNumCombination(2) (Because adding **2** to each such combination would give sum 4) +\\nNumCombination(1) (Becasue adding **3**... you get the idea!)\\n\\n**Step 1: Brute force DFS** (Time Limit Exceeded)\\n```\\nint combinationSum4(int *n, int nsz, int target)    {\\n    int scnt = 0, i;    \\n    for (i = 0; i < nsz && target; ++i) {\\n\\t\\t/* DFS, recursively apply the logic. */\\n         if (target - n[i] >= 0)\\t\\t \\n            scnt += combinationSum4(n, nsz, target - n[i]);\\n    }\\n    /* Handle case when target = 0. */\\n    return target ? scnt : 1  ;\\n}\\n```\\n Works, but does not scale. O(nsz ^ target) complexity and we also repeat computation for sub-problems.\\n\\n**Step 2:  DP + DFS** (Time Limit Exceeded)\\n\\nWe simply cache the result of an already calculated combination count.\\n\\n```\\nuint64_t helper(int *n, int nsz, int target, uint64_t *dp) {\\n    int i;\\n\\n\\t/* Return cached result. */\\n    if (dp[target]) return dp[target];\\n\\t\\n\\tfor (i = 0; i < nsz && target; ++i) {\\n\\t\\t/* Cache the result. */\\n        if (target - n[i] >= 0)\\n\\t\\t\\tdp[target] += helper(n, nsz, target - n[i], dp);\\n\\t}    \\t\\n    return dp[target];\\n}\\n\\nint combinationSum4(int *n, int nsz, int target)    {\\n    int scnt = 0;\\n    uint64_t *dp = calloc(target + 1, sizeof(uint64_t));\\n\\n    if (!dp) return 0;\\n\\n\\tdp[0] = 1;\\n    scnt = helper(n, nsz, target, dp);\\n    free(dp);    \\n\\n    return scnt;\\n}\\n```\\n\\nWith caching we optimize on computation, but complexity is still O(nsz ^ target)\\n\\n**Step 3: DP + Bottom up** (0/4 mSec)\\n\\nWith bottom up approach we cache the results and also get O(nsz * target) complexity.\\n\\n```\\nint combinationSum4(int *n, int nsz, int target)    {\\n    int scnt = 0, i, j;\\n    uint64_t *dp = calloc(target + 1, sizeof(uint64_t));\\n    if (!dp) return scnt;\\n    dp[0] = 1;\\n    for (i = 1; i <= target; ++i) {\\n        for (j = 0; j < nsz; ++j) {\\n            if (n[j] <= i)\\n                dp[i] += dp[i - n[j]];\\n        }\\n    }\\n    scnt = dp[target];\\n    free(dp);    \\n    return scnt;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint combinationSum4(int *n, int nsz, int target)    {\\n    int scnt = 0, i;    \\n    for (i = 0; i < nsz && target; ++i) {\\n\\t\\t/* DFS, recursively apply the logic. */\\n         if (target - n[i] >= 0)\\t\\t \\n            scnt += combinationSum4(n, nsz, target - n[i]);\\n    }\\n    /* Handle case when target = 0. */\\n    return target ? scnt : 1  ;\\n}\\n```\n```\\nuint64_t helper(int *n, int nsz, int target, uint64_t *dp) {\\n    int i;\\n\\n\\t/* Return cached result. */\\n    if (dp[target]) return dp[target];\\n\\t\\n\\tfor (i = 0; i < nsz && target; ++i) {\\n\\t\\t/* Cache the result. */\\n        if (target - n[i] >= 0)\\n\\t\\t\\tdp[target] += helper(n, nsz, target - n[i], dp);\\n\\t}    \\t\\n    return dp[target];\\n}\\n\\nint combinationSum4(int *n, int nsz, int target)    {\\n    int scnt = 0;\\n    uint64_t *dp = calloc(target + 1, sizeof(uint64_t));\\n\\n    if (!dp) return 0;\\n\\n\\tdp[0] = 1;\\n    scnt = helper(n, nsz, target, dp);\\n    free(dp);    \\n\\n    return scnt;\\n}\\n```\n```\\nint combinationSum4(int *n, int nsz, int target)    {\\n    int scnt = 0, i, j;\\n    uint64_t *dp = calloc(target + 1, sizeof(uint64_t));\\n    if (!dp) return scnt;\\n    dp[0] = 1;\\n    for (i = 1; i <= target; ++i) {\\n        for (j = 0; j < nsz; ++j) {\\n            if (n[j] <= i)\\n                dp[i] += dp[i - n[j]];\\n        }\\n    }\\n    scnt = dp[target];\\n    free(dp);    \\n    return scnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537450,
                "title": "python-dfs-memoisation-sorting-28ms-99-5",
                "content": "I find that I was able to beat most python entries by using the following:\\n- top-down DP through DFS with memoisation (bottom-up DP would compute \"dead-end\" interim results - top-down DFS avoids these)\\n-  sorting (surprisingly many python entries don\\'t do it)\\n\\n```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        ways = [1] + [-1]*target # -1 as a flag that the sum hasn\\'t been computed\\n        nums.sort()  # this, actually, saves quite a bit of time (see break clause)\\n        def dfs (target):\\n            if ways[target] != -1: return ways[target] #memoisation: don\\'t repeat interim results\\n            res = 0\\n            for i in nums:\\n                if i <= target:\\n                    res += dfs(target - i)\\n                else: break # the numbers only get higher: no reason to continue\\n            ways[target] = res\\n            return res\\n        return dfs(target)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        ways = [1] + [-1]*target # -1 as a flag that the sum hasn\\'t been computed\\n        nums.sort()  # this, actually, saves quite a bit of time (see break clause)\\n        def dfs (target):\\n            if ways[target] != -1: return ways[target] #memoisation: don\\'t repeat interim results\\n            res = 0\\n            for i in nums:\\n                if i <= target:\\n                    res += dfs(target - i)\\n                else: break # the numbers only get higher: no reason to continue\\n            ways[target] = res\\n            return res\\n        return dfs(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484199,
                "title": "javascript-dynamic-programming",
                "content": "```\\nfunction combinationSum4(nums, target) {\\n  nums.sort((a, b) => a - b);\\n  let dp = new Array(target + 1).fill(0);\\n  for (let i = 1; i <= target; i++) {\\n    for (let num of nums) {\\n      if (num > i) {\\n        break;\\n      }\\n      if (i === num) {\\n        dp[i]++;\\n      }\\n      dp[i] += dp[i - num];\\n    }\\n  }\\n  return dp[dp.length - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction combinationSum4(nums, target) {\\n  nums.sort((a, b) => a - b);\\n  let dp = new Array(target + 1).fill(0);\\n  for (let i = 1; i <= target; i++) {\\n    for (let num of nums) {\\n      if (num > i) {\\n        break;\\n      }\\n      if (i === num) {\\n        dp[i]++;\\n      }\\n      dp[i] += dp[i - num];\\n    }\\n  }\\n  return dp[dp.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 409401,
                "title": "4-lines-self-explanatory-code-in-python",
                "content": "```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\tdp = [1]+ [0]*target\\n\\tfor i in range(1,target+1):\\n\\t\\tdp[i]=sum(dp[i-j] for j in nums if i-j>=0)\\n\\treturn dp[-1]\\n```\\nThe same idea as others, just using one dimensional DP array.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef combinationSum4(self, nums: List[int], target: int) -> int:\\n\\tdp = [1]+ [0]*target\\n\\tfor i in range(1,target+1):\\n\\t\\tdp[i]=sum(dp[i-j] for j in nums if i-j>=0)\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 285503,
                "title": "simple-1ms-java-solution-similar-to-coin-change",
                "content": "dp[i] represents number of ways to sum up to \"i\"\\nfind number of ways for each i from 1 to target, using each number in the array.\\n```\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        dp[0] = 1;\\n        for(int i=1;i<=target;i++){\\n            for(int num : nums){\\n                if(i >= num)\\n                    dp[i] += dp[i-num];\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        dp[0] = 1;\\n        for(int i=1;i<=target;i++){\\n            for(int num : nums){\\n                if(i >= num)\\n                    dp[i] += dp[i-num];\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 263064,
                "title": "java-backtrack",
                "content": "```java\\npublic class Solution {\\n\\n    private Integer[] memo;\\n    private int[] nums;\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        this.memo = new Integer[target + 1];\\n        this.nums = nums;\\n        return backtrack(target);\\n    }\\n\\n    // Returns # of ways to add up to target\\n    public int backtrack(int target) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n\\n        if (memo[target] != null) {\\n            return memo[target];\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            total += backtrack(target - nums[i]);\\n        }\\n\\n        memo[target] = total;\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n\\n    private Integer[] memo;\\n    private int[] nums;\\n\\n    public int combinationSum4(int[] nums, int target) {\\n        this.memo = new Integer[target + 1];\\n        this.nums = nums;\\n        return backtrack(target);\\n    }\\n\\n    // Returns # of ways to add up to target\\n    public int backtrack(int target) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n\\n        if (memo[target] != null) {\\n            return memo[target];\\n        }\\n\\n        int total = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            total += backtrack(target - nums[i]);\\n        }\\n\\n        memo[target] = total;\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251090,
                "title": "general-backtracking-dfs-recursion-and-dp-solution-in-python",
                "content": "Like classical ```permutation/combination``` problem, the general ```backtracking``` solution is as following. However, it is so bruteforceful and TLE.\\n```\\ndef combinationSum4(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def backtrack(tmp):\\n            cur_sum = sum(tmp)\\n            if cur_sum == target:\\n                self.ans += 1\\n                return\\n            if cur_sum > target:\\n                return\\n            for i in range(N):\\n                backtrack(tmp + [nums[i]])\\n\\n        self.ans = 0\\n        N = len(nums)\\n        backtrack([])\\n        return self.ans\\n```\\nNow, let\\'s do the optimization with memorization. The it is much more efficient and it is the prototype of DP solution.\\n```\\ndef combinationSum4(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def backtrack(remain):\\n            if remain in memo:\\n                return memo[remain]\\n            if remain == 0:\\n                return 1\\n            if remain < 0:\\n                return 0\\n            res = 0\\n            for i in range(N):\\n                res += backtrack(remain - nums[i])\\n            memo[remain] = res\\n            return res\\n\\n        N = len(nums)\\n        memo = collections.defaultdict(int)\\n        return backtrack(target)\\n```\\nNaturally, according the above DP prototype, the standard DP version can be written as following.\\n```\\ndef combinationSum4(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        dp = [0 for _ in range(target + 1)]\\n        dp[0] = 1\\n        for i in range(target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        return dp[target]\\n```",
                "solutionTags": [],
                "code": "```permutation/combination```\n```backtracking```\n```\\ndef combinationSum4(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def backtrack(tmp):\\n            cur_sum = sum(tmp)\\n            if cur_sum == target:\\n                self.ans += 1\\n                return\\n            if cur_sum > target:\\n                return\\n            for i in range(N):\\n                backtrack(tmp + [nums[i]])\\n\\n        self.ans = 0\\n        N = len(nums)\\n        backtrack([])\\n        return self.ans\\n```\n```\\ndef combinationSum4(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def backtrack(remain):\\n            if remain in memo:\\n                return memo[remain]\\n            if remain == 0:\\n                return 1\\n            if remain < 0:\\n                return 0\\n            res = 0\\n            for i in range(N):\\n                res += backtrack(remain - nums[i])\\n            memo[remain] = res\\n            return res\\n\\n        N = len(nums)\\n        memo = collections.defaultdict(int)\\n        return backtrack(target)\\n```\n```\\ndef combinationSum4(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        dp = [0 for _ in range(target + 1)]\\n        dp[0] = 1\\n        for i in range(target + 1):\\n            for num in nums:\\n                if i >= num:\\n                    dp[i] += dp[i - num]\\n        return dp[target]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 85048,
                "title": "java-dp-solution-with-follow-up-explanation",
                "content": "Attention: Filling the dp array with -1 is very important, because it can maintain the result that there is no solution for current value.\\n```\\npublic class Solution {\\n    //assume element in nums and target are positive\\n    public int combinationSum4(int[] nums, int target) {\\n        if(nums==null || nums.length==0) return 0;\\n        int[] dp = new int[target+1];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 1;\\n        return combSum(nums, target, dp);\\n    }\\n    private int combSum(int[] nums, int target, int[] dp){\\n        if(target<0) return 0;\\n        if(dp[target]>=0) return dp[target]; \\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            count += combSum(nums, target-nums[i], dp);\\n        }\\n        dp[target] = count;\\n        return count;\\n    }\\n}\\n```\\n\\nFollow up:\\nIf negative numbers exist in input array, then the combinations could be infinite length. For example, nums = [-1, 1] and target = 1. There could have infinite (-1, 1) pairs plus a single 1. \\n\\nIf we limit the length of the combination sequence, the problem will have a finite solution.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    //assume element in nums and target are positive\\n    public int combinationSum4(int[] nums, int target) {\\n        if(nums==null || nums.length==0) return 0;\\n        int[] dp = new int[target+1];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 1;\\n        return combSum(nums, target, dp);\\n    }\\n    private int combSum(int[] nums, int target, int[] dp){\\n        if(target<0) return 0;\\n        if(dp[target]>=0) return dp[target]; \\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            count += combSum(nums, target-nums[i], dp);\\n        }\\n        dp[target] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85155,
                "title": "4-liner-in-python-60ms",
                "content": "I've learned so much from you guys lately, especially code golfers like @StefanPochmann \\n\\nTrying to catch up here:\\n```\\n        dp = [1]\\n        for i in range(1, target+1):\\n            dp.append(sum(dp[i-n] for n in nums if i-n >= 0))\\n        return dp[target]\\n```",
                "solutionTags": [],
                "code": "```\\n        dp = [1]\\n        for i in range(1, target+1):\\n            dp.append(sum(dp[i-n] for n in nums if i-n >= 0))\\n        return dp[target]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85166,
                "title": "simple-java-dp",
                "content": "```\\npublic class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] ways = new int[target + 1];\\n        ways[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                if (i - nums[j] >= 0) {\\n                    ways[i] += ways[i - nums[j]];\\n                }\\n            }\\n        }\\n        return ways[target];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] ways = new int[target + 1];\\n        ways[0] = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                if (i - nums[j] >= 0) {\\n                    ways[i] += ways[i - nums[j]];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4023092,
                "title": "c-solution-for-combination-sum-iv-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the above solution is to use dynamic programming to count the number of ways to reach the target sum using the given numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to create an array dp, where dp[i] represents the number of ways to reach the sum i using the numbers from the nums array. We initialize dp[0] to 1 because there is one way to reach the target sum of 0, which is by using no numbers.\\n\\nThe code then iterates through the target sum from 1 to the actual target value, and for each value, it iterates through the numbers in the nums array. For each number num, if i >= num, it means we can use that number to reach the sum i, so we add dp[i - num] to dp[i] to accumulate the number of ways.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(target * n), where n is the length of the nums array. We have a nested loop structure, where the outer loop iterates through the target values from 1 to the actual target, and the inner loop iterates through the nums array. In the worst case, this results in O(target * n) iterations.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(target + 1), which simplifies to O(target) because we only need an array of length target + 1 to store the dp values. This space is used to store the intermediate results of subproblems.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CombinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1; // There\\'s one way to reach target 0, which is by using no numbers.\\n\\n        for (int i = 1; i <= target; i++) {\\n            foreach (int num in nums) {\\n                if (i >= num) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n\\n        return dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CombinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target + 1];\\n        dp[0] = 1; // There\\'s one way to reach target 0, which is by using no numbers.\\n\\n        for (int i = 1; i <= target; i++) {\\n            foreach (int num in nums) {\\n                if (i >= num) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n\\n        return dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022968,
                "title": "already-you-are-mine",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an integer array `dp` to store the number of combinations for each target value.\\n```java\\nint[] dp = new int[target + 1];\\n```\\n\\n2. Initialize the base case: Set `dp[0]` to `1` because there\\'s one way to make the target sum `0`, which is by not selecting any number.\\n```java\\ndp[0] = 1;\\n```\\n\\n3. Initialize a loop variable `i` to iterate through target values.\\n```java\\nfor (int i = 1; i <= target; i++) {\\n```\\n4. Start iterating through the given numbers in `nums` using a for-each loop.\\n```java\\nfor (int n : nums) {\\n```\\n5. Check if the current number `n` can be used to form the current target value `i`.\\n\\n```java\\nif (n <= i) {\\n```\\n6. Update the number of combinations for the current target value `i` by adding the number of combinations for the remaining target after subtracting the current number `n`.\\n\\n```java\\ndp[i] += dp[i - n];\\n```\\n7. The final result is stored in `dp[target]`, which represents the number of combinations to reach the given target.\\n```java\\nreturn dp[target];\\n```\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        dp[0] = 1;\\n        for(int i=1; i<=target; i++)\\n            for(int n:nums){\\n                if(n <= i) dp[i] += dp[i-n];\\n        return dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nint[] dp = new int[target + 1];\\n```\n```java\\ndp[0] = 1;\\n```\n```java\\nfor (int i = 1; i <= target; i++) {\\n```\n```java\\nfor (int n : nums) {\\n```\n```java\\nif (n <= i) {\\n```\n```java\\ndp[i] += dp[i - n];\\n```\n```java\\nreturn dp[target];\\n```\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int[] dp = new int[target+1];\\n        dp[0] = 1;\\n        for(int i=1; i<=target; i++)\\n            for(int n:nums){\\n                if(n <= i) dp[i] += dp[i-n];\\n        return dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022118,
                "title": "easiest-dp-java-solution-beats-easy-to-understand",
                "content": "# Intuition\\nCalculate now of ways for get combination sum for all values less than target and then we can get combination sum for given target.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInitialize a dp of size = target+1\\nPut dp[0] = 1;\\nThen check for all values from 1 to target that how many ways possible.\\nFor i = i, we check from j = 0 to j = i-1, if j+difference of sum is present in nums then dp[i] = dp[i] + dp[j].\\nExample i = 5, for j = 2, dp[j] = 3 then if 3 is present in nums then for all thw ways sum 2 was made them sum 5 is also possible, so dp[5] = dp[5] + dp[2].\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int[] dp = new int[target+1];\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i: nums){\\n            set.add(i);\\n        }\\n        dp[0] = 1;\\n        for(int i=0;i<=target;i++){\\n            for(int j=0;j<i;j++){\\n                if(set.contains(i-j)){\\n                    dp[i] += dp[j];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int[] dp = new int[target+1];\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i: nums){\\n            set.add(i);\\n        }\\n        dp[0] = 1;\\n        for(int i=0;i<=target;i++){\\n            for(int j=0;j<i;j++){\\n                if(set.contains(i-j)){\\n                    dp[i] += dp[j];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022057,
                "title": "simple-c-video-solution-recursion-memoization-dynamic-programming",
                "content": "# Video Solution\\nhttps://youtu.be/Z06gGYt5xn8\\n# Intuition\\nIterate over array and choose `nums[i]` and recursively solve for `target-nums[i]`.\\nUse memoization in order to reduce time complexity. \\n![image.png](https://assets.leetcode.com/users/images/d5410027-1813-4a5b-aa49-8022a9d91e4f_1694256653.2961202.png)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*target)$$\\n- Space complexity:\\n$$O(target)$$\\n\\n**Please upvote if  you liked !!!**\\n\\n# Code\\n```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n// this function will return number of combinations to achieve sum==left...\\n    int get_combination(int left,vector<int>&nums,vector<int>&dp){\\n        if(left==0){\\n            // some how we have achieved our sum==target there left target==0\\n            return 1;\\n        }\\n        if(left<0){\\n            return 0;\\n        }\\n        if(dp[left]!=-1){\\n            // we know number of combinations corresponding to left..\\n            return dp[left];\\n        }\\n        int ans=0;\\n        for(auto ele:nums){\\n            // if we have ele.. left will be decresed by ele..\\n            ans+=get_combination(left-ele,nums,dp);\\n        }\\n        return dp[left]=ans;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int>dp(target+1,-1); // it will store number of combinations corresponding to each sum from 0-target...\\n\\n        // initially left==target...\\n        return get_combination(target,nums,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n// this function will return number of combinations to achieve sum==left...\\n    int get_combination(int left,vector<int>&nums,vector<int>&dp){\\n        if(left==0){\\n            // some how we have achieved our sum==target there left target==0\\n            return 1;\\n        }\\n        if(left<0){\\n            return 0;\\n        }\\n        if(dp[left]!=-1){\\n            // we know number of combinations corresponding to left..\\n            return dp[left];\\n        }\\n        int ans=0;\\n        for(auto ele:nums){\\n            // if we have ele.. left will be decresed by ele..\\n            ans+=get_combination(left-ele,nums,dp);\\n        }\\n        return dp[left]=ans;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int>dp(target+1,-1); // it will store number of combinations corresponding to each sum from 0-target...\\n\\n        // initially left==target...\\n        return get_combination(target,nums,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021948,
                "title": "combination-sum-iv-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1);\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++) {\\n            for(int num: nums) {\\n                if(i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1);\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++) {\\n            for(int num: nums) {\\n                if(i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021615,
                "title": "c-easy-bottom-up-dp",
                "content": "# Approach: Bottom Up DP\\n- This problem lends it self to a bottom up dynamic programming approach.\\n\\n**1. Initialize a DP vector**\\n- in our dp vector we want every number to have a place from 0->target\\n- we will store in each index the number of ways we can make a number\\n- for 0, it will always be a value of 1. This is because we can always not include any of our numbers and the value will be 0;\\n\\nLets walk through the example of:\\n```\\nnums = [1,2,3], target = 4\\n```\\n- We will need an array to store values for 0 -> 4.\\n- can give index 0 a value of 1 (as explained above)\\n\\n![IMG_0719.jpeg](https://assets.leetcode.com/users/images/cd6ae8ca-f62d-46f7-8ba6-8ec7ecb0d3fd_1694250574.793422.jpeg)\\n\\n**2. Caluclate the number of ways to make each number**\\n- This will be done by comparing the numbers we have available to use\\n- lets walk through this example\\n\\n1:\\n- our current number is 1. \\n- we have numbers [1,2,3] available to us to make 1. \\n- how do we know which values add up to 1?\\n- we can see which values of num in the equation 1 - num is >= 0\\n```\\n1 - 1 = 0       yes\\n1 - 2 = -1      no\\n1 - 3 = -2      no\\n```\\n- there we can only use 1 in this combination\\n- the value of 1 - 1 = 0. therefore we can add the number of cominations of zero to the count for 1. This is because if we can reach zero we can just add a 1 to every combination and now it equals 1.\\n![IMG_0718.jpeg](https://assets.leetcode.com/users/images/98c26c45-3826-43c7-8a38-5706fc02397f_1694250695.7025988.jpeg)\\n\\n\\n\\n2:\\n- we will follow the same process for 2\\n```\\n2 - 1 = 1\\n2 - 2 = 0\\n2 - 3 = -1\\n```\\ntherefore now we can use 1 and 2 to make combinations. \\n![IMG_0721.jpeg](https://assets.leetcode.com/users/images/3eccec9b-9bea-46f1-bef3-7e252b63385e_1694250838.053931.jpeg)\\n\\n3:\\n- same process repeats\\n\\n![IMG_0722.jpeg](https://assets.leetcode.com/users/images/3afc8167-cd2e-4904-8b7a-721f788a93f6_1694250919.6731737.jpeg)\\n\\n\\n4: \\n- same process repeats\\n![IMG_0723.jpeg](https://assets.leetcode.com/users/images/1265c072-0281-4902-b9e1-a1f5c91e0f99_1694251116.494113.jpeg)\\n\\n# Complexity\\n- Time complexity: O(t * n) (where t is target and num is the number of numbers in nums )\\n\\n- Space complexity: O(t) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1);\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++) {\\n            for(int num: nums) {\\n                if(i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums = [1,2,3], target = 4\\n```\n```\\n1 - 1 = 0       yes\\n1 - 2 = -1      no\\n1 - 3 = -2      no\\n```\n```\\n2 - 1 = 1\\n2 - 2 = 0\\n2 - 3 = -1\\n```\n```\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<unsigned int> dp(target + 1);\\n        dp[0] = 1;\\n        for(int i = 1; i <= target; i++) {\\n            for(int num: nums) {\\n                if(i - num >= 0) {\\n                    dp[i] += dp[i - num];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021476,
                "title": "100-recursion-with-memoization-unbounded-knapsack-pick-and-not-pick-striver",
                "content": "# Intuition\\nto solve the \"Combination Sum IV\" problem, we can use a recursive approach with memoization. We start by considering each element in the nums array and recursively call a helper function with the current target value. Two base cases are crucial: when the target becomes zero, indicating a valid combination is found, we return 1; and when we reach the end of the nums array without finding a valid combination, we return 0. To avoid redundant calculations, we utilize memoization, storing previously computed results in a 2D array. In each recursive step, we have two choices: we can include the current element (subtracting it from the target) or skip it (moving to the next index). We return the sum of these choices. The main function initializes the memoization array and calls the recursive function with the initial parameters, achieving an efficient solution to count combinations that sum up to the target using elements from nums.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> If target is 0, then there is 1 combination, the empty combination.\\n-> If ind is equal to the size of the array, then there are no combinations.\\nOtherwise, check if the table dp has a value for ind and target. If it does, then return that value.\\n\\nOtherwise, let pick be the number of combinations that add up to target - nums[ind] using the first ind - 1 elements of the array nums.\\nLet notpick be the number of combinations that add up to target using the first ind elements of the array nums, without using the number nums[ind].\\n\\nRecursively call the function combinationSum4help with the arguments nums, target - nums[ind], ind + 1, and dp. This will find the number of combinations that add up to target - nums[ind] using the first ind + 1 elements of the array nums.\\ndp[ind][target] = pick + notpick.\\nReturn dp[ind][target].\\n# Complexity\\n- Time complexity:O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int combinationSum4help(vector<int>& nums, int target,int ind,vector<vector<int>>&dp) {     \\n           if(target==0) return 1;\\n           if(ind==nums.size()){\\n               return 0;\\n           }\\n           if(dp[ind][target]!=-1) return dp[ind][target];\\n           int pick=0;\\n           if(nums[ind]<=target){\\n            pick=combinationSum4help(nums,target-nums[ind],0,dp);\\n\\n           }\\n           int notpick=combinationSum4help(nums,target,ind+1,dp);\\n\\n           return  dp[ind][target]=pick+notpick;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<vector<int>>dp(201,vector<int>(1001,-1));\\n        return combinationSum4help(nums,target,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int combinationSum4help(vector<int>& nums, int target,int ind,vector<vector<int>>&dp) {     \\n           if(target==0) return 1;\\n           if(ind==nums.size()){\\n               return 0;\\n           }\\n           if(dp[ind][target]!=-1) return dp[ind][target];\\n           int pick=0;\\n           if(nums[ind]<=target){\\n            pick=combinationSum4help(nums,target-nums[ind],0,dp);\\n\\n           }\\n           int notpick=combinationSum4help(nums,target,ind+1,dp);\\n\\n           return  dp[ind][target]=pick+notpick;\\n    }\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<vector<int>>dp(201,vector<int>(1001,-1));\\n        return combinationSum4help(nums,target,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564540,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1566669,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1565390,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1568159,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1566505,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 2049766,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1565993,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1565118,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1569103,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1576570,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1564540,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1566669,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1565390,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1568159,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1566505,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 2049766,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1565993,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1565118,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1569103,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1576570,
                "content": [
                    {
                        "username": "codecola",
                        "content": "[1,1,2] and [2, 1, 1] are two different combinations, never heard this before...\\nMr. Permutation is unhappy and angry~"
                    },
                    {
                        "username": "mfirozahmed",
                        "content": "[@AssortedFantasy](/AssortedFantasy) that\\'s a great hint to think and solve, thanks a lot."
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "Combination === Permutation \\uD83D\\uDE01"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "This is the comment I was looking for."
                    },
                    {
                        "username": "Pratheek08",
                        "content": "ikr\\n"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "https://leetcode.com/problems/coin-change-ii/ is the combination problem where order does not matter.\\n\\nInterestingly enough, the difference is actually only in the order of loops (for each possible sum, for each usable integer) vs (for each usable integer, for each possible sum) for permutations vs combinations respectively.\\n\\nI think its an interesting combinatoric exercise to show that the permutations value is strictly larger.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@bparanj](/bparanj) Nevertheless, it\\'s a bad description. It can be easily changed to \"sequence\".\\nWhat makes it worse is that it does not explain the difference in the problem description itself but in the example only."
                    },
                    {
                        "username": "bparanj",
                        "content": "In many mathematical contexts, a combination refers to a selection of items where the order of the items does not matter. This means that [1,1,2] and [2,1,1] would be considered the same combination.\\n\\nHowever, in some computational contexts (like in this problem), the term combination may refer to a multi-set, where the order does matter, and [1,1,2] and [2,1,1] would indeed be considered two different combinations.\\n\\nThis may seem a bit confusing, but it\\'s an example of how the same term can have slightly different interpretations in different fields or contexts. The key thing is to understand how the term is being used in the context of the specific problem you\\'re working on.\\n\\nFor the problem you\\'re dealing with, when we say \\'combination\\', we mean a sequence of numbers that add up to a target number, where the order of the numbers in the sequence does matter. So, [1,1,2] and [2,1,1] are counted as separate combinations. This is a somewhat looser usage of the term \\'combination\\' than you might see in a strict mathematical context. \\n\\nThis is why it\\'s important to read and understand the problem statement carefully - to make sure you understand the definitions and constraints it\\'s using."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "Mr. Permutation left earth"
                    },
                    {
                        "username": "user9123lL",
                        "content": "If negative numbers are included in the array then repetition will lead to infinity, thus giving infinite answers. \\nFor example: given array: **[-2,2]** and **target=0** then **possible solutions will go as {-2,2} {-2,-2,2,2} {-2,-2,-2,2,2,2}...**\\nSo in that case the question should specifically mention that each element can only be taken once.\\n**PS:** Please correct me if I am wrong :)"
                    },
                    {
                        "username": "unexplainedfile",
                        "content": "[@aman_sonker](/aman_sonker) what about [-2,2,3] and target = 3?\\n"
                    },
                    {
                        "username": "aman_sonker",
                        "content": "But since target range is given from 1 to 1000 and nums range is also 1000 therefor your case is not consider ."
                    },
                    {
                        "username": "nithinu2810",
                        "content": "Yes...! that\\'s Correct bro but look at the constraints which says that we are given with Positive Numbers. So if the Negative numbers embedded on the Input may provide Infinity..."
                    },
                    {
                        "username": "zhhackk",
                        "content": "If each element has to be taken at most once, then its not a dp problem anymore, instead prefix_sum can be used to solve the problem in O(n) time."
                    },
                    {
                        "username": "bparanj",
                        "content": "If negative numbers are allowed in the given array, it significantly changes the dynamics of the problem. With the inclusion of negative numbers, an infinite number of combinations can sum up to the target number. For example, if the target number is 4, you can reach it with the sequence [4, -1, 1], [4, -1, -1, 1, 1], [4, -1, -1, -1, 1, 1, 1] and so on. In other words, you can add and remove the same negative number and its positive counterpart any number of times.\\n\\nThis would pose a problem to your algorithm since it cannot handle an infinite number of combinations. Therefore, if negative numbers were allowed, you\\'d have to add some limitations or additional rules to keep the problem manageable. \\n\\nFor instance, you could add a rule that each number can only be used once, or a certain fixed number of times. Alternatively, you could specify that the solution should return the combination with the smallest number of elements, or the one that uses the smallest numbers.\\n\\nThe constraints to be added will largely depend on the specifics of the problem you are trying to solve. In most cases, you\\'ll need to add constraints that prevent infinite loops and make the problem solvable within a reasonable time frame."
                    },
                    {
                        "username": "foodlover",
                        "content": "Anyone else getting a runtime error for signed integer overflow on this one ? I keep getting this for the [3,33,333] & sum of 10000 test case, with both my soln as well as solns from what others have reported here."
                    },
                    {
                        "username": "kenlau",
                        "content": "[@SxreaM](/SxreaM) The original comment was from 2019 so the problem setup maybe quite different compare to now (2023)"
                    },
                    {
                        "username": "SxreaM",
                        "content": "the target can\\'t be greater than 1000"
                    },
                    {
                        "username": "dpwang",
                        "content": "It is a Permutation problem not a combination problem."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) Let me shorten up what you said\\n1. We have unique items with positive numbers attached.\\n2. We want to reach a specific total sum.\\n3. The goal is to count how many different ways we can pick these items to reach the total.\\n4. We can pick the same item multiple times.\\n5. The order in which we pick them matters, even if we\\'re picking the same items.\\n6. Our task is to find all the different ways to reach the total using these items."
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@bparanj](/bparanj) What in the gibberish explanation is that? Next time please make it short and in \"English.\""
                    },
                    {
                        "username": "bparanj",
                        "content": "Let's formulate an abstract representation of this problem:\n\nWe have a pool of unique objects, each assigned with a certain positive number. There is also a designated sum total we aim to achieve. The challenge lies in identifying how many unique ways we can pick objects (repeating the same object is permitted) from our pool so that the sum of their assigned numbers equals the designated sum. The sequence of picking matters – even when the same objects are chosen, differing sequences are considered unique.\n\nHere, the pool of objects corresponds to our array of numbers (`nums`), the assigned positive number of each object is the integer value itself, and the designated sum is the `target`. We are searching for different ways of picking these objects (where picking the same object multiple times is possible) such that the sum of the objects' numbers is equal to the `target`. \n\nThis general representation removes specific details about numbers, arrays, and targets, and instead highlights the main structure of the problem and the principal task: identifying the number of ways to pick objects from a pool to total up to a designated sum, where sequence matters and repetition is possible.\n\nBy formulating our own general representation, we steer clear of ambiguous terms and express our understanding of the problem.\n"
                    },
                    {
                        "username": "challenai",
                        "content": "thank you, finally understand what the problem talks about after a failed submission."
                    },
                    {
                        "username": "djslim",
                        "content": "Yes, exactly \\uD83D\\uDC46"
                    },
                    {
                        "username": "andywanghappy",
                        "content": "if negative numbers are allowed in the given array, the number of possible combinations will be infinity."
                    },
                    {
                        "username": "anwendeng",
                        "content": "\"different sequences are counted as different combinations.\"\nIt 's not combination problem, but a problem for permutations.\n\nAccording to the description for example 1, this problem is a problem for permutations with repetition. Each element in the array nums can be chosen many times as you wish.\n\nA real hint for C/C++ users, use unsigned! Even using long long it overflows, very strange! But try unsigned, it will be fine.\nOne useful testcase\n```\n[10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111]\n999\n```\nThough LC says \"The test cases are generated so that the answer can fit in a 32-bit integer.\" But not for intermediate values."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) No it wouldn\\'t. It works the way I described. INT_MAX + 1 = INT_MIN (a negative value). Keep adding to the number and it becomes positive again and so on."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Right, but what does the overflow result from in the first place? We add up only non-negative values, the running sum never decreases, so in case of an intermediate overflow it would stay that way at the final value."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Unlike C/C++ integer overflow in Java reliably wraps around from 2^31 - 1 to -2^31. Intermediate values definitely exceed 2^31-1 for some test cases (they will become negative for Java) but since they don't play a part in the final solution, you wouldn't have noticed. If you want to check for integer overflow/underflow in Java then you can use ``Math.addExact()`` or ``Math.subtractExact()`` which will throw an ArithmeticException in overflow/underflow situations."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) I think that it is the different behavior  for  different type.  Signed integer (int or long long) in GCC will break as an error  when overflowing. But unsigned integers will do the arithmetic as an modular operation when overflowing. "
                    },
                    {
                        "username": "Kaladin7637",
                        "content": "Thanks. It is a life saver. Although, I am curious why others did not get such an error."
                    },
                    {
                        "username": "sergei99",
                        "content": "Folks, what are you talking about, what do you mean we need unsigned types? I\\'ve solved it totally in 32-bit types in O(n * t) in Java and Scala which don\\'t even have unsigned types. None of the intermediate values ever exceed 2^31-1. Or are you reaching better asymptotic at the cost of higher intermediate values?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That \"unsigned\" hint got me over this very test case and allowed me to submit my solution. As you say, \"very strange!\". Out of curiosity, I converted my bottom up solution to recursion + memoization and the test case passed without the need to use an unsigned int. Curiouser and curiouser.\nIncidentally, modding your intermediate results with a large integer also works. \n\nI checked and the C standard guarantees that UINT_MAX + 1 reliably wraps around to 0. However, it is not guaranteed that INT_MAX + 1 will wrap around to INT_MIN (it can lead to undefined behaviour) which is why LeetCode traps it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@krhemant172003](/krhemant172003) You use sort. Maybe it is other method."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Really we don\\'t need using unsigned or any other datatype than int as the answer perfectly fits in 32-bit integer.\\nI had written the recursive solution with int it is working perfectly fine."
                    },
                    {
                        "username": "arakee1",
                        "content": "If we allow negative numbers then we have to put the limitation that for each positive number x in nums, there does not exist a combination of sums of negative numbers y_0, y_1, ..., y_n in nums such that -x = y_0 + y_1 + ... + y_n\\n\\nit is easy to see that if we do have this be the case then we will have a cycle that will lead to us having an infinite number of combinations. E.g if we have nums = [-1,1] and target = 0 then we can have an infinite number of sums such as (-1, 1,), (-1, -1, 1, 1), (-1, -1, -1, 1, 1, 1), .... and so on\\n\\nSo this is actually a really huge limitation on what negative numbers and positive numbers we will accept in our input. For example, if we have any positive number in nums, then we can never have a -1 in nums.\\n\\nIf we assume that our input abides by this limitation then one way we can solve the problem is to:\\niterate i=0..target and compute, dp[0] = 1, dp[i] += dp[i-num] for every positive num x, i >= x.\\niterate i=target..0, and compute dp[i] += dp[i-num] for every negative num x, i-x <= target"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "[@deCodeIt](/deCodeIt) Ohh so yeah you seem correct. Thanks\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Wait, won't there always exists a cycle ( a sub-combination summing to 0 ) if we get a negative number?\n\nWhat I mean is let's say n1 and n2 are two elements from nums where n1 is negative and n2 is positive. In this case won't there exist a combination a * n1 + b * n2 = 0 where a > 0 and b > 0 ( a is the number of times to repeat n1 and b is the number of times to repeat n2 in the combination)?\nEg. Let's take a = n2 and b = -n1 ( n1 is negative ), we get a combination which results in a sum 0 i.e. this combination could be repeated infinitely to generate infinite possible combinations in our result of combination which actually sum to the original target sum as adding the value 0 to target does not affect target value and is a valid combination.\n\nSo I believe even if a single negative number exists, it will lead to infinite number of solutions. Correct me If'm wrong."
                    },
                    {
                        "username": "grshlok",
                        "content": "Superb!!"
                    },
                    {
                        "username": "maimaihu",
                        "content": "Anyone has concise solution for this case? If we still need to use the same code, it will lead to infinite loop? how to fix it?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Scarletleaph",
                        "content": "base case .... ? A base case to break it"
                    },
                    {
                        "username": "newtt",
                        "content": "IMO this question is better to be named permutation sum."
                    },
                    {
                        "username": "mandy1339",
                        "content": "I thought this was going to be a *Coin Change II* clone. LOL It was Permutation instead"
                    }
                ]
            },
            {
                "id": 1567257,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 1719691,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 1568152,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 1567966,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 2049941,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 1576255,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 1571838,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 2050363,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 2049979,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 2049839,
                "content": [
                    {
                        "username": "chaos28",
                        "content": "\\nIn complete backpack problem, the 1D-array dp solution is a optimization of 2D-array dp solution.In the discuss , most solution is 1D-array dp solution, how to write the 2D-array dp solution just like the complete backpack problem?"
                    },
                    {
                        "username": "OmerAplatony",
                        "content": "Can someone explain why my intuition of using backtrack is wrong?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Backtracking is a very valid approach to many problems, particularly those involving combinations and permutations. It\\'s actually a common first instinct, and it can definitely be applied here. The idea would be to start with an empty combination and then, for each number in the input array, try adding it to the combination and see if it gets you closer to the target. If it does, you continue down that path; if it doesn\\'t, or if it overshoots the target, you backtrack and try the next number. \\n\\nThe problem with backtracking in this particular case, however, is that it can be very inefficient. Specifically, it can lead to a lot of repeated work. Imagine, for example, that the array contains the numbers 1 and 2, and the target is 1000. If you\\'re using backtracking, you might first try adding 1 to your combination a thousand times. Then, you might try adding 1 nine hundred and ninety-nine times and 2 once. Then 1 nine hundred and ninety-eight times and 2 twice. And so on. Each of these attempts involves a lot of repetition - a lot of adding the same numbers over and over again. \\n\\nDynamic programming, on the other hand, avoids this repetition by \"remembering\" previous results. It solves the problem for smaller sub-targets first, and then uses these solutions to build up to the solution for the larger target. So, in the example above, a dynamic programming solution would start by figuring out how many combinations sum to 1, then how many sum to 2, and so on, up to 1000. At each step, it can just look at the previous steps to see how many ways there are to make up the remainder after adding each possible number. \\n\\nSo while backtracking could certainly be used to solve this problem, dynamic programming is generally a more efficient approach."
                    },
                    {
                        "username": "sklisa",
                        "content": "Same question. Is it wrong or is it simply TLE"
                    },
                    {
                        "username": "zzzhe1990",
                        "content": "The tile states as \"combination sum\"; however, it does ask for permutations in the requirement. Well, this is forgivable since I do not see a big difference in the code; but the incorrect defination causes an unavoidable problem \"overflow issue\".\\n\\nA new test case is added \"[3,33,333] 10000\" and you can still pass the test case if you set the type of DP array as unsigned integer. \\nHowever, you will not be able to pass the test case \"[3,33,333] 10002\". We can expand this test case further to \"[3,33,333] 1000002\". \\nThere will be a valid result for sure because both 10002 and 1000002 can be completely divided by 3.\\n\\nConsidering this overflow issue, I guess that the problem should either add restrictions or change the requirement to real combination instead of permutation."
                    },
                    {
                        "username": "limestone",
                        "content": "What if negative numbers are allowed in the given array?\\nHow does it change the problem?\\nWhat limitation we need to add to the question to allow negative numbers?\\nI think the limitation is there could not be numbers pair like -1 and 1.\\nWho can give the answers to these 3 question? Thanks!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "I don\\'t think it\\'ll help e.g) Say array has 4 and -2 then again it\\'ll create same issue"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "DP week it is\\n"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "**Hello Guys **\\nif You are here for the solution then see the below code which is also the brute force solution of this problem.\\n![image](https://assets.leetcode.com/users/images/a3d55ee5-5071-430a-aeff-4756b4c848b8_1642491171.4047725.png)\\n**by the above you get TLE So we have to use Memorization.**\\n![image](https://assets.leetcode.com/users/images/7df69e01-800d-4165-a073-4fa30fe23435_1642491289.6971462.png)\\n**by the above code you can pass many test cases but when length of answer and no. of recursion calls are getting higher and then you again get a TLE So, we have to move towards our final code in which we use Bottom up approach(tabulation).**\\n![image](https://assets.leetcode.com/users/images/0aba8c89-f4a9-45e8-b471-2afbd1ac7dcf_1642492927.0151525.png)\\n**in above code we used Tabulation method As you can see and also we are doing mod % our dp table elements with 10e9+7 for getting the perfect answer.**\\n**At last if you get any type of help from this post then please let me know in comments because comments give motivation to make these type posts.**\\n**And Thank You.**"
                    },
                    {
                        "username": "shajalahamedcse",
                        "content": "For the first question it was a coin change problem .So i can choose element unlimited amount of times.But when the array is populated with negative numbers then we can not choose the numbers multiple time .Because that will generate infinite combination of configuration. So the problem converts from coin change to knapsack. Correct me ..if i am wrong."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track with your thinking!\\n\\nYou\\'re correct that when we introduce negative numbers into the problem, it can generate an infinite number of combinations. For example, if the target sum is 0, and we have -1 and 1 in the array, we can add an unlimited number of -1 and 1 pairs to achieve the target sum of 0, leading to infinite combinations.\\n\\nThis change certainly affects our problem and how we would approach it. The crux here is not merely the transition from a \"coin change\" to a \"knapsack\" problem, but in defining new constraints to handle the introduction of negative numbers to maintain a meaningful and solvable problem.\\n\\nOne way we could modify the problem to handle negative numbers would be to add a constraint such that each number in the array can only be used once. This turns the problem into a variation of the subset sum problem: we\\'re looking for subsets of the array that sum up to the target value. This also avoids the issue of infinite combinations since each number can only be used once. This problem can also be solved using dynamic programming, but with a different DP formulation than the one used for the original problem."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what does recursive solution give TLE? and how to choose the DP solution over recursive? (as in when I look at the problem I feel this is recursive, so how do I come up withe DP intuition. Anyone, Please help!  "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@pratgeesh1999](/pratgeesh1999) Yes, that is pretty much the way to go about it. But only you can decide whether or not **DP** will improve your solution. In this case, it does because you're going from an exponential time complexity ($$O(2^n)$$) to a complexity of $$O(target * n)$$, where `n` is the size of the input array. The brute force approach is exponential because you have only two choices for each candidate. You either take it or not."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What I do in my case, is write the recursive solution first. And then try memoization. Usually whenever the recursive method is returning an int or string(not void), dp comes to mind. \\nI look at the changing parameters/dp dimensions and make the nested for loops accordingly. I then copy the recursive call and see if it works. \\nHope it helps. "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "[@SSHshadow2222](/SSHshadow2222) So, what I am assuming is given a problem try to solve it using the intuitive approach, in this case the recursive and then if possible try to figure out if the same sub problem for which the solution has already been found in the previous steps would arise, if yes then Is that an indication that some sort of caching or rather storing solution to the previously solved sub problems would be ideal and hence in that case DP? ( Is this the way to go about figuring out if DP could be used for a given problem statement?)"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "What I understand by you saying recursive is the **brute force** approach, which is always the best place to start when solving this kind of problem. When drawing the **decision tree**, you will notice that subproblems repeat themselves, which means you produce the same result multiple times. This tells you that some form of caching will increase the performance of the overall algorithm, and that is the whole concept of **dynamic programming**, storing previously computed values for subproblems.\n\n*Note that you don't have to return the \"combinations\"; all you need to do is determine the total count.*"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found this to have best explanation https://leetcode.com/problems/combination-sum-iv/solutions/4020701/easy-dp-solution/"
                    },
                    {
                        "username": "Naga_Subramanian",
                        "content": "Will definitely learn combinations and permutations but not TODAY :("
                    }
                ]
            },
            {
                "id": 2049812,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 2044499,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1968497,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1954888,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1925439,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1759873,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1750477,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1696731,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1680417,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1624735,
                "content": [
                    {
                        "username": "_tushar_13",
                        "content": "**NEED HELP WITH THIS ** \\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums)==1 and target!=nums[0]:return 0\\n        ans=[];ds=[]\\n        def count(index,target,nums):\\n            if target==0:\\n                ans.append(ds[:])\\n                return \\n            if target < 0 or index >= len(nums):\\n                return\\n            ds.append(nums[index])\\n            count(index,target-nums[index],nums)\\n            ds.pop()\\n            count(index+1,target,nums)\\n        count(0,target,nums)\\n        print(ans)\\n        #return len(ans)*2-1 if 1 in nums  elselen(ans)*2     \\n"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It looks like you are trying to solve the problem using a recursive approach (backtracking). This solution seems to attempt to find all possible combinations and then count them. However, there are more efficient ways to solve the problem. If you want to try - this might work:\\n\\n\\nclass Solution:\\n    def combinationSum4(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 1 and target != nums[0]:\\n            return 0\\n        \\n        self.ans = 0\\n        \\n        def count(target):\\n            if target == 0:\\n                self.ans += 1\\n                return\\n            if target < 0:\\n                return\\n            \\n            for num in nums:\\n                count(target - num)\\n        \\n        count(target)\\n        \\n        return self.ans\\n\\n\\nAlthough this would technically work, it will be inefficient for larger values of target and nums due to repeated calculations. A dynamic programming approach will be much faster for larger inputs.\\n"
                    },
                    {
                        "username": "WE_VIBING",
                        "content": "change the word \"combination\" to \"permutation.\" otherwise it doesn\\'t make sense. you can see in the comments that not only it confuses everyone, but it\\'s also incorrect."
                    },
                    {
                        "username": "Popat_lal",
                        "content": "What is the difference between the this and coin change 2 problem ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s call Combination Sum IV as Problem A. It is about finding the number of combinations that sum up to a target. The Coin Change 2 problem (let\\'s call it Problem B), on the other hand, is also about finding the number of combinations of coins that can make up a certain amount. \\n\\nAt first glance, both problems seem similar because both involve finding combinations to reach a target sum. However, there are some key differences:\\n\\n1. **Order of selection matters in Problem A but not in Problem B**: In Problem A, [1,2] and [2,1] are considered two different combinations because the order in which the numbers are selected matters. But in Problem B, [1,2] and [2,1] are considered the same combination, because the order in which coins are selected doesn\\'t matter. \\n\\n2. **Different Definitions of \\'Combination\\'**: Because of the above point, these two problems use different definitions of \"combination\". In Problem A, a \"combination\" is a sequence where order matters. In Problem B, a \"combination\" is a set where order does not matter.\\n\\nThese differences affect how we approach solving the problems. Even though both can be solved using dynamic programming, the formulation of the DP problem would be different."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "How this question is different from unbounded knapsack problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Unbounded Knapsack problem and the Combination Sum IV problem both deal with the selection of items multiple times from a given set. However, there are fundamental differences between these two problems:\\n\\n1. **Objective**: The primary difference lies in what we are trying to maximize or achieve. In the Unbounded Knapsack problem, we\\'re trying to maximize the total value of items in the knapsack while not exceeding a specific weight limit. On the other hand, in the Combination Sum IV problem, we\\'re not trying to maximize or minimize anything. Instead, we\\'re trying to count the number of ways we can sum up to a specific target. \\n\\n2. **Order Matters**: In the Combination Sum IV problem, the order of the elements matters. This means that [1, 2] and [2, 1] are considered two distinct combinations. In contrast, in the Unbounded Knapsack problem, the order of selection doesn\\'t matter. It\\'s only the final collection of items (and their total value) that matters.\\n\\n3. **Output**: The output of the Unbounded Knapsack problem is the maximum value that can be carried in the knapsack. The output of the Combination Sum IV problem is the count of distinct combinations that can sum up to the target.\\n\\nThese differences necessitate different strategies for solving each problem. While dynamic programming can be used for both problems, the structure of the dynamic programming table and the way the solutions are built up will be different.\\n"
                    },
                    {
                        "username": "sobolxxx",
                        "content": "\"The test cases are generated so that the answer can fit in a 32-bit integer.\"\\nYeah, but this is misleading - the intermediate values don\\'t always fit in 32 bit signed int."
                    },
                    {
                        "username": "itshimashis",
                        "content": "why it cannot be solved as a 2d dp problem like on dp on subequences?.  like an unbounded knapsack one?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem could also be approached using a 2D dynamic programming similar to the unbounded knapsack problem. However, the reason we use a 1D DP approach instead of a 2D DP is to optimize space complexity.\\n\\nIn a 2D DP solution, you would create a 2D table where the row index represents the index of `nums` (let\\'s say `i`), and the column index represents all sums from `0` to `target` (let\\'s say `j`). Each cell would contain the count of combinations that can sum to `j` using numbers from `nums` up to index `i`. \\n\\nHowever, when you inspect the 2D table, you\\'ll realize that to fill the cell for `i` and `j`, you only need to look at the cell of the previous row (`i-1`) and the cell `nums[i]` columns before in the current row (`j-nums[i]`). This means that the solution for a particular `i` and `j` doesn\\'t depend on any other `i` and `j` except for the ones mentioned. \\n\\nSo, essentially, the count of combinations for a specific sum `j` only depends on the previous smaller sums, not on which numbers we have considered up to this point. This allows us to reduce the problem to a 1D DP solution, using a 1D table where the index `j` represents all sums from `0` to `target`, and each cell contains the count of combinations that sum to `j`.\\n\\nThis reduces our space complexity from O(`n` * `target`) in a 2D DP solution to just O(`target`) in a 1D DP solution, where `n` is the size of the `nums` array. Thus, for large inputs, the 1D DP solution would be more space-efficient."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "because [1,1,2] and [2,1,1] are counted different"
                    },
                    {
                        "username": "user9111KE",
                        "content": "Are there some similar question?    I want to practice..."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/): This problem requires you to find the minimum number of coins needed to form a certain amount. This is similar to the current problem as both use a dynamic programming solution and involve forming a target sum from a given set of numbers.\\n\\n2. [Perfect Squares (LeetCode 279)](https://leetcode.com/problems/perfect-squares/): This problem asks for the least number of perfect square numbers which sum to a given number. The concept is very similar, only that the set of numbers you can use are perfect squares. \\n\\n3. [Partition Equal Subset Sum (LeetCode 416)](https://leetcode.com/problems/partition-equal-subset-sum/): This problem involves determining if an array can be partitioned into two subsets such that the sums of elements in both subsets are equal. The knapsack pattern in dynamic programming used here is similar to the current problem.\\n\\n4. [Ones and Zeroes (LeetCode 474)](https://leetcode.com/problems/ones-and-zeroes/): This problem is a variant of the knapsack problem, where you\\'re asked to find the maximum number of strings you can form with a given number of zeros and ones.\\n\\n5. [Target Sum (LeetCode 494)](https://leetcode.com/problems/target-sum/): This problem asks you to find the number of ways to assign symbols to make the sum of numbers equal to target S. The dynamic programming approach used here is similar to the current problem.\\n\\n6. [Best Time to Buy and Sell Stock with Cooldown (LeetCode 309)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/): In this problem, you need to maximize your profit from stock transactions with a cooldown period. This requires similar dynamic programming strategies as in the current problem.\\n\\n7. [Coin Change 2 (LeetCode 518)](https://leetcode.com/problems/coin-change-2/): In this problem, you are asked to find the number of combinations that make up a certain amount. It\\'s similar because it\\'s another variant of the knapsack problem.\\n\\n8. [Unique Paths (LeetCode 62)](https://leetcode.com/problems/unique-paths/): This problem asks how many unique paths exist from top-left to bottom-right corner in a grid, which is similar because it involves counting possibilities using dynamic programming.\\n\\n9. [Decode Ways (LeetCode 91)](https://leetcode.com/problems/decode-ways/): This problem involves counting the number of ways to decode a string, a problem solved with dynamic programming.\\n\\n10. [Word Break (LeetCode 139)](https://leetcode.com/problems/word-break/): This problem requires determining whether a string can be segmented into space-separated words from a given dictionary. The approach to building up the solution through dynamic programming is similar."
                    },
                    {
                        "username": "yis13014",
                        "content": "follow up question: how to solve this without different sequences"
                    },
                    {
                        "username": "_persistent",
                        "content": "These should have been mentioned in question\\n1. each integer can be used infinite number of times\\n2. The question has the word \"combination\" confused with \"permutation\" (as clear from given example)"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "We can approach the problem by dividing into  the subproblem that how many combinations we can make from target-nums[0], target-nums[1]....... and so on. Specifically their addition will be the ans. Some edge cases are that if it goes out of bound(i.e., if target<nums[i]) and if target is 0 (i.e., no. of combinations of 0 is 1(default case) ).\\nHope it helps"
                    }
                ]
            },
            {
                "id": 1575813,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 1575161,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 1575635,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 2052336,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 2051851,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 2051625,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 2050948,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 2050812,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 2050787,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 2050781,
                "content": [
                    {
                        "username": "ramakrishna0201",
                        "content": "It should be named as` Permutation Sum `  .. AM i right??  \\n"
                    },
                    {
                        "username": "redgreenboo",
                        "content": "if we allow for negatives, theres potential for it to run away to infinite solutions,\\nfor example:\\nif the array is [-1,2] and n = 3\\nwe get all the permutations of (-1, 2, 2)\\nbut also  (-1,-1,-1,2,2,2)\\nand  (-1,-1,-1,-1,-1,2,2,2,2)\\netc... to any solution set you can append (-1,-1,2) since its sum is equal to zero.\\nIt seems that to make this problem viable with negative numbers, you would have to add the condition that there are no subsets that sum to 0?"
                    },
                    {
                        "username": "desai10",
                        "content": "[Please check my medium article for the solution!](https://medium.com/@isriramdesai/leetcode-combination-sum-iv-7ef1d5f19237)\\n\\nThis article explains the requirements of the problem, the things I concidered to solve the question, the solution it self, the time complexity analysis of this problem and the answer to the follow up question as well!"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "good article"
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Am I the only one to use Pascal\\'s Triangle to solve this one because of the previous day\\'s daily challenge? It\\'s probably needlessly complicated but it does work!"
                    },
                    {
                        "username": "itzBlue",
                        "content": " Why this brute force won't work?\n`\nclass Solution {\n\npublic:\n    int findans(vector<int>& nums, int i, int sum, int target) {\n        if(sum>target) return 0;\n        if(sum==target) return 1;\n        if(i>=nums.size()) return 0;\n        return findans(nums, i, sum+nums[i], target)+findans(nums, i+1, sum, target);\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return findans(nums, 0, 0, target);\n    }\n};\n`"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Notice the examples they gave you for array 1,2,3. One is 1,2,1 and 3,1. How are we choosing 1 which is i == 0 after our i == 1 and i == 2? It\\'s as if we are repeating the recursion all over again. \\n--> findans(nums, 0, sum+nums[i], target) \\nTry it now. Tell me if it works or if you have any questions!"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone tell whats wrong with this approach , it's not passing the first test case\n int solve(int i,int target,vector<int>& nums){\n        if(target==0) return 1;\n        if(i==0) return target%nums[0]==0?1:0;\n        int not_take=solve(i-1,target,nums);\n        int take=0;\n        if(nums[i]<=target) take=solve(i,target-nums[i],nums);\n        return take+not_take;\n\n    }\n    int combinationSum4(vector<int>& nums, int target) {\n        return solve(nums.size()-1,target,nums);   \n    }"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I am really sorry if I were unclear. The main answer to your first question:\\nIf you return 1 to a check of whether you can form target from nums[0], you will miss out on other ways, thus decreasing your answer.\\nThe main ans to your second question:\\nYou should enter the starting point of your first recursive as i as this will allow you to access elements before your current index."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "[@utkarsh_verma](/utkarsh_verma) I will answer your second question first. Look at the example of [1,2,3]. One combination was 1,2,1 and another was 3,1. How are we choosing elements that come before our current index. If our index is 1 while we are on element 2, why can we be able to choose element 1? Isn\\'t it as if the recursion is repeating itself over and over again? \\nWhen you enter i as the parameter in your take recursive, you are forcing the recursion to take the element you are standing on (i) or anything after it. \\nI hope you got this idea.\\nI do apologize for the misinformation about the modulus. Please, let me clarify my point. The problem with checking the modular and return 1 is that return value may be more than 1. Say, you have a target 6 and nums = [2] . You will check if 6%2 == 0 and return 1. Your answer is correct. But what if nums = [2,1] and target = 7? Now, your answer will be 4, but the correct ans is 21. Why so far off? \\nLet\\'s see: You start rec(n-1). If you try to make a list of lists and store all your combinations, you can see that all will be produced, but why aren\\'t we getting the correct answer? \\nBecause whenever i == 0, it returns only 1 when it should return all the possible ways to make target. So if we are at i == 0 and target = 6, instead of returning 1 for the way 2,2,2 can\\'t we return another 1 for 2,2,1,1 and another 1 for 2,1,1,2? \\nIf we were to return the recursion itself, could help count all possible ways??\\nI am really sorry for the lengthy replies. Tell me if I made it clear now. "
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": " target%nums[0]==0?1:0 means if the remaining target value is completely divisible by nums[0] then it would return 1 else 0 will be returned,  so 2%1 which is equal to 0 would return a 1 \\n\"   Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1\" but the index position for 2 in 1,2,3 is 1 so how would nums,length()-1 help? "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Look I think you have the idea correct. Your i in combinationSum4 is n-1, yes? Now, let\\'s say we are on i == 2 in 1,2,3 array and you didn\\'t take 3. Your i is 1, correct? Let\\'s decide to take 2, shouldn\\'t your i be nums.length-1? It should. But you entered i which means your i is now 1. (If this is what you want, feel free to ask why i should be n-1 not i). \\nThis means that we have to separate n from i. Hence include another variable in your recursive call such that i can be decremented alone in not_take and could return to n-1 in take:\\n\\nint solve(int i, int target, int n, vector& nums){\\n\\nFor this line: if(i==0) return target%nums[0]==0?1:0; \\nI have a question: Say we are in i == 0, and our target is now 2 in the 1,2,3 array, and 2%1 is 1, should we really return 0? Or can\\'t we return 1 if we took 1 twice?! \\nHence, the correct check in my opinion(u can experiment) is target >= nums[0] and if that\\'s correct call the method again. That\\'s what you return, because it could even be more than 1.\\n\\nif(i==0) return target%nums[0]==0?1:0;  SHOULD BE:\\nif(i==0){\\n            if(nums[0] <= target) return solve(n-1,target-nums[i],n,nums);\\n            return 0;\\n        };\\n\\nI hope I made it clear to you. Tell me if anything was unclear!"
                    },
                    {
                        "username": "ronlek",
                        "content": "How to solve the run time problem with signed integer overflow?\\n\\nHere\\'s my solution which is identical to the Java solutions\\n\\n```cpp\\nint tabulationCombinationSum4(vector<int> &nums, int target){\\n\\n        vector<int> dpTab(target + 1);\\n        dpTab[0] = 1;\\n        for(int combSum = 1; combSum < target + 1; ++combSum){\\n            for(int num: nums){\\n                if(combSum - num >= 0){\\n                    dpTab[combSum] += dpTab[combSum - num];\\n                }\\n            }\\n        }\\n\\n        return dpTab[target];\\n    }\\n```"
                    },
                    {
                        "username": "ronlek",
                        "content": "Turns out sum values can be very large. Using `unsigned long long` for the DP vector is the solution to this."
                    },
                    {
                        "username": "therealpx",
                        "content": "Could someone help me understand why a statement like this is true? `comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1]`. I understand if we have 1, 2, 3 in our array the only way we can get to 4 is through individual elements but that doesn\\'t mean we\\'ll actually get there? \\n\\nRegardless of the method, a lot of the solutions start from this as their base. I\\'m having a hard time wrapping my head around it because - say we\\'re trying to find combinations for target as 4 and we knew how many ways we can sum up to 1,2,3 i.e. target - nums[i] but adding them all still doesn\\'t mean they\\'ll add up to 4 right? we don\\'t seem to be checking for whether the sum actually equals 4. "
                    },
                    {
                        "username": "sergei99",
                        "content": "For any target t we calculate all paths leading to t, which means sum up all previously computed combinations for t - nums[i] for each i (if this produces a negative index, then the sum cannot be reached, so assume 0 as the corresponding term). The reachability of t is guaranteed by the way we choose the previous t\\'s: if the previous target = t-nums[i] is reachable in k ways, then t is also reachable in k ways via that target.\\nWe don\\'t check any actual sums, because we only store counts of paths, not sums."
                    },
                    {
                        "username": "ItiSingh",
                        "content": "this is a good question."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "good enough to make me scratch out my head"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yep!! Spent the last 10+ hours trying to solve it. I can\\'t tell you how beautiful that feeling is lol!!"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Suggested way to approach this problem is:\\n\\n- Create a LC list named `useless`.\\n- Add this problem to that list\\n- Now you can proceed further....\\n\\n**If you miss this method, you may never get the underlying logic.**"
                    }
                ]
            },
            {
                "id": 2050730,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050686,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050412,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050393,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050379,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050351,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050308,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050275,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050160,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050128,
                "content": [
                    {
                        "username": "HeavyValkyrie",
                        "content": "question quite similar to 322. Coin Change"
                    },
                    {
                        "username": "khushichauhan05",
                        "content": "someone pls tell me why my code is giving wrong answers \\nclass Solution {\\n    public int combinationSum4(int[] nums, int target) {\\n        \\n       return f(nums,target,nums.length-1);\\n        \\n    }\\n    public int f(int[] arr,int t,int n)\\n    {\\n        int x=0,z=0;\\n         if (n < 0) \\n         return 0;  \\n         if(t==0)\\n         {\\n        System.out.println(\"b\"+arr[n]);\\n        return 1;\\n         } \\n        if(arr[n]==t)\\n        {\\n          System.out.println(\"kfw\"+arr[n]);\\n          return 1;\\n        }\\n        if(arr[n]>t) return 0;\\n        if(t>=arr[n])\\n        x=f(arr,t-arr[n],n-1);\\n        if(t>=arr[n])\\n        z=f(arr,t-arr[n],n);\\n        int y=f(arr,t,n-1);\\n        return x+y+z;\\n    }\\n}"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Hello, I tried to pinpoint your mistakes. Here are some: \n1-) You should have an int index that will change when you don't pick an element. Separated from n.\n2-) No need for z. Because both x and z indicate you picked. You only need two var pick & not_pick.\n3-) Don't add too many checks. Checking if arr[ind] >= t and arr[n] == t etc.. Try to assess where the edge cases are, and apply checks on those only.\n\nSome of my personal notes are added to your code. I made your code work, so check if that helps you! Hope it does!!\n\n\n\nreturn f(nums.length-1, nums,target,nums.length);\n    \n}\n    public int f(int ind, int[] arr,int t,int n){\n        int x=0; //pick;\n        if (ind < 0) return 0; //ind NOT n, because we will\n        //use n as a constant while ind changes with every call\n        if(t==0) return 1;\n        if(ind == 0){ //This check is better than ind<0;\n          if(arr[ind] <= t){\n            \n            //if(arr[n] == t)\n            //This line isn't that accurate. We have a check that says if t >= arr[n];\n            //The line you wanted to write was where ind == 0 and arr[0] is <= t.\n            //Notice: arr[n] LESS than or =. Because this will take the element more than once.\n            //If t == 2 and arr[n] is 1, we can return 0 since 1 repeated twice is 2.\n\n            return f(n-1, arr, t-arr[ind], n); \n            //Notice how we didn't return 1. We called the method again in order to repeat recursion.\n          }\n          return 0;\n        }\n\n        //if(arr[ind] < t) return 0; No need. You already have x is 0. If x was >0 and you returned,\n        //you will not have a correct ans. \n\n        if(t >= arr[ind]) //You picked this element hence, ind goes back to starting point of\n        //recurrence (n-1);\n          x = f(n-1, arr, t-arr[ind], n);\n\n        //if(t >= arr[n])\n        //  z = f(arr, t-arr[n], n);\n\n        int y = f(ind-1,arr,t, n); //not_pick hence, ind--. Note: n stays the same always!\n        \n        return x+y;\n  }\n  //HOPE IT HELPS!!\n}"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Understanding the following **decision tree** is crucial to solving this problem, where each node represents the current target, and every green path is a solution for the overall result. At each step, we pick a candidate and move along with it. We only stop once we hit a target lower than 1.\n\n![](https://lh3.googleusercontent.com/u/0/drive-viewer/AITFw-yihXOLiwoRL3woKWZJbioNOOL3GhtoQde816xYoMKkNnp20g5U_S1cjGRcQoc3E5n1Pep36k2BL0gQjFDE7Vqe6_ku-A=w1920-h965)"
                    },
                    {
                        "username": "sidhartha1729",
                        "content": "what if there is a 0 in the list we will get infinite answers no matter what we do"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "That\\'s why the constraints say that nums[i]>= 1. "
                    },
                    {
                        "username": "SG-C",
                        "content": "Basic DP Question but not for me\\uD83E\\uDD72"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am a Beginner, Please suggest some tips to solve questions!"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@TasneemAyham](/TasneemAyham) thanks men!!!"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I am a beginner too. And I think you should do easy problems if you are going for brain teasers or easier programming concepts and problems to help with strengthening your coding/thinking abilities. \\nGo for medium problems when you learn concepts. I tried medium problems like this one before knowing about DP. All that did was demoralize me. Hence, I was searching YouTube for people who teach concepts, and I really enjoy TakeUForward. His videos explain the concept clearly and work to make you understand the question. Then he picks some questions and solves them with us. Like this problem. He explained ones like it, by recursion then optimizing by Memoization and Tabulation and finally Space Optimization. \\nOnly when you feel like you are confident with both Code AND Concept go for hard. \\nI hope this helps you!! \\nGood Luck!!"
                    },
                    {
                        "username": "natitati",
                        "content": "Start with really easy ones. When you feel comfortable, move onto medium ones and start doing daily questions (this is really helpful). Dont bump your head against the wall too much... if you can\\'t solve a question within 30-40 minutes, look at the solution, and try to understand it. I suggest - before looking at the solution tab, see if Neetcode (youtuber) has a solution to this problem. He explains really well."
                    },
                    {
                        "username": "natitati",
                        "content": "Pretty nice question. Took me 10 mins."
                    },
                    {
                        "username": "Pankaj_DTU",
                        "content": "those who are facing run time error with the tabuation method, try to assign the `vector<unsigned int> dp`. It will help in dealing integer overflow."
                    },
                    {
                        "username": "takavik",
                        "content": "Guys talk about backtracking, why my textbook does not drop a single word on it???"
                    },
                    {
                        "username": "hanjyun",
                        "content": "Could anyone help me find out why it FAIL with \"int\" type but PASS with \"unsigned int\" ?\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        // method: bottom up\\n        // dp[t] := the combination counts of target t\\n        vector<int> dp(target+1, 0);\\n        dp[0] = 1;\\n        for(int t = 1; t <= target; ++t) {\\n            for(int num : nums) {\\n                if(t-num >= 0) {\\n                    // PASS\\n                    dp[t] += static_cast<unsigned int>(dp[t-num]);\\n                    // FAIL\\n                    // dp[t] += dp[t-num];\\n                } \\n            }\\n        }\\n        return dp[target];\\n    }\\n};"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98) Learn a lesson, thanks"
                    },
                    {
                        "username": "hanjyun",
                        "content": "[@zhehui98](/zhehui98)  Thank you man!"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "zhehui98",
                        "content": "overflows will error out if you use `int`, but with `unsigned int` the result will be the remainder modulo 2^32-1.\\nif you use bottom-up you are calculating intermediate cases that may not be used for the final result, and those cases may overflow (but since they are not used, it doesn\\'t matter if you calculated the wrong result for those cases)"
                    }
                ]
            },
            {
                "id": 2050115,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2050114,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2050099,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2050066,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2050035,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2049947,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2049925,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2049866,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2049858,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2049852,
                "content": [
                    {
                        "username": "BogdanJava",
                        "content": "I was able to solve the question just by applying the general top-down DP pattern... Even without really realizing how the program is gonna work."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "[@SSHshadow2222](/SSHshadow2222) ++Flex;"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Flex++"
                    },
                    {
                        "username": "mathtsai",
                        "content": "I use long long dp[1001], and I get TLE.\\nIf I use unsigned int dp[1001], I will pass the 14th testcase.\\nCan anyone explain why this happened?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The C standard guarantees that UINT_MAX+1 will reliably wrap around to 0 but there is no guarantee that INT_MAX+1 will wrap around to INT_MIN (it can lead to unpredictable behaviour) so LeetCode traps it."
                    },
                    {
                        "username": "shlphw07",
                        "content": "Why is nobody realising that its \"N ways to reach a stair\" question?? Its the biggest hint!"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I realized it after reading your comments. before that I was struggling to find its solution. But with this approach my code beats only 28% in terms of speed . Hows your solution perform in term of speed.?"
                    },
                    {
                        "username": "shlphw07",
                        "content": "[@SSHshadow2222](/SSHshadow2222) Exactly, the first and most basic question of DP"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "We call that **dynamic programming** :)"
                    },
                    {
                        "username": "Premdwivedi",
                        "content": "I think it means that by using the given digits how many different numbers we can form whose digits adds up to the target number for eg 211, 121, and 112."
                    },
                    {
                        "username": "Jugalpatel",
                        "content": "I am stuck at this error :\\nLine 9: Char 23: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type \\'long long int\\' [solution.c]"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@Jugal Patel](/Jugalpatel) Use unsigned int. I was also facing similar issue."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed the long long int range - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "sukriti_05",
                        "content": "# Need Help, Run time error\\n\\n `\\nint combinationSum4(vector<int>& nums, int t) {\\n\\n            vector<int> next(t+1, 0);\\n            int n= nums.size();\\n            next[0]= 1;\\n\\n            for(int j=0; j<=t; j++){\\n                for(int i=0; i<n; i++){\\n                    if(nums[i]<=j){\\n                        next[j]= next[j]+next[j-nums[i]];\\n                    }\\n                }\\n            }\\n\\n            return next[t];\\n    }\\n\\n`\\n\\nGetting this error:-\\n\\nRuntime Error\\n14 / 15 testcases passed\\nLine 12: Char 41: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)"
                    },
                    {
                        "username": "VAINOI",
                        "content": "[@Sukriti Sood](/sukriti_05) can you explain your way you do, why its code can solve this problem?"
                    },
                    {
                        "username": "sukriti_05",
                        "content": "[@psionl0](/psionl0) Thanks, it\\'s resolved by using unsigned int."
                    },
                    {
                        "username": "psionl0",
                        "content": "Intermediate results can well exceed INT_MAX - even if the end result fits in a signed integer. Try modding your intermediate results with a large integer."
                    },
                    {
                        "username": "zhouzilong2020",
                        "content": "[1,2,1], [1,1,2], [2,1,1] are three different combinations??????????????????"
                    },
                    {
                        "username": "Pratheek08",
                        "content": "............"
                    },
                    {
                        "username": "user8272RT",
                        "content": "My initial approach was coin change, so I failed to produce a solution."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "thank god, there\\'s no negative number here, else infinity number of possible solutions will be there"
                    }
                ]
            },
            {
                "id": 2049849,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 2049846,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 2049843,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 2049836,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 2049817,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 2049811,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 2049769,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 1923610,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 1914134,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            },
            {
                "id": 1746029,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s permutation not combination"
                    },
                    {
                        "username": "s3stan",
                        "content": "Don\\'t forget that order matters. And this is the main thing in solving the problem"
                    },
                    {
                        "username": "SeineAle",
                        "content": "if you are facing the issue with signed int overflow, use unsigned int instead"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I\\'ve applied 1d DP on target\\nwhy am I getting TLE :(\\nhow can I optimize further\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The 2nd time there was no Hard on a weekend."
                    },
                    {
                        "username": "psionl0",
                        "content": "There is still 1 day left of the weekend."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "This overflow issue is nuts..."
                    },
                    {
                        "username": "mochy",
                        "content": "cloud saving \\uD83D\\uDC80"
                    },
                    {
                        "username": "VitrivDolkom",
                        "content": "Infinite amount of possible combinations if negative numbers are allowed"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "It is an easy problem. The issue you might face is integer overflow. It won\\'t go away even if you use long long. In this case just ignore those result, since it is mentioned that answer is within limits.\\n\\nFor eg., I used this check:\\n`dp[i-nums[j]]<INT_MAX-dp[i]`\\n"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "Can somebody identify the error\\n\\nat the if condition there is a runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\\n\\nint solveTabulation(vector<int>& nums, int target){\\n    vector<int>dp(target+1, 0);\\n    dp[0]=1;\\n    for(int i=1; i<=target; i++){ \\n        for(int j=0; j<nums.size(); j++){\\n            if(i-nums[j]>=0){   // to check valid index\\n                dp[i]+=dp[i-nums[j]];          \\n            }\\n        }       \\n    }\\n    return dp[target];\\n}\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error message you\\'re seeing, \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\'\", is a result of trying to store a value larger than the maximum limit of an integer in an integer variable. \\n\\nIn C++, the size of an integer (`int`) is 4 bytes, and it can store values from -2147483648 to 2147483647. If you try to store a value larger than 2147483647 in an integer variable, you get an integer overflow.\\n\\nIn your case, the problem seems to be with this line:\\n\\n`dp[i] += dp[i - nums[j]];`\\n\\nIf `dp[i - nums[j]]` is large enough, adding it to `dp[i]` can result in a value that exceeds the maximum limit for an integer.\\n\\nTo fix this, you could use a `long long int` for your `dp` array instead of `int`, as `long long int` can store much larger values. Here is how you can do it:\\n\\n```cpp\\nvector<long long int> dp(target+1, 0);\\n```\\n\\nIf you\\'re working with very large numbers, you might want to consider using modular arithmetic to avoid overflow. For example, if the problem statement allows, you could return the answer modulo 10^9+7 (a common modulus used in competitive programming). However, it\\'s important to remember to apply the modulus operation after every addition to prevent overflow:\\n\\n```cpp\\ndp[i] = (dp[i] + dp[i - nums[j]]) % 1000000007;\\n``` \\n\\nPlease make sure to check the problem requirements before using this approach."
                    },
                    {
                        "username": "makeller1",
                        "content": "The problem description says the *answer* will fit in a 32 bit int, but does not guarantee the sub problem solutions will. You must use unsigned long long int for your dp vector. "
                    },
                    {
                        "username": "Deep74",
                        "content": "if you get it right then plz write it here\\n"
                    },
                    {
                        "username": "Deep74",
                        "content": "same error\\n"
                    }
                ]
            }
        ]
    }
]