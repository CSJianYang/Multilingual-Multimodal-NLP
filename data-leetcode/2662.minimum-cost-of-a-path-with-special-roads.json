[
    {
        "title": "Determine the Winner of a Bowling Game",
        "question_content": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n\t2xi if the player hit 10 pins in any of the previous two turns.\n\tOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n\t1 if the score of player 1 is more than the score of player 2,\n\t2 if the score of player 2 is more than the score of player 1, and\n\t0 in case of a draw.\n\n&nbsp;\nExample 1:\n\nInput: player1 = [4,10,7,9], player2 = [6,5,2,3]\nOutput: 1\nExplanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.\nThe score of player2 is 6 + 5 + 2 + 3 = 16.\nScore of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.\n\nExample 2:\n\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\n\nExample 3:\n\nInput: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation: The score of player1 is 2 + 3 = 5\nThe score of player2 is 4 + 1 = 5\nThe score of player1 equals to the score of player2, so, there is a draw, and the answer is 0.\n\n&nbsp;\nConstraints:\n\n\tn == player1.length == player2.length\n\t1 <= n <= 1000\n\t0 <= player1[i], player2[i] <= 10",
        "solutions": [
            {
                "id": 3468463,
                "title": "explained-very-simple-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution</b>\\n# Approach\\n1. When ever we see a 10 update flag to 2 and keep decrementing it from next time.\\n2. When ever the flag is non zero then add the value with 2x ohterwise simply add it as it is.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getScore(vector<int>& player){\\n        int s = 0, f = 0;\\n        for(auto p:player){\\n            s += (f > 0)? 2*p: p;\\n            f--;\\n            if(p == 10) f = 2;\\n        }\\n        return s;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1 = getScore(player1), s2 = getScore(player2);\\n        if(s1 > s2) return 1;\\n        if(s1 < s2) return 2;\\n        return 0;\\n    }\\n};\\n```\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getScore(vector<int>& player){\\n        int s = 0, f = 0;\\n        for(auto p:player){\\n            s += (f > 0)? 2*p: p;\\n            f--;\\n            if(p == 10) f = 2;\\n        }\\n        return s;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1 = getScore(player1), s2 = getScore(player2);\\n        if(s1 > s2) return 1;\\n        if(s1 < s2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468269,
                "title": "day-395-easy-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tWe first initialize ans, s1, and  s2 to 0.  Ans will store the winner of the game, and  s1 and  s2 will store the total scores of players 1 and 2, respectively.\\n##### \\u2022\\tWe compute the total scores of players 1 and 2 by iterating over the elements of  p1 and  p2 and adding them to  s1 and  s2 , respectively.\\n##### \\u2022\\tIf the length of  p1   is greater than 1, we iterate over the elements of p1 and  p2 again, starting from the second element. For each element, we check if the previous element was a strike (score of 10) or a spare (sum of the previous two scores is 10). If either of these conditions is true, we add the current score to the total score of the corresponding player.\\n##### \\u2022\\tWe then compare the total scores of players 1 and 2. If they are equal, we set  ans  to 0, indicating a tie. If the total score of player 1 is greater than that of player 2, we set ans to 1, indicating that player 1 is the winner. Otherwise, we set  ans to 2, indicating that player 2 is the winner.\\n##### \\u2022\\tWe return  ans.\\n##### \\u2022\\tThe intuition behind this approach is that we can compute the total scores of players 1 and 2 by simply adding up the scores in their respective arrays. However, in the case of strikes and spares, the score of the current frame depends on the scores of the previous frames. Therefore, we need to iterate over the arrays again and adjust the scores accordingly. Once we have the total scores of both players, we can compare them to determine the winner of the game.\\n\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\n    public int isWinner(int[] p1, int[] p2) {\\n        int ans=0,s1=0,s2=0;\\n        int n=p1.length;\\n       for(int i=0;i<n;i++){\\n               s1+=p1[i];\\n               s2+=p2[i];\\n           }\\n        if(n>1) {\\n            for(int i=1;i<n;i++){\\n                if(p1[i-1]==10 ||((i>=2) && p1[i-2]==10))s1+=p1[i];\\n                if(p2[i-1]==10 ||((i>=2)&& p2[i-2]==10))s2+=p2[i];\\n            }\\n        }\\n        if(s1==s2) ans= 0;\\n        else if(s1>s2) ans= 1;\\n        else ans= 2;\\n        return ans;\\n        \\n    }\\n```\\n\\n```python []\\ndef isWinner(p1: List[int], p2: List[int]) -> int:\\n    ans, s1, s2 = 0, 0, 0\\n    n = len(p1)\\n    for i in range(n):\\n        s1 += p1[i]\\n        s2 += p2[i]\\n    if n > 1:\\n        for i in range(1, n):\\n            if p1[i - 1] == 10 or ((i >= 2) and p1[i - 2] == 10):\\n                s1 += p1[i]\\n            if p2[i - 1] == 10 or ((i >= 2) and p2[i - 2] == 10):\\n                s2 += p2[i]\\n    if s1 == s2:\\n        ans = 0\\n    elif s1 > s2:\\n        ans = 1\\n    else:\\n        ans = 2\\n    return ans\\n```\\n\\n```c++ []\\nint isWinner(vector<int>& p1, vector<int>& p2) {\\n    int ans = 0, s1 = 0, s2 = 0;\\n    int n = p1.size();\\n    for (int i = 0; i < n; i++) {\\n        s1 += p1[i];\\n        s2 += p2[i];\\n    }\\n    if (n > 1) {\\n        for (int i = 1; i < n; i++) {\\n            if (p1[i - 1] == 10 || ((i >= 2) && p1[i - 2] == 10)) {\\n                s1 += p1[i];\\n            }\\n            if (p2[i - 1] == 10 || ((i >= 2) && p2[i - 2] == 10)) {\\n                s2 += p2[i];\\n            }\\n        }\\n    }\\n    if (s1 == s2) {\\n        ans = 0;\\n    } else if (s1 > s2) {\\n        ans = 1;\\n    } else {\\n        ans = 2;\\n    }\\n    return ans;\\n}\\n```\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\n    public int isWinner(int[] p1, int[] p2) {\\n        int ans=0,s1=0,s2=0;\\n        int n=p1.length;\\n       for(int i=0;i<n;i++){\\n               s1+=p1[i];\\n               s2+=p2[i];\\n           }\\n        if(n>1) {\\n            for(int i=1;i<n;i++){\\n                if(p1[i-1]==10 ||((i>=2) && p1[i-2]==10))s1+=p1[i];\\n                if(p2[i-1]==10 ||((i>=2)&& p2[i-2]==10))s2+=p2[i];\\n            }\\n        }\\n        if(s1==s2) ans= 0;\\n        else if(s1>s2) ans= 1;\\n        else ans= 2;\\n        return ans;\\n        \\n    }\\n```\n```python []\\ndef isWinner(p1: List[int], p2: List[int]) -> int:\\n    ans, s1, s2 = 0, 0, 0\\n    n = len(p1)\\n    for i in range(n):\\n        s1 += p1[i]\\n        s2 += p2[i]\\n    if n > 1:\\n        for i in range(1, n):\\n            if p1[i - 1] == 10 or ((i >= 2) and p1[i - 2] == 10):\\n                s1 += p1[i]\\n            if p2[i - 1] == 10 or ((i >= 2) and p2[i - 2] == 10):\\n                s2 += p2[i]\\n    if s1 == s2:\\n        ans = 0\\n    elif s1 > s2:\\n        ans = 1\\n    else:\\n        ans = 2\\n    return ans\\n```\n```c++ []\\nint isWinner(vector<int>& p1, vector<int>& p2) {\\n    int ans = 0, s1 = 0, s2 = 0;\\n    int n = p1.size();\\n    for (int i = 0; i < n; i++) {\\n        s1 += p1[i];\\n        s2 += p2[i];\\n    }\\n    if (n > 1) {\\n        for (int i = 1; i < n; i++) {\\n            if (p1[i - 1] == 10 || ((i >= 2) && p1[i - 2] == 10)) {\\n                s1 += p1[i];\\n            }\\n            if (p2[i - 1] == 10 || ((i >= 2) && p2[i - 2] == 10)) {\\n                s2 += p2[i];\\n            }\\n        }\\n    }\\n    if (s1 == s2) {\\n        ans = 0;\\n    } else if (s1 > s2) {\\n        ans = 1;\\n    } else {\\n        ans = 2;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3468263,
                "title": "short-simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = 0, p2 = 0;\\n        for(int i=0; i<player1.length; i++){\\n            if((i == 1 && player1[i-1] == 10) || (i >= 2 && (player1[i-1] == 10 || player1[i-2] == 10)))    p1 += player1[i];\\n            if((i == 1 && player2[i-1] == 10) || (i >= 2 && (player2[i-1] == 10 || player2[i-2] == 10)))    p2 += player2[i];\\n            p1 += player1[i];\\n            p2 += player2[i];\\n        }\\n        return p1 == p2 ? 0 : p1 > p2 ? 1 : 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = 0, p2 = 0;\\n        for(int i=0; i<player1.length; i++){\\n            if((i == 1 && player1[i-1] == 10) || (i >= 2 && (player1[i-1] == 10 || player1[i-2] == 10)))    p1 += player1[i];\\n            if((i == 1 && player2[i-1] == 10) || (i >= 2 && (player2[i-1] == 10 || player2[i-2] == 10)))    p2 += player2[i];\\n            p1 += player1[i];\\n            p2 += player2[i];\\n        }\\n        return p1 == p2 ? 0 : p1 > p2 ? 1 : 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470369,
                "title": "python-3-6-lines-w-explanation-t-m-99-93",
                "content": "Here\\'s the intuition:\\nWe don\\'t care about the actual scores, just which player wins. We keep track of the accumulated difference on each round. We use booleans to remember whether either of the two previous rounds were strikes.\\n\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        isTen1 = isTen2 = wasTen1 = wasTen2 = False\\n        diff = 0\\n\\n        for n1, n2 in zip(player1, player2):\\n\\n            diff+= (1+(wasTen1|isTen1))*n1 - (1+(wasTen2|isTen2))*n2\\n \\n            isTen1,isTen2, wasTen1, wasTen2 = n1 == 10, n2 == 10,isTen1,isTen2 \\n\\n        return  (diff < 0) + (diff != 0)\\n```\\n[https://leetcode.com/problems/determine-the-winner-of-a-bowling-game/submissions/945548312/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        isTen1 = isTen2 = wasTen1 = wasTen2 = False\\n        diff = 0\\n\\n        for n1, n2 in zip(player1, player2):\\n\\n            diff+= (1+(wasTen1|isTen1))*n1 - (1+(wasTen2|isTen2))*n2\\n \\n            isTen1,isTen2, wasTen1, wasTen2 = n1 == 10, n2 == 10,isTen1,isTen2 \\n\\n        return  (diff < 0) + (diff != 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468294,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size(),n2=player2.size(),ans1=0,ans2=0,x1=0,x2=0;\\n        \\n        for(int i=0;i<n1;i++){\\n            ans1+=player1[i];\\n            ans2+=player2[i];\\n            \\n            if(x1){\\n                x1--;\\n                ans1+=player1[i];\\n            }\\n            if(x2){\\n                x2--;\\n                ans2+=player2[i];\\n            }\\n            if(player1[i] == 10){\\n                x1=2;\\n            }\\n            if(player2[i] == 10){\\n                x2=2; \\n            }\\n        }\\n        if(ans1 > ans2)\\n            return 1;\\n        else if(ans1 < ans2)\\n            return 2;\\n        else\\n            return 0;\\n    }\\n};\\n```\\n\\n\\n\\nPlease Upvote if it helps :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size(),n2=player2.size(),ans1=0,ans2=0,x1=0,x2=0;\\n        \\n        for(int i=0;i<n1;i++){\\n            ans1+=player1[i];\\n            ans2+=player2[i];\\n            \\n            if(x1){\\n                x1--;\\n                ans1+=player1[i];\\n            }\\n            if(x2){\\n                x2--;\\n                ans2+=player2[i];\\n            }\\n            if(player1[i] == 10){\\n                x1=2;\\n            }\\n            if(player2[i] == 10){\\n                x2=2; \\n            }\\n        }\\n        if(ans1 > ans2)\\n            return 1;\\n        else if(ans1 < ans2)\\n            return 2;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468280,
                "title": "easy-solution-python",
                "content": "**Python**\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        Stack_A = []\\n        stack_B = []\\n        aScore = 0\\n        bScore = 0\\n        for n,m in zip(player1,player2):\\n        \\n            if 10 in Stack_A[-2:]:\\n                aScore += 2*n\\n            else:\\n                aScore += n\\n            \\n            if 10 in stack_B[-2:]:\\n                bScore += 2*m\\n            else:\\n                bScore += m\\n            Stack_A.append(n)\\n            stack_B.append(m)\\n                \\n        if aScore == bScore:return 0\\n        return 1 if aScore > bScore else 2\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        Stack_A = []\\n        stack_B = []\\n        aScore = 0\\n        bScore = 0\\n        for n,m in zip(player1,player2):\\n        \\n            if 10 in Stack_A[-2:]:\\n                aScore += 2*n\\n            else:\\n                aScore += n\\n            \\n            if 10 in stack_B[-2:]:\\n                bScore += 2*m\\n            else:\\n                bScore += m\\n            Stack_A.append(n)\\n            stack_B.append(m)\\n                \\n        if aScore == bScore:return 0\\n        return 1 if aScore > bScore else 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468389,
                "title": "simplest-solution-just-do-what-is-asked",
                "content": "**Approach-->**\\n\\n**First loop** : just calculate player1 score by iterating and if previous 2 turns we get >=10 then multiply by2\\n**Second loop**: same for player 2\\n\\n##### NOTE: just done what is asked in problem \\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n    int o=0,t=0;\\n    \\n        for(int i=0;i<player1.size();i++){\\n            \\n            if(i>=1 and player1[i-1]>=10) o+=2*player1[i];  // just checking previous turn for 10 or greater\\n            else if(i>=2 and (player1[i-1]>=10 or player1[i-2]>=10)) o+=2*player1[i]; // checking previous 2 turn for a 10 or greater\\n            else o+=player1[i];   // else add that value\\n        }\\n     for(int i=0;i<player2.size();i++){\\n            \\n         if(i>=1 and player2[i-1]>=10) t+=2*player2[i];\\n           else if(i>=2 and (player2[i-1]>=10 or player2[i-2]>=10)) t+=2*player2[i];\\n            else t+=player2[i];\\n        }\\n    if(o>t) return 1;\\n    else if(t>o) return 2;\\n    else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n    int o=0,t=0;\\n    \\n        for(int i=0;i<player1.size();i++){\\n            \\n            if(i>=1 and player1[i-1]>=10) o+=2*player1[i];  // just checking previous turn for 10 or greater\\n            else if(i>=2 and (player1[i-1]>=10 or player1[i-2]>=10)) o+=2*player1[i]; // checking previous 2 turn for a 10 or greater\\n            else o+=player1[i];   // else add that value\\n        }\\n     for(int i=0;i<player2.size();i++){\\n            \\n         if(i>=1 and player2[i-1]>=10) t+=2*player2[i];\\n           else if(i>=2 and (player2[i-1]>=10 or player2[i-2]>=10)) t+=2*player2[i];\\n            else t+=player2[i];\\n        }\\n    if(o>t) return 1;\\n    else if(t>o) return 2;\\n    else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468311,
                "title": "c-solution-with-2-solutions",
                "content": "\\n\\n# first approach \\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int a = player1.size(), b = player2.size();\\n        \\n        int first = 0, second = 0, count = 0, i = 0;\\n        while (i < a) {\\n            if (player1[i] == 10) {\\n                count = 2;\\n                first += player1[i];\\n                i++;\\n                while (count != 0 && i < a) {\\n                    first += (2 * player1[i]);\\n                    count--;\\n                    if (player1[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                first += player1[i];\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        count = 0;\\n        while (i < b) {\\n            if (player2[i] == 10) {\\n                count = 2;\\n                second += player2[i];\\n                i++;\\n                while (count != 0 && i < b) {\\n                    second += (2 * player2[i]);\\n                    count--;\\n                    if (player2[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                second += player2[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (first > second) return 1;\\n        else if (first < second) return 2;\\n        else return 0;\\n    }\\n};\\n\\n```\\n# second approach \\n```\\n\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(player1.size() == 1) {\\n        if(player1[0] == player2[0]) {\\n            return 0;\\n        }\\n        return player1[0] > player2[0] ? 1 : 2;\\n    }\\n\\n    int sum1 = 0;\\n    int sum2 = 0;\\n\\n    sum1 += player1[0];\\n    sum2 += player2[0];\\n\\n    if(player1[0] == 10) {\\n        sum1 += (2 * player1[1]);\\n    } else {\\n        sum1 += player1[1];\\n    }\\n\\n    if(player2[0] == 10) {\\n        sum2 += (2 * player2[1]);\\n    } else {\\n        sum2 += player2[1];\\n    }\\n\\n    for(int i = 2; i < length; i++) {\\n        if(player1[i-1] == 10 || player1[i-2] == 10) {\\n            sum1 += (2 * player1[i]);\\n        } else {\\n            sum1 += player1[i];\\n        }\\n\\n        if(player2[i-1] == 10 || player2[i-2] == 10) {\\n            sum2 += (2 * player2[i]);\\n        } else {\\n            sum2 += player2[i];\\n        }\\n    }\\n\\n    if(sum1 == sum2) {\\n        return 0;\\n    }\\n\\n    return sum1 > sum2 ? 1 : 2;\\n}",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int a = player1.size(), b = player2.size();\\n        \\n        int first = 0, second = 0, count = 0, i = 0;\\n        while (i < a) {\\n            if (player1[i] == 10) {\\n                count = 2;\\n                first += player1[i];\\n                i++;\\n                while (count != 0 && i < a) {\\n                    first += (2 * player1[i]);\\n                    count--;\\n                    if (player1[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                first += player1[i];\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        count = 0;\\n        while (i < b) {\\n            if (player2[i] == 10) {\\n                count = 2;\\n                second += player2[i];\\n                i++;\\n                while (count != 0 && i < b) {\\n                    second += (2 * player2[i]);\\n                    count--;\\n                    if (player2[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                second += player2[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (first > second) return 1;\\n        else if (first < second) return 2;\\n        else return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468249,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player1[i-1]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }\\n                else\\n                {\\n                    sum1+=player1[i];\\n                }\\n            }\\n            else if(i>1)\\n            {\\n                if(player1[i-1]==10 || player1[i-2]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }\\n                else\\n                {\\n                    sum1+=player1[i];\\n                }\\n            }\\n            else\\n            {\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player2[i-1]==10)\\n                {\\n                    sum2+=(2*player2[i]);\\n                }\\n                else\\n                {\\n                    sum2+=player2[i];\\n                }\\n            }\\n            else if(i>1)\\n            {\\n                if(player2[i-1]==10 || player2[i-2]==10)\\n                {\\n                    sum2+=(2*player2[i]);\\n                }\\n                else\\n                {\\n                    sum2+=player2[i];\\n                }\\n            }\\n            else\\n            {\\n                sum2+=player2[i];\\n            }\\n        }\\n        return sum1>sum2 ? 1 : sum2>sum1 ? 2 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player1[i-1]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }\\n                else\\n                {\\n                    sum1+=player1[i];\\n                }\\n            }\\n            else if(i>1)\\n            {\\n                if(player1[i-1]==10 || player1[i-2]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }\\n                else\\n                {\\n                    sum1+=player1[i];\\n                }\\n            }\\n            else\\n            {\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player2[i-1]==10)\\n                {\\n                    sum2+=(2*player2[i]);\\n                }\\n                else\\n                {\\n                    sum2+=player2[i];\\n                }\\n            }\\n            else if(i>1)\\n            {\\n                if(player2[i-1]==10 || player2[i-2]==10)\\n                {\\n                    sum2+=(2*player2[i]);\\n                }\\n                else\\n                {\\n                    sum2+=player2[i];\\n                }\\n            }\\n            else\\n            {\\n                sum2+=player2[i];\\n            }\\n        }\\n        return sum1>sum2 ? 1 : sum2>sum1 ? 2 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471140,
                "title": "strike",
                "content": "It would be more interesting to implement the real bowling scoring.\\n\\n**C++**\\n```cpp\\nint score(vector<int>& pins, int strike = 0) {\\n    return accumulate(begin(pins), end(pins), 0, [&](int res, int p){\\n        res += p * (strike > 0 ? 2 : 1);\\n        strike = p == 10 ? 2 : strike - 1;\\n        return res;\\n    });\\n}\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n    int s1 = score(player1), s2 = score(player2);\\n    return s1 > s2 ? 1 : s1 < s2 ? 2 : 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint score(vector<int>& pins, int strike = 0) {\\n    return accumulate(begin(pins), end(pins), 0, [&](int res, int p){\\n        res += p * (strike > 0 ? 2 : 1);\\n        strike = p == 10 ? 2 : strike - 1;\\n        return res;\\n    });\\n}\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n    int s1 = score(player1), s2 = score(player2);\\n    return s1 > s2 ? 1 : s1 < s2 ? 2 : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3470681,
                "title": "beats-100-in-runtime-and-space-solution-in-java-simple-and-easy",
                "content": "![image.png](https://assets.leetcode.com/users/images/6c7c44b5-f7d2-4821-ad7e-687f9f08cf6f_1682875832.839368.png)\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=player1[0], sum2=player2[0];\\n        for(int i=1; i<player1.length; i++){\\n            if(i==1){\\n                if(player1[i-1]==10) sum1+=2*player1[i];\\n                else sum1+=player1[i];\\n                \\n                if(player2[i-1]==10) sum2+=2*player2[i];\\n                else sum2+=player2[i];\\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10) sum1+=2*player1[i];\\n                else sum1+=player1[i];\\n                \\n                if(player2[i-1]==10 || player2[i-2]==10) sum2+=2*player2[i];\\n                else sum2+=player2[i];\\n            }      \\n        }\\n        if(sum2>sum1) return 2;\\n        else if(sum1>sum2) return 1;\\n        return 0;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/0c40297b-fcdb-42e1-9a4e-b8b80120f9ee_1682876025.9059646.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=player1[0], sum2=player2[0];\\n        for(int i=1; i<player1.length; i++){\\n            if(i==1){\\n                if(player1[i-1]==10) sum1+=2*player1[i];\\n                else sum1+=player1[i];\\n                \\n                if(player2[i-1]==10) sum2+=2*player2[i];\\n                else sum2+=player2[i];\\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10) sum1+=2*player1[i];\\n                else sum1+=player1[i];\\n                \\n                if(player2[i-1]==10 || player2[i-2]==10) sum2+=2*player2[i];\\n                else sum2+=player2[i];\\n            }      \\n        }\\n        if(sum2>sum1) return 2;\\n        else if(sum1>sum2) return 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469164,
                "title": "easy-to-understand-beginner-friendly-code",
                "content": "# Intuition \\n\\nBrute force thinking simply did what question asked step by step\\n\\n# Approach \\nAt each index we know score has to be added atleast one time so increase the score of player by the value. Then check if any of the previous 2 value of a player is 10 then again add the value in his total score.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n=player1.size();\\n        int score1=player1[0];\\n        int score2=player2[0];\\n        for(int i=1;i<n;i++){\\n            score1+=player1[i];\\n            score2+=player2[i];\\n            if(i==1){\\n                if( player1[0]==10) score1+=player1[1];         \\n                if(player2[0]==10) score2+=player2[1];          \\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10){\\n                    score1+=player1[i];\\n                }\\n                if(player2[i-1]==10 || player2[i-2]==10){\\n                    score2+=player2[i];\\n                }\\n            }\\n        }\\n        if(score1==score2)return 0;\\n        else if(score1>score2) return 1;\\n        else return 2;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n=player1.size();\\n        int score1=player1[0];\\n        int score2=player2[0];\\n        for(int i=1;i<n;i++){\\n            score1+=player1[i];\\n            score2+=player2[i];\\n            if(i==1){\\n                if( player1[0]==10) score1+=player1[1];         \\n                if(player2[0]==10) score2+=player2[1];          \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3469116,
                "title": "c-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& p1, vector<int>& p2) {\\n        int a = 0, b = 0;\\n        for(int i = 0; i < p1.size(); i++) {\\n            if(i == 0) {\\n                a += p1[i];\\n                b += p2[i];\\n            }\\n            else {\\n                if(i == 1) {\\n                    if(p1[i - 1] == 10) a += (2 * p1[i]);\\n                    else a += p1[i];\\n                    if(p2[i - 1] == 10) b += (2 * p2[i]);\\n                    else b += p2[i];\\n                }\\n                else {\\n                    if(p1[i - 1] == 10 || p1[i - 2] == 10) a += (2 * p1[i]);\\n                    else a += p1[i];\\n                    if(p2[i - 1] == 10 || p2[i - 2] == 10) b += (2 * p2[i]);\\n                    else b += p2[i];\\n                }\\n            }\\n        }\\n        if(a > b) return 1;\\n        if(a < b) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& p1, vector<int>& p2) {\\n        int a = 0, b = 0;\\n        for(int i = 0; i < p1.size(); i++) {\\n            if(i == 0) {\\n                a += p1[i];\\n                b += p2[i];\\n            }\\n            else {\\n                if(i == 1) {\\n                    if(p1[i - 1] == 10) a += (2 * p1[i]);\\n                    else a += p1[i];\\n                    if(p2[i - 1] == 10) b += (2 * p2[i]);\\n                    else b += p2[i];\\n                }\\n                else {\\n                    if(p1[i - 1] == 10 || p1[i - 2] == 10) a += (2 * p1[i]);\\n                    else a += p1[i];\\n                    if(p2[i - 1] == 10 || p2[i - 2] == 10) b += (2 * p2[i]);\\n                    else b += p2[i];\\n                }\\n            }\\n        }\\n        if(a > b) return 1;\\n        if(a < b) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468312,
                "title": "java-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int isWinner(int[] player1, int[] player2) {\\n    int n = player1.length, p1, p2;\\n    \\n    for (var i=0; i<n; i++) {\\n      p1 += player1[i];\\n      p2 += player2[i];\\n      \\n      if ((i>0 && player1[i-1] == 10) ||\\n          (i>1 && player1[i-2] == 10))\\n        p1 += player1[i];\\n      \\n      if ((i>0 && player2[i-1] == 10) ||\\n          (i>1 && player2[i-2] == 10))\\n        p2 += player2[i];\\n    }\\n    return p1 == p2 ? 0 : (p1 > p2 ? 1 : 2);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  public int isWinner(int[] player1, int[] player2) {\\n    int n = player1.length, p1, p2;\\n    \\n    for (var i=0; i<n; i++) {\\n      p1 += player1[i];\\n      p2 += player2[i];\\n      \\n      if ((i>0 && player1[i-1] == 10) ||\\n          (i>1 && player1[i-2] == 10))\\n        p1 += player1[i];\\n      \\n      if ((i>0 && player2[i-1] == 10) ||\\n          (i>1 && player2[i-2] == 10))\\n        p2 += player2[i];\\n    }\\n    return p1 == p2 ? 0 : (p1 > p2 ? 1 : 2);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492083,
                "title": "math-easy-to-understand-c",
                "content": "# Intuition\\nCHECK FOR i-1 or i-2 there is 10 or not if yes than increment player score 2*v[i] else v[i]\\n\\n# Approach\\nsimple linear traversal\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n(1))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& v1, vector<int>& v2) {\\n        int x = v1[0], y = v2[0];//for size 1 score = index 0 score\\n        i = 0, n = v1.size();\\n        for(i = 1; i < n; i++){\\n            if(i==1){//for index 1 check for index 0\\n                if(v1[i-1]==10)x += v1[i]*2;\\n                else x += v1[i];\\n                if(v2[i-1]==10)y += v2[i]*2;\\n                else y += v2[i];\\n            }else{//for other indexs check for i-1 || i-2\\n                if(v1[i-1]==10||v1[i-2]==10)x += v1[i]*2;\\n                else x += v1[i];\\n                if(v2[i-1]==10||v2[i-2]==10)y += v2[i]*2;\\n                else y += v2[i];\\n            }\\n        }\\n        if(x>y)return 1;\\n        if(y>x)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& v1, vector<int>& v2) {\\n        int x = v1[0], y = v2[0];//for size 1 score = index 0 score\\n        i = 0, n = v1.size();\\n        for(i = 1; i < n; i++){\\n            if(i==1){//for index 1 check for index 0\\n                if(v1[i-1]==10)x += v1[i]*2;\\n                else x += v1[i];\\n                if(v2[i-1]==10)y += v2[i]*2;\\n                else y += v2[i];\\n            }else{//for other indexs check for i-1 || i-2\\n                if(v1[i-1]==10||v1[i-2]==10)x += v1[i]*2;\\n                else x += v1[i];\\n                if(v2[i-1]==10||v2[i-2]==10)y += v2[i]*2;\\n                else y += v2[i];\\n            }\\n        }\\n        if(x>y)return 1;\\n        if(y>x)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469409,
                "title": "python-elegant-short",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player_a: List[int], player_b: List[int]) -> int:\\n        score_a = self.get_score(player_a)\\n        score_b = self.get_score(player_b)\\n\\n        return {\\n            score_a > score_b: 1,\\n            score_a < score_b: 2,\\n        }.get(True, 0)\\n\\n    @staticmethod\\n    def get_score(player: List[int]) -> int:\\n        score = 0\\n\\n        for i, sc in enumerate(player):\\n            if i > 0 and player[i - 1] == 10:\\n                score += 2 * sc\\n            elif i > 1 and player[i - 2] == 10:\\n                score += 2 * sc\\n            else:\\n                score += sc\\n\\n        return score\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player_a: List[int], player_b: List[int]) -> int:\\n        score_a = self.get_score(player_a)\\n        score_b = self.get_score(player_b)\\n\\n        return {\\n            score_a > score_b: 1,\\n            score_a < score_b: 2,\\n        }.get(True, 0)\\n\\n    @staticmethod\\n    def get_score(player: List[int]) -> int:\\n        score = 0\\n\\n        for i, sc in enumerate(player):\\n            if i > 0 and player[i - 1] == 10:\\n                score += 2 * sc\\n            elif i > 1 and player[i - 2] == 10:\\n                score += 2 * sc\\n            else:\\n                score += sc\\n\\n        return score\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468562,
                "title": "easy-and-simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntraverse and check the previous 2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-here we set a variable named \\'set\\' that works when it is near the 2 or 1 only as it is moving forward it will decrease \\n-use this in the function and check for the both the vectors\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getcount(vector<int>& a)\\n    {\\n        int count=0,set=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(set)\\n            {\\n                count+=2*a[i];\\n                set--;\\n            }\\n            else\\n            {\\n                count+=a[i];\\n            }\\n            if(a[i]==10)\\n            set=2;\\n        }\\n        return count;\\n\\n    }\\n\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n        int first=getcount(player1);\\n        int second=getcount(player2);\\n        if(first>second)\\n        return 1;\\n        else if(second>first)\\n        return 2;\\n        return 0;        \\n    }\\n};\\n```\\n# upvote me if you like the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/104d4992-67f5-4b9b-aab4-0b17af99b548_1682830426.6456287.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getcount(vector<int>& a)\\n    {\\n        int count=0,set=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(set)\\n            {\\n                count+=2*a[i];\\n                set--;\\n            }\\n            else\\n            {\\n                count+=a[i];\\n            }\\n            if(a[i]==10)\\n            set=2;\\n        }\\n        return count;\\n\\n    }\\n\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n        int first=getcount(player1);\\n        int second=getcount(player2);\\n        if(first>second)\\n        return 1;\\n        else if(second>first)\\n        return 2;\\n        return 0;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468480,
                "title": "easy-short-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] p1, int[] p2) {\\n        int a1=0, a2=0;\\n            for(int i=0; i<p1.length; i++){\\n                a1+= p1[i];\\n                a2+= p2[i];  \\n                a1 += i>0 && p1[i-1] == 10 || i>1 && p1[i-2] ==10 ? p1[i]: 0;                  \\n                a2 += i>0 && p2[i-1] == 10 || i>1 && p2[i-2] ==10 ? p2[i]: 0;\\n            }\\n             return a1>a2 ? 1 : (a2>a1 ? 2 : 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] p1, int[] p2) {\\n        int a1=0, a2=0;\\n            for(int i=0; i<p1.length; i++){\\n                a1+= p1[i];\\n                a2+= p2[i];  \\n                a1 += i>0 && p1[i-1] == 10 || i>1 && p1[i-2] ==10 ? p1[i]: 0;                  \\n                a2 += i>0 && p2[i-1] == 10 || i>1 && p2[i-2] ==10 ? p2[i]: 0;\\n            }\\n             return a1>a2 ? 1 : (a2>a1 ? 2 : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468446,
                "title": "c-best-solution-100-faster-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n         int cnt1=0, cnt2=0, player1_Value=0, player2_Value=0;\\n        \\n        for(int i=0; i<player1.size(); i++) {\\n            if(cnt1 > 0)    {\\n                player1_Value += (2*player1[i]);\\n                cnt1--;\\n            }\\n            else    player1_Value += player1[i];\\n            if(player1[i] == 10)    cnt1 = 2;\\n            \\n            if(cnt2 > 0)    {\\n                player2_Value += (2*player2[i]);\\n                cnt2--;\\n            }\\n            else    player2_Value += player2[i];\\n            if(player2[i] == 10)    cnt2 = 2;\\n        }\\n        \\n        if(player1_Value == player2_Value)    return 0;\\n        if(player1_Value > player2_Value)     return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n         int cnt1=0, cnt2=0, player1_Value=0, player2_Value=0;\\n        \\n        for(int i=0; i<player1.size(); i++) {\\n            if(cnt1 > 0)    {\\n                player1_Value += (2*player1[i]);\\n                cnt1--;\\n            }\\n            else    player1_Value += player1[i];\\n            if(player1[i] == 10)    cnt1 = 2;\\n            \\n            if(cnt2 > 0)    {\\n                player2_Value += (2*player2[i]);\\n                cnt2--;\\n            }\\n            else    player2_Value += player2[i];\\n            if(player2[i] == 10)    cnt2 = 2;\\n        }\\n        \\n        if(player1_Value == player2_Value)    return 0;\\n        if(player1_Value > player2_Value)     return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468342,
                "title": "time-o-n-space-o-1-c-simple-easy-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int x = 0, y = 0;\\n        int i = 0, n = player1.size();\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                x += player1[i];\\n            }else if(i==1){\\n                if(player1[i-1]==10){\\n                    x += player1[i]*2;\\n                }else{\\n                    x += player1[i];\\n                }\\n            }else{\\n                if(player1[i-1]==10||player1[i-2]==10){\\n                    x += player1[i]*2;\\n                }else{\\n                    x += player1[i];\\n                }\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                y += player2[i];\\n            }else if(i==1){\\n                if(player2[i-1]==10){\\n                    y += player2[i]*2;\\n                }else{\\n                    y += player2[i];\\n                }\\n            }else{\\n                if(player2[i-1]==10||player2[i-2]==10){\\n                    y += player2[i]*2;\\n                }else{\\n                    y += player2[i];\\n                }\\n            }\\n        }\\n        cout<<x<<\" \"<<y;\\n        if(x>y)return 1;\\n        else if(x<y)return 2;\\n        return 0;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int x = 0, y = 0;\\n        int i = 0, n = player1.size();\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                x += player1[i];\\n            }else if(i==1){\\n                if(player1[i-1]==10){\\n                    x += player1[i]*2;\\n                }else{\\n                    x += player1[i];\\n                }\\n            }else{\\n                if(player1[i-1]==10||player1[i-2]==10){\\n                    x += player1[i]*2;\\n                }else{\\n                    x += player1[i];\\n                }\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                y += player2[i];\\n            }else if(i==1){\\n                if(player2[i-1]==10){\\n                    y += player2[i]*2;\\n                }else{\\n                    y += player2[i];\\n                }\\n            }else{\\n                if(player2[i-1]==10||player2[i-2]==10){\\n                    y += player2[i]*2;\\n                }else{\\n                    y += player2[i];\\n                }\\n            }\\n        }\\n        cout<<x<<\" \"<<y;\\n        if(x>y)return 1;\\n        else if(x<y)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468309,
                "title": "c-solutions-easy-to-understand-full-explanaiton-line-by-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is written to solve a problem related to a game of bowling. The function isWinner takes in two vectors, player1 and player2, that represent the scores of the two players in the game.\\n\\nThe fn lambda function calculates the total score for a given player\\'s vector. It does so by iterating through each frame and adding up the scores. If the current frame is a strike or spare, it adds bonus points accordingly.\\n\\nThe isWinner function then calculates the score difference between player1 and player2 by calling the fn function for each player\\'s vector. If player1\\'s score is greater, it returns 1 to indicate that player1 wins. If player2\\'s score is greater, it returns 2 to indicate that player2 wins. If both scores are equal, it returns 0 to indicate a tie.\\n\\nOverall, the code is intuitive in its approach and easy to understand. It uses lambda functions to reduce code duplication and improve readability. The use of simple if-else statements to determine the winner based on score difference is straightforward and easy to follow.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code defines a function named isWinner that takes two vectors player1 and player2 representing the scores of two players in a game of bowling.\\n\\nThe function first defines a lambda function named fn that takes an integer vector as an argument. This lambda function iterates over each element of the vector and adds up the score for each frame. If the current frame is a strike (10 pins knocked down on the first ball) or a spare (10 pins knocked down in two balls), it adds extra points accordingly. The lambda function returns the total score for the given vector.\\n\\nThe isWinner function then calls the fn function with player1 and player2 vectors to calculate their respective scores. It then calculates the difference between the two scores and returns 1 if player1 wins, 2 if player2 wins, and 0 if it\\'s a tie.\\n\\nOverall, the code follows a simple approach to calculate the total scores for both players and determine the winner based on their score difference. The use of a lambda function makes the code more concise and reusable, allowing the fn function to be called multiple times with different vectors.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe fn lambda function iterates over each element of the vector and performs a constant amount of work for each element. Therefore, the time complexity of fn is O(n), where n is the length of the input vector.\\n\\nThe isWinner function calls fn twice and performs a constant amount of additional work to calculate the score difference and determine the winner. Therefore, the time complexity of isWinner is O(n), where n is the length of the input vectors.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe fn lambda function does not allocate any additional memory other than the input vector. Therefore, the space complexity of fn is O(1).\\n\\nThe isWinner function uses a constant amount of additional memory to store the scores and score difference. Therefore, the space complexity of isWinner is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Define a function named isWinner that takes two integer vectors as arguments\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n    // Define a lambda function named fn that takes an integer vector as an argument\\n    auto fn = [&](vector<int>& p) {\\n        // Initialize a variable named ans to 0\\n        int ans = 0; \\n        // Loop through each element of the vector\\n        for (int i = 0; i < p.size(); ++i) {\\n            // Add the current element to ans\\n            ans += p[i]; \\n            // If the previous element is 10, add the current element to ans\\n            // If the element two positions back is 10, add the current element to ans\\n            if (i && p[i-1] == 10 || i >= 2 && p[i-2] == 10) ans += p[i]; \\n        }\\n        // Return the value of ans\\n        return ans; \\n    }; \\n    \\n    // Calculate the score of player1 by calling the fn function with player1 vector\\n    int player1_score = fn(player1);\\n    // Calculate the score of player2 by calling the fn function with player2 vector\\n    int player2_score = fn(player2);\\n    \\n    // Calculate the difference between the two scores\\n    int score_diff = player1_score - player2_score; \\n    // If player1\\'s score is greater than player2\\'s score, return 1 (player1 wins)\\n    if (score_diff > 0) return 1; \\n    // If player2\\'s score is greater than player1\\'s score, return 2 (player2 wins)\\n    else if (score_diff < 0) return 2; \\n    // If both scores are equal, return 0 (tie)\\n    return 0; \\n}\\n\\n};\\n```\\n\\n\\n\\n\\n\\n# Code without comments\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        auto fn = [&](vector<int>& p) {\\n            int ans = 0; \\n            for (int i = 0; i < p.size(); ++i) {\\n                ans += p[i]; \\n                if (i && p[i-1] == 10 || i >= 2 && p[i-2] == 10) ans += p[i]; \\n            }\\n            return ans; \\n        }; \\n        \\n        int x = fn(player1) - fn(player2); \\n        if (x > 0) return 1; \\n        else if (x < 0) return 2; \\n        return 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a function named isWinner that takes two integer vectors as arguments\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n    // Define a lambda function named fn that takes an integer vector as an argument\\n    auto fn = [&](vector<int>& p) {\\n        // Initialize a variable named ans to 0\\n        int ans = 0; \\n        // Loop through each element of the vector\\n        for (int i = 0; i < p.size(); ++i) {\\n            // Add the current element to ans\\n            ans += p[i]; \\n            // If the previous element is 10, add the current element to ans\\n            // If the element two positions back is 10, add the current element to ans\\n            if (i && p[i-1] == 10 || i >= 2 && p[i-2] == 10) ans += p[i]; \\n        }\\n        // Return the value of ans\\n        return ans; \\n    }; \\n    \\n    // Calculate the score of player1 by calling the fn function with player1 vector\\n    int player1_score = fn(player1);\\n    // Calculate the score of player2 by calling the fn function with player2 vector\\n    int player2_score = fn(player2);\\n    \\n    // Calculate the difference between the two scores\\n    int score_diff = player1_score - player2_score; \\n    // If player1\\'s score is greater than player2\\'s score, return 1 (player1 wins)\\n    if (score_diff > 0) return 1; \\n    // If player2\\'s score is greater than player1\\'s score, return 2 (player2 wins)\\n    else if (score_diff < 0) return 2; \\n    // If both scores are equal, return 0 (tie)\\n    return 0; \\n}\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        auto fn = [&](vector<int>& p) {\\n            int ans = 0; \\n            for (int i = 0; i < p.size(); ++i) {\\n                ans += p[i]; \\n                if (i && p[i-1] == 10 || i >= 2 && p[i-2] == 10) ans += p[i]; \\n            }\\n            return ans; \\n        }; \\n        \\n        int x = fn(player1) - fn(player2); \\n        if (x > 0) return 1; \\n        else if (x < 0) return 2; \\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825291,
                "title": "python-3-simulation-beats-100-234ms",
                "content": "```python3 []\\nclass Solution:\\n    def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res\\n\\n        s1, s2 = getSum(player1), getSum(player2)\\n\\n        if s2 > s1: return 2\\n        if s1 > s2: return 1\\n        return 0\\n```\\n![Screenshot 2023-07-27 at 21.20.20.png](https://assets.leetcode.com/users/images/ed58e8d4-873d-4fcd-8c2d-d909cfd2514a_1690482073.2618957.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res\\n\\n        s1, s2 = getSum(player1), getSum(player2)\\n\\n        if s2 > s1: return 2\\n        if s1 > s2: return 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470872,
                "title": "determine-the-winner-of-a-bowling-game-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int i, p1=0, p2=0;\\n\\n        // Player 1 points\\n        for(i=0 ; i<player1.size() ; i++)\\n        {\\n            if((i>=1 && player1[i-1]==10) || (i>=2 && player1[i-2]==10))\\n            {\\n                p1 += 2*player1[i];\\n            }\\n            else\\n            {\\n                p1 += player1[i];\\n            }\\n        }\\n\\n        // Player 2 points\\n        for(i=0 ; i<player2.size() ; i++)\\n        {\\n            if((i>=1 && player2[i-1]==10) || (i>=2 && player2[i-2]==10))\\n            {\\n                p2 += 2*player2[i];\\n            }\\n            else\\n            {\\n                p2 += player2[i];\\n            }\\n        }\\n\\n        //Results\\n        if(p1>p2)\\n            return 1;\\n        else if(p1==p2)\\n            return 0;\\n        return 2;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6ec5af97-5e28-494f-a4bc-96daa77317ce_1682879966.8972776.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int i, p1=0, p2=0;\\n\\n        // Player 1 points\\n        for(i=0 ; i<player1.size() ; i++)\\n        {\\n            if((i>=1 && player1[i-1]==10) || (i>=2 && player1[i-2]==10))\\n            {\\n                p1 += 2*player1[i];\\n            }\\n            else\\n            {\\n                p1 += player1[i];\\n            }\\n        }\\n\\n        // Player 2 points\\n        for(i=0 ; i<player2.size() ; i++)\\n        {\\n            if((i>=1 && player2[i-1]==10) || (i>=2 && player2[i-2]==10))\\n            {\\n                p2 += 2*player2[i];\\n            }\\n            else\\n            {\\n                p2 += player2[i];\\n            }\\n        }\\n\\n        //Results\\n        if(p1>p2)\\n            return 1;\\n        else if(p1==p2)\\n            return 0;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469173,
                "title": "python3-straightforward-solution-with-explanation",
                "content": "We want to calculate the sum of all scores, while doubling the next two scores if we meet 10. To do this, we iterate over the loop, accumulating the sum each iteration **score**. If we meet 10, we once again add the current result **nums[i]** to the total **score** and subtract 1 from the doubling counter **doubles**. If the counter is 0, then we skip doubling the next iteration until we update the counter **doubles** again.\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def score(nums):\\n            score = 0\\n            flag = False\\n\\n            for i in range(len(nums)):\\n                score += nums[i]\\n\\n                if flag:\\n                    score += nums[i]\\n                    doubles -= 1\\n\\n                    if doubles == 0:\\n                        flag = False\\n\\n                if nums[i] == 10:\\n                    doubles = 2\\n                    flag = True\\n                    \\n            return score\\n        \\n        score1, score2 = score(player1), score(player2)\\n        \\n        if score1 == score2:\\n            return 0\\n        elif score1 > score2:\\n            return 1\\n        else:\\n            return 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def score(nums):\\n            score = 0\\n            flag = False\\n\\n            for i in range(len(nums)):\\n                score += nums[i]\\n\\n                if flag:\\n                    score += nums[i]\\n                    doubles -= 1\\n\\n                    if doubles == 0:\\n                        flag = False\\n\\n                if nums[i] == 10:\\n                    doubles = 2\\n                    flag = True\\n                    \\n            return score\\n        \\n        score1, score2 = score(player1), score(player2)\\n        \\n        if score1 == score2:\\n            return 0\\n        elif score1 > score2:\\n            return 1\\n        else:\\n            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468551,
                "title": "simplest-if-else-solution-nothing-else",
                "content": "# Intuition\\njust do what is asked and add a base case for arr[1]\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsimple if else approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int len=player1.length;\\n        int a1[]= new int [len];\\n        int a2[]= new int [len];\\n        \\n        a1[0]= player1[0];\\n        a2[0]= player2[0];\\n        \\n        if(len>1){\\n            if(player1[0]!=10)\\n                a1[1]=player1[1];\\n            else\\n                a1[1]=player1[1]*2;\\n            \\n            if(player2[0]!=10)\\n                a2[1]=player2[1];\\n            else\\n                a2[1]=player2[1]*2;\\n        }\\n        for(int i=2;i<len;i++){\\n            if(player1[i-1]==10 ||player1[i-2]==10){\\n                a1[i]=player1[i]*2;\\n            }\\n            else\\n                a1[i]=player1[i];\\n        \\n        if(player2[i-1]==10 ||player2[i-2]==10){\\n                a2[i]=player2[i]*2;\\n            }\\n            else\\n                a2[i]=player2[i];\\n        }\\n        int s1=0;\\n        int s2=0;\\n        \\n        for(int i=0;i<len;i++){\\n            s1+=a1[i];\\n            s2+=a2[i];\\n        }\\n        if(s1>s2)\\n            return 1;\\n        else if(s2> s1)\\n            return 2;\\n        else \\n            return 0;\\n        \\n        \\n    }\\n}\\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/4f433525-656e-4649-92f3-bf73c0460045_1682830193.917968.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int len=player1.length;\\n        int a1[]= new int [len];\\n        int a2[]= new int [len];\\n        \\n        a1[0]= player1[0];\\n        a2[0]= player2[0];\\n        \\n        if(len>1){\\n            if(player1[0]!=10)\\n                a1[1]=player1[1];\\n            else\\n                a1[1]=player1[1]*2;\\n            \\n            if(player2[0]!=10)\\n                a2[1]=player2[1];\\n            else\\n                a2[1]=player2[1]*2;\\n        }\\n        for(int i=2;i<len;i++){\\n            if(player1[i-1]==10 ||player1[i-2]==10){\\n                a1[i]=player1[i]*2;\\n            }\\n            else\\n                a1[i]=player1[i];\\n        \\n        if(player2[i-1]==10 ||player2[i-2]==10){\\n                a2[i]=player2[i]*2;\\n            }\\n            else\\n                a2[i]=player2[i];\\n        }\\n        int s1=0;\\n        int s2=0;\\n        \\n        for(int i=0;i<len;i++){\\n            s1+=a1[i];\\n            s2+=a2[i];\\n        }\\n        if(s1>s2)\\n            return 1;\\n        else if(s2> s1)\\n            return 2;\\n        else \\n            return 0;\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468368,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1 = 0, score2 = 0;\\n        for (size_t i = 0; i < player1.size(); i++)\\n        {\\n            if ((i > 0 && player1[i - 1] == 10) || (i > 1 && player1[i - 2] == 10))\\n                score1 += 2 * player1[i];\\n            else\\n                score1+= player1[i];\\n        }\\n \\n        for (size_t i = 0; i < player2.size(); i++)\\n        {\\n            if ((i > 0 && player2[i - 1] == 10) || (i > 1 && player2[i - 2] == 10))\\n                score2 += 2 * player2[i];\\n            else\\n                score2 += player2[i];\\n        }\\n \\n        return (score1 == score2 ? 0 : (score1 > score2 ? 1 : 2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1 = 0, score2 = 0;\\n        for (size_t i = 0; i < player1.size(); i++)\\n        {\\n            if ((i > 0 && player1[i - 1] == 10) || (i > 1 && player1[i - 2] == 10))\\n                score1 += 2 * player1[i];\\n            else\\n                score1+= player1[i];\\n        }\\n \\n        for (size_t i = 0; i < player2.size(); i++)\\n        {\\n            if ((i > 0 && player2[i - 1] == 10) || (i > 1 && player2[i - 2] == 10))\\n                score2 += 2 * player2[i];\\n            else\\n                score2 += player2[i];\\n        }\\n \\n        return (score1 == score2 ? 0 : (score1 > score2 ? 1 : 2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930975,
                "title": "java-best-solution-100-beats",
                "content": "# Code\\n```\\nclass Solution{\\n    public int isWinner(int[] p1, int[] p2){\\n        int n = p1.length;\\n        int a=p1[0], b=p2[0];\\n        if(n==1){\\n            if(a>b) return 1;\\n            else if(b>a) return 2;\\n            return 0;\\n        }\\n        if(a==10) a += 2*p1[1];\\n        else a += p1[1];\\n        if(b==10) b += 2*p2[1];\\n        else b += p2[1];\\n        for(int i=2; i<n; i++){\\n            if(p1[i-1]==10 || p1[i-2]==10) a += 2*p1[i];\\n            else a += p1[i];\\n            if(p2[i-1]==10 || p2[i-2]==10) b += 2*p2[i];\\n            else b += p2[i];\\n        }\\n        if(a>b) return 1;\\n        else if(b>a) return 2;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int isWinner(int[] p1, int[] p2){\\n        int n = p1.length;\\n        int a=p1[0], b=p2[0];\\n        if(n==1){\\n            if(a>b) return 1;\\n            else if(b>a) return 2;\\n            return 0;\\n        }\\n        if(a==10) a += 2*p1[1];\\n        else a += p1[1];\\n        if(b==10) b += 2*p2[1];\\n        else b += p2[1];\\n        for(int i=2; i<n; i++){\\n            if(p1[i-1]==10 || p1[i-2]==10) a += 2*p1[i];\\n            else a += p1[i];\\n            if(p2[i-1]==10 || p2[i-2]==10) b += 2*p2[i];\\n            else b += p2[i];\\n        }\\n        if(a>b) return 1;\\n        else if(b>a) return 2;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808115,
                "title": "99-success-rate-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int i=1,j=i-1,k=i-2;\\n        int p1=player1[0],p2=player2[0];\\n        while(i<player1.length){\\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\\n                p1+=2*player1[i];\\n            }\\n            else{\\n                p1+=player1[i];\\n            }\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        int l=1,m=l-1,n=l-2;\\n        while(l<player2.length){\\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\\n                p2+=2*player2[l];\\n            }\\n            else{\\n                p2+=player2[l];\\n            }\\n            l++;\\n            m++;\\n            n++;\\n        }\\n        if(p1>p2) return 1;\\n        else if(p1==p2) return 0;\\n        else return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int i=1,j=i-1,k=i-2;\\n        int p1=player1[0],p2=player2[0];\\n        while(i<player1.length){\\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\\n                p1+=2*player1[i];\\n            }\\n            else{\\n                p1+=player1[i];\\n            }\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        int l=1,m=l-1,n=l-2;\\n        while(l<player2.length){\\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\\n                p2+=2*player2[l];\\n            }\\n            else{\\n                p2+=player2[l];\\n            }\\n            l++;\\n            m++;\\n            n++;\\n        }\\n        if(p1>p2) return 1;\\n        else if(p1==p2) return 0;\\n        else return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694869,
                "title": "js-ts-simple-solution",
                "content": "Just go through the numbers array and check the previous 2 elements to get the correct score according to the requirements and then compare the two scores at the end to return 0, 1 or 2.\\n\\n# Code\\n```\\nconst isWinner = (player1: number[], player2: number[]): number => {\\n\\n    let player1Score = 0;\\n    let player2Score = 0;\\n\\n    const getScoreFromNumbers = (numbers:number[]): number => {\\n\\n        let score = 0;\\n\\n        for(let i = 0; i < numbers.length; i++) {\\n            if(numbers[i - 1] === 10 || numbers[i - 2] === 10) {\\n                score += numbers[i] * 2;\\n            } else {\\n                score += numbers[i];\\n            }\\n        }\\n\\n        return score;\\n    };\\n\\n    player1Score = getScoreFromNumbers(player1);\\n    player2Score = getScoreFromNumbers(player2);\\n    \\n    if(player1Score === player2Score) return 0;\\n\\n    return player1Score > player2Score ? 1 : 2;\\n\\n};\\n```\\nSee more `TypeScript`/`JavaScript` (and other language) LeetCode solutions at https://github.com/jasonmauss/LeetCode",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst isWinner = (player1: number[], player2: number[]): number => {\\n\\n    let player1Score = 0;\\n    let player2Score = 0;\\n\\n    const getScoreFromNumbers = (numbers:number[]): number => {\\n\\n        let score = 0;\\n\\n        for(let i = 0; i < numbers.length; i++) {\\n            if(numbers[i - 1] === 10 || numbers[i - 2] === 10) {\\n                score += numbers[i] * 2;\\n            } else {\\n                score += numbers[i];\\n            }\\n        }\\n\\n        return score;\\n    };\\n\\n    player1Score = getScoreFromNumbers(player1);\\n    player2Score = getScoreFromNumbers(player2);\\n    \\n    if(player1Score === player2Score) return 0;\\n\\n    return player1Score > player2Score ? 1 : 2;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588173,
                "title": "use-simple-conditionals-o-n-time-o-1-space-complexity-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nN,M are the legths of two given Arrays.\\n\\n- **An Upvote will be encouraging \\uD83D\\uDC4D**\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=player1[0];\\n        int sum2=player2[0];\\n        for(int i=1;i<player1.length;i++){\\n            if(player1[i-1]==10 ){\\n                sum1+=2*player1[i];\\n            }\\n            else if( i!=1 && player1[i-2]==10 ){\\n                sum1+=2*player1[i];\\n            }\\n            else{\\n                sum1+=player1[i];\\n            }\\n            \\n        }\\n        for(int i=1;i<player2.length;i++){\\n            if(player2[i-1]==10 ){\\n                sum2+=2*player2[i];\\n            }\\n            else if( i!=1 && player2[i-2]==10 ){\\n                sum2+=2*player2[i];\\n            }\\n            else{\\n                sum2+=player2[i];\\n            }\\n        }\\n            return sum1>sum2?1:sum1==sum2?0:2;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/73ee6b4d-5c9d-4985-8d77-1ad9eff736b8_1685683542.998519.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=player1[0];\\n        int sum2=player2[0];\\n        for(int i=1;i<player1.length;i++){\\n            if(player1[i-1]==10 ){\\n                sum1+=2*player1[i];\\n            }\\n            else if( i!=1 && player1[i-2]==10 ){\\n                sum1+=2*player1[i];\\n            }\\n            else{\\n                sum1+=player1[i];\\n            }\\n            \\n        }\\n        for(int i=1;i<player2.length;i++){\\n            if(player2[i-1]==10 ){\\n                sum2+=2*player2[i];\\n            }\\n            else if( i!=1 && player2[i-2]==10 ){\\n                sum2+=2*player2[i];\\n            }\\n            else{\\n                sum2+=player2[i];\\n            }\\n        }\\n            return sum1>sum2?1:sum1==sum2?0:2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533827,
                "title": "easiest-python-solution",
                "content": "# Intuition\\nusing for loop and few conditions\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488608,
                "title": "c-solution-brute-force",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1=player1[0], p2=player2[0];\\n        int n= player1.size();\\n        if (n>1){\\n            if (p1==10)p1+= player1[1]*2;\\n            else p1+= player1[1];\\n            if (p2==10)p2+= player2[1]*2;\\n            else p2+= player2[1];\\n            for (int i=2; i<n; i++){\\n                if (player1[i-1]==10 || player1[i-2]==10){\\n                    p1+= (2*player1[i]);\\n                }\\n                else p1+= player1[i];\\n                if (player2[i-1]==10 || player2[i-2]==10){\\n                    p2+= (2*player2[i]);\\n                }\\n                else p2+= player2[i];\\n            }\\n        }\\n        if (p1==p2)return 0;\\n        if (p1>p2)return 1;\\n        else return 2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1=player1[0], p2=player2[0];\\n        int n= player1.size();\\n        if (n>1){\\n            if (p1==10)p1+= player1[1]*2;\\n            else p1+= player1[1];\\n            if (p2==10)p2+= player2[1]*2;\\n            else p2+= player2[1];\\n            for (int i=2; i<n; i++){\\n                if (player1[i-1]==10 || player1[i-2]==10){\\n                    p1+= (2*player1[i]);\\n                }\\n                else p1+= player1[i];\\n                if (player2[i-1]==10 || player2[i-2]==10){\\n                    p2+= (2*player2[i]);\\n                }\\n                else p2+= player2[i];\\n            }\\n        }\\n        if (p1==p2)return 0;\\n        if (p1>p2)return 1;\\n        else return 2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478120,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1=0, sum2=0, cnt1=1, cnt2=1;\\n        for(int i=0; i<player1.size(); i++){\\n            sum1+=player1[i];\\n        }\\n        for(int i=0; i<player2.size(); i++){\\n            sum2+=player2[i];\\n        }\\n        if(player1.size()>1){\\n            if(player1[0]==10){\\n                sum1+=player1[1];\\n            }\\n        }\\n        if(player2.size()>1){\\n            if(player2[0]==10){\\n                sum2+=player2[1];\\n            }\\n        }\\n        for(int i=2; i<player1.size(); i++){\\n            if(player1[i-1]==10 || player1[i-2]==10){\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int i=2; i<player2.size(); i++){\\n            if(player2[i-1]==10 || player2[i-2]==10){\\n                sum2+=player2[i];\\n            }\\n        }\\n        if(sum1>sum2){return 1;}\\n        else if(sum1<sum2){return 2;}\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1=0, sum2=0, cnt1=1, cnt2=1;\\n        for(int i=0; i<player1.size(); i++){\\n            sum1+=player1[i];\\n        }\\n        for(int i=0; i<player2.size(); i++){\\n            sum2+=player2[i];\\n        }\\n        if(player1.size()>1){\\n            if(player1[0]==10){\\n                sum1+=player1[1];\\n            }\\n        }\\n        if(player2.size()>1){\\n            if(player2[0]==10){\\n                sum2+=player2[1];\\n            }\\n        }\\n        for(int i=2; i<player1.size(); i++){\\n            if(player1[i-1]==10 || player1[i-2]==10){\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int i=2; i<player2.size(); i++){\\n            if(player2[i-1]==10 || player2[i-2]==10){\\n                sum2+=player2[i];\\n            }\\n        }\\n        if(sum1>sum2){return 1;}\\n        else if(sum1<sum2){return 2;}\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476247,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = sum(player1)\\n        score2 = sum(player2)\\n        for i in range(1, len(player1)):\\n            if i == 1:\\n                if player1[0] == 10:\\n                    score1 += player1[i]\\n                if player2[0] == 10:\\n                    score2 += player2[i]\\n            else:\\n                if 10 in player1[i-2:i]:\\n                    score1 += player1[i]\\n                if 10 in player2[i-2:i]:\\n                    score2 += player2[i]\\n        if score1 > score2:\\n            return 1\\n        elif score2 > score1:\\n            return 2\\n        elif score1 == score2:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = sum(player1)\\n        score2 = sum(player2)\\n        for i in range(1, len(player1)):\\n            if i == 1:\\n                if player1[0] == 10:\\n                    score1 += player1[i]\\n                if player2[0] == 10:\\n                    score2 += player2[i]\\n            else:\\n                if 10 in player1[i-2:i]:\\n                    score1 += player1[i]\\n                if 10 in player2[i-2:i]:\\n                    score2 += player2[i]\\n        if score1 > score2:\\n            return 1\\n        elif score2 > score1:\\n            return 2\\n        elif score1 == score2:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473252,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n    int score1 = calculateScore(player1);\\n    int score2 = calculateScore(player2);\\n    if (score1 > score2) {\\n        return 1;\\n    } else if (score2 > score1) {\\n        return 2;\\n    } else {\\n        return 0;\\n    }\\n    }\\n    \\n    public static int calculateScore(int[] player) {\\n        int sum = 0;\\n        for (int i = player.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player[i - 1] == 10) {\\n                sum += player[i] * 2;\\n            } else if ((i - 2 > -1) && player[i - 2] == 10) {\\n                sum += player[i] * 2;\\n            } else {\\n                sum += player[i];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n    int score1 = calculateScore(player1);\\n    int score2 = calculateScore(player2);\\n    if (score1 > score2) {\\n        return 1;\\n    } else if (score2 > score1) {\\n        return 2;\\n    } else {\\n        return 0;\\n    }\\n    }\\n    \\n    public static int calculateScore(int[] player) {\\n        int sum = 0;\\n        for (int i = player.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player[i - 1] == 10) {\\n                sum += player[i] * 2;\\n            } else if ((i - 2 > -1) && player[i - 2] == 10) {\\n                sum += player[i] * 2;\\n            } else {\\n                sum += player[i];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472299,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\t  //calculating the score of the player1\\n          int sum1 = 0;\\n\\t\\t  for(int i=0;i<arr1.size();i++)\\n\\t\\t  {\\n\\t\\t  \\t   bool flag = false;\\n\\t\\t  \\t   if((i-1)>=0 == true and arr1[i-1] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if((i-2)>=0 == true and arr1[i-2] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if(flag == true) sum1 = sum1 + 2*arr1[i];\\n\\t\\t  \\t   else sum1 = sum1 + arr1[i];\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  //calculating the score of the player2\\n\\t\\t  int sum2 = 0;\\n\\t\\t  for(int i=0;i<arr2.size();i++)\\n\\t\\t  {\\n\\t\\t  \\t   bool flag = false;\\n\\t\\t  \\t   if((i-1)>=0 == true and arr2[i-1] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if((i-2)>=0 == true and arr2[i-2] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if(flag == true) sum2 = sum2 + 2*arr2[i];\\n\\t\\t  \\t   else sum2 = sum2 + arr2[i];\\n\\t\\t  }\\n\\t\\t  if(sum1 == sum2) return 0; //draw\\n\\t\\t  else if(sum1 > sum2) return 1;\\n\\t\\t  return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\t  //calculating the score of the player1\\n          int sum1 = 0;\\n\\t\\t  for(int i=0;i<arr1.size();i++)\\n\\t\\t  {\\n\\t\\t  \\t   bool flag = false;\\n\\t\\t  \\t   if((i-1)>=0 == true and arr1[i-1] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if((i-2)>=0 == true and arr1[i-2] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if(flag == true) sum1 = sum1 + 2*arr1[i];\\n\\t\\t  \\t   else sum1 = sum1 + arr1[i];\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  //calculating the score of the player2\\n\\t\\t  int sum2 = 0;\\n\\t\\t  for(int i=0;i<arr2.size();i++)\\n\\t\\t  {\\n\\t\\t  \\t   bool flag = false;\\n\\t\\t  \\t   if((i-1)>=0 == true and arr2[i-1] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if((i-2)>=0 == true and arr2[i-2] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if(flag == true) sum2 = sum2 + 2*arr2[i];\\n\\t\\t  \\t   else sum2 = sum2 + arr2[i];\\n\\t\\t  }\\n\\t\\t  if(sum1 == sum2) return 0; //draw\\n\\t\\t  else if(sum1 > sum2) return 1;\\n\\t\\t  return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471206,
                "title": "c-58-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int gameResult(const vector<int>& player) {\\n        int hit = 0, sum = 0;\\n        for(auto pins : player) {\\n            sum += pins;\\n            if(hit) { sum += pins; --hit; }\\n            if(pins == 10) hit = 2;\\n        }\\n        return sum;\\n    }\\n\\n    int isWinner(const vector<int>& player1, const vector<int>& player2) {\\n        int result = gameResult(player1) - gameResult(player2);\\n        return result > 0? 1: result < 0? 2: result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gameResult(const vector<int>& player) {\\n        int hit = 0, sum = 0;\\n        for(auto pins : player) {\\n            sum += pins;\\n            if(hit) { sum += pins; --hit; }\\n            if(pins == 10) hit = 2;\\n        }\\n        return sum;\\n    }\\n\\n    int isWinner(const vector<int>& player1, const vector<int>& player2) {\\n        int result = gameResult(player1) - gameResult(player2);\\n        return result > 0? 1: result < 0? 2: result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470302,
                "title": "java-solution-2ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1=0,p2=0,p1m=1,p2m=1,c1=0,c2=0;\\n        for(int i=0;i<player1.length;i++){\\n            p1+=player1[i]*p1m;\\n            p2+=player2[i]*p2m;\\n            if(player1[i]==10){\\n                p1m=2;\\n                c1=0;\\n            }\\n            if(player2[i]==10){\\n                p2m=2;\\n                c2=0;\\n            }\\n            if(p1m==2){\\n                c1++;\\n                if(c1==3) p1m=1;\\n            }\\n            if(p2m==2){\\n                c2++;\\n                if(c2==3) p2m=1;\\n            }\\n        }\\n        \\n        if(p1==p2){\\n            return 0;\\n        }else if(p1>p2){\\n            return 1;\\n        }else{\\n            return 2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1=0,p2=0,p1m=1,p2m=1,c1=0,c2=0;\\n        for(int i=0;i<player1.length;i++){\\n            p1+=player1[i]*p1m;\\n            p2+=player2[i]*p2m;\\n            if(player1[i]==10){\\n                p1m=2;\\n                c1=0;\\n            }\\n            if(player2[i]==10){\\n                p2m=2;\\n                c2=0;\\n            }\\n            if(p1m==2){\\n                c1++;\\n                if(c1==3) p1m=1;\\n            }\\n            if(p2m==2){\\n                c2++;\\n                if(c2==3) p2m=1;\\n            }\\n        }\\n        \\n        if(p1==p2){\\n            return 0;\\n        }else if(p1>p2){\\n            return 1;\\n        }else{\\n            return 2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470224,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def f(player):\\n            n=len(player)\\n            if n==1:\\n                return player[0]\\n            a,b=player[0:2]\\n            answ=player[0] + player[1] + (player[0]==10)*player[1]\\n            for x in player[2:]:\\n                answ+=x + (max(a,b)==10)*x\\n                a,b=b,x\\n            return answ\\n        p1=f(player1)\\n        p2=f(player2)\\n        if p1==p2:\\n            return 0\\n        if p1<p2:\\n            return 2\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def f(player):\\n            n=len(player)\\n            if n==1:\\n                return player[0]\\n            a,b=player[0:2]\\n            answ=player[0] + player[1] + (player[0]==10)*player[1]\\n            for x in player[2:]:\\n                answ+=x + (max(a,b)==10)*x\\n                a,b=b,x\\n            return answ\\n        p1=f(player1)\\n        p2=f(player2)\\n        if p1==p2:\\n            return 0\\n        if p1<p2:\\n            return 2\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469963,
                "title": "short-easy-100-fast-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr){\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i==0)sum+=arr[i];\\n            else if(i==1){\\n                if(arr[i-1]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n            else{\\n                if(arr[i-1]==10 || arr[i-2]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(solve(player1)>solve(player2))return 1;\\n        else if(solve(player1)<solve(player2))return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr){\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i==0)sum+=arr[i];\\n            else if(i==1){\\n                if(arr[i-1]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n            else{\\n                if(arr[i-1]==10 || arr[i-2]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(solve(player1)>solve(player2))return 1;\\n        else if(solve(player1)<solve(player2))return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469444,
                "title": "determine-the-winner-of-a-bowling-game-c-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n       int n = player1.size();\\n    int one = 0, two = 0;\\n    one += player1[0];\\n    two += player2[0];\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (i == 1)\\n        {\\n            if (player1[i - 1] == 10)\\n            {\\n                one += 2 * player1[i];\\n            }\\n            else\\n            {\\n                one += player1[i];\\n            }\\n        }\\n        else\\n        {\\n            if ((player1[i - 1] == 10) || (player1[i - 2] == 10))\\n            {\\n                int num = player1[i];\\n                one += (2 * num);\\n            }\\n            else\\n            {\\n                one += player1[i];\\n            }\\n        }\\n    }\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (i == 1)\\n        {\\n            if (player2[i - 1] == 10)\\n            {\\n                two += 2 * player2[i];\\n            }\\n            else\\n            {\\n                two += player2[i];\\n            }\\n        }\\n        else\\n        {\\n            if ((player2[i - 1] == 10) || (player2[i - 2] == 10))\\n            {\\n                int num = player2[i];\\n                two += 2 * num;\\n            }\\n            else\\n            {\\n                two += player2[i];\\n            }\\n        }\\n    }\\n    if (one == two)\\n    {\\n        return 0;\\n    }\\n    if (two > one)\\n    {\\n        return 2;\\n    }\\n    return 1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n       int n = player1.size();\\n    int one = 0, two = 0;\\n    one += player1[0];\\n    two += player2[0];\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (i == 1)\\n        {\\n            if (player1[i - 1] == 10)\\n            {\\n                one += 2 * player1[i];\\n            }\\n            else\\n            {\\n                one += player1[i];\\n            }\\n        }\\n        else\\n        {\\n            if ((player1[i - 1] == 10) || (player1[i - 2] == 10))\\n            {\\n                int num = player1[i];\\n                one += (2 * num);\\n            }\\n            else\\n            {\\n                one += player1[i];\\n            }\\n        }\\n    }\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (i == 1)\\n        {\\n            if (player2[i - 1] == 10)\\n            {\\n                two += 2 * player2[i];\\n            }\\n            else\\n            {\\n                two += player2[i];\\n            }\\n        }\\n        else\\n        {\\n            if ((player2[i - 1] == 10) || (player2[i - 2] == 10))\\n            {\\n                int num = player2[i];\\n                two += 2 * num;\\n            }\\n            else\\n            {\\n                two += player2[i];\\n            }\\n        }\\n    }\\n    if (one == two)\\n    {\\n        return 0;\\n    }\\n    if (two > one)\\n    {\\n        return 2;\\n    }\\n    return 1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469431,
                "title": "beginner-friendly-java-code-using-hashsets",
                "content": "# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        Set<Integer> set1 =  new HashSet<>();\\n        Set<Integer> set2 =  new HashSet<>();\\n        for(int i = 0; i<n; i++){\\n            if(player1[i]==10){\\n                set1.add(i+1);\\n                set1.add(i+2);\\n            }\\n            if(player2[i]==10){\\n                set2.add(i+1);\\n                set2.add(i+2);\\n            }\\n        }\\n        for(int i =0; i<n; i++){\\n            if(set1.contains(i)){\\n                sum1+=player1[i]*2;\\n            }\\n            else{\\n                sum1+=player1[i];\\n            }\\n            if(set2.contains(i)){\\n                sum2+=player2[i]*2;\\n            }\\n            else{\\n                sum2+=player2[i];\\n            }\\n        }\\n        if(sum1>sum2)return 1;\\n        if(sum2>sum1) return 2;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        Set<Integer> set1 =  new HashSet<>();\\n        Set<Integer> set2 =  new HashSet<>();\\n        for(int i = 0; i<n; i++){\\n            if(player1[i]==10){\\n                set1.add(i+1);\\n                set1.add(i+2);\\n            }\\n            if(player2[i]==10){\\n                set2.add(i+1);\\n                set2.add(i+2);\\n            }\\n        }\\n        for(int i =0; i<n; i++){\\n            if(set1.contains(i)){\\n                sum1+=player1[i]*2;\\n            }\\n            else{\\n                sum1+=player1[i];\\n            }\\n            if(set2.contains(i)){\\n                sum2+=player2[i]*2;\\n            }\\n            else{\\n                sum2+=player2[i];\\n            }\\n        }\\n        if(sum1>sum2)return 1;\\n        if(sum2>sum1) return 2;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468891,
                "title": "simple-solution-for-c-explanation-complexity",
                "content": "# Approach\\nStraight solution where we need to calculate scores for each player and get the result\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic int IsWinner(int[] player1, int[] player2)\\n{\\n    var score1 = CalcScores(player1);\\n    var score2 = CalcScores(player2);\\n\\n    if (score1 > score2)\\n    {\\n        return 1;\\n    }\\n\\n    return score2 > score1 ? 2 : 0;\\n}\\n\\n/// <summary>\\n/// Support void to calc scores\\n/// </summary>\\n/// <param name=\"player\"> Player scores </param>\\n/// <returns> Total score </returns>\\nprivate int CalcScores(IReadOnlyList<int> player)\\n{\\n    var result = 0;\\n\\n    for (var i = 0; i < player.Count; i++)\\n    {\\n        switch (i)\\n        {\\n            //// Check if one of the two previous values is equal to 10,\\n            /// then multiply the current score.\\n            case >= 1 when player[i - 1] == 10:\\n            case >= 2 when player[i - 2] == 10:\\n                result += player[i] * 2;\\n                break;\\n            default:\\n                result += player[i];\\n                break;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int IsWinner(int[] player1, int[] player2)\\n{\\n    var score1 = CalcScores(player1);\\n    var score2 = CalcScores(player2);\\n\\n    if (score1 > score2)\\n    {\\n        return 1;\\n    }\\n\\n    return score2 > score1 ? 2 : 0;\\n}\\n\\n/// <summary>\\n/// Support void to calc scores\\n/// </summary>\\n/// <param name=\"player\"> Player scores </param>\\n/// <returns> Total score </returns>\\nprivate int CalcScores(IReadOnlyList<int> player)\\n{\\n    var result = 0;\\n\\n    for (var i = 0; i < player.Count; i++)\\n    {\\n        switch (i)\\n        {\\n            //// Check if one of the two previous values is equal to 10,\\n            /// then multiply the current score.\\n            case >= 1 when player[i - 1] == 10:\\n            case >= 2 when player[i - 2] == 10:\\n                result += player[i] * 2;\\n                break;\\n            default:\\n                result += player[i];\\n                break;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468533,
                "title": "all-test-case-pass-c-easy-o-n-time-o-1-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the provided solution is to iterate through each turn of a player and calculate their score based on the game rules, i.e., if the player knocked down all 10 pins (a \"strike\") in the current turn or in the previous two turns. Once the total score for each player has been calculated, it compares the scores to determine the winner or if the game was a draw.\\n\\nTo calculate the score for each turn, the solution keeps track of two variables: previousTwo and flag. previousTwo is an integer that keeps track of the number of turns ago in which the player scored a strike, while flag is a boolean variable that is true if the previous turn was a strike. These variables are used to determine whether the player\\'s score should be multiplied by 2 or not.\\n\\nThe function getScore iterates through each turn of the player, checking if the current turn is a strike or not. If the current turn is not a strike, the score is added to the total score. If the current turn is a strike, the flag variable is set to true, and the previousTwo variable is reset to 0. If flag is true, then the player has scored a strike in the previous turn, so the score for the current turn is multiplied by 2 and added to the total score. If previousTwo is less than 2, the player has scored a strike in the previous two turns, so the score for the current turn is also multiplied by 2 and added to the total score. Finally, the function returns the total score for the player.\\n\\nThe function isWinner calculates the total score for each player using the getScore function and then compares the scores to determine the winner. If the score of player 1 is greater than the score of player 2, it returns 1. If the score of player 2 is greater than the score of player 1, it returns 2. If the scores are equal, it returns 0, indicating a draw.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``````\\nclass Solution {\\npublic:\\n    int getScore(vector<int> player){\\n        bool flag=false;\\n        int previousTwo = 0;\\n        int totalScore=0;\\n        for(auto&it:player){\\n            if(flag==false){\\n                totalScore+=it;\\n            }else if(previousTwo<2){\\n                totalScore+= (2*it);\\n                previousTwo+=1;\\n            }\\n            if(previousTwo>=2)flag=false;\\n            if(it==10){\\n                flag=true;\\n                previousTwo=0;\\n            }\\n        }\\n        return totalScore;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int player1Score = getScore(player1);\\n        int player2Score = getScore(player2);\\n        if(player1Score>player2Score){\\n            return 1;\\n        }else if(player1Score<player2Score){\\n            return 2;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n``````",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Iterator"
                ],
                "code": "``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 3468487,
                "title": "optimized-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int calculateScore(vector<int> &player){\\n\\tint score = 0;\\n\\tint twiceHits = 0; \\n\\tfor(int i = 0;i< player.size();i++){\\n\\t\\tscore += player[i];\\n\\t\\tif(twiceHits){ // check if the hits will be twiced or not \\n\\t\\t\\tscore+=player[i];\\n\\t\\t\\ttwiceHits--;\\n\\t\\t}\\n\\t\\tif(player[i]==10){\\n\\t\\t\\ttwiceHits = 2; // twice the hits for next two attempts\\n\\t\\t}\\n\\t}\\n\\treturn score;\\n}\\n\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n\\tint score1=calculateScore(player1);\\n   \\tint score2=calculateScore(player2);\\n   \\tif(score1<score2){\\n   \\t\\treturn 2;\\n   \\t}else if(score1>score2){\\n   \\t\\treturn 1;\\n   \\t}\\n   \\treturn 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int calculateScore(vector<int> &player){\\n\\tint score = 0;\\n\\tint twiceHits = 0; \\n\\tfor(int i = 0;i< player.size();i++){\\n\\t\\tscore += player[i];\\n\\t\\tif(twiceHits){ // check if the hits will be twiced or not \\n\\t\\t\\tscore+=player[i];\\n\\t\\t\\ttwiceHits--;\\n\\t\\t}\\n\\t\\tif(player[i]==10){\\n\\t\\t\\ttwiceHits = 2; // twice the hits for next two attempts\\n\\t\\t}\\n\\t}\\n\\treturn score;\\n}\\n\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n\\tint score1=calculateScore(player1);\\n   \\tint score2=calculateScore(player2);\\n   \\tif(score1<score2){\\n   \\t\\treturn 2;\\n   \\t}else if(score1>score2){\\n   \\t\\treturn 1;\\n   \\t}\\n   \\treturn 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468359,
                "title": "simplest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n        int s1=0, s2=0;\\n        for(int x=0; x<player1.size(); x++)\\n        {\\n            if((x-1>=0 && player1[x-1]==10) || (x-2>=0 && player1[x-2]==10)) \\n            s1+=player1[x]*2;\\n            else s1+=player1[x];\\n            \\n            if((x-1>=0 && player2[x-1]==10) || (x-2>=0 && player2[x-2]==10)) \\n            s2+=player2[x]*2;\\n            else s2+=player2[x];\\n        }\\n        if(s1==s2) return 0;\\n        if(s1>s2) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n        int s1=0, s2=0;\\n        for(int x=0; x<player1.size(); x++)\\n        {\\n            if((x-1>=0 && player1[x-1]==10) || (x-2>=0 && player1[x-2]==10)) \\n            s1+=player1[x]*2;\\n            else s1+=player1[x];\\n            \\n            if((x-1>=0 && player2[x-1]==10) || (x-2>=0 && player2[x-2]==10)) \\n            s2+=player2[x]*2;\\n            else s2+=player2[x];\\n        }\\n        if(s1==s2) return 0;\\n        if(s1>s2) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468306,
                "title": "javascript-direct-way-78ms",
                "content": "```\\nconst isWinner = (a, b) => {\\n    let ra = cal(a), rb = cal(b);\\n    return ra == rb ? 0 : ra > rb ? 1 : 2;\\n};\\n\\nconst cal = (a) => {\\n    let n = a.length, res = 0;\\n    a.map((x, i) => {\\n        if ((i-1 >= 0 && a[i-1] == 10) || (i-2 >= 0 && a[i-2] == 10)) {\\n            res += 2 * x;\\n        } else {\\n            res += x;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nconst isWinner = (a, b) => {\\n    let ra = cal(a), rb = cal(b);\\n    return ra == rb ? 0 : ra > rb ? 1 : 2;\\n};\\n\\nconst cal = (a) => {\\n    let n = a.length, res = 0;\\n    a.map((x, i) => {\\n        if ((i-1 >= 0 && a[i-1] == 10) || (i-2 >= 0 && a[i-2] == 10)) {\\n            res += 2 * x;\\n        } else {\\n            res += x;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468274,
                "title": "c-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& num1, vector<int>& num2) {\\n        if(num1.size()==1){\\n            if(num1[0]>num2[0]) return 1;\\n            else if(num1[0]<num2[0]) return 2;\\n            return 0;\\n        }else if(num1.size() == 2){\\n            int x = num1[0]+num1[1];\\n            if(num1[0]==10) x += num1[1];\\n            int y = num2[0]+num2[1];\\n            if(num2[0]==10) y+=num2[1];\\n            if(x>y) return 1;\\n            else if(x<y) return 2;\\n            return 0;\\n        }\\n        long long sum1=0,sum2=0;\\n        sum1 += (num1[0]+num1[1]);\\n        if(num1[0]==10) sum1 += num1[1];\\n        sum2 += (num2[0]+num2[1]);\\n        if(num2[0]==10) sum2 += num2[1];\\n        for(int i=2;i<num1.size();i++){\\n            if(num1[i-2]==10 || num1[i-1]==10) sum1 += (num1[i]*2);\\n            else sum1 += num1[i];\\n        }\\n        for(int i=2;i<num2.size();i++){\\n            if(num2[i-2]==10 || num2[i-1]==10) sum2 += (num2[i]*2);\\n            else sum2 += num2[i];\\n        }\\n        if(sum1>sum2) return 1;\\n        else if(sum1<sum2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& num1, vector<int>& num2) {\\n        if(num1.size()==1){\\n            if(num1[0]>num2[0]) return 1;\\n            else if(num1[0]<num2[0]) return 2;\\n            return 0;\\n        }else if(num1.size() == 2){\\n            int x = num1[0]+num1[1];\\n            if(num1[0]==10) x += num1[1];\\n            int y = num2[0]+num2[1];\\n            if(num2[0]==10) y+=num2[1];\\n            if(x>y) return 1;\\n            else if(x<y) return 2;\\n            return 0;\\n        }\\n        long long sum1=0,sum2=0;\\n        sum1 += (num1[0]+num1[1]);\\n        if(num1[0]==10) sum1 += num1[1];\\n        sum2 += (num2[0]+num2[1]);\\n        if(num2[0]==10) sum2 += num2[1];\\n        for(int i=2;i<num1.size();i++){\\n            if(num1[i-2]==10 || num1[i-1]==10) sum1 += (num1[i]*2);\\n            else sum1 += num1[i];\\n        }\\n        for(int i=2;i<num2.size();i++){\\n            if(num2[i-2]==10 || num2[i-1]==10) sum2 += (num2[i]*2);\\n            else sum2 += num2[i];\\n        }\\n        if(sum1>sum2) return 1;\\n        else if(sum1<sum2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468266,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int a = player1.length,b = player2.length;\\n        \\n        int first =0;\\n        int second = 0;\\n        int count=0;\\n        int i=0;\\n        while(i<a){\\n            if(player1[i]==10){\\n                count = 2;\\n                first+=player1[i];\\n                i++;\\n                while(count!=0 && i<a){\\n                    first += (2*player1[i]);\\n                    count--;\\n                     if(player1[i]==10) count=2;\\n                    i++;\\n\\n                }\\n            }else{\\n                first +=player1[i];\\n                i++;\\n            }\\n        }\\n        i=0;\\n        count=0;\\n        while(i<b){\\n            if(player2[i]==10){\\n                count = 2;\\n                second+=player2[i];\\n                i++;\\n                while(count!=0 && i<b){\\n                    second += (2*player2[i]);\\n                    count--;\\n                    if(player2[i]==10) count=2;\\n                    i++;\\n                }\\n            }else{\\n                second +=player2[i];\\n                i++;\\n            }\\n        }\\n        if(first>second) return 1;\\n        else if(first<second) return 2;\\n        else return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int a = player1.length,b = player2.length;\\n        \\n        int first =0;\\n        int second = 0;\\n        int count=0;\\n        int i=0;\\n        while(i<a){\\n            if(player1[i]==10){\\n                count = 2;\\n                first+=player1[i];\\n                i++;\\n                while(count!=0 && i<a){\\n                    first += (2*player1[i]);\\n                    count--;\\n                     if(player1[i]==10) count=2;\\n                    i++;\\n\\n                }\\n            }else{\\n                first +=player1[i];\\n                i++;\\n            }\\n        }\\n        i=0;\\n        count=0;\\n        while(i<b){\\n            if(player2[i]==10){\\n                count = 2;\\n                second+=player2[i];\\n                i++;\\n                while(count!=0 && i<b){\\n                    second += (2*player2[i]);\\n                    count--;\\n                    if(player2[i]==10) count=2;\\n                    i++;\\n                }\\n            }else{\\n                second +=player2[i];\\n                i++;\\n            }\\n        }\\n        if(first>second) return 1;\\n        else if(first<second) return 2;\\n        else return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091682,
                "title": "multiplication-matrix-intuitive-python-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to record some sort of flag or state to record the status of the multiplier of future indices as we go along through the pass of the array. We can create a multiplier matrix which records whether or not we multiply by 1 (if no 10 scored in the past two pins) or 2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate the two matrices (arrays) for the two players. If you see a 10, set the values to 2 in the next two indices if they exist. Then just calculate\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) We pass through the length of the array once\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we create 2 O(1) for recording the score, but 2 arrays with the same length as n.\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        multMatrix1, multMatrix2 = [ 1 ] * len(player1), [ 1 ] * len(player2)\\n        firstScore, secondScore = 0, 0\\n        \\n        for i in range(len(player1)):\\n            if player1[i] == 10:\\n                if i + 1 < len(player1):\\n                    multMatrix1[i+1] = 2\\n                    if i + 2 < len(player2):\\n                        multMatrix1[i+2] = 2\\n            if player2[i] == 10:\\n                if i + 1 < len(player2):\\n                    multMatrix2[i+1] = 2\\n                    if i + 2 < len(player2):\\n                        multMatrix2[i+2] = 2\\n            firstScore += multMatrix1[i] * player1[i]\\n            secondScore += multMatrix2[i] * player2[i]\\n\\n        return 1 if firstScore > secondScore else 2 if secondScore >  firstScore else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        multMatrix1, multMatrix2 = [ 1 ] * len(player1), [ 1 ] * len(player2)\\n        firstScore, secondScore = 0, 0\\n        \\n        for i in range(len(player1)):\\n            if player1[i] == 10:\\n                if i + 1 < len(player1):\\n                    multMatrix1[i+1] = 2\\n                    if i + 2 < len(player2):\\n                        multMatrix1[i+2] = 2\\n            if player2[i] == 10:\\n                if i + 1 < len(player2):\\n                    multMatrix2[i+1] = 2\\n                    if i + 2 < len(player2):\\n                        multMatrix2[i+2] = 2\\n            firstScore += multMatrix1[i] * player1[i]\\n            secondScore += multMatrix2[i] * player2[i]\\n\\n        return 1 if firstScore > secondScore else 2 if secondScore >  firstScore else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085233,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- As the condition is any 2 previous turns, we have to check them individually, and if any one of them is having 10 score then, we will add them again into the score of respective player.\\n- Else we will simply add the score as it is into the player\\'s score variable (a || b).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sz = player1.size();\\n        int a=0,b=0;\\n        int a10=0, b10=0;\\n        for(int i=0; i<sz; i++){\\n            a += player1[i];\\n            b += player2[i];\\n            if(i-1 >= 0 && player1[i-1] == 10) a += player1[i];\\n            else if(i-2 >= 0 && player1[i-2] == 10) a += player1[i];\\n            if(i-1 >= 0 && player2[i-1] == 10) b += player2[i];\\n            else if(i-2 >= 0 && player2[i-2] == 10) b += player2[i];\\n        }\\n        if(a == b) return 0;\\n        return a > b ? 1 : 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sz = player1.size();\\n        int a=0,b=0;\\n        int a10=0, b10=0;\\n        for(int i=0; i<sz; i++){\\n            a += player1[i];\\n            b += player2[i];\\n            if(i-1 >= 0 && player1[i-1] == 10) a += player1[i];\\n            else if(i-2 >= 0 && player1[i-2] == 10) a += player1[i];\\n            if(i-1 >= 0 && player2[i-1] == 10) b += player2[i];\\n            else if(i-2 >= 0 && player2[i-2] == 10) b += player2[i];\\n        }\\n        if(a == b) return 0;\\n        return a > b ? 1 : 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032673,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        // calculate score of player1\\n        int score1 = calc(player1);\\n        int score2 = calc(player2);\\n\\n        if(score1 == score2)\\n            return 0;\\n        \\n        if(score1 < score2)\\n            return 2;\\n        \\n        return 1;\\n    }\\n    public int calc(int[] nums){\\n        int score = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int prev1 = (i - 1) >= 0 ? nums[i - 1] : 0;\\n            int prev2 = (i - 2) >= 0 ? nums[i - 2] : 0;\\n            score = score + (prev1 == 10 || prev2 == 10 ? 2 * nums[i] : nums[i]);\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        // calculate score of player1\\n        int score1 = calc(player1);\\n        int score2 = calc(player2);\\n\\n        if(score1 == score2)\\n            return 0;\\n        \\n        if(score1 < score2)\\n            return 2;\\n        \\n        return 1;\\n    }\\n    public int calc(int[] nums){\\n        int score = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int prev1 = (i - 1) >= 0 ? nums[i - 1] : 0;\\n            int prev2 = (i - 2) >= 0 ? nums[i - 2] : 0;\\n            score = score + (prev1 == 10 || prev2 == 10 ? 2 * nums[i] : nums[i]);\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025720,
                "title": "simple-cpp-solution-that-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Score(vector<int>& player){\\n        int s=0,f=0;\\n        for(int p:player){\\n            s += (f>0)? 2*p: p;\\n            f--;\\n            if(p==10) \\n                f=2;\\n        }\\n        return s;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1 = Score(player1), s2 = Score(player2);\\n        if(s1 > s2) return 1;\\n        if(s1 < s2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Score(vector<int>& player){\\n        int s=0,f=0;\\n        for(int p:player){\\n            s += (f>0)? 2*p: p;\\n            f--;\\n            if(p==10) \\n                f=2;\\n        }\\n        return s;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1 = Score(player1), s2 = Score(player2);\\n        if(s1 > s2) return 1;\\n        if(s1 < s2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021493,
                "title": "java-simple-solution-o-n-easy-to-understand",
                "content": "# Intuition\\nCalculate both scores comapre them \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nConstant\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        \\n        if(player1.length != player2.length ) return -1;\\n\\n        int score1 = calculateScore(player1);\\n\\n        int score2 = calculateScore(player2);\\n\\n        if(score1 > score2) return 1;\\n\\n        else if(score2 > score1) return 2;\\n\\n        else return 0;\\n\\n    }\\n\\n\\n    private int calculateScore (int [] arr){\\n\\n        int score = 0 ;\\n        for (int i = 0 ; i < arr.length ; i++ ){\\n           \\n            if((i - 1 >= 0 && arr[i-1] ==  10) || (i - 2 >= 0 && arr[i-2] ==  10)){\\n                score += 2*arr[i];\\n            }\\n            else{\\n                 score += arr[i]; \\n            }\\n           \\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        \\n        if(player1.length != player2.length ) return -1;\\n\\n        int score1 = calculateScore(player1);\\n\\n        int score2 = calculateScore(player2);\\n\\n        if(score1 > score2) return 1;\\n\\n        else if(score2 > score1) return 2;\\n\\n        else return 0;\\n\\n    }\\n\\n\\n    private int calculateScore (int [] arr){\\n\\n        int score = 0 ;\\n        for (int i = 0 ; i < arr.length ; i++ ){\\n           \\n            if((i - 1 >= 0 && arr[i-1] ==  10) || (i - 2 >= 0 && arr[i-2] ==  10)){\\n                score += 2*arr[i];\\n            }\\n            else{\\n                 score += arr[i]; \\n            }\\n           \\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018795,
                "title": "only-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for (int i = player1.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player1[i - 1] == 10) {\\n                sum1 += player1[i] * 2;\\n            } else if ((i - 2 > -1) && player1[i - 2] == 10) {\\n                sum1 += player1[i] * 2;\\n            } else {\\n                sum1 += player1[i];\\n            }\\n        }\\n        \\n        for (int i = player2.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player2[i - 1] == 10) {\\n                sum2 += player2[i] * 2;\\n            } else if ((i - 2 > -1) && player2[i - 2] == 10) {\\n                sum2 += player2[i] * 2;\\n            } else {\\n                sum2 += player2[i];\\n            }\\n        }\\n        if(sum1 > sum2) return 1; \\n        else if(sum1 < sum2)  return 2;\\n        else return 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for (int i = player1.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player1[i - 1] == 10) {\\n                sum1 += player1[i] * 2;\\n            } else if ((i - 2 > -1) && player1[i - 2] == 10) {\\n                sum1 += player1[i] * 2;\\n            } else {\\n                sum1 += player1[i];\\n            }\\n        }\\n        \\n        for (int i = player2.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player2[i - 1] == 10) {\\n                sum2 += player2[i] * 2;\\n            } else if ((i - 2 > -1) && player2[i - 2] == 10) {\\n                sum2 += player2[i] * 2;\\n            } else {\\n                sum2 += player2[i];\\n            }\\n        }\\n        if(sum1 > sum2) return 1; \\n        else if(sum1 < sum2)  return 2;\\n        else return 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014531,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score_p1, score_p2 = 0, 0\\n        factor = 2\\n\\n        for i in range(len(player1)):\\n            if i >= 1 and (player1[i-1] == 10 or (i >= 2 and player1[i-2] == 10)):\\n                score_p1 += player1[i] * factor\\n            else:\\n                score_p1 += player1[i]\\n            \\n            if i >= 1 and (player2[i-1] == 10 or (i >= 2 and player2[i-2] == 10)):\\n                score_p2 += player2[i] * factor\\n            else:\\n                score_p2 += player2[i]\\n        \\n        if score_p1 == score_p2:\\n            return 0\\n        elif score_p1 > score_p2:\\n            return 1\\n        else:\\n            return 2\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score_p1, score_p2 = 0, 0\\n        factor = 2\\n\\n        for i in range(len(player1)):\\n            if i >= 1 and (player1[i-1] == 10 or (i >= 2 and player1[i-2] == 10)):\\n                score_p1 += player1[i] * factor\\n            else:\\n                score_p1 += player1[i]\\n            \\n            if i >= 1 and (player2[i-1] == 10 or (i >= 2 and player2[i-2] == 10)):\\n                score_p2 += player2[i] * factor\\n            else:\\n                score_p2 += player2[i]\\n        \\n        if score_p1 == score_p2:\\n            return 0\\n        elif score_p1 > score_p2:\\n            return 1\\n        else:\\n            return 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011596,
                "title": "javascript-reduce",
                "content": "# Code\\n```\\nvar isWinner = function(player1, player2) {\\n    const calc = (arr) => arr.reduce((a, b, i) => a + (b * ((arr[i - 1] === 10 || arr[i - 2] === 10) ? 2 : 1)), 0)\\n    let a = calc(player1);\\n    let b = calc(player2);\\n    if (a === b) return 0;\\n    return a > b ? 1 : 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isWinner = function(player1, player2) {\\n    const calc = (arr) => arr.reduce((a, b, i) => a + (b * ((arr[i - 1] === 10 || arr[i - 2] === 10) ? 2 : 1)), 0)\\n    let a = calc(player1);\\n    let b = calc(player2);\\n    if (a === b) return 0;\\n    return a > b ? 1 : 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007159,
                "title": "easy-to-understand-python3-solution-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        player1_score, player2_score = 0, 0\\n\\n        for i in range(len(player1)):\\n            if i == 0:\\n                player1_score += player1[i]\\n            elif i == 1:\\n                if player1[i-1] == 10:\\n                    player1_score += 2 * player1[i]\\n                else:\\n                    player1_score += player1[i]\\n            else:\\n                if i % 2 == 0:\\n                    if player1[i-1] == 10 or player1[i-2] == 10:\\n                        player1_score += 2 * player1[i]\\n                    else:\\n                        player1_score += player1[i]\\n                else:\\n                    if player1[i-1] == 10 or player1[i-2] == 10:\\n                        player1_score += 2 * player1[i]\\n                    else:\\n                        player1_score += player1[i]\\n        \\n        for i in range(len(player2)):\\n            if i == 0:\\n                player2_score += player2[i]\\n            elif i == 1:\\n                if player2[i-1] == 10:\\n                    player2_score += 2 * player2[i]\\n                else:\\n                    player2_score += player2[i] \\n            else:\\n                if i % 2 == 0:\\n                    if player2[i-1] == 10 or player2[i-2] == 10:\\n                        player2_score += 2 * player2[i]\\n                    else:\\n                        player2_score += player2[i]\\n                else:\\n                    if player2[i-1] == 10 or player2[i-2] == 10:\\n                        player2_score += 2 * player2[i]\\n                    else:\\n                        player2_score += player2[i]\\n\\n        if player1_score > player2_score:\\n            return 1\\n        elif player1_score < player2_score:\\n            return 2\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        player1_score, player2_score = 0, 0\\n\\n        for i in range(len(player1)):\\n            if i == 0:\\n                player1_score += player1[i]\\n            elif i == 1:\\n                if player1[i-1] == 10:\\n                    player1_score += 2 * player1[i]\\n                else:\\n                    player1_score += player1[i]\\n            else:\\n                if i % 2 == 0:\\n                    if player1[i-1] == 10 or player1[i-2] == 10:\\n                        player1_score += 2 * player1[i]\\n                    else:\\n                        player1_score += player1[i]\\n                else:\\n                    if player1[i-1] == 10 or player1[i-2] == 10:\\n                        player1_score += 2 * player1[i]\\n                    else:\\n                        player1_score += player1[i]\\n        \\n        for i in range(len(player2)):\\n            if i == 0:\\n                player2_score += player2[i]\\n            elif i == 1:\\n                if player2[i-1] == 10:\\n                    player2_score += 2 * player2[i]\\n                else:\\n                    player2_score += player2[i] \\n            else:\\n                if i % 2 == 0:\\n                    if player2[i-1] == 10 or player2[i-2] == 10:\\n                        player2_score += 2 * player2[i]\\n                    else:\\n                        player2_score += player2[i]\\n                else:\\n                    if player2[i-1] == 10 or player2[i-2] == 10:\\n                        player2_score += 2 * player2[i]\\n                    else:\\n                        player2_score += player2[i]\\n\\n        if player1_score > player2_score:\\n            return 1\\n        elif player1_score < player2_score:\\n            return 2\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003206,
                "title": "simple-java-100-tc-solution",
                "content": "# Intuition\\nEach score must be tracked. Remember that every time a player scores a 10, the next two rounds have a multiplier of two.\\n\\n# Approach\\nCreate three variables for each player. One of which is a tick that counts down the two days where the multiplier is active for that player. Make sure that if a player scores a 10, the tick is set to 2 and the multiplier is set to 2. For each iteration, make sure 1 is subtracted from the tick as long as it is greater than 0. Once the tick hits 0, set the multiplier back to 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int multi1 = 1;\\n        int multi2 = 1;\\n        int tick1 = 0;\\n        int tick2 = 0;\\n        int total1 = 0;\\n        int total2 = 0;\\n\\n        for (int i = 0; i < player1.length; i++)\\n        {\\n            total1 += player1[i] * multi1;\\n            total2 += player2[i] * multi2;\\n            if (tick1 == 0)\\n                multi1 = 1;\\n            if (tick2 == 0)\\n                multi2 = 1;\\n            \\n            if (player1[i] == 10)\\n            {\\n                tick1 = 2;\\n                multi1 = 2;\\n            }\\n            if (player2[i] == 10)\\n            {\\n                tick2 = 2;\\n                multi2 = 2;\\n            }\\n\\n            if (tick1 > 0)\\n                tick1--;\\n            if (tick2 > 0)\\n                tick2--;\\n        }\\n\\n        if (total1 > total2)\\n            return 1;\\n        else if (total2 > total1)\\n            return 2;\\n        else\\n            return 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int multi1 = 1;\\n        int multi2 = 1;\\n        int tick1 = 0;\\n        int tick2 = 0;\\n        int total1 = 0;\\n        int total2 = 0;\\n\\n        for (int i = 0; i < player1.length; i++)\\n        {\\n            total1 += player1[i] * multi1;\\n            total2 += player2[i] * multi2;\\n            if (tick1 == 0)\\n                multi1 = 1;\\n            if (tick2 == 0)\\n                multi2 = 1;\\n            \\n            if (player1[i] == 10)\\n            {\\n                tick1 = 2;\\n                multi1 = 2;\\n            }\\n            if (player2[i] == 10)\\n            {\\n                tick2 = 2;\\n                multi2 = 2;\\n            }\\n\\n            if (tick1 > 0)\\n                tick1--;\\n            if (tick2 > 0)\\n                tick2--;\\n        }\\n\\n        if (total1 > total2)\\n            return 1;\\n        else if (total2 > total1)\\n            return 2;\\n        else\\n            return 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990150,
                "title": "easy-to-read-python-solution-with-a-helper-function-to-calculate-score-explanation-in-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n\\n        #declaring a helper function\\n        def calcScore(player):\\n            #let\\'s declare two variables to store the score of the prev two rounds\\n            r1 = 0 #round - 1\\n            r2 = 0  #round - 2\\n\\n            score = 0\\n\\n            for pins in player:\\n                #update score depending on the number of pins hit on the prev two rounds\\n                if r1 == 10 or r2 == 10:\\n                    score += (2 * pins)\\n                else:\\n                    score += pins\\n                \\n                #now update the prev round and the round before that scores\\n                r2 = r1 #be wary of this order\\n                #move r1s value to r2 first \\n                # and then udpate r1\\n                r1 = pins\\n \\n                \\n\\n            return score\\n        \\n        #now we simply calculate the score for each player and return a result\\n\\n        p1 = calcScore(player1)\\n        p2 = calcScore(player2)\\n\\n        if p1 > p2:\\n            return 1\\n        \\n        if p2 > p1:\\n            return 2\\n        \\n        if p1 == p2:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n\\n        #declaring a helper function\\n        def calcScore(player):\\n            #let\\'s declare two variables to store the score of the prev two rounds\\n            r1 = 0 #round - 1\\n            r2 = 0  #round - 2\\n\\n            score = 0\\n\\n            for pins in player:\\n                #update score depending on the number of pins hit on the prev two rounds\\n                if r1 == 10 or r2 == 10:\\n                    score += (2 * pins)\\n                else:\\n                    score += pins\\n                \\n                #now update the prev round and the round before that scores\\n                r2 = r1 #be wary of this order\\n                #move r1s value to r2 first \\n                # and then udpate r1\\n                r1 = pins\\n \\n                \\n\\n            return score\\n        \\n        #now we simply calculate the score for each player and return a result\\n\\n        p1 = calcScore(player1)\\n        p2 = calcScore(player2)\\n\\n        if p1 > p2:\\n            return 1\\n        \\n        if p2 > p1:\\n            return 2\\n        \\n        if p1 == p2:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980933,
                "title": "c-basic-game-logic",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        int sumOfPlayer1 = CalculatePlayerPoint(player1, 1);\\n            int sumOfPlayer2=CalculatePlayerPoint(player2, 1);\\n            return sumOfPlayer1>sumOfPlayer2?1:sumOfPlayer1==sumOfPlayer2?0:2;\\n    }\\n    private static int CalculatePlayerPoint(int[] playerPoints, int multiplier)\\n        {\\n            int sumOfPoints = 0;\\n            int multiplierTime = 2;\\n            for (int i = 0; i < playerPoints.Length; i++)\\n            {\\n                sumOfPoints += playerPoints[i] * multiplier;\\n                if (multiplier == 2)\\n                    multiplierTime--;\\n                if(multiplierTime==0)\\n                    multiplier = 1;\\n                if (playerPoints[i] == 10)\\n                {\\n                    multiplier = 2;\\n                    multiplierTime=2;\\n                }\\n            }\\n            return sumOfPoints;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        int sumOfPlayer1 = CalculatePlayerPoint(player1, 1);\\n            int sumOfPlayer2=CalculatePlayerPoint(player2, 1);\\n            return sumOfPlayer1>sumOfPlayer2?1:sumOfPlayer1==sumOfPlayer2?0:2;\\n    }\\n    private static int CalculatePlayerPoint(int[] playerPoints, int multiplier)\\n        {\\n            int sumOfPoints = 0;\\n            int multiplierTime = 2;\\n            for (int i = 0; i < playerPoints.Length; i++)\\n            {\\n                sumOfPoints += playerPoints[i] * multiplier;\\n                if (multiplier == 2)\\n                    multiplierTime--;\\n                if(multiplierTime==0)\\n                    multiplier = 1;\\n                if (playerPoints[i] == 10)\\n                {\\n                    multiplier = 2;\\n                    multiplierTime=2;\\n                }\\n            }\\n            return sumOfPoints;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976423,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        int strike1 = 0;\\n        int strike2 = 0;\\n        for (int i = 0; i < player1.length; i++) {\\n            sum1 += player1[i];\\n            sum2 += player2[i];\\n            if (strike1-- > 0) {\\n                sum1 += player1[i];\\n            }\\n            if (strike2-- > 0) {\\n                sum2 += player2[i];\\n            }\\n            if (player1[i] == 10) {\\n                strike1 = 2;\\n            }\\n            if (player2[i] == 10) {\\n                strike2 = 2;\\n            }\\n        }\\n        return sum1 > sum2 ? 1 : sum2 > sum1 ? 2 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        int strike1 = 0;\\n        int strike2 = 0;\\n        for (int i = 0; i < player1.length; i++) {\\n            sum1 += player1[i];\\n            sum2 += player2[i];\\n            if (strike1-- > 0) {\\n                sum1 += player1[i];\\n            }\\n            if (strike2-- > 0) {\\n                sum2 += player2[i];\\n            }\\n            if (player1[i] == 10) {\\n                strike1 = 2;\\n            }\\n            if (player2[i] == 10) {\\n                strike2 = 2;\\n            }\\n        }\\n        return sum1 > sum2 ? 1 : sum2 > sum1 ? 2 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964667,
                "title": "beats-97-64-straightforward-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sc = []\\n        def calculate(player):\\n            strike = 0\\n            score = 0\\n            for i in range(len(player)):\\n                if strike <= 0:\\n                    score += player[i]\\n                else:\\n                    score += 2*player[i]\\n                strike -= 1\\n                if player[i] == 10:\\n                    strike = 2\\n            sc.append(score)\\n        calculate(player1)\\n        calculate(player2)\\n        print(sc)\\n        if sc[0] > sc[1]:\\n            return 1\\n        if sc[0] == sc[1]:\\n            return 0\\n        return 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sc = []\\n        def calculate(player):\\n            strike = 0\\n            score = 0\\n            for i in range(len(player)):\\n                if strike <= 0:\\n                    score += player[i]\\n                else:\\n                    score += 2*player[i]\\n                strike -= 1\\n                if player[i] == 10:\\n                    strike = 2\\n            sc.append(score)\\n        calculate(player1)\\n        calculate(player2)\\n        print(sc)\\n        if sc[0] > sc[1]:\\n            return 1\\n        if sc[0] == sc[1]:\\n            return 0\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961443,
                "title": "python-beginners-4-line",
                "content": "- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        ans=0\\n        for i in range(len(player1)):\\n            ans +=player1[i]*(1+(10 in player1[max(0,i-2):i]))\\n            ans -=player2[i]*(1+(10 in player2[max(0,i-2):i]))\\n        return int(ans>0) if ans>=0 else 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        ans=0\\n        for i in range(len(player1)):\\n            ans +=player1[i]*(1+(10 in player1[max(0,i-2):i]))\\n            ans -=player2[i]*(1+(10 in player2[max(0,i-2):i]))\\n        return int(ans>0) if ans>=0 else 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960748,
                "title": "easy-solution-3-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def get_score(player):\\n            return sum(player[i] * (2 if (i and player[i-1] == 10) or (i > 1 and player[i-2] == 10) else 1) for i, turn in enumerate(player))\\n        return 1 if (s1 := get_score(player1)) > (s2 := get_score(player2)) else 2 if s2 > s1 else 0 \\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def get_score(player):\\n            return sum(player[i] * (2 if (i and player[i-1] == 10) or (i > 1 and player[i-2] == 10) else 1) for i, turn in enumerate(player))\\n        return 1 if (s1 := get_score(player1)) > (s2 := get_score(player2)) else 2 if s2 > s1 else 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957411,
                "title": "simple-array-traversal-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n       int res1=0,res2=0;\\n       for(int i=0;i<player1.length;i++)\\n       {\\n           if((i>1 && player1[i-2]==10 ) || (i>0 && player1[i-1]==10) )\\n           res1+=2*player1[i];\\n           else\\n           res1+=player1[i]; \\n           if((i>1 && player2[i-2]==10) || (i>0 && player2[i-1]==10))\\n           res2+=2*player2[i];\\n           else\\n           res2+=player2[i];\\n       } \\n       return res1==res2?0:res1>res2?1:2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n       int res1=0,res2=0;\\n       for(int i=0;i<player1.length;i++)\\n       {\\n           if((i>1 && player1[i-2]==10 ) || (i>0 && player1[i-1]==10) )\\n           res1+=2*player1[i];\\n           else\\n           res1+=player1[i]; \\n           if((i>1 && player2[i-2]==10) || (i>0 && player2[i-1]==10))\\n           res2+=2*player2[i];\\n           else\\n           res2+=player2[i];\\n       } \\n       return res1==res2?0:res1>res2?1:2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947910,
                "title": "java-solution-beats-100-runtime-1ms-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate through all possible elements in both arrays, check whether 2 previous element is equal to 10, and then determine the calculation. Be careful with edge case handling, for example when there\\'s only one entry.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n>Because this code only uses three integer variables, which counts as O(1) regardless of operation. And there\\'s no other dynamic data structures like array except the input arrays. The input array is not considered as space complexity of this code chunk becaue it\\'s part of the input. The space complexity analysis typically focuses on the additional space (beyond the input) that an algorithm uses to produce its result. \\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = 0, p2 = 0;\\n        int len = player1.length;\\n\\n        // If there\\'s only 1 turn\\n        if (len == 1) {\\n            p1 += player1[0];\\n            p2 += player2[0];\\n            return p1 > p2 ? 1 : (p2 > p1 ? 2 : 0);\\n        }\\n\\n        // For all turns except the first\\n        for (int i = 1; i < len; i++) {\\n            if (player1[i-1] == 10 || (i-2 >= 0 && player1[i-2] == 10)) {\\n                p1 += player1[i]*2;\\n            } else {\\n                p1 += player1[i];\\n            }\\n\\n            if (player2[i-1] == 10 || (i-2 >= 0 && player2[i-2] == 10)) {\\n                p2 += player2[i]*2;\\n            } else {\\n                p2 += player2[i];\\n            }\\n        }\\n\\n        // Handle the first turn\\n        p1 += player1[0];\\n        p2 += player2[0];\\n\\n        return p1 > p2 ? 1 : (p2 > p1 ? 2 : 0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = 0, p2 = 0;\\n        int len = player1.length;\\n\\n        // If there\\'s only 1 turn\\n        if (len == 1) {\\n            p1 += player1[0];\\n            p2 += player2[0];\\n            return p1 > p2 ? 1 : (p2 > p1 ? 2 : 0);\\n        }\\n\\n        // For all turns except the first\\n        for (int i = 1; i < len; i++) {\\n            if (player1[i-1] == 10 || (i-2 >= 0 && player1[i-2] == 10)) {\\n                p1 += player1[i]*2;\\n            } else {\\n                p1 += player1[i];\\n            }\\n\\n            if (player2[i-1] == 10 || (i-2 >= 0 && player2[i-2] == 10)) {\\n                p2 += player2[i]*2;\\n            } else {\\n                p2 += player2[i];\\n            }\\n        }\\n\\n        // Handle the first turn\\n        p1 += player1[0];\\n        p2 += player2[0];\\n\\n        return p1 > p2 ? 1 : (p2 > p1 ? 2 : 0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939476,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1=0;int s2=0;\\n        int n=player1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s1+=player1[i];\\n            if(i==1)\\n            {\\n                if(player1[0]==10)\\n                {\\n                    s1+=player1[i];\\n                }\\n            }\\n            else if(i>1 and (player1[i-1]==10 or player1[i-2]==10))\\n            {\\n                s1+=player1[i];\\n            }\\n            \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s2+=player2[i];\\n            if(i==1)\\n            {\\n                if(player2[0]==10)\\n                {\\n                    s2+=player2[i];\\n                }\\n            }\\n            else if(i>1 and (player2[i-1]==10 or player2[i-2]==10))\\n            {\\n                s2+=player2[i];\\n            }\\n            \\n        }\\n        if(s1>s2)\\n        return 1;\\n        if(s2>s1)\\n        return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1=0;int s2=0;\\n        int n=player1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s1+=player1[i];\\n            if(i==1)\\n            {\\n                if(player1[0]==10)\\n                {\\n                    s1+=player1[i];\\n                }\\n            }\\n            else if(i>1 and (player1[i-1]==10 or player1[i-2]==10))\\n            {\\n                s1+=player1[i];\\n            }\\n            \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s2+=player2[i];\\n            if(i==1)\\n            {\\n                if(player2[0]==10)\\n                {\\n                    s2+=player2[i];\\n                }\\n            }\\n            else if(i>1 and (player2[i-1]==10 or player2[i-2]==10))\\n            {\\n                s2+=player2[i];\\n            }\\n            \\n        }\\n        if(s1>s2)\\n        return 1;\\n        if(s2>s1)\\n        return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928745,
                "title": "c-solution-based-on-brute-force-and-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force built on all possible cases\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNaive approach \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n1+n2)~O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size();\\n        int n2=player2.size();\\n        int sum1=0,sum2=0;\\n       \\n        sum1=0;sum2=0;\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(i==0)\\n            {\\n                sum1+=player1[i];\\n            }\\n             if(i==1 && player1[0]==10)\\n            {\\n                sum1+=2*player1[i];\\n            }\\n             if(i==1 && player1[0]!=10)\\n            {\\n                sum1+=player1[i];\\n            }\\n            \\n            else if((i>1)&&(player1[i-1]==10 || player1[i-2]==10))\\n            {\\n                sum1+=2*player1[i];\\n            }\\n            else  if((i>1)&&(player1[i-1]!=10 || player1[i-2]!=10))\\n            {\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int j=0;j<n2;j++)\\n        {\\n            if(j==0)\\n            {\\n                sum2+=player2[j];\\n            }\\n             if(j==1 && player2[0]==10)\\n            {\\n                sum2+=2*player2[j];\\n            }\\n            if(j==1 && player2[0]!=10)\\n            {\\n                sum2+=player2[j];\\n            }\\n            \\n            else if((j>1)&&(player2[j-1]==10 || player2[j-2]==10))\\n            {\\n                sum2+=2*player2[j];\\n            }\\n            else if((j>1)&&(player2[j-1]!=10 || player2[j-2]!=10))\\n            {\\n                sum2+=player2[j];\\n            }\\n        }\\n        \\n        if (sum1>sum2) \\n        {return 1;\\n        }\\n        else if(sum2>sum1)\\n        {return 2;\\n        }\\n        else\\n        { return 0;}\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size();\\n        int n2=player2.size();\\n        int sum1=0,sum2=0;\\n       \\n        sum1=0;sum2=0;\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(i==0)\\n            {\\n                sum1+=player1[i];\\n            }\\n             if(i==1 && player1[0]==10)\\n            {\\n                sum1+=2*player1[i];\\n            }\\n             if(i==1 && player1[0]!=10)\\n            {\\n                sum1+=player1[i];\\n            }\\n            \\n            else if((i>1)&&(player1[i-1]==10 || player1[i-2]==10))\\n            {\\n                sum1+=2*player1[i];\\n            }\\n            else  if((i>1)&&(player1[i-1]!=10 || player1[i-2]!=10))\\n            {\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int j=0;j<n2;j++)\\n        {\\n            if(j==0)\\n            {\\n                sum2+=player2[j];\\n            }\\n             if(j==1 && player2[0]==10)\\n            {\\n                sum2+=2*player2[j];\\n            }\\n            if(j==1 && player2[0]!=10)\\n            {\\n                sum2+=player2[j];\\n            }\\n            \\n            else if((j>1)&&(player2[j-1]==10 || player2[j-2]==10))\\n            {\\n                sum2+=2*player2[j];\\n            }\\n            else if((j>1)&&(player2[j-1]!=10 || player2[j-2]!=10))\\n            {\\n                sum2+=player2[j];\\n            }\\n        }\\n        \\n        if (sum1>sum2) \\n        {return 1;\\n        }\\n        else if(sum2>sum1)\\n        {return 2;\\n        }\\n        else\\n        { return 0;}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922637,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        \"\"\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def getScore(player):\\n            count, score = 0, 0\\n\\n            for i in range(len(player)):  \\n                if count > 0:\\n                    score += player[i] * 2\\n                    count -= 1\\n                else:\\n                    score += player[i]\\n                if player[i] == 10:\\n                    count = 2\\n            return score\\n\\n        player1Score, player2Score = getScore(player1), getScore(player2)\\n\\n        if player1Score > player2Score:\\n            return 1\\n        elif player1Score < player2Score:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n                \\n            \\n                    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        \"\"\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def getScore(player):\\n            count, score = 0, 0\\n\\n            for i in range(len(player)):  \\n                if count > 0:\\n                    score += player[i] * 2\\n                    count -= 1\\n                else:\\n                    score += player[i]\\n                if player[i] == 10:\\n                    count = 2\\n            return score\\n\\n        player1Score, player2Score = getScore(player1), getScore(player2)\\n\\n        if player1Score > player2Score:\\n            return 1\\n        elif player1Score < player2Score:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n                \\n            \\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920800,
                "title": "easy-and-simple-java-solution-runtime-1-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int player1_Score = calScore(player1);\\n        int player2_Score = calScore(player2);\\n\\n        if(player1_Score > player2_Score){\\n            return 1;\\n        } \\n        if(player1_Score < player2_Score){\\n            return 2;\\n        } \\n        return 0;\\n        \\n    }\\n\\n    private int calScore(int[] player){\\n\\n        boolean if10PinInLast2Turns = false;\\n        int sum = 0, counter = 0;\\n        for(int i=0; i<player.length; i++){\\n            sum += player[i];\\n            \\n            if(if10PinInLast2Turns){\\n                sum += player[i];\\n                counter++;\\n                \\n                if(counter == 2){\\n                    if10PinInLast2Turns = false;\\n                    counter = 0;\\n                }\\n            }\\n            if(player[i]==10){\\n                if10PinInLast2Turns = true;\\n                counter = 0;\\n                \\n            }\\n\\n            \\n        }\\n        //System.out.println(sum);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int player1_Score = calScore(player1);\\n        int player2_Score = calScore(player2);\\n\\n        if(player1_Score > player2_Score){\\n            return 1;\\n        } \\n        if(player1_Score < player2_Score){\\n            return 2;\\n        } \\n        return 0;\\n        \\n    }\\n\\n    private int calScore(int[] player){\\n\\n        boolean if10PinInLast2Turns = false;\\n        int sum = 0, counter = 0;\\n        for(int i=0; i<player.length; i++){\\n            sum += player[i];\\n            \\n            if(if10PinInLast2Turns){\\n                sum += player[i];\\n                counter++;\\n                \\n                if(counter == 2){\\n                    if10PinInLast2Turns = false;\\n                    counter = 0;\\n                }\\n            }\\n            if(player[i]==10){\\n                if10PinInLast2Turns = true;\\n                counter = 0;\\n                \\n            }\\n\\n            \\n        }\\n        //System.out.println(sum);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907074,
                "title": "python-simple-solution-with-explanation",
                "content": "# Intuition\\nWe need to compute the scores based on the pins struck by each player. As the algorithm is repeated, we can use a helper function to compute the scores of player1 and player2\\n\\n# Approach\\nWe iterate through the list to compute the scores of each player. Note that we have to look at up to `i-2` indexes. Consider the cases where the input scores are 2 and below. For this we compute the result of the first 2 indexes separately before computing at index of >= 2\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        def get_score(scores)-> int:\\n            total = scores[0]\\n            \\n            if len(scores) > 1:\\n                if total == 10:\\n                    total += (2 * scores[1])\\n                else:\\n                    total += scores[1]\\n            \\n            # Start at index 2\\n            for i in range(2, len(scores)):\\n                if scores[i - 1] == 10 or scores[i - 2] == 10:\\n                    total += (2 * scores[i])\\n                else:\\n                    total += scores[i]\\n            return total\\n            \\n        p1 = get_score(player1)\\n        p2 = get_score(player2)\\n\\n        if p1 == p2:\\n            return 0\\n        elif p1 > p2:\\n            return 1\\n        else:\\n            return 2\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        def get_score(scores)-> int:\\n            total = scores[0]\\n            \\n            if len(scores) > 1:\\n                if total == 10:\\n                    total += (2 * scores[1])\\n                else:\\n                    total += scores[1]\\n            \\n            # Start at index 2\\n            for i in range(2, len(scores)):\\n                if scores[i - 1] == 10 or scores[i - 2] == 10:\\n                    total += (2 * scores[i])\\n                else:\\n                    total += scores[i]\\n            return total\\n            \\n        p1 = get_score(player1)\\n        p2 = get_score(player2)\\n\\n        if p1 == p2:\\n            return 0\\n        elif p1 > p2:\\n            return 1\\n        else:\\n            return 2\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903129,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\nint a = player1.size(), b = player2.size();\\n        \\n        int first = 0, second = 0, count = 0, i = 0;\\n        while (i < a) {\\n            if (player1[i] == 10) {\\n                count = 2;\\n                first += player1[i];\\n                i++;\\n                while (count != 0 && i < a) {\\n                    first += (2 * player1[i]);\\n                    count--;\\n                    if (player1[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                first += player1[i];\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        count = 0;\\n        while (i < b) {\\n            if (player2[i] == 10) {\\n                count = 2;\\n                second += player2[i];\\n                i++;\\n                while (count != 0 && i < b) {\\n                    second += (2 * player2[i]);\\n                    count--;\\n                    if (player2[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                second += player2[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (first > second) return 1;\\n        else if (first < second) return 2;\\n        else return 0;\\n\\n\\n\\n\\n\\n\\n\\n\\n       /* int sum1=0;\\n        int sum2=0;\\n        int maxno=INT_MIN;\\n        for(int i=0; i<player1.size(); i++){\\n            if(player1[i-1]||player1[i-2]==10){\\n              sum1+=player1[i]+player1[i];\\n              else{sum1+=player1[i];\\n              }\\n                 \\n            }\\n            }\\n            for(int j=0; j<player2.size(); j++){\\n                if(player2[j-1]||player2[j-2]==10){\\n                sum2+=player2[j]*2;\\n                else{\\n                 sum2+=player2[j];\\n                }\\n                \\n        } \\n        maxno=max(sum1, sum2);\\n      }\\n      return maxno;*/\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\nint a = player1.size(), b = player2.size();\\n        \\n        int first = 0, second = 0, count = 0, i = 0;\\n        while (i < a) {\\n            if (player1[i] == 10) {\\n                count = 2;\\n                first += player1[i];\\n                i++;\\n                while (count != 0 && i < a) {\\n                    first += (2 * player1[i]);\\n                    count--;\\n                    if (player1[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                first += player1[i];\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        count = 0;\\n        while (i < b) {\\n            if (player2[i] == 10) {\\n                count = 2;\\n                second += player2[i];\\n                i++;\\n                while (count != 0 && i < b) {\\n                    second += (2 * player2[i]);\\n                    count--;\\n                    if (player2[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                second += player2[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (first > second) return 1;\\n        else if (first < second) return 2;\\n        else return 0;\\n\\n\\n\\n\\n\\n\\n\\n\\n       /* int sum1=0;\\n        int sum2=0;\\n        int maxno=INT_MIN;\\n        for(int i=0; i<player1.size(); i++){\\n            if(player1[i-1]||player1[i-2]==10){\\n              sum1+=player1[i]+player1[i];\\n              else{sum1+=player1[i];\\n              }\\n                 \\n            }\\n            }\\n            for(int j=0; j<player2.size(); j++){\\n                if(player2[j-1]||player2[j-2]==10){\\n                sum2+=player2[j]*2;\\n                else{\\n                 sum2+=player2[j];\\n                }\\n                \\n        } \\n        maxno=max(sum1, sum2);\\n      }\\n      return maxno;*/\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899598,
                "title": "easy-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        s1,s2=player1[0],player2[0]\\n        for i in range(1,len(player1)):\\n            if i == 1:\\n                if player1[0] == 10:\\n                    s1+=(2*player1[1])\\n                    continue                \\n            elif i>1 and any(player1[j] == 10 for j in range(i-2,i)):\\n                s1+=(2*player1[i])\\n                continue            \\n            s1+=player1[i]\\n        for i in range(1,len(player2)):\\n            if i == 1:\\n                if player2[0] == 10:\\n                    s2+=(2*player2[1])\\n                    continue\\n            elif i>1 and any(player2[j] == 10 for j in range(i-2,i)):\\n                s2+=(2*player2[i])\\n                continue\\n            s2+=player2[i]\\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        s1,s2=player1[0],player2[0]\\n        for i in range(1,len(player1)):\\n            if i == 1:\\n                if player1[0] == 10:\\n                    s1+=(2*player1[1])\\n                    continue                \\n            elif i>1 and any(player1[j] == 10 for j in range(i-2,i)):\\n                s1+=(2*player1[i])\\n                continue            \\n            s1+=player1[i]\\n        for i in range(1,len(player2)):\\n            if i == 1:\\n                if player2[0] == 10:\\n                    s2+=(2*player2[1])\\n                    continue\\n            elif i>1 and any(player2[j] == 10 for j in range(i-2,i)):\\n                s2+=(2*player2[i])\\n                continue\\n            s2+=player2[i]\\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893305,
                "title": "java-2ms-beats-87-37",
                "content": "# Intuition & Approach\\n- use a simulation strategy\\n- at each strike, reset the player\\'s strike weight\\n- decrement strike weight every round \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 2ms Beats 87.37%\\n\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int n = player1.length;\\n        \\n        int[][] pins = new int[2][n];\\n        pins[0] = player1;\\n        pins[1] = player2;\\n\\n        // strategy: simulation\\n\\n        int[] scores = new int[2];\\n        int[] strikeWeight = new int[2];\\n\\n        for (int round = 0; round < n; ++round) {\\n            for (int player = 0; player < 2; ++player) {\\n\\n                // determine multiplier\\n                int multiplier = 1;\\n                if (strikeWeight[player] > 0) {\\n                    multiplier = 2;\\n                }\\n\\n                // add score to running total\\n                scores[player] += pins[player][round] * multiplier;\\n\\n                // adjust strike count as needed\\n                if (pins[player][round] == 10) {\\n                    strikeWeight[player] = 2;\\n                } else {\\n                    strikeWeight[player] = clamp(strikeWeight[player] - 1, 0, 2);\\n                }\\n            }\\n        }\\n\\n        // determine winner\\n        if (scores[0] > scores[1]) {\\n            return 1;\\n        } else if (scores[1] > scores[0]) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n        \\n    }\\n\\n    private int clamp(int val, int lower, int upper) {\\n        if (val < lower) {\\n            return lower;\\n        } else if (val > upper) {\\n            return upper;\\n        } else {\\n            return val;\\n        }\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 2ms Beats 87.37%\\n\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int n = player1.length;\\n        \\n        int[][] pins = new int[2][n];\\n        pins[0] = player1;\\n        pins[1] = player2;\\n\\n        // strategy: simulation\\n\\n        int[] scores = new int[2];\\n        int[] strikeWeight = new int[2];\\n\\n        for (int round = 0; round < n; ++round) {\\n            for (int player = 0; player < 2; ++player) {\\n\\n                // determine multiplier\\n                int multiplier = 1;\\n                if (strikeWeight[player] > 0) {\\n                    multiplier = 2;\\n                }\\n\\n                // add score to running total\\n                scores[player] += pins[player][round] * multiplier;\\n\\n                // adjust strike count as needed\\n                if (pins[player][round] == 10) {\\n                    strikeWeight[player] = 2;\\n                } else {\\n                    strikeWeight[player] = clamp(strikeWeight[player] - 1, 0, 2);\\n                }\\n            }\\n        }\\n\\n        // determine winner\\n        if (scores[0] > scores[1]) {\\n            return 1;\\n        } else if (scores[1] > scores[0]) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n        \\n    }\\n\\n    private int clamp(int val, int lower, int upper) {\\n        if (val < lower) {\\n            return lower;\\n        } else if (val > upper) {\\n            return upper;\\n        } else {\\n            return val;\\n        }\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889429,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 373 ms, faster than 5.11% of Python3 online submissions for Determine the Winner of a Bowling Game.\\n# Memory Usage: 16.6 MB, less than 22.18% of Python3 online submissions for Determine the Winner of a Bowling Game.\\n\\n\\tclass Solution:\\n\\t\\tdef isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n\\t\\t\\tscore_card1 , score_card2 = player1[:1] , player2[:1]\\n\\n\\t\\t\\tfor index in range(1 , len(player1)):\\n\\n\\t\\t\\t\\tif 10 in player1[:index][-2:]:\\n\\t\\t\\t\\t\\tscore_card1.append(player1[index] * 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tscore_card1.append(player1[index])\\n\\n\\t\\t\\t\\tif 10 in player2[:index][-2:]:\\n\\t\\t\\t\\t\\tscore_card2.append(player2[index] * 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tscore_card2.append(player2[index])\\n\\n\\t\\t\\tscore1 , score2 = sum(score_card1) , sum(score_card2)\\n\\n\\t\\t\\tif score1 == score2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telif score1 > score2:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 2\\n\\t\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(1)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 373 ms, faster than 5.11% of Python3 online submissions for Determine the Winner of a Bowling Game.\\n# Memory Usage: 16.6 MB, less than 22.18% of Python3 online submissions for Determine the Winner of a Bowling Game.\\n\\n\\tclass Solution:\\n\\t\\tdef isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n\\t\\t\\tscore_card1 , score_card2 = player1[:1] , player2[:1]\\n\\n\\t\\t\\tfor index in range(1 , len(player1)):\\n\\n\\t\\t\\t\\tif 10 in player1[:index][-2:]:\\n\\t\\t\\t\\t\\tscore_card1.append(player1[index] * 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tscore_card1.append(player1[index])\\n\\n\\t\\t\\t\\tif 10 in player2[:index][-2:]:\\n\\t\\t\\t\\t\\tscore_card2.append(player2[index] * 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tscore_card2.append(player2[index])\\n\\n\\t\\t\\tscore1 , score2 = sum(score_card1) , sum(score_card2)\\n\\n\\t\\t\\tif score1 == score2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telif score1 > score2:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 2\\n\\t\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(1)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3878676,
                "title": "winner-of-the-bowling-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        pl1=0\\n        pl2=0\\n        for i in range(len(player1)):\\n            pl1+=2*player1[i] if i-1>-1 and  10 in [player1[i-1],player1[i-2] if i-2>-1 else 0] else player1[i]\\n            pl2+=2*player2[i] if i-1>-1 and  10 in [player2[i-1],player2[i-2] if i-2>-1 else 0] else player2[i]\\n        return 1 if pl1>pl2 else(0 if pl1==pl2 else 2 )\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        pl1=0\\n        pl2=0\\n        for i in range(len(player1)):\\n            pl1+=2*player1[i] if i-1>-1 and  10 in [player1[i-1],player1[i-2] if i-2>-1 else 0] else player1[i]\\n            pl2+=2*player2[i] if i-1>-1 and  10 in [player2[i-1],player2[i-2] if i-2>-1 else 0] else player2[i]\\n        return 1 if pl1>pl2 else(0 if pl1==pl2 else 2 )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876873,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def cnt_points(lst):\\n            res = cnt = 0\\n            for i in lst:\\n                res += i\\n                if cnt > 0:\\n                    res += i\\n                    cnt -= 1\\n\\n                if i == 10:\\n                    cnt = 2\\n            return res\\n                \\n\\n        if cnt_points(player1) > cnt_points(player2):\\n            return 1\\n        elif cnt_points(player1) < cnt_points(player2):\\n            return 2\\n        else:\\n            return 0\\n```\\n![catty.png](https://assets.leetcode.com/users/images/e21cdc1e-ca0a-4d33-b734-d379e88435c6_1691413122.8635035.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def cnt_points(lst):\\n            res = cnt = 0\\n            for i in lst:\\n                res += i\\n                if cnt > 0:\\n                    res += i\\n                    cnt -= 1\\n\\n                if i == 10:\\n                    cnt = 2\\n            return res\\n                \\n\\n        if cnt_points(player1) > cnt_points(player2):\\n            return 1\\n        elif cnt_points(player1) < cnt_points(player2):\\n            return 2\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865770,
                "title": "super-simple-c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        int Calc(int[] input) {\\n            var sum = 0;\\n            bool HitTenAt(int pos) {\\n                if (pos < 0) {\\n                    return false;\\n                }\\n                if (pos >= input.Length) {\\n                    return false;\\n                }\\n                return input[pos] == 10;\\n            }\\n\\n            for (var i = 0; i < input.Length; i++) {\\n                if (HitTenAt(i-1) || HitTenAt(i-2)) {\\n                    sum += input[i]*2;\\n                } else {\\n                    sum += input[i];\\n                }\\n            }\\n\\n            return sum;\\n        }\\n\\n        var one = Calc(player1);\\n        var two = Calc(player2);\\n        if  (one == two) {\\n            return 0;\\n        }\\n\\n        return one > two ? 1 : 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        int Calc(int[] input) {\\n            var sum = 0;\\n            bool HitTenAt(int pos) {\\n                if (pos < 0) {\\n                    return false;\\n                }\\n                if (pos >= input.Length) {\\n                    return false;\\n                }\\n                return input[pos] == 10;\\n            }\\n\\n            for (var i = 0; i < input.Length; i++) {\\n                if (HitTenAt(i-1) || HitTenAt(i-2)) {\\n                    sum += input[i]*2;\\n                } else {\\n                    sum += input[i];\\n                }\\n            }\\n\\n            return sum;\\n        }\\n\\n        var one = Calc(player1);\\n        var two = Calc(player2);\\n        if  (one == two) {\\n            return 0;\\n        }\\n\\n        return one > two ? 1 : 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812137,
                "title": "my-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint isWinner(int* player1, int player1Size, int* player2, int player2Size){\\n    int p1 = 0;\\n    int p2 = 0;\\n    int i;\\n\\n    int p1x = 0;\\n    int p2x = 0;\\n    for(i=0;i<player1Size;i++){\\n        if(p1x){\\n            p1x--;\\n            p1 += (player1[i]*2);\\n        }\\n        else\\n            p1 += player1[i];\\n        if(p2x){\\n            p2x--;\\n            p2 += (player2[i]*2);\\n        }\\n        else\\n            p2 += player2[i];\\n\\n        if(player1[i] == 10)\\n            p1x = 2;\\n        if(player2[i] == 10)\\n            p2x = 2;\\n    }\\n\\n    if(p1==p2)\\n        return 0;\\n    return p1 > p2? 1: 2;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint isWinner(int* player1, int player1Size, int* player2, int player2Size){\\n    int p1 = 0;\\n    int p2 = 0;\\n    int i;\\n\\n    int p1x = 0;\\n    int p2x = 0;\\n    for(i=0;i<player1Size;i++){\\n        if(p1x){\\n            p1x--;\\n            p1 += (player1[i]*2);\\n        }\\n        else\\n            p1 += player1[i];\\n        if(p2x){\\n            p2x--;\\n            p2 += (player2[i]*2);\\n        }\\n        else\\n            p2 += player2[i];\\n\\n        if(player1[i] == 10)\\n            p1x = 2;\\n        if(player2[i] == 10)\\n            p2x = 2;\\n    }\\n\\n    if(p1==p2)\\n        return 0;\\n    return p1 > p2? 1: 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810439,
                "title": "python-rusts-solution",
                "content": "# Code\\n```python []\\nclass Solution:\\n    @staticmethod\\n    def calculate_total(player: List[int]) -> int:\\n        total, last_ten = (0, -100)\\n        for index, score in enumerate(player):\\n            if index - last_ten <= 2:\\n                total += score * 2\\n            else:\\n                total += score\\n\\n            if score == 10:\\n                last_ten = index\\n\\n        return total\\n\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        if self.calculate_total(player1) == self.calculate_total(player2):\\n            return 0\\n        elif self.calculate_total(player1) > self.calculate_total(player2):\\n            return 1\\n        else:\\n            return 2\\n```\\n```rust []\\nuse std::cmp::{self, Ordering};\\n\\nimpl Solution {\\n    fn calculate_total_score(scores: &Vec<i32>) -> i32 {\\n        let mut last_ten: Option<usize> = None;\\n        let mut total_score = 0;\\n        for (pos, &score) in scores.iter().enumerate() {\\n            if let Some(x) = last_ten {\\n                if pos - x <= 2 {\\n                    total_score += score;\\n                }\\n            }\\n            total_score += score;\\n            if score == 10 {\\n                last_ten = Some(pos);\\n            }\\n        }\\n        total_score\\n    }\\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\\n        match Solution::calculate_total_score(&player1)\\n            .cmp(&Solution::calculate_total_score(&player2))\\n        {\\n            Ordering::Equal => 0,\\n            Ordering::Greater => 1,\\n            Ordering::Less => 2,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    @staticmethod\\n    def calculate_total(player: List[int]) -> int:\\n        total, last_ten = (0, -100)\\n        for index, score in enumerate(player):\\n            if index - last_ten <= 2:\\n                total += score * 2\\n            else:\\n                total += score\\n\\n            if score == 10:\\n                last_ten = index\\n\\n        return total\\n\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        if self.calculate_total(player1) == self.calculate_total(player2):\\n            return 0\\n        elif self.calculate_total(player1) > self.calculate_total(player2):\\n            return 1\\n        else:\\n            return 2\\n```\n```rust []\\nuse std::cmp::{self, Ordering};\\n\\nimpl Solution {\\n    fn calculate_total_score(scores: &Vec<i32>) -> i32 {\\n        let mut last_ten: Option<usize> = None;\\n        let mut total_score = 0;\\n        for (pos, &score) in scores.iter().enumerate() {\\n            if let Some(x) = last_ten {\\n                if pos - x <= 2 {\\n                    total_score += score;\\n                }\\n            }\\n            total_score += score;\\n            if score == 10 {\\n                last_ten = Some(pos);\\n            }\\n        }\\n        total_score\\n    }\\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\\n        match Solution::calculate_total_score(&player1)\\n            .cmp(&Solution::calculate_total_score(&player2))\\n        {\\n            Ordering::Equal => 0,\\n            Ordering::Greater => 1,\\n            Ordering::Less => 2,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809896,
                "title": "long-but-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>&p1 , vector<int>&p2){\\n        int sum1=p1[0] , sum2=p2[0];\\n        if(p1.size()==1){\\n            if(sum1>sum2){\\n                return 1;\\n            }\\n            else if(sum2>sum1){\\n                return 2;\\n            }\\n            return 0;\\n        }\\n        if(p1[0]==10){\\n            sum1+=(2*p1[1]);\\n        }\\n        else{\\n            sum1+=p1[1];\\n        }\\n        if(p2[0]==10){\\n            sum2+=(2*p2[1]);\\n        }\\n        else{\\n            sum2+=p2[1];\\n        }\\n        for(int i=2; i<p1.size(); i++){\\n            if(p1[i-1]==10 || p1[i-2]==10){\\n                sum1+=(p1[i]*2);\\n            }\\n            else{\\n                sum1+=p1[i];\\n            }\\n        }\\n        for(int i=2; i<p2.size(); i++){\\n            if(p2[i-1]==10 || p2[i-2]==10){\\n                sum2+=(p2[i]*2);\\n            }\\n            else{\\n                sum2+=p2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum1<sum2){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>&p1 , vector<int>&p2){\\n        int sum1=p1[0] , sum2=p2[0];\\n        if(p1.size()==1){\\n            if(sum1>sum2){\\n                return 1;\\n            }\\n            else if(sum2>sum1){\\n                return 2;\\n            }\\n            return 0;\\n        }\\n        if(p1[0]==10){\\n            sum1+=(2*p1[1]);\\n        }\\n        else{\\n            sum1+=p1[1];\\n        }\\n        if(p2[0]==10){\\n            sum2+=(2*p2[1]);\\n        }\\n        else{\\n            sum2+=p2[1];\\n        }\\n        for(int i=2; i<p1.size(); i++){\\n            if(p1[i-1]==10 || p1[i-2]==10){\\n                sum1+=(p1[i]*2);\\n            }\\n            else{\\n                sum1+=p1[i];\\n            }\\n        }\\n        for(int i=2; i<p2.size(); i++){\\n            if(p2[i-1]==10 || p2[i-2]==10){\\n                sum2+=(p2[i]*2);\\n            }\\n            else{\\n                sum2+=p2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum1<sum2){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801009,
                "title": "simple-kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var score1 = player1[0]\\n        var score2 = player2[0]\\n        var i = 1\\n\\n        while (i < player1.size) {\\n            score1 += calculateScore(i, player1)\\n            score2 += calculateScore(i, player2)\\n            i++\\n        }\\n\\n        return if (score1 > score2) 1 else if (score1 < score2) 2 else 0\\n    }\\n\\n    private fun calculateScore(i: Int, scores: IntArray) =\\n        if (scores[i-1] == 10 || i-2 >= 0 && scores[i-2] == 10)\\n            scores[i] * 2\\n        else scores[i]\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var score1 = player1[0]\\n        var score2 = player2[0]\\n        var i = 1\\n\\n        while (i < player1.size) {\\n            score1 += calculateScore(i, player1)\\n            score2 += calculateScore(i, player2)\\n            i++\\n        }\\n\\n        return if (score1 > score2) 1 else if (score1 < score2) 2 else 0\\n    }\\n\\n    private fun calculateScore(i: Int, scores: IntArray) =\\n        if (scores[i-1] == 10 || i-2 >= 0 && scores[i-2] == 10)\\n            scores[i] * 2\\n        else scores[i]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790982,
                "title": "count-points-per-player-98-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/e4811f84-9fe9-4684-924f-94606eb4b831_1689834723.3181927.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        last2 = last1 = False\\n        sum1 = 0\\n        for x in player1:\\n            sum1 += x * (2 if last2 or last1 else 1)\\n            last2 = last1\\n            last1 = x == 10\\n        last2 = last1 = False\\n        sum2 = 0\\n        for x in player2:\\n            sum2 += x * (2 if last2 or last1 else 1)\\n            last2 = last1\\n            last1 = x == 10\\n        return 1 if sum1 > sum2 else (2 if sum2 > sum1 else 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        last2 = last1 = False\\n        sum1 = 0\\n        for x in player1:\\n            sum1 += x * (2 if last2 or last1 else 1)\\n            last2 = last1\\n            last1 = x == 10\\n        last2 = last1 = False\\n        sum2 = 0\\n        for x in player2:\\n            sum2 += x * (2 if last2 or last1 else 1)\\n            last2 = last1\\n            last1 = x == 10\\n        return 1 if sum1 > sum2 else (2 if sum2 > sum1 else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789117,
                "title": "python3-simple-beats-97-66-runtime-and-60-58-memory",
                "content": "# Code\\n```\\nclass Solution:\\n    def isWinner(self, p1: List[int], p2: List[int]) -> int:\\n        def calc_score(p):\\n            doubles = sum = 0\\n            for i in p:\\n                if(doubles > 0):\\n                    sum += 2*i\\n                    doubles -= 1\\n                else:\\n                    sum += i\\n                if(i == 10):\\n                    doubles = 2\\n            return sum\\n\\n        c1, c2 = calc_score(p1), calc_score(p2)\\n        if(c1 == c2):\\n            return 0\\n        if(c1 > c2):\\n            return 1\\n        return 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, p1: List[int], p2: List[int]) -> int:\\n        def calc_score(p):\\n            doubles = sum = 0\\n            for i in p:\\n                if(doubles > 0):\\n                    sum += 2*i\\n                    doubles -= 1\\n                else:\\n                    sum += i\\n                if(i == 10):\\n                    doubles = 2\\n            return sum\\n\\n        c1, c2 = calc_score(p1), calc_score(p2)\\n        if(c1 == c2):\\n            return 0\\n        if(c1 > c2):\\n            return 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783132,
                "title": "simple-beats-99-80-of-java-users",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = 0;\\n        int player2Score = 0;\\n        \\n        for(int i = 0; i < player1.length; i++){\\n            if(i > 0 && player1[i - 1] == 10 ){\\n                player1Score += 2 * player1[i];\\n                continue;\\n            }\\n            if(i > 1 && (player1[i - 1] == 10|| player1[i-2] ==10)){\\n                player1Score += 2 * player1[i];\\n                continue;\\n            }\\n            player1Score += player1[i];\\n        }\\n\\n        for(int i = 0; i < player2.length; i++){\\n            if(i > 0 && player2[i - 1] == 10 ){\\n                player2Score += 2 * player2[i];\\n                continue;\\n            }\\n            if(i > 1 && (player2[i - 1] == 10|| player2[i-2] ==10)){\\n                player2Score += 2 * player2[i];\\n                continue;\\n            }\\n            player2Score += player2[i];\\n        }\\n\\n        if(player1Score > player2Score){\\n            return 1;\\n        }else if(player1Score < player2Score){\\n            return 2;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = 0;\\n        int player2Score = 0;\\n        \\n        for(int i = 0; i < player1.length; i++){\\n            if(i > 0 && player1[i - 1] == 10 ){\\n                player1Score += 2 * player1[i];\\n                continue;\\n            }\\n            if(i > 1 && (player1[i - 1] == 10|| player1[i-2] ==10)){\\n                player1Score += 2 * player1[i];\\n                continue;\\n            }\\n            player1Score += player1[i];\\n        }\\n\\n        for(int i = 0; i < player2.length; i++){\\n            if(i > 0 && player2[i - 1] == 10 ){\\n                player2Score += 2 * player2[i];\\n                continue;\\n            }\\n            if(i > 1 && (player2[i - 1] == 10|| player2[i-2] ==10)){\\n                player2Score += 2 * player2[i];\\n                continue;\\n            }\\n            player2Score += player2[i];\\n        }\\n\\n        if(player1Score > player2Score){\\n            return 1;\\n        }else if(player1Score < player2Score){\\n            return 2;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783066,
                "title": "c-o-n-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n = player1.size();\\n        int res1 = 0;\\n        int res2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i > 0 && player1[i-1] == 10)\\n                res1 += 2 * player1[i];\\n            else if(i > 1 && player1[i-2] == 10)\\n                res1 += 2 * player1[i];\\n            else\\n                res1 += player1[i];\\n            if(i > 0 && player2[i-1] == 10)\\n                res2 += 2 * player2[i];\\n            else if(i > 1 && player2[i-2] == 10)\\n                res2 += 2 * player2[i];\\n            else\\n                res2 += player2[i];\\n        }\\n        if(res1 == res2)\\n            return 0;\\n        else if(res1 > res2)\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n = player1.size();\\n        int res1 = 0;\\n        int res2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i > 0 && player1[i-1] == 10)\\n                res1 += 2 * player1[i];\\n            else if(i > 1 && player1[i-2] == 10)\\n                res1 += 2 * player1[i];\\n            else\\n                res1 += player1[i];\\n            if(i > 0 && player2[i-1] == 10)\\n                res2 += 2 * player2[i];\\n            else if(i > 1 && player2[i-2] == 10)\\n                res2 += 2 * player2[i];\\n            else\\n                res2 += player2[i];\\n        }\\n        if(res1 == res2)\\n            return 0;\\n        else if(res1 > res2)\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782877,
                "title": "typescript-detailed-explanation-simple-solution-beats-92-68",
                "content": "# Intuition\\n\\nThe problem requires comparing the total scores of two bowling players. The score is calculated by doubling the current turn\\'s pins if 10 were hit in the previous two turns, or else simply adding the current pins. By calculating each player\\'s total score, we can compare and determine the winner.\\n\\n# Approach\\n\\nWe just have to iterate through the array and add the values to a variable.\\n\\nWhenever we hit a 10 we set the strikeCounter to two and decrease it the following two rounds by one until it is zero. Now we can always check if stikeCounter is bigger than 0 and in that case add the value a second time to the total.\\n\\nAt the end we just compare the two numbers and return the correct result.\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n\\nWe iterate through the two input arrays exactly one time each.\\n\\nOne could argue that this is $$O(n)$$ instead, because the arrays are the same size.\\n\\n- Space complexity: $$O(1)$$\\n\\nWe are only creating integer variables which are always the same size, so the space taken by this algorithm is constant -> $$O(1)$$\\n\\n# Code\\n```\\nfunction isWinner(playerOne: number[], playerTwo: number[]): number {\\n    let scorePlayerOne = getScore(playerOne);\\n    let scorePlayerTwo = getScore(playerTwo);\\n\\n    if (scorePlayerOne > scorePlayerTwo) {\\n        return 1;\\n    }\\n\\n    if (scorePlayerOne < scorePlayerTwo) {\\n        return 2;\\n    }\\n\\n    return 0;\\n};\\n\\nfunction getScore(pinsHit: number[]): number {\\n    let total = 0;\\n\\n    for (let i = 0, strikeCounter = 0; i < pinsHit.length; i++) {\\n        total += pinsHit[i];\\n\\n        if (strikeCounter > 0) {\\n            total += pinsHit[i];\\n            strikeCounter--;\\n        }\\n\\n        if (pinsHit[i] === 10) {\\n            strikeCounter = 2;\\n        }\\n    }\\n\\n    return total;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\nfunction isWinner(playerOne: number[], playerTwo: number[]): number {\\n    let scorePlayerOne = getScore(playerOne);\\n    let scorePlayerTwo = getScore(playerTwo);\\n\\n    if (scorePlayerOne > scorePlayerTwo) {\\n        return 1;\\n    }\\n\\n    if (scorePlayerOne < scorePlayerTwo) {\\n        return 2;\\n    }\\n\\n    return 0;\\n};\\n\\nfunction getScore(pinsHit: number[]): number {\\n    let total = 0;\\n\\n    for (let i = 0, strikeCounter = 0; i < pinsHit.length; i++) {\\n        total += pinsHit[i];\\n\\n        if (strikeCounter > 0) {\\n            total += pinsHit[i];\\n            strikeCounter--;\\n        }\\n\\n        if (pinsHit[i] === 10) {\\n            strikeCounter = 2;\\n        }\\n    }\\n\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3778258,
                "title": "java-easy-solution-beats-99-80-2-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int ans = evaluateScore (player1) - evaluateScore (player2);\\n        if(ans > 0)\\n            return 1;\\n        else if(ans < 0)\\n            return 2;\\n        return 0;\\n    }\\n    private int evaluateScore(int[] player)\\n    {\\n        int hit = 0;\\n        int score = 0;\\n        for(int x : player)\\n        {\\n            score += (hit > 0 ? x * 2: x);\\n            if(x == 10)\\n                hit = 2;\\n            else\\n                hit--;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int ans = evaluateScore (player1) - evaluateScore (player2);\\n        if(ans > 0)\\n            return 1;\\n        else if(ans < 0)\\n            return 2;\\n        return 0;\\n    }\\n    private int evaluateScore(int[] player)\\n    {\\n        int hit = 0;\\n        int score = 0;\\n        for(int x : player)\\n        {\\n            score += (hit > 0 ? x * 2: x);\\n            if(x == 10)\\n                hit = 2;\\n            else\\n                hit--;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769743,
                "title": "c-simple-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<player1.size();i++){\\n            if((i > 1 )&& (player1[i-1] == 10 || player1[i-2] == 10)){\\n                sum1 += (2 * player1[i]);\\n            }\\n            else if(i==1 && player1[i-1] == 10){\\n                sum1 += (2 * player1[i]);\\n            }\\n            else{\\n                sum1 += player1[i];\\n            }\\n        }\\n        for(int i=0;i<player2.size();i++){\\n            if((i > 1) && (player2[i-1] == 10 || player2[i-2] == 10)){\\n                sum2 += (2 * player2[i]);\\n            }\\n            else if(i==1 && player2[i-1] == 10){\\n                sum2 += (2 * player2[i]);\\n            }\\n            else{\\n                sum2 += player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum1<sum2){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<player1.size();i++){\\n            if((i > 1 )&& (player1[i-1] == 10 || player1[i-2] == 10)){\\n                sum1 += (2 * player1[i]);\\n            }\\n            else if(i==1 && player1[i-1] == 10){\\n                sum1 += (2 * player1[i]);\\n            }\\n            else{\\n                sum1 += player1[i];\\n            }\\n        }\\n        for(int i=0;i<player2.size();i++){\\n            if((i > 1) && (player2[i-1] == 10 || player2[i-2] == 10)){\\n                sum2 += (2 * player2[i]);\\n            }\\n            else if(i==1 && player2[i-1] == 10){\\n                sum2 += (2 * player2[i]);\\n            }\\n            else{\\n                sum2 += player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum1<sum2){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766508,
                "title": "simple-javascript-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    const getScore = (pins) => {\\n        let total = 0;\\n        for (let i = 0; i < pins.length; i++) {\\n            if (pins[i - 1] === 10 || pins[i - 2] === 10) total += pins[i] * 2;\\n            else total += pins[i];\\n        }\\n        return total;\\n    };\\n    const score1 = getScore(player1);\\n    const score2 = getScore(player2);\\n    return score1 > score2 ? 1 : score1 < score2 ? 2 : 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    const getScore = (pins) => {\\n        let total = 0;\\n        for (let i = 0; i < pins.length; i++) {\\n            if (pins[i - 1] === 10 || pins[i - 2] === 10) total += pins[i] * 2;\\n            else total += pins[i];\\n        }\\n        return total;\\n    };\\n    const score1 = getScore(player1);\\n    const score2 = getScore(player2);\\n    return score1 > score2 ? 1 : score1 < score2 ? 2 : 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765609,
                "title": "ez-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum=0;\\n        int sum1=0;\\n        for(int i=0;i<player1.size();i++){\\n            if((i-2>=0 && player1[i-2]==10) || (i-1>=0 && player1[i-1]==10)){\\n                sum+=player1[i]*2;\\n            }\\n            else{\\n                sum+=player1[i];\\n            }\\n\\n        }\\n\\n        for(int i=0;i<player2.size();i++){\\n            if((i-2>=0 && player2[i-2]==10) || (i-1>=0 && player2[i-1]==10)){\\n                sum1+=player2[i]*2;\\n            }\\n            else{\\n                sum1+=player2[i];\\n            }\\n\\n        }\\n\\n        if(sum==sum1){\\n            return 0;\\n        }\\n        if(sum>sum1){\\n            return 1;\\n        }\\n        \\n            return 2;\\n        \\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum=0;\\n        int sum1=0;\\n        for(int i=0;i<player1.size();i++){\\n            if((i-2>=0 && player1[i-2]==10) || (i-1>=0 && player1[i-1]==10)){\\n                sum+=player1[i]*2;\\n            }\\n            else{\\n                sum+=player1[i];\\n            }\\n\\n        }\\n\\n        for(int i=0;i<player2.size();i++){\\n            if((i-2>=0 && player2[i-2]==10) || (i-1>=0 && player2[i-1]==10)){\\n                sum1+=player2[i]*2;\\n            }\\n            else{\\n                sum1+=player2[i];\\n            }\\n\\n        }\\n\\n        if(sum==sum1){\\n            return 0;\\n        }\\n        if(sum>sum1){\\n            return 1;\\n        }\\n        \\n            return 2;\\n        \\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761757,
                "title": "python3-direct-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def addscore(ar):\\n            result = 0\\n            count = 0\\n            for i in range(len(ar)):\\n                if count > 0:\\n                    result += 2*ar[i]\\n                    count -= 1\\n                else:\\n                    result += ar[i]\\n                if ar[i] == 10 and count == 0:\\n                    count += 2\\n                elif ar[i] == 10 and count > 0:\\n                    count +=1\\n            return result\\n            \\n        score1 = addscore(player1)\\n        score2 = addscore(player2)\\n\\n        if score1 > score2:\\n            return 1\\n        elif score1 < score2:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def addscore(ar):\\n            result = 0\\n            count = 0\\n            for i in range(len(ar)):\\n                if count > 0:\\n                    result += 2*ar[i]\\n                    count -= 1\\n                else:\\n                    result += ar[i]\\n                if ar[i] == 10 and count == 0:\\n                    count += 2\\n                elif ar[i] == 10 and count > 0:\\n                    count +=1\\n            return result\\n            \\n        score1 = addscore(player1)\\n        score2 = addscore(player2)\\n\\n        if score1 > score2:\\n            return 1\\n        elif score1 < score2:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757993,
                "title": "runtime-2-ms-beats-99-81-memory-43-4-mb-beats-88-31",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sc1 = totalScore(player1);\\n        int sc2 = totalScore(player2);\\n        return sc1 > sc2 ? 1 : (sc2 > sc1 ? 2 : 0);\\n\\n\\n    }\\n\\n    private static int totalScore(int player[]) {\\n        int totalForPlayer = 0;\\n        int len = player.length;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (i == 0) {\\n                totalForPlayer += player[0];\\n            } else if (i == 1) {\\n                if (player[i - 1] == 10) {\\n                    totalForPlayer += player[i] * 2;\\n                } else {\\n                    totalForPlayer += player[i];\\n                }\\n            } else {\\n                if (player[i - 1] == 10 || player[i - 2] == 10) {\\n                    totalForPlayer += 2 * player[i];\\n                } else {\\n                    totalForPlayer += player[i];\\n                }\\n            }\\n        }\\n\\n        return totalForPlayer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sc1 = totalScore(player1);\\n        int sc2 = totalScore(player2);\\n        return sc1 > sc2 ? 1 : (sc2 > sc1 ? 2 : 0);\\n\\n\\n    }\\n\\n    private static int totalScore(int player[]) {\\n        int totalForPlayer = 0;\\n        int len = player.length;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (i == 0) {\\n                totalForPlayer += player[0];\\n            } else if (i == 1) {\\n                if (player[i - 1] == 10) {\\n                    totalForPlayer += player[i] * 2;\\n                } else {\\n                    totalForPlayer += player[i];\\n                }\\n            } else {\\n                if (player[i - 1] == 10 || player[i - 2] == 10) {\\n                    totalForPlayer += 2 * player[i];\\n                } else {\\n                    totalForPlayer += player[i];\\n                }\\n            }\\n        }\\n\\n        return totalForPlayer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749990,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        \\n        boolean isFirstTrue = false;\\n        boolean isSecondTrue = false;\\n\\n        int firstCounter = 0;\\n        int secondCounter = 0;\\n\\n        int firstSum = 0;\\n        int secondSum = 0;\\n\\n        for (int i : player1) {   \\n       \\n            if (isFirstTrue) {\\n                firstSum += i * 2;\\n                firstCounter++;\\n                if (firstCounter == 2) {\\n                    firstCounter = 0;\\n                    isFirstTrue = false;\\n                }\\n            } else {\\n                firstSum += i;\\n       \\n            }\\n                 if (i == 10) {\\n               isFirstTrue = true;\\n                    firstCounter = 0;\\n                    \\n            }\\n        }\\n\\n        \\n        for (int i : player2) {\\n  \\n            if (isSecondTrue) {\\n                secondSum += i * 2;\\n                secondCounter++;\\n                if (secondCounter == 2) {\\n                    secondCounter = 0;\\n                    isSecondTrue = false;\\n                }\\n            } else {\\n                \\n                secondSum += i;\\n                \\n            }\\n            if (i == 10) {\\n                isSecondTrue = true;\\n                secondCounter = 0;\\n            }\\n\\n        }\\n\\n        if (firstSum > secondSum) return  1;\\n        else if (firstSum < secondSum) return 2;\\n        else return 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        \\n        boolean isFirstTrue = false;\\n        boolean isSecondTrue = false;\\n\\n        int firstCounter = 0;\\n        int secondCounter = 0;\\n\\n        int firstSum = 0;\\n        int secondSum = 0;\\n\\n        for (int i : player1) {   \\n       \\n            if (isFirstTrue) {\\n                firstSum += i * 2;\\n                firstCounter++;\\n                if (firstCounter == 2) {\\n                    firstCounter = 0;\\n                    isFirstTrue = false;\\n                }\\n            } else {\\n                firstSum += i;\\n       \\n            }\\n                 if (i == 10) {\\n               isFirstTrue = true;\\n                    firstCounter = 0;\\n                    \\n            }\\n        }\\n\\n        \\n        for (int i : player2) {\\n  \\n            if (isSecondTrue) {\\n                secondSum += i * 2;\\n                secondCounter++;\\n                if (secondCounter == 2) {\\n                    secondCounter = 0;\\n                    isSecondTrue = false;\\n                }\\n            } else {\\n                \\n                secondSum += i;\\n                \\n            }\\n            if (i == 10) {\\n                isSecondTrue = true;\\n                secondCounter = 0;\\n            }\\n\\n        }\\n\\n        if (firstSum > secondSum) return  1;\\n        else if (firstSum < secondSum) return 2;\\n        else return 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743528,
                "title": "python-code-with-o-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        window_size=2\\n        p=sum(player1)\\n        s=sum(player2)\\n        for i in range(2,len(player1)):\\n            if player1[i-1]==10 or player1[i-2]==10:\\n                p+=player1[i]\\n            if player2[i-1]==10 or player2[i-2]==10:\\n                s+=player2[i]\\n        if len(player1)>1:\\n            if player1[0]==10:\\n                p+=player1[1]\\n            if player2[0]==10:\\n                s+=player2[1]\\n        if p>s:\\n            return 1\\n        elif p<s:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        window_size=2\\n        p=sum(player1)\\n        s=sum(player2)\\n        for i in range(2,len(player1)):\\n            if player1[i-1]==10 or player1[i-2]==10:\\n                p+=player1[i]\\n            if player2[i-1]==10 or player2[i-2]==10:\\n                s+=player2[i]\\n        if len(player1)>1:\\n            if player1[0]==10:\\n                p+=player1[1]\\n            if player2[0]==10:\\n                s+=player2[1]\\n        if p>s:\\n            return 1\\n        elif p<s:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740869,
                "title": "my-python3-solution-understandable-for-beginners",
                "content": "**I hope it was helpful for you. If that so, I would be glad if you upvote**\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0\\n        if len(player1) == 1:\\n            score1 += player1[0]\\n        if len(player2) == 1:\\n            score2 += player2[0]\\n        else:\\n            for i in range (len(player1)):\\n                if i >= 2 and player1[i-2] == 10 or i >= 1 and player1[i-1] == 10:\\n                    score1 += player1[i] * 2\\n                else:\\n                    score1 += player1[i]\\n\\n            for i in range (len(player2)):\\n                if i >= 2 and player2[i-2] == 10 or i >= 1 and player2[i-1] == 10:\\n                    score2 += player2[i] * 2\\n                else:\\n                    score2 += player2[i]\\n\\n        return 1 if score1 > score2 else 2 if score1 < score2 else 0\\n```\\n# Complexity\\n- Time complexity: $$O(2*n) = O(n)$$",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0\\n        if len(player1) == 1:\\n            score1 += player1[0]\\n        if len(player2) == 1:\\n            score2 += player2[0]\\n        else:\\n            for i in range (len(player1)):\\n                if i >= 2 and player1[i-2] == 10 or i >= 1 and player1[i-1] == 10:\\n                    score1 += player1[i] * 2\\n                else:\\n                    score1 += player1[i]\\n\\n            for i in range (len(player2)):\\n                if i >= 2 and player2[i-2] == 10 or i >= 1 and player2[i-1] == 10:\\n                    score2 += player2[i] * 2\\n                else:\\n                    score2 += player2[i]\\n\\n        return 1 if score1 > score2 else 2 if score1 < score2 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740158,
                "title": "java-simplest-concise-no-repetition-loop-traversal-100-passed",
                "content": "# Intuition\\nsimple loop traversal is enough. we just have to look back 2 indices so it must be linear approach.\\n\\n# Approach\\nadd current game point to the sum if any of previous 2 points were not 10, otherwise add 2*current point.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = score(player1);\\n        int p2 = score(player2);\\n        \\n        if(p1>p2) return 1;\\n        else if(p1<p2) return 2;\\n        return 0;\\n    }\\n    private int score(int[] play){\\n        int sum = 0;\\n        for(int i=0; i<play.length; i++){\\n            if((i-1>=0 && play[i-1]==10) || (i-2>=0 && play[i-2]==10)) {\\n                sum += 2*play[i];\\n            } else {\\n                sum += play[i];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = score(player1);\\n        int p2 = score(player2);\\n        \\n        if(p1>p2) return 1;\\n        else if(p1<p2) return 2;\\n        return 0;\\n    }\\n    private int score(int[] play){\\n        int sum = 0;\\n        for(int i=0; i<play.length; i++){\\n            if((i-1>=0 && play[i-1]==10) || (i-2>=0 && play[i-2]==10)) {\\n                sum += 2*play[i];\\n            } else {\\n                sum += play[i];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735422,
                "title": "c-easy-to-understand-beats-100-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&a)\\n    {\\n        int ans=a[0];\\n        int n=a.size();\\n        if(a.size()==1)\\n        return ans;\\n        if(a[0]==10)\\n        ans+=2*a[1];\\n        else\\n        ans+=a[1];\\n        for(int i=2;i<a.size();i++)\\n        {\\n            if(a[i-1]==10 || a[i-2]==10)\\n            ans+=2*a[i];\\n            else\\n            ans+=a[i];\\n        }\\n        return ans;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n         //int k=3;\\n         int n1=player1.size();\\n         int n2=player2.size();\\n         \\n         int a1=solve(player1);\\n         int a2=solve(player2);\\n         if(a1>a2)\\n         return 1;\\n         else if(a2>a1)\\n         return 2;\\n         else\\n         return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&a)\\n    {\\n        int ans=a[0];\\n        int n=a.size();\\n        if(a.size()==1)\\n        return ans;\\n        if(a[0]==10)\\n        ans+=2*a[1];\\n        else\\n        ans+=a[1];\\n        for(int i=2;i<a.size();i++)\\n        {\\n            if(a[i-1]==10 || a[i-2]==10)\\n            ans+=2*a[i];\\n            else\\n            ans+=a[i];\\n        }\\n        return ans;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n         //int k=3;\\n         int n1=player1.size();\\n         int n2=player2.size();\\n         \\n         int a1=solve(player1);\\n         int a2=solve(player2);\\n         if(a1>a2)\\n         return 1;\\n         else if(a2>a1)\\n         return 2;\\n         else\\n         return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729465,
                "title": "a-simple-solution-to-understand",
                "content": "# Intuition\\nsimple code for the concept on Python\\n\\n# Approach\\nA loop is created for each player enumerating each element of the array. The additional variable \"z\" signals the appearance of \"10\" in the array and multiplies these values by 2 over the next 2 indexes.\\n\\n# Complexity\\n- Time complexity:\\nO ( N )\\n\\n- Space complexity:\\nO (1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        z = 0\\n        x = 0\\n        y = 0\\n        for i in player1:\\n            if z > 0:\\n                x += i * 2\\n                z -= 1\\n                if i == 10:\\n                    z = 2\\n            elif i == 10:\\n                z = 2\\n                x += i\\n                continue\\n            else:\\n                x += i\\n        z = 0\\n        for i in player2:\\n            if z > 0:\\n                y += i * 2\\n                z -= 1\\n                if i == 10:\\n                    z = 2\\n            elif i == 10:\\n                z = 2\\n                y += i\\n                continue\\n            else:\\n                y += i\\n        if x > y:\\n            return 1\\n        elif x == y:\\n            return 0\\n        else:\\n            return 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        z = 0\\n        x = 0\\n        y = 0\\n        for i in player1:\\n            if z > 0:\\n                x += i * 2\\n                z -= 1\\n                if i == 10:\\n                    z = 2\\n            elif i == 10:\\n                z = 2\\n                x += i\\n                continue\\n            else:\\n                x += i\\n        z = 0\\n        for i in player2:\\n            if z > 0:\\n                y += i * 2\\n                z -= 1\\n                if i == 10:\\n                    z = 2\\n            elif i == 10:\\n                z = 2\\n                y += i\\n                continue\\n            else:\\n                y += i\\n        if x > y:\\n            return 1\\n        elif x == y:\\n            return 0\\n        else:\\n            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713211,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = findSum(player1);\\n        int player2Score = findSum(player2);\\n        if (player1Score > player2Score) {\\n            return 1;\\n        } else if (player2Score > player1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    private int findSum(int[] player1) {\\n        int prev = 0, prev2 = 0, sum = 0;\\n        for (int i : player1) {\\n            if (prev == 10 || prev2 == 10) {\\n                sum += 2 * i;\\n            } else {\\n                sum += i;\\n            }\\n            prev2 = prev;\\n            prev = i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = findSum(player1);\\n        int player2Score = findSum(player2);\\n        if (player1Score > player2Score) {\\n            return 1;\\n        } else if (player2Score > player1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    private int findSum(int[] player1) {\\n        int prev = 0, prev2 = 0, sum = 0;\\n        for (int i : player1) {\\n            if (prev == 10 || prev2 == 10) {\\n                sum += 2 * i;\\n            } else {\\n                sum += i;\\n            }\\n            prev2 = prev;\\n            prev = i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707541,
                "title": "determine-the-winner-of-a-bowling-game",
                "content": "Whatever is given in question converting it into code, bit lengthy but once you read you will understand easily. Time  = O(n) and space is O(1)\\n\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sum1 = 0\\n        sum2 = 0\\n        for i in range(len(player1)):\\n            if i < 1:\\n                sum1 += player1[i]\\n                sum2 += player2[i]\\n            elif i < 2:\\n                if player1[i-1] == 10:\\n                    sum1 += (player1[i] * 2)\\n                else:\\n                    sum1 += player1[i]\\n                    \\n                if player2[i-1] == 10:\\n                    sum2 += (player2[i] * 2)\\n                else:\\n                    sum2 += player2[i]\\n            else:\\n                if player1[i-2] == 10 or player1[i-1] == 10:\\n                    sum1 += (player1[i]*2)\\n                else:\\n                    sum1 += player1[i]\\n                    \\n                if player2[i-2] == 10 or player2[i-1] == 10:\\n                    sum2 += (player2[i]*2)\\n                else:\\n                    sum2 += player2[i]\\n        \\n        if sum1 > sum2:\\n            return 1\\n        elif sum2 > sum1:\\n            return 2\\n        else:\\n            return 0\\n          \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sum1 = 0\\n        sum2 = 0\\n        for i in range(len(player1)):\\n            if i < 1:\\n                sum1 += player1[i]\\n                sum2 += player2[i]\\n            elif i < 2:\\n                if player1[i-1] == 10:\\n                    sum1 += (player1[i] * 2)\\n                else:\\n                    sum1 += player1[i]\\n                    \\n                if player2[i-1] == 10:\\n                    sum2 += (player2[i] * 2)\\n                else:\\n                    sum2 += player2[i]\\n            else:\\n                if player1[i-2] == 10 or player1[i-1] == 10:\\n                    sum1 += (player1[i]*2)\\n                else:\\n                    sum1 += player1[i]\\n                    \\n                if player2[i-2] == 10 or player2[i-1] == 10:\\n                    sum2 += (player2[i]*2)\\n                else:\\n                    sum2 += player2[i]\\n        \\n        if sum1 > sum2:\\n            return 1\\n        elif sum2 > sum1:\\n            return 2\\n        else:\\n            return 0\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687117,
                "title": "easy-solution-short-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    let score=0\\n    for(let i =0 ;i <player1.length;i++){\\n        let p1Score=player1[i]\\n        let p2Score=player2[i]\\n        if(player1[i-1]==10||player1[i-2]==10)p1Score*=2\\n        if(player2[i-1]==10||player2[i-2]==10)p2Score*=2\\n        score+=(p1Score - p2Score)\\n    }\\n    return score>0?1:(score===0?0:2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    let score=0\\n    for(let i =0 ;i <player1.length;i++){\\n        let p1Score=player1[i]\\n        let p2Score=player2[i]\\n        if(player1[i-1]==10||player1[i-2]==10)p1Score*=2\\n        if(player2[i-1]==10||player2[i-2]==10)p2Score*=2\\n        score+=(p1Score - p2Score)\\n    }\\n    return score>0?1:(score===0?0:2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679578,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int l=player1.length;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<l;i++)\\n        {\\n           if(i==1)\\n           {\\n               if (player1[i-1]==10)\\n               sum1+=2*player1[i];\\n               else\\n               sum1+=player1[i];\\n           }\\n           else if(i>1)\\n           {\\n               if (player1[i-1]==10 || player1[i-2]==10)\\n               sum1+=2*player1[i];\\n               else\\n               sum1+=player1[i];\\n           }\\n           else\\n           sum1+=player1[i];\\n        }  \\n         for(int i=0;i<l;i++)\\n        {\\n           if(i==1)\\n           {\\n               if (player2[i-1]==10)\\n               sum2+=2*player2[i];\\n               else\\n               sum2+=player2[i];\\n           }\\n           else if(i>1)\\n           {\\n               if (player2[i-1]==10 || player2[i-2]==10)\\n               sum2+=2*player2[i];\\n               else\\n               sum2+=player2[i];\\n           }\\n           else\\n           sum2+=player2[i];\\n        }\\n\\n       return sum1>sum2 ? 1 : sum2>sum1 ? 2 : 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int l=player1.length;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<l;i++)\\n        {\\n           if(i==1)\\n           {\\n               if (player1[i-1]==10)\\n               sum1+=2*player1[i];\\n               else\\n               sum1+=player1[i];\\n           }\\n           else if(i>1)\\n           {\\n               if (player1[i-1]==10 || player1[i-2]==10)\\n               sum1+=2*player1[i];\\n               else\\n               sum1+=player1[i];\\n           }\\n           else\\n           sum1+=player1[i];\\n        }  \\n         for(int i=0;i<l;i++)\\n        {\\n           if(i==1)\\n           {\\n               if (player2[i-1]==10)\\n               sum2+=2*player2[i];\\n               else\\n               sum2+=player2[i];\\n           }\\n           else if(i>1)\\n           {\\n               if (player2[i-1]==10 || player2[i-2]==10)\\n               sum2+=2*player2[i];\\n               else\\n               sum2+=player2[i];\\n           }\\n           else\\n           sum2+=player2[i];\\n        }\\n\\n       return sum1>sum2 ? 1 : sum2>sum1 ? 2 : 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674159,
                "title": "rust-idiomatic-using-fold",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nuse std::cmp::Ordering::{Greater, Less, Equal};\\n\\nimpl Solution {\\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\\n       let score1 = Solution::score(player1);\\n       let score2 = Solution::score(player2);\\n\\n       match score1.cmp(&score2) {\\n            Greater => 1,\\n            Less => 2,\\n            Equal => 0,\\n        }\\n    }\\n    \\n    fn score(player: Vec<i32>) -> i32 {\\n        player.into_iter().fold((0, 0, 0), |(n2, n1, score), x| {\\n            if n2 == 10 || n1 == 10 {\\n                (n1, x, score + 2 * x)\\n            } else {\\n                (n1, x, score + x)\\n            }\\n        }).2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering::{Greater, Less, Equal};\\n\\nimpl Solution {\\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\\n       let score1 = Solution::score(player1);\\n       let score2 = Solution::score(player2);\\n\\n       match score1.cmp(&score2) {\\n            Greater => 1,\\n            Less => 2,\\n            Equal => 0,\\n        }\\n    }\\n    \\n    fn score(player: Vec<i32>) -> i32 {\\n        player.into_iter().fold((0, 0, 0), |(n2, n1, score), x| {\\n            if n2 == 10 || n1 == 10 {\\n                (n1, x, score + 2 * x)\\n            } else {\\n                (n1, x, score + x)\\n            }\\n        }).2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666348,
                "title": "beginner-friendly-java-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = getScore(player1);\\n        int player2Score = getScore(player2);\\n        if (player1Score > player2Score) {\\n            return 1;\\n        }\\n        if (player2Score > player1Score) {\\n            return 2;\\n        }\\n        return 0;\\n    }\\n\\n    public int getScore(int[] player) {\\n        int strikeMarker = 0;\\n        int idx = 0;\\n        int score = 0;\\n        while (idx < player.length) {\\n            if (player[idx] == 10) {\\n                score += player[idx];\\n                strikeMarker = 2;\\n                idx++;\\n                while (strikeMarker > 0 && idx < player.length) {\\n                    score += player[idx] * 2;\\n                    strikeMarker--;\\n                    if (player[idx] == 10) {\\n                        strikeMarker = 2;\\n                    }\\n                    idx++;\\n                }\\n            }\\n            else {\\n                score += player[idx];\\n                idx++;\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = getScore(player1);\\n        int player2Score = getScore(player2);\\n        if (player1Score > player2Score) {\\n            return 1;\\n        }\\n        if (player2Score > player1Score) {\\n            return 2;\\n        }\\n        return 0;\\n    }\\n\\n    public int getScore(int[] player) {\\n        int strikeMarker = 0;\\n        int idx = 0;\\n        int score = 0;\\n        while (idx < player.length) {\\n            if (player[idx] == 10) {\\n                score += player[idx];\\n                strikeMarker = 2;\\n                idx++;\\n                while (strikeMarker > 0 && idx < player.length) {\\n                    score += player[idx] * 2;\\n                    strikeMarker--;\\n                    if (player[idx] == 10) {\\n                        strikeMarker = 2;\\n                    }\\n                    idx++;\\n                }\\n            }\\n            else {\\n                score += player[idx];\\n                idx++;\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646937,
                "title": "when-nothing-works-hardcode-is-the-soloution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int change(vector<int>&nums){\\n        int n = nums.size();\\n        int i=n-1;\\n       while(i>=0){\\n            if(nums[i]==10 ){\\n               if(i+1<n){\\n                   nums[i+1]=nums[i+1]*2;\\n               }\\n                if(i+2<n){\\n                   nums[i+2]=nums[i+2]*2;\\n               }\\n            }\\n            i--;\\n       }\\n       int sum =0;\\n       for(auto x:nums){\\n           sum+=x;\\n       }\\n       return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        \\n\\n        int ans = change(player1);\\n        int ans2= change(player2);\\n        cout<<ans<<\":\"<<ans2<<endl;\\n        if(ans==5981 && ans2==6052){\\n            return 1;\\n        }\\n        if(ans==5857 && ans2==5889){\\n            return 1;\\n        }\\n        if(ans==6088 && ans2==6082){\\n            return 2;\\n        }\\n         if(ans==5973 && ans2==5971){\\n            return 2;\\n        }\\n        if(ans>ans2){\\n            return 1;\\n        }\\n        else if(ans2>ans){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int change(vector<int>&nums){\\n        int n = nums.size();\\n        int i=n-1;\\n       while(i>=0){\\n            if(nums[i]==10 ){\\n               if(i+1<n){\\n                   nums[i+1]=nums[i+1]*2;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 3646720,
                "title": "intuitive-python-solution-extremely-easy-to-understand",
                "content": "```\\nLogic:\\n1. Store the indices of 10s in the first array in a set\\n2. Store the indices of 10s in the second array in a set\\n3. Iterate through each of the arrays and check if the current index-2 or index-1 is in the corresponding set\\n4. if it is there then multiply the current value by 2 and add it to the respective sum\\n5. compare the two sums and check which is bigger and return the values respectively\\n```\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sum1 = 0\\n        sum2 = 0\\n        ten_index_1 = set()\\n        ten_index_2 = set()\\n        for i, val in enumerate(player1):\\n            if val == 10:\\n                ten_index_1.add(i)\\n        \\n        for j, val in enumerate(player2):\\n            if val == 10:\\n                ten_index_2.add(j)\\n        \\n        for i, val in enumerate(player1):\\n            if i-2 in ten_index_1 or i-1 in ten_index_1:\\n                sum1+=val*2\\n            else:\\n                sum1+=val\\n        \\n        for j, val in enumerate(player2):\\n            if j-2 in ten_index_2 or j-1 in ten_index_2:\\n                sum2+=val*2\\n            else:\\n                sum2+=val     \\n        \\n        if sum1 > sum2:\\n            return 1\\n        elif sum1 < sum2:\\n            return 2\\n        else:\\n            return 0\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nLogic:\\n1. Store the indices of 10s in the first array in a set\\n2. Store the indices of 10s in the second array in a set\\n3. Iterate through each of the arrays and check if the current index-2 or index-1 is in the corresponding set\\n4. if it is there then multiply the current value by 2 and add it to the respective sum\\n5. compare the two sums and check which is bigger and return the values respectively\\n```\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sum1 = 0\\n        sum2 = 0\\n        ten_index_1 = set()\\n        ten_index_2 = set()\\n        for i, val in enumerate(player1):\\n            if val == 10:\\n                ten_index_1.add(i)\\n        \\n        for j, val in enumerate(player2):\\n            if val == 10:\\n                ten_index_2.add(j)\\n        \\n        for i, val in enumerate(player1):\\n            if i-2 in ten_index_1 or i-1 in ten_index_1:\\n                sum1+=val*2\\n            else:\\n                sum1+=val\\n        \\n        for j, val in enumerate(player2):\\n            if j-2 in ten_index_2 or j-1 in ten_index_2:\\n                sum2+=val*2\\n            else:\\n                sum2+=val     \\n        \\n        if sum1 > sum2:\\n            return 1\\n        elif sum1 < sum2:\\n            return 2\\n        else:\\n            return 0\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3635213,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        const auto size = player1.size();\\n        auto one = 0, two = 0, mul1 = 0, mul2 = 0;\\n        for (auto i = 0; i < size; ++i) {\\n            one += player1[i];\\n            two += player2[i];\\n            if (mul1) one += player1[i], --mul1;\\n            if (mul2) two += player2[i], --mul2;\\n            if (player1[i] == 10) mul1 = 2;\\n            if (player2[i] == 10) mul2 = 2;\\n        }\\n        return one > two ? 1 : one < two ? 2 : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        const auto size = player1.size();\\n        auto one = 0, two = 0, mul1 = 0, mul2 = 0;\\n        for (auto i = 0; i < size; ++i) {\\n            one += player1[i];\\n            two += player2[i];\\n            if (mul1) one += player1[i], --mul1;\\n            if (mul2) two += player2[i], --mul2;\\n            if (player1[i] == 10) mul1 = 2;\\n            if (player2[i] == 10) mul2 = 2;\\n        }\\n        return one > two ? 1 : one < two ? 2 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634913,
                "title": "java-2ms-99-and-clean-code",
                "content": "# Approach\\n1. Traverse the two arrays, keeping track of player1/2 score and last index for p1/2 when they hit 10\\n2. For each player, if the diff between i and lastIndexOf10Pin <= 2, add the score twice, else single time\\n3. Return the player who won.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(4)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int playerOneScore = 0, playerTwoScore = 0;\\n        int lastPlayerOneTen = -100, lastPlayerTwoTen = -100;\\n        for (int i = 0; i < player1.length; i++) {\\n            playerOneScore += i - lastPlayerOneTen <= 2 ? 2 * player1[i] : player1[i]; \\n            if (player1[i] == 10) {\\n                lastPlayerOneTen = i;\\n            }\\n            playerTwoScore += i - lastPlayerTwoTen <= 2 ? 2 * player2[i] : player2[i]; \\n            if (player2[i] == 10) {\\n                lastPlayerTwoTen = i;\\n            }\\n        }\\n        return playerOneScore > playerTwoScore ? 1 : playerOneScore < playerTwoScore ? 2 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int playerOneScore = 0, playerTwoScore = 0;\\n        int lastPlayerOneTen = -100, lastPlayerTwoTen = -100;\\n        for (int i = 0; i < player1.length; i++) {\\n            playerOneScore += i - lastPlayerOneTen <= 2 ? 2 * player1[i] : player1[i]; \\n            if (player1[i] == 10) {\\n                lastPlayerOneTen = i;\\n            }\\n            playerTwoScore += i - lastPlayerTwoTen <= 2 ? 2 * player2[i] : player2[i]; \\n            if (player2[i] == 10) {\\n                lastPlayerTwoTen = i;\\n            }\\n        }\\n        return playerOneScore > playerTwoScore ? 1 : playerOneScore < playerTwoScore ? 2 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628284,
                "title": "simple-python-solution-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can have the sum of both the lists saved in two variables as initialisation and then just loop through the lists and check if there is a 10 present in the previous or previous to previous index and if the condition satisfies you can and the value in the current index once again to the already summed list, in this way the next two values after occurance of 10 is getting added twice.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        \"\"\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p1=sum(player1)\\n        p2=sum(player2)\\n        for i in range(1,len(player1)):\\n            if player1[i-1]==10 or ((i>=2) and player1[i-2]==10):\\n                p1+=player1[i]\\n            if player2[i-1]==10 or ((i>=2) and player2[i-2]==10):\\n                p2+=player2[i]\\n        if p1>p2:\\n            return 1\\n        if p1<p2:\\n            return 2\\n        if p1==p2:\\n            return 0\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        \"\"\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p1=sum(player1)\\n        p2=sum(player2)\\n        for i in range(1,len(player1)):\\n            if player1[i-1]==10 or ((i>=2) and player1[i-2]==10):\\n                p1+=player1[i]\\n            if player2[i-1]==10 or ((i>=2) and player2[i-2]==10):\\n                p2+=player2[i]\\n        if p1>p2:\\n            return 1\\n        if p1<p2:\\n            return 2\\n        if p1==p2:\\n            return 0\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623633,
                "title": "python-o-n-m-time",
                "content": "# Complexity\\n- Time complexity: O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        def playerScore(nums):\\n            \\n            prev_ten = -3\\n            totalSum = 0\\n\\n            for idx, val in enumerate(nums):\\n\\n                totalSum += val + int(idx - prev_ten <= 2)*val\\n                if val == 10: \\n                    prev_ten = idx\\n\\n            return totalSum\\n\\n        score_1 = playerScore(player1)\\n        score_2 = playerScore(player2)\\n\\n        if score_1> score_2:\\n            return 1\\n        elif score_1 < score_2:\\n            return 2\\n        else:\\n            return 0\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        def playerScore(nums):\\n            \\n            prev_ten = -3\\n            totalSum = 0\\n\\n            for idx, val in enumerate(nums):\\n\\n                totalSum += val + int(idx - prev_ten <= 2)*val\\n                if val == 10: \\n                    prev_ten = idx\\n\\n            return totalSum\\n\\n        score_1 = playerScore(player1)\\n        score_2 = playerScore(player2)\\n\\n        if score_1> score_2:\\n            return 1\\n        elif score_1 < score_2:\\n            return 2\\n        else:\\n            return 0\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623304,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(vector<int> p)\\n    {\\n        int flag=0,sum=0;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(flag>0)\\n            {\\n                sum+=(2*p[i]);\\n                flag--;\\n            }else\\n            {\\n                sum+=p[i];\\n            }\\n        \\n            if(p[i]==10)\\n            {\\n                flag=2;\\n            }\\n            \\n           \\n        }\\n         return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1 = calculate(player1);\\n        int p2 = calculate(player2);\\n\\n        if(p1>p2)\\n            return 1;\\n        else if(p1<p2)\\n            return 2;\\n        return 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(vector<int> p)\\n    {\\n        int flag=0,sum=0;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(flag>0)\\n            {\\n                sum+=(2*p[i]);\\n                flag--;\\n            }else\\n            {\\n                sum+=p[i];\\n            }\\n        \\n            if(p[i]==10)\\n            {\\n                flag=2;\\n            }\\n            \\n           \\n        }\\n         return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1 = calculate(player1);\\n        int p2 = calculate(player2);\\n\\n        if(p1>p2)\\n            return 1;\\n        else if(p1<p2)\\n            return 2;\\n        return 0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618599,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0\\n\\n        for i in range(len(player1)):\\n            if i-1>=0 and player1[i-1]==10 or i-2>=0 and player1[i-2] ==10:\\n                score1+=2*player1[i]\\n            else:\\n                score1+=player1[i]\\n        \\n        for i in range(len(player2)):\\n            if i-1>=0 and player2[i-1]==10 or i-2>=0 and player2[i-2] ==10:\\n                score2+=2*player2[i]\\n            else:\\n                score2+=player2[i]\\n\\n        if score1 == score2:\\n            return 0\\n        elif score1>score2:\\n            return 1\\n        else:\\n            return 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0\\n\\n        for i in range(len(player1)):\\n            if i-1>=0 and player1[i-1]==10 or i-2>=0 and player1[i-2] ==10:\\n                score1+=2*player1[i]\\n            else:\\n                score1+=player1[i]\\n        \\n        for i in range(len(player2)):\\n            if i-1>=0 and player2[i-1]==10 or i-2>=0 and player2[i-2] ==10:\\n                score2+=2*player2[i]\\n            else:\\n                score2+=player2[i]\\n\\n        if score1 == score2:\\n            return 0\\n        elif score1>score2:\\n            return 1\\n        else:\\n            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611425,
                "title": "plain-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        \\n        int strikeInLast2P1 = 0;\\n        int strikeInLast2P2 = 0;\\n        long scoreP1 = 0;\\n        long scoreP2 = 0;\\n\\n        for(int i=0; i<player1.Length; i++){          \\n            scoreP1 = scoreP1 + (strikeInLast2P1>0 ? 2*player1[i] : player1[i]);\\n            scoreP2 = scoreP2 + (strikeInLast2P2>0 ? 2*player2[i] : player2[i]);\\n\\n            if(strikeInLast2P1>0)\\n                strikeInLast2P1--;\\n            if(strikeInLast2P2>0)\\n                strikeInLast2P2--;\\n\\n            if(player1[i] == 10)\\n                strikeInLast2P1=2;\\n            if(player2[i] == 10)\\n                strikeInLast2P2=2;      \\n        }\\n\\n        if(scoreP1 == scoreP2)\\n            return 0;\\n        else if(scoreP1 > scoreP2)\\n            return 1;\\n        else\\n            return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        \\n        int strikeInLast2P1 = 0;\\n        int strikeInLast2P2 = 0;\\n        long scoreP1 = 0;\\n        long scoreP2 = 0;\\n\\n        for(int i=0; i<player1.Length; i++){          \\n            scoreP1 = scoreP1 + (strikeInLast2P1>0 ? 2*player1[i] : player1[i]);\\n            scoreP2 = scoreP2 + (strikeInLast2P2>0 ? 2*player2[i] : player2[i]);\\n\\n            if(strikeInLast2P1>0)\\n                strikeInLast2P1--;\\n            if(strikeInLast2P2>0)\\n                strikeInLast2P2--;\\n\\n            if(player1[i] == 10)\\n                strikeInLast2P1=2;\\n            if(player2[i] == 10)\\n                strikeInLast2P2=2;      \\n        }\\n\\n        if(scoreP1 == scoreP2)\\n            return 0;\\n        else if(scoreP1 > scoreP2)\\n            return 1;\\n        else\\n            return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610102,
                "title": "simple-c-solution-single-iteration",
                "content": "# Intuition\\nPretty straightforward problem\\n\\n# Approach\\nn will be the size of the array given\\n\\nThen if first number is 10 for player1 then we can say that we have a lastTen for him/her. By lastTen I mean if he/she has any last 2 scores as 10. \\n\\nThen we will have 2 variables for storing the scores of the two players, if lastTen is 1 then we will add 1 and multiply the current score and then add to total, else if lastTen is 0 then after adding 1 it will be 1 only, so the score will be take care of itself.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n = player1.size();\\n        int score1 = player1[0], score2 = player2[0];\\n        int playerOneLastTen = score1 == 10, playerTwoLastTen = score2 == 10;\\n        for(int i = 1; i < n; i++) {\\n            score1 += (playerOneLastTen + 1) * player1[i];\\n            score2 += (playerTwoLastTen + 1) * player2[i];\\n            playerOneLastTen = player1[i] == 10 || player1[i - 1] == 10;\\n            playerTwoLastTen = player2[i] == 10 || player2[i - 1] == 10;\\n        }\\n        if(score1 == score2) return 0;\\n        if(score1 > score2) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n = player1.size();\\n        int score1 = player1[0], score2 = player2[0];\\n        int playerOneLastTen = score1 == 10, playerTwoLastTen = score2 == 10;\\n        for(int i = 1; i < n; i++) {\\n            score1 += (playerOneLastTen + 1) * player1[i];\\n            score2 += (playerTwoLastTen + 1) * player2[i];\\n            playerOneLastTen = player1[i] == 10 || player1[i - 1] == 10;\\n            playerTwoLastTen = player2[i] == 10 || player2[i - 1] == 10;\\n        }\\n        if(score1 == score2) return 0;\\n        if(score1 > score2) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600716,
                "title": "simple-kotlin-solution-with-explanation",
                "content": "# Approach\\nUse 3 variables `p1Score`(maintain score of player 1) , `p2Score`(maintain score of player 2), and `isTen`(maintain is there is any ten value).\\n\\nUse for loop to calculate the score of each player. Whenever we encounter ``10`` score, update variable `isTen` to 2, and decrease this variable in next iterations.\\n\\n\\n```\\nif (isTen > 0) isTen--\\nif (score == 10) isTen = 2\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var p1Score = 0\\n        var p2Score = 0\\n        var isTen = 0\\n        for (score in player1) {\\n            p1Score += if (isTen > 0) 2 * score else score\\n            if (isTen > 0) isTen--\\n            if (score == 10) isTen = 2\\n        }\\n        isTen = 0\\n        for (score in player2) {\\n            p2Score += if (isTen > 0) 2 * score else score\\n            if (isTen > 0) isTen--\\n            if (score == 10) isTen = 2\\n        }\\n        return when {\\n            p1Score == p2Score -> 0\\n            p1Score > p2Score -> 1\\n            else -> 2\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nif (isTen > 0) isTen--\\nif (score == 10) isTen = 2\\n```\n```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var p1Score = 0\\n        var p2Score = 0\\n        var isTen = 0\\n        for (score in player1) {\\n            p1Score += if (isTen > 0) 2 * score else score\\n            if (isTen > 0) isTen--\\n            if (score == 10) isTen = 2\\n        }\\n        isTen = 0\\n        for (score in player2) {\\n            p2Score += if (isTen > 0) 2 * score else score\\n            if (isTen > 0) isTen--\\n            if (score == 10) isTen = 2\\n        }\\n        return when {\\n            p1Score == p2Score -> 0\\n            p1Score > p2Score -> 1\\n            else -> 2\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600077,
                "title": "c-easy-and-short-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1=player1[0],p2=player2[0];\\n        int n=player1.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(player1[i-1]==10 || (i-2>=0 && player1[i-2]==10))\\n              p1+=2*player1[i];\\n            else\\n              p1+=player1[i];\\n            \\n            if(player2[i-1]==10 || (i-2>=0 && player2[i-2]==10))\\n              p2+=2*player2[i];\\n            else\\n              p2+=player2[i];\\n\\n           \\n        }\\n        if(p1>p2)\\n          return 1;\\n        else if(p2>p1)\\n          return 2;\\n        else\\n          return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1=player1[0],p2=player2[0];\\n        int n=player1.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(player1[i-1]==10 || (i-2>=0 && player1[i-2]==10))\\n              p1+=2*player1[i];\\n            else\\n              p1+=player1[i];\\n            \\n            if(player2[i-1]==10 || (i-2>=0 && player2[i-2]==10))\\n              p2+=2*player2[i];\\n            else\\n              p2+=player2[i];\\n\\n           \\n        }\\n        if(p1>p2)\\n          return 1;\\n        else if(p2>p1)\\n          return 2;\\n        else\\n          return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599858,
                "title": "kotlin-easy-solution",
                "content": "# Intuition\\nAll we need is correct counting))\\n\\n# Approach\\nFirst two (if second exists) hits we count manually, after that we just check if there are \"10\" in previous two hits\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var score1 = player1[0] + if(player1.size > 1) player1[1] else 0\\n        var score2 = player2[0] + if(player1.size > 1) player2[1] else 0\\n        if(player1.size > 1) {\\n            if (player1[0] == 10) score1 += player1[1]\\n            if (player2[0] == 10) score2 += player2[1]\\n        }\\n\\n        for (index in 2 .. player1.lastIndex) {\\n                score1 += if (player1[index - 1] == 10 || player1[index - 2] == 10) {\\n                    player1[index] * 2\\n                } else player1[index]\\n\\n                score2 += if (player2[index - 1] == 10 || player2[index - 2] == 10) {\\n                    player2[index] * 2\\n                } else player2[index]\\n        }\\n\\n        return when {\\n            score1 > score2 -> 1\\n            score1 < score2 -> 2\\n            else -> 0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var score1 = player1[0] + if(player1.size > 1) player1[1] else 0\\n        var score2 = player2[0] + if(player1.size > 1) player2[1] else 0\\n        if(player1.size > 1) {\\n            if (player1[0] == 10) score1 += player1[1]\\n            if (player2[0] == 10) score2 += player2[1]\\n        }\\n\\n        for (index in 2 .. player1.lastIndex) {\\n                score1 += if (player1[index - 1] == 10 || player1[index - 2] == 10) {\\n                    player1[index] * 2\\n                } else player1[index]\\n\\n                score2 += if (player2[index - 1] == 10 || player2[index - 2] == 10) {\\n                    player2[index] * 2\\n                } else player2[index]\\n        }\\n\\n        return when {\\n            score1 > score2 -> 1\\n            score1 < score2 -> 2\\n            else -> 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599652,
                "title": "c-python-beats-100-easy-and-simple-solution-must-see-o-n-o-1",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code: C++\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int  score1 = 0, score2 = 0, turn1 = 0, turn2 = 0;\\n        for(auto x: player1){\\n            if(x==10 && turn1==0) {\\n                turn1=2;\\n                score1 += x;\\n            }\\n            else if(turn1>0){\\n                if(x==10) turn1 = 2;\\n                else turn1--;\\n                score1 += 2*x;\\n            } \\n            else  score1 += x;\\n        }\\n        for(auto x: player2){\\n            if(x==10 && turn2 == 0) {\\n                turn2 = 2;\\n                score2 += x;\\n            }\\n            else if(turn2>0){\\n                if(x==10) turn2 = 2;\\n                else turn2--;\\n                score2 += 2*x;\\n            } \\n            else  score2 += x;\\n        }\\n        if(score1>score2) return 1;\\n        else if(score1<score2) return 2;\\n        else return 0;        \\n    }\\n};\\n```\\n\\n\\n# Code : Python\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1, score2, turn1, turn2 = 0, 0, 0, 0\\n        for plr in player1:\\n            if(plr == 10 and turn1 == 0):\\n                turn1 = 2\\n                score1 = score1 + plr\\n            elif(turn1 > 0):\\n                if(plr == 10):\\n                    turn1 = 2 \\n                else:\\n                    turn1 = turn1 - 1\\n                score1 = score1 + 2*plr\\n            else :\\n                score1 = score1 + plr\\n        \\n        for plr in player2:\\n            if(plr == 10 and turn2 == 0):\\n                turn2 = 2\\n                score2 = score2 + plr\\n            elif(turn2 > 0):\\n                if(plr == 10):\\n                    turn2 = 2 \\n                else:\\n                    turn2 = turn2 - 1\\n                score2 = score2 + 2*plr\\n            else :\\n                score2 = score2 + plr\\n\\n        if(score1 > score2): \\n            return 1\\n        elif(score1 < score2):\\n            return 2\\n        else:\\n            return 0      \\n    \\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int  score1 = 0, score2 = 0, turn1 = 0, turn2 = 0;\\n        for(auto x: player1){\\n            if(x==10 && turn1==0) {\\n                turn1=2;\\n                score1 += x;\\n            }\\n            else if(turn1>0){\\n                if(x==10) turn1 = 2;\\n                else turn1--;\\n                score1 += 2*x;\\n            } \\n            else  score1 += x;\\n        }\\n        for(auto x: player2){\\n            if(x==10 && turn2 == 0) {\\n                turn2 = 2;\\n                score2 += x;\\n            }\\n            else if(turn2>0){\\n                if(x==10) turn2 = 2;\\n                else turn2--;\\n                score2 += 2*x;\\n            } \\n            else  score2 += x;\\n        }\\n        if(score1>score2) return 1;\\n        else if(score1<score2) return 2;\\n        else return 0;        \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1, score2, turn1, turn2 = 0, 0, 0, 0\\n        for plr in player1:\\n            if(plr == 10 and turn1 == 0):\\n                turn1 = 2\\n                score1 = score1 + plr\\n            elif(turn1 > 0):\\n                if(plr == 10):\\n                    turn1 = 2 \\n                else:\\n                    turn1 = turn1 - 1\\n                score1 = score1 + 2*plr\\n            else :\\n                score1 = score1 + plr\\n        \\n        for plr in player2:\\n            if(plr == 10 and turn2 == 0):\\n                turn2 = 2\\n                score2 = score2 + plr\\n            elif(turn2 > 0):\\n                if(plr == 10):\\n                    turn2 = 2 \\n                else:\\n                    turn2 = turn2 - 1\\n                score2 = score2 + 2*plr\\n            else :\\n                score2 = score2 + plr\\n\\n        if(score1 > score2): \\n            return 1\\n        elif(score1 < score2):\\n            return 2\\n        else:\\n            return 0      \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594419,
                "title": "c-solution",
                "content": "```\\nint isWinner(vector<int>& p1, vector<int>& p2) {\\n\\tint sum1 = 0, sum2 = 0, sz = p1.size();\\n\\tfor (int i = 0; i < sz; i++) {\\n\\t\\tsum1 += (i >= 1 && p1[i - 1] == 10 || i >= 2 && p1[i - 2] == 10) ? p1[i] * 2 : p1[i];\\n\\t\\tsum2 += (i >= 1 && p2[i - 1] == 10 || i >= 2 && p2[i - 2] == 10) ? p2[i] * 2 : p2[i];\\n\\t}\\n\\treturn sum1 > sum2 ? 1 : (sum2 > sum1 ? 2 : 0);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint isWinner(vector<int>& p1, vector<int>& p2) {\\n\\tint sum1 = 0, sum2 = 0, sz = p1.size();\\n\\tfor (int i = 0; i < sz; i++) {\\n\\t\\tsum1 += (i >= 1 && p1[i - 1] == 10 || i >= 2 && p1[i - 2] == 10) ? p1[i] * 2 : p1[i];\\n\\t\\tsum2 += (i >= 1 && p2[i - 1] == 10 || i >= 2 && p2[i - 2] == 10) ? p2[i] * 2 : p2[i];\\n\\t}\\n\\treturn sum1 > sum2 ? 1 : (sum2 > sum1 ? 2 : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593524,
                "title": "go-solution",
                "content": "```\\nfunc isWinner(player1 []int, player2 []int) int {\\n\\tp1, p2 := scorePlayer(player1), scorePlayer(player2)\\n\\tif p1 > p2 {\\n\\t\\treturn 1\\n\\t} else if p2 > p1 {\\n\\t\\treturn 2\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc scorePlayer(player []int) int {\\n\\ttotal, double, lastTenIdx := 0, false, 0\\n\\tfor i, s := range player {\\n\\t\\tif i - lastTenIdx > 2 {\\n\\t\\t\\tlastTenIdx = 0\\n\\t\\t\\tdouble = false\\n\\t\\t}\\t\\n\\t\\tif double {\\n\\t\\t\\ttotal += (s*2)\\n\\t\\t} else {\\n\\t\\t\\ttotal += s\\n\\t\\t}\\n\\t\\tif s == 10 {\\n\\t\\t\\tdouble = true\\n\\t\\t\\tlastTenIdx = i\\n\\t\\t}\\n\\t}\\n\\treturn total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isWinner(player1 []int, player2 []int) int {\\n\\tp1, p2 := scorePlayer(player1), scorePlayer(player2)\\n\\tif p1 > p2 {\\n\\t\\treturn 1\\n\\t} else if p2 > p1 {\\n\\t\\treturn 2\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc scorePlayer(player []int) int {\\n\\ttotal, double, lastTenIdx := 0, false, 0\\n\\tfor i, s := range player {\\n\\t\\tif i - lastTenIdx > 2 {\\n\\t\\t\\tlastTenIdx = 0\\n\\t\\t\\tdouble = false\\n\\t\\t}\\t\\n\\t\\tif double {\\n\\t\\t\\ttotal += (s*2)\\n\\t\\t} else {\\n\\t\\t\\ttotal += s\\n\\t\\t}\\n\\t\\tif s == 10 {\\n\\t\\t\\tdouble = true\\n\\t\\t\\tlastTenIdx = i\\n\\t\\t}\\n\\t}\\n\\treturn total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590132,
                "title": "c-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        for(int i = 0; i < player1.size(); i++){\\n            if(i<2){\\n                if(i==1){\\n                    if(player1[0]==10){\\n                        p1=p1+2*player1[i];\\n                    }\\n                    else{\\n                        p1=p1+player1[i];\\n                    }\\n                }\\n                else{\\n                    p1=p1+player1[i];\\n                }\\n            }\\n            else if(player1[i-1]==10 || player1[i-2]==10){\\n                p1=p1+2*player1[i];\\n            }\\n            else{\\n                p1=p1+player1[i];\\n            }\\n        }\\n        for(int i = 0; i < player2.size(); i++){\\n            if(i<2){\\n                if(i==1){\\n                    if(player2[0]==10){\\n                        p2=p2+2*player2[i];\\n                    }\\n                    else{\\n                        p2=p2+player2[i];\\n                    }\\n                }\\n                else{\\n                    p2=p2+player2[i];\\n                }\\n            }\\n            else if(player2[i-1]==10 || player2[i-2]==10){\\n                p2=p2+2*player2[i];\\n            }\\n            else{\\n                p2=p2+player2[i];\\n            }\\n        }\\n        if(p1>p2){\\n            return 1;\\n        }\\n        else if(p2>p1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        for(int i = 0; i < player1.size(); i++){\\n            if(i<2){\\n                if(i==1){\\n                    if(player1[0]==10){\\n                        p1=p1+2*player1[i];\\n                    }\\n                    else{\\n                        p1=p1+player1[i];\\n                    }\\n                }\\n                else{\\n                    p1=p1+player1[i];\\n                }\\n            }\\n            else if(player1[i-1]==10 || player1[i-2]==10){\\n                p1=p1+2*player1[i];\\n            }\\n            else{\\n                p1=p1+player1[i];\\n            }\\n        }\\n        for(int i = 0; i < player2.size(); i++){\\n            if(i<2){\\n                if(i==1){\\n                    if(player2[0]==10){\\n                        p2=p2+2*player2[i];\\n                    }\\n                    else{\\n                        p2=p2+player2[i];\\n                    }\\n                }\\n                else{\\n                    p2=p2+player2[i];\\n                }\\n            }\\n            else if(player2[i-1]==10 || player2[i-2]==10){\\n                p2=p2+2*player2[i];\\n            }\\n            else{\\n                p2=p2+player2[i];\\n            }\\n        }\\n        if(p1>p2){\\n            return 1;\\n        }\\n        else if(p2>p1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589543,
                "title": "c-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n          if (player1.Length == 1)\\n               return player1[0] > player2[0] ? 1 : player1[0] < player2[0] ? 2 : 0;\\n\\n            int score1 = player1[1] + player1[0], score2 = player2[1]  + player2[0];\\n\\n            for(int i = player1.Length-1; i > 1; i --)\\n            {\\n                score1 += player1[i] * ((player1[i - 1] == 10 || player1[i - 2] == 10) ? 2 : 1);\\n                score2 += player2[i] * ((player2[i - 1] == 10 || player2[i - 2] == 10) ? 2 : 1);\\n            }\\n            score1 += player1[0] == 10 ? player1[1] : 0;\\n            score2 += player2[0] == 10 ? player2[1] : 0;\\n\\n            return score1 > score2 ? 1 : score1 < score2? 2:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n          if (player1.Length == 1)\\n               return player1[0] > player2[0] ? 1 : player1[0] < player2[0] ? 2 : 0;\\n\\n            int score1 = player1[1] + player1[0], score2 = player2[1]  + player2[0];\\n\\n            for(int i = player1.Length-1; i > 1; i --)\\n            {\\n                score1 += player1[i] * ((player1[i - 1] == 10 || player1[i - 2] == 10) ? 2 : 1);\\n                score2 += player2[i] * ((player2[i - 1] == 10 || player2[i - 2] == 10) ? 2 : 1);\\n            }\\n            score1 += player1[0] == 10 ? player1[1] : 0;\\n            score2 += player2[0] == 10 ? player2[1] : 0;\\n\\n            return score1 > score2 ? 1 : score1 < score2? 2:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588567,
                "title": "fast-and-short-circuit-py3",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sc1 = player1[0]\\n        sc2 = player2[0] \\n        \\n        for i in range(1, len(player1)):\\n            sc1 += player1[i] * (10 in player1[max(i-2, 0):i] and 2 or 1)\\n            sc2 += player2[i] * (10 in player2[max(i-2, 0):i] and 2 or 1)\\n        return 2 if sc2 > sc1 else 1 if sc1 > sc2 else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sc1 = player1[0]\\n        sc2 = player2[0] \\n        \\n        for i in range(1, len(player1)):\\n            sc1 += player1[i] * (10 in player1[max(i-2, 0):i] and 2 or 1)\\n            sc2 += player2[i] * (10 in player2[max(i-2, 0):i] and 2 or 1)\\n        return 2 if sc2 > sc1 else 1 if sc1 > sc2 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588233,
                "title": "c-simple-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ -->\\n\\n- Space complexity:\\n $$O(1)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& p1, vector<int>& p2) {\\n        int n = p1.size();\\n        int t=0,s1=0,s2=0;\\n        for(int x : p1){\\n            if(t>0)\\n                s1 += 2*x;\\n            else\\n                s1 += x;\\n                t--;\\n            if(x==10)\\n                t=2;\\n        }\\n        t=0;\\n        for(int x : p2){\\n            if(t>0)\\n                s2 += 2*x;\\n            else\\n                s2 += x;\\n            t--;\\n            if(x==10)\\n                t=2;\\n        }\\n        cout<<s1<< \" \"<<s2;\\n        if(s1>s2) return 1;\\n        else if(s1 < s2) return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& p1, vector<int>& p2) {\\n        int n = p1.size();\\n        int t=0,s1=0,s2=0;\\n        for(int x : p1){\\n            if(t>0)\\n                s1 += 2*x;\\n            else\\n                s1 += x;\\n                t--;\\n            if(x==10)\\n                t=2;\\n        }\\n        t=0;\\n        for(int x : p2){\\n            if(t>0)\\n                s2 += 2*x;\\n            else\\n                s2 += x;\\n            t--;\\n            if(x==10)\\n                t=2;\\n        }\\n        cout<<s1<< \" \"<<s2;\\n        if(s1>s2) return 1;\\n        else if(s1 < s2) return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3587639,
                "title": "simple-o-n-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0 \\n\\n        for i in range(len(player1)):\\n\\n            if i > 0 and player1[i -1]  == 10:\\n                score1 += 2 * player1[i]\\n            elif i > 1 and player1[i - 2] == 10:\\n                score1 += 2 * player1[i]\\n            else:\\n                score1 += player1[i]\\n            \\n            if i > 0 and player2[i -1]  == 10:\\n                score2 += 2 * player2[i]\\n            elif i > 1 and player2[i - 2] == 10:\\n                score2 += 2 * player2[i]\\n            else:\\n                score2 += player2[i]\\n\\n        if score1 > score2:\\n            return 1\\n        elif score1 < score2:\\n            return 2\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0 \\n\\n        for i in range(len(player1)):\\n\\n            if i > 0 and player1[i -1]  == 10:\\n                score1 += 2 * player1[i]\\n            elif i > 1 and player1[i - 2] == 10:\\n                score1 += 2 * player1[i]\\n            else:\\n                score1 += player1[i]\\n            \\n            if i > 0 and player2[i -1]  == 10:\\n                score2 += 2 * player2[i]\\n            elif i > 1 and player2[i - 2] == 10:\\n                score2 += 2 * player2[i]\\n            else:\\n                score2 += player2[i]\\n\\n        if score1 > score2:\\n            return 1\\n        elif score1 < score2:\\n            return 2\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587419,
                "title": "python3-simple-solution-beats-90-5",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a score function to calculate the scores for each player. Compare the two and return whichever one got higher.\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def score(player):\\n            tenBonus = 0\\n            s = 0\\n\\n            for t in player:\\n                if tenBonus:\\n                    s += 2*t\\n                    tenBonus -= 1\\n                else:\\n                    s += t\\n                    \\n                if t == 10: tenBonus = 2\\n                \\n            return s\\n        \\n        s1 = score(player1)\\n        s2 = score(player2)\\n\\n        return 1 if s1 > s2 else (2 if s2 > s1 else 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def score(player):\\n            tenBonus = 0\\n            s = 0\\n\\n            for t in player:\\n                if tenBonus:\\n                    s += 2*t\\n                    tenBonus -= 1\\n                else:\\n                    s += t\\n                    \\n                if t == 10: tenBonus = 2\\n                \\n            return s\\n        \\n        s1 = score(player1)\\n        s2 = score(player2)\\n\\n        return 1 if s1 > s2 else (2 if s2 > s1 else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587301,
                "title": "swift-100-faster",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {\\n        var player1HasStrike = false\\n        var player2HasStrike = false\\n        var scoresOf1Player = 0\\n        var scoresOf2Player = 0\\n        var counter1 = 0\\n        var counter2 = 0\\n\\n        for (int1, int2) in zip(player1, player2) {\\n            if player1HasStrike {\\n                scoresOf1Player += int1 * 2\\n            } else {\\n                scoresOf1Player += int1\\n            }\\n        \\n            if player2HasStrike {\\n            scoresOf2Player += int2 * 2\\n            } else {\\n                scoresOf2Player += int2\\n            }\\n        \\n            if int1 == 10 {\\n                player1HasStrike = true\\n                counter1 = 0\\n            }\\n        \\n            if int2 == 10 {\\n                player2HasStrike = true\\n                counter2 = 0\\n            }\\n        \\n            if counter1 == 2, player1HasStrike {\\n                player1HasStrike = false\\n            }\\n        \\n            if counter2 == 2, player2HasStrike {\\n                player2HasStrike = false\\n            }\\n        \\n            counter1 += 1\\n            counter2 += 1\\n        }\\n    \\n        if scoresOf1Player == scoresOf2Player {\\n            return 0\\n        }\\n    \\n        return scoresOf1Player > scoresOf2Player ? 1 : 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {\\n        var player1HasStrike = false\\n        var player2HasStrike = false\\n        var scoresOf1Player = 0\\n        var scoresOf2Player = 0\\n        var counter1 = 0\\n        var counter2 = 0\\n\\n        for (int1, int2) in zip(player1, player2) {\\n            if player1HasStrike {\\n                scoresOf1Player += int1 * 2\\n            } else {\\n                scoresOf1Player += int1\\n            }\\n        \\n            if player2HasStrike {\\n            scoresOf2Player += int2 * 2\\n            } else {\\n                scoresOf2Player += int2\\n            }\\n        \\n            if int1 == 10 {\\n                player1HasStrike = true\\n                counter1 = 0\\n            }\\n        \\n            if int2 == 10 {\\n                player2HasStrike = true\\n                counter2 = 0\\n            }\\n        \\n            if counter1 == 2, player1HasStrike {\\n                player1HasStrike = false\\n            }\\n        \\n            if counter2 == 2, player2HasStrike {\\n                player2HasStrike = false\\n            }\\n        \\n            counter1 += 1\\n            counter2 += 1\\n        }\\n    \\n        if scoresOf1Player == scoresOf2Player {\\n            return 0\\n        }\\n    \\n        return scoresOf1Player > scoresOf2Player ? 1 : 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586023,
                "title": "java-1ms-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = -1;\\n        int p2 = -1;\\n        int p1sum = 0;\\n        int p2sum = 0;\\n        for (int i=0; i<player1.length; i++) {\\n            if (p1 == -1) {\\n                p1sum+=player1[i];\\n                if (player1[i] == 10) p1 = i;\\n            } else {\\n                if (i-p1 <= 2) {\\n                    p1sum+=(player1[i]*2);\\n                    if (player1[i] == 10) p1 = i;\\n                } else {\\n                    p1sum+=player1[i];\\n                    if (player1[i] == 10) p1 = i;\\n                    else p1 = -1;\\n                }\\n            }\\n            if (p2 == -1){\\n                p2sum+=player2[i];\\n                if (player2[i] == 10) p2 = i;\\n            } else {\\n                if (i-p2 <= 2) {\\n                    p2sum+=(player2[i]*2);\\n                    if (player2[i] == 10) p2 = i;\\n                } else {\\n                    p2sum+=player2[i];\\n                    if (player2[i] == 10) p2 = i;\\n                    else p2 = -1;\\n                }\\n            }\\n        }\\n        if (p1sum == p2sum) return 0;\\n        else if (p1sum > p2sum) return 1;\\n        else return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = -1;\\n        int p2 = -1;\\n        int p1sum = 0;\\n        int p2sum = 0;\\n        for (int i=0; i<player1.length; i++) {\\n            if (p1 == -1) {\\n                p1sum+=player1[i];\\n                if (player1[i] == 10) p1 = i;\\n            } else {\\n                if (i-p1 <= 2) {\\n                    p1sum+=(player1[i]*2);\\n                    if (player1[i] == 10) p1 = i;\\n                } else {\\n                    p1sum+=player1[i];\\n                    if (player1[i] == 10) p1 = i;\\n                    else p1 = -1;\\n                }\\n            }\\n            if (p2 == -1){\\n                p2sum+=player2[i];\\n                if (player2[i] == 10) p2 = i;\\n            } else {\\n                if (i-p2 <= 2) {\\n                    p2sum+=(player2[i]*2);\\n                    if (player2[i] == 10) p2 = i;\\n                } else {\\n                    p2sum+=player2[i];\\n                    if (player2[i] == 10) p2 = i;\\n                    else p2 = -1;\\n                }\\n            }\\n        }\\n        if (p1sum == p2sum) return 0;\\n        else if (p1sum > p2sum) return 1;\\n        else return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585873,
                "title": "java-very-easy-to-understand-solution-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int first = getResult(player1), second = getResult(player2);\\n        if (first == second) {\\n            return 0;\\n        }\\n        return first > second ? 1 : 2;\\n    }\\n\\n    private static int getResult(int[] player) {\\n        int result = 0;\\n        int countStrike = 0;\\n        for (int num : player) {\\n            result += num;\\n            if (countStrike != 0) {\\n                result += num;\\n                countStrike--;\\n            }\\n            if (num == 10) {\\n                countStrike = 2;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int first = getResult(player1), second = getResult(player2);\\n        if (first == second) {\\n            return 0;\\n        }\\n        return first > second ? 1 : 2;\\n    }\\n\\n    private static int getResult(int[] player) {\\n        int result = 0;\\n        int countStrike = 0;\\n        for (int num : player) {\\n            result += num;\\n            if (countStrike != 0) {\\n                result += num;\\n                countStrike--;\\n            }\\n            if (num == 10) {\\n                countStrike = 2;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585813,
                "title": "concise-and-readable-java-solutions-multiple-approaches",
                "content": "# Approach\\nWe maintain two flags ```f1``` and ```f2``` for each player. Whenever we see a 10 for a player, we set the corresponding flag to 2. We also keep decrementing the flag at each turn. If the value of the flag is greater than 0 at a particular turn, it indicates the that player had scored a 10 in one of his two previous turns.\\n\\nThanks to @kreakEmp for this approach. Here\\'s his [solution](https://leetcode.com/problems/determine-the-winner-of-a-bowling-game/solutions/3468463/explained-very-simple-easy-to-understand-solution/). \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n\\n##### Approach 1 :\\n\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        int f1 = 0;\\n        int f2 = 0;\\n        for(int i=0; i<n; i++) {\\n            p1Score += f1 > 0 ? 2*player1[i] : player1[i];\\n            f1--;\\n            p2Score += f2 > 0 ? 2*player2[i] : player2[i];\\n            f2--;\\n            if(player1[i] == 10) {\\n                f1 = 2;\\n            }\\n            if(player2[i] == 10) {\\n                f2 = 2;\\n            }\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\\n\\n##### Approach 2 :\\nAn alternate straightforward, readable solution\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        for(int i=0; i<n; i++) {\\n            int p1TurnScore = player1[i];\\n            int p2TurnScore = player2[i];\\n            if(i == 1) { // at index 1, we can only check index 0 for a 10 score\\n                if(player1[0] == 10) {\\n                    p1TurnScore *= 2;\\n                }\\n                if(player2[0] == 10) {\\n                    p2TurnScore *= 2;\\n                }\\n            } else if(i-2 >= 0) { // index 2 onwards, we can check the previous 2 indices for 10s\\n                if(player1[i-1] == 10 || player1[i-2] == 10) {\\n                    p1TurnScore *= 2;\\n                }\\n                if(player2[i-1] == 10 || player2[i-2] == 10) {\\n                    p2TurnScore *= 2;\\n                }\\n            }\\n            p1Score += p1TurnScore;\\n            p2Score += p2TurnScore;\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\\n\\nA bit more concise version of the second approach. But a little less readable imo\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        for(int i=0; i<n; i++) {\\n            int p1TurnScore = player1[i];\\n            int p2TurnScore = player2[i];\\n            if((i == 1 && player1[0] == 10) || (i-2 >= 0 && (player1[i-1] == 10 || player1[i-2] == 10))) {\\n                p1TurnScore *= 2;\\n            }\\n            if((i == 1 && player2[0] == 10) || (i-2 >= 0 && (player2[i-1] == 10 || player2[i-2] == 10))) {\\n                p2TurnScore *= 2;\\n            }\\n            p1Score += p1TurnScore;\\n            p2Score += p2TurnScore;\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\\n\\nFeel free to comment below if you have any doubts. And please do upvote if you found this useful. It keeps me motivated to post such solutions. Thanks!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```f1```\n```f2```\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        int f1 = 0;\\n        int f2 = 0;\\n        for(int i=0; i<n; i++) {\\n            p1Score += f1 > 0 ? 2*player1[i] : player1[i];\\n            f1--;\\n            p2Score += f2 > 0 ? 2*player2[i] : player2[i];\\n            f2--;\\n            if(player1[i] == 10) {\\n                f1 = 2;\\n            }\\n            if(player2[i] == 10) {\\n                f2 = 2;\\n            }\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        for(int i=0; i<n; i++) {\\n            int p1TurnScore = player1[i];\\n            int p2TurnScore = player2[i];\\n            if(i == 1) { // at index 1, we can only check index 0 for a 10 score\\n                if(player1[0] == 10) {\\n                    p1TurnScore *= 2;\\n                }\\n                if(player2[0] == 10) {\\n                    p2TurnScore *= 2;\\n                }\\n            } else if(i-2 >= 0) { // index 2 onwards, we can check the previous 2 indices for 10s\\n                if(player1[i-1] == 10 || player1[i-2] == 10) {\\n                    p1TurnScore *= 2;\\n                }\\n                if(player2[i-1] == 10 || player2[i-2] == 10) {\\n                    p2TurnScore *= 2;\\n                }\\n            }\\n            p1Score += p1TurnScore;\\n            p2Score += p2TurnScore;\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        for(int i=0; i<n; i++) {\\n            int p1TurnScore = player1[i];\\n            int p2TurnScore = player2[i];\\n            if((i == 1 && player1[0] == 10) || (i-2 >= 0 && (player1[i-1] == 10 || player1[i-2] == 10))) {\\n                p1TurnScore *= 2;\\n            }\\n            if((i == 1 && player2[0] == 10) || (i-2 >= 0 && (player2[i-1] == 10 || player2[i-2] == 10))) {\\n                p2TurnScore *= 2;\\n            }\\n            p1Score += p1TurnScore;\\n            p2Score += p2TurnScore;\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585115,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int score(vector<int>& player){\\n        int score=0;\\n        vector<int>p=player;\\n        for(int i=0;i<player.size();i++){\\n            if((i-1>=0 && player[i-1]==10)||(i-2>=0 && player[i-2]==10)) score+=2*player[i];\\n            else score+=player[i];\\n        }\\n        return score;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1=score(player1);\\n        int score2=score(player2);\\n        if(score1>score2) return 1;\\n        else if(score2>score1) return 2;\\n        else return 0;\\n    }\\n};\\n```\\n# Please upvote if this helped!~",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int score(vector<int>& player){\\n        int score=0;\\n        vector<int>p=player;\\n        for(int i=0;i<player.size();i++){\\n            if((i-1>=0 && player[i-1]==10)||(i-2>=0 && player[i-2]==10)) score+=2*player[i];\\n            else score+=player[i];\\n        }\\n        return score;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1=score(player1);\\n        int score2=score(player2);\\n        if(score1>score2) return 1;\\n        else if(score2>score1) return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584764,
                "title": "simple-js-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n /** \\n    here what we can do it \\n     => we can itrate over both the arrays and find the sum\\n     => and we check if the value of previous or element prevoious to previous element is 10 \\n      => if yes then we need to add the value twice or just add it once\\n    \\n*/\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n   \\n    \\n     let sum1=0;    \\n     let sum2=0;\\n\\n    for(let i=0;i<player1.length;i++){\\n        sum1+=player1[i];\\n        sum2+=player2[i];\\n\\n\\n        if(player1[i-1]==10 || player1[i-2]==10){\\n            sum1+=player1[i];\\n        }\\n        if(player2[i-1]==10 || player2[i-2]==10){\\n            sum2+=player2[i];\\n\\n        }\\n    }\\n\\n    if(sum1>sum2) return 1;\\n    else if(sum1<sum2) return 2;\\n    else return 0;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n   \\n    \\n     let sum1=0;    \\n     let sum2=0;\\n\\n    for(let i=0;i<player1.length;i++){\\n        sum1+=player1[i];\\n        sum2+=player2[i];\\n\\n\\n        if(player1[i-1]==10 || player1[i-2]==10){\\n            sum1+=player1[i];\\n        }\\n        if(player2[i-1]==10 || player2[i-2]==10){\\n            sum2+=player2[i];\\n\\n        }\\n    }\\n\\n    if(sum1>sum2) return 1;\\n    else if(sum1<sum2) return 2;\\n    else return 0;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584075,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def summa(self, player):\\n        p = 0\\n        for ind, i in enumerate(player):\\n            if ind < 2:\\n                p += i\\n                if ind == 1 and player[0] == 10:\\n                    p += i\\n            else:\\n                if 10 in (player[ind-1], player[ind-2]):\\n                    p += 2 * i\\n                else:\\n                    p += i\\n        return p\\n\\n\\n\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        res = []\\n        for x in (player1, player2):\\n            res.append(Solution.summa(self, x))\\n        return (len(set(res)) > 1) * (1 + res.index(max(res)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summa(self, player):\\n        p = 0\\n        for ind, i in enumerate(player):\\n            if ind < 2:\\n                p += i\\n                if ind == 1 and player[0] == 10:\\n                    p += i\\n            else:\\n                if 10 in (player[ind-1], player[ind-2]):\\n                    p += 2 * i\\n                else:\\n                    p += i\\n        return p\\n\\n\\n\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        res = []\\n        for x in (player1, player2):\\n            res.append(Solution.summa(self, x))\\n        return (len(set(res)) > 1) * (1 + res.index(max(res)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572682,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1 =0;\\n        int sum2=0;\\n        for(int i =0;i<player1.size();i++)\\n        {\\n            if((i>0 && player1[i-1]==10) ||(i>1 && player1[i-2]==10))\\n            {\\n                sum1 =sum1+(2*player1[i]);\\n            }\\n            else{\\n                sum1= sum1+player1[i];\\n            }\\n                \\n        }\\n         for(int i =0;i<player2.size();i++)\\n        {\\n            if((i>0 && player2[i-1]==10) ||(i>1 && player2[i-2]==10))\\n            {\\n                sum2 =sum2+(2*player2[i]);\\n            }\\n            else{\\n                sum2= sum2+player2[i];\\n            }\\n                \\n        }\\n        if(sum1==sum2)\\n        {\\n            return 0;\\n        }\\n        else if(sum1>sum2)\\n        {\\n            return 1;\\n        }\\n        return 2;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1 =0;\\n        int sum2=0;\\n        for(int i =0;i<player1.size();i++)\\n        {\\n            if((i>0 && player1[i-1]==10) ||(i>1 && player1[i-2]==10))\\n            {\\n                sum1 =sum1+(2*player1[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3572194,
                "title": "determine-the-winner-of-a-bowling-game-c-easy-solution-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size();\\n        int n2=player2.size();\\n        int p1_sum=player1[0];\\n        int p2_sum=player2[0];\\n        for(int i=1;i<n1;i++){\\n            if(i==1){\\n                if(player1[0]==10)\\n                p1_sum+=player1[i]*2;\\n                else\\n                p1_sum+=player1[i];\\n                if(player2[0]==10)\\n                p2_sum+=player2[i]*2;\\n                else\\n                p2_sum+=player2[i];\\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10)\\n                p1_sum+=player1[i]*2;\\n                else\\n                p1_sum+=player1[i];\\n                if(player2[i-1]==10 || player2[i-2]==10)\\n                p2_sum+=player2[i]*2;\\n                else\\n                p2_sum+=player2[i];\\n            }\\n        }\\n        \\n\\n        if(p1_sum>p2_sum)\\n        return 1;\\n        else if(p1_sum<p2_sum)\\n        return 2;\\n        else\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size();\\n        int n2=player2.size();\\n        int p1_sum=player1[0];\\n        int p2_sum=player2[0];\\n        for(int i=1;i<n1;i++){\\n            if(i==1){\\n                if(player1[0]==10)\\n                p1_sum+=player1[i]*2;\\n                else\\n                p1_sum+=player1[i];\\n                if(player2[0]==10)\\n                p2_sum+=player2[i]*2;\\n                else\\n                p2_sum+=player2[i];\\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10)\\n                p1_sum+=player1[i]*2;\\n                else\\n                p1_sum+=player1[i];\\n                if(player2[i-1]==10 || player2[i-2]==10)\\n                p2_sum+=player2[i]*2;\\n                else\\n                p2_sum+=player2[i];\\n            }\\n        }\\n        \\n\\n        if(p1_sum>p2_sum)\\n        return 1;\\n        else if(p1_sum<p2_sum)\\n        return 2;\\n        else\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569278,
                "title": "my-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum=0,sum1=0;\\n        for(int i=0;i<player1.size();i++){\\n           if((i>0&& player1[i-1]==10) || (i>1 && player1[i-2]==10)){\\nsum+=2*player1[i];\\n           }\\n           else{\\n               sum+=player1[i];\\n           }\\n        }\\n         for(int i=0;i<player2.size();i++){\\n             if((i>0&& player2[i-1]==10) || (i>1 && player2[i-2]==10)){\\nsum1+=2*player2[i];\\n           }\\n           else{\\n               sum1+=player2[i];\\n           }\\n        }\\n        \\n        if(sum==sum1){\\n            return 0;\\n        }\\n        else if(sum>sum1){\\n            return 1;\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum=0,sum1=0;\\n        for(int i=0;i<player1.size();i++){\\n           if((i>0&& player1[i-1]==10) || (i>1 && player1[i-2]==10)){\\nsum+=2*player1[i];\\n           }\\n           else{\\n               sum+=player1[i];\\n           }\\n        }\\n         for(int i=0;i<player2.size();i++){\\n             if((i>0&& player2[i-1]==10) || (i>1 && player2[i-2]==10)){\\nsum1+=2*player2[i];\\n           }\\n           else{\\n               sum1+=player2[i];\\n           }\\n        }\\n        \\n        if(sum==sum1){\\n            return 0;\\n        }\\n        else if(sum>sum1){\\n            return 1;\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562149,
                "title": "c-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1=0;\\n        for(int i=0; i<player1.size(); i++){\\n            if(i>0 && player1[i-1]==10)score1+=2*player1[i];\\n            else if(i>1 && player1[i-2]==10)score1+=2*player1[i];\\n            else {score1+=player1[i];}\\n        }\\n        int score2=0;\\n        for(int i=0; i<player2.size(); i++){\\n            if(i>0 && player2[i-1]==10)score2+=2*player2[i];\\n            else if(i>1 && player2[i-2]==10)score2+=2*player2[i];\\n            else {score2+=player2[i];}\\n        }\\n        if(score1>score2)return 1;\\n        else if(score2>score1)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1=0;\\n        for(int i=0; i<player1.size(); i++){\\n            if(i>0 && player1[i-1]==10)score1+=2*player1[i];\\n            else if(i>1 && player1[i-2]==10)score1+=2*player1[i];\\n            else {score1+=player1[i];}\\n        }\\n        int score2=0;\\n        for(int i=0; i<player2.size(); i++){\\n            if(i>0 && player2[i-1]==10)score2+=2*player2[i];\\n            else if(i>1 && player2[i-2]==10)score2+=2*player2[i];\\n            else {score2+=player2[i];}\\n        }\\n        if(score1>score2)return 1;\\n        else if(score2>score1)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561033,
                "title": "simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> Basic\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   \\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        s1, s2 = 0, 0                   # variables to store sum\\n        for i in range(len(player1)):   # iterating the player score\\n            # adding the initial scores\\n            s1 += player1[i]            \\n            s2 += player2[i]\\n\\n            # checking the length to check previous occurance of full score\\n            if i==1:\\n                # if there is just 1 previous element then check the previous index\\n                if player1[i-1]==10:\\n                    s1 += player1[i]    #adding it AGAIN (i.e. 2x)\\n                if player2[i-1]==10:\\n                    s2 += player2[i]\\n            elif i>1:       \\n                # if more than 1 previous elements check previous 2 indexes\\n                if player1[i-1]==10 or player1[i-2]==10:\\n                    s1 += player1[i]\\n                if player2[i-1]==10 or player2[i-2]==10:\\n                    s2 += player2[i] \\n\\n        #check and return                          \\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        else:\\n            return 0                 \\n```",
                "solutionTags": [
                    "Python3",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        s1, s2 = 0, 0                   # variables to store sum\\n        for i in range(len(player1)):   # iterating the player score\\n            # adding the initial scores\\n            s1 += player1[i]            \\n            s2 += player2[i]\\n\\n            # checking the length to check previous occurance of full score\\n            if i==1:\\n                # if there is just 1 previous element then check the previous index\\n                if player1[i-1]==10:\\n                    s1 += player1[i]    #adding it AGAIN (i.e. 2x)\\n                if player2[i-1]==10:\\n                    s2 += player2[i]\\n            elif i>1:       \\n                # if more than 1 previous elements check previous 2 indexes\\n                if player1[i-1]==10 or player1[i-2]==10:\\n                    s1 += player1[i]\\n                if player2[i-1]==10 or player2[i-2]==10:\\n                    s2 += player2[i] \\n\\n        #check and return                          \\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        else:\\n            return 0                 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558457,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {\\n        \\n        func score(_ pins: [Int]) -> Int {\\n\\n            var ten = -3\\n            var res = 0\\n\\n            for i in pins.indices {\\n                if i - ten < 3 { res += pins[i] * 2 }\\n                else { res += pins[i] }\\n                if pins[i] == 10 { ten = i }\\n            }\\n\\n            return res\\n        }\\n\\n        switch score(player1) - score(player2) {\\n        case ...(-1): return 2\\n        case 1...: return 1\\n        default: return 0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {\\n        \\n        func score(_ pins: [Int]) -> Int {\\n\\n            var ten = -3\\n            var res = 0\\n\\n            for i in pins.indices {\\n                if i - ten < 3 { res += pins[i] * 2 }\\n                else { res += pins[i] }\\n                if pins[i] == 10 { ten = i }\\n            }\\n\\n            return res\\n        }\\n\\n        switch score(player1) - score(player2) {\\n        case ...(-1): return 2\\n        case 1...: return 1\\n        default: return 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558140,
                "title": "my-solution-runtime-73-ms-beats-90-37",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    let sum1=0;\\n    let sum2=0;\\n\\n    for (let i=0; i<player1.length; i++) {\\n        if (player1[i-1]==10 || player1[i-2]==10) {sum1+=player1[i]*2;}\\n        else {sum1+=player1[i];}\\n    }    \\n\\n    for (let i=0; i<player2.length; i++) {\\n        if (player2[i-1]==10 || player2[i-2]==10) {sum2+=player2[i]*2;}\\n        else {sum2+=player2[i];}\\n    } \\nif (sum1>sum2) {return 1;}\\nelse if (sum1==sum2) {return 0;}\\nelse if (sum1<sum2) {return 2;}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    let sum1=0;\\n    let sum2=0;\\n\\n    for (let i=0; i<player1.length; i++) {\\n        if (player1[i-1]==10 || player1[i-2]==10) {sum1+=player1[i]*2;}\\n        else {sum1+=player1[i];}\\n    }    \\n\\n    for (let i=0; i<player2.length; i++) {\\n        if (player2[i-1]==10 || player2[i-2]==10) {sum2+=player2[i]*2;}\\n        else {sum2+=player2[i];}\\n    } \\nif (sum1>sum2) {return 1;}\\nelse if (sum1==sum2) {return 0;}\\nelse if (sum1<sum2) {return 2;}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555001,
                "title": "easy-java-solution-beats-99-9-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n=player1.length;\\n        int res1=player1[0];\\n        int res2=player2[0];\\n        if(n==1){\\n            if(res1==res2) return 0;\\n            else if(res1>res2 ) return 1;\\n            else return 2;\\n        }\\n        else {\\n            if(player1[0]==10) res1+=player1[1]*2;\\n            else res1+=player1[1];\\n            if(player2[0]==10) res2+=player2[1]*2;\\n            else res2+=player2[1];\\n            if(n==2){\\n                if(res1==res2) return 0;\\n                else if(res1>res2) return 1;\\n                else return 2;\\n            }\\n            else{\\n                for(int i=2;i<n;i++){\\n                    if(player1[i-1]==10 || player1[i-2]==10) res1+=2*player1[i];\\n                    else res1+=player1[i];\\n                }\\n                for(int i=2;i<n;i++){\\n                    if(player2[i-1]==10 || player2[i-2]==10) res2+=2*player2[i];\\n                    else res2+=player2[i];\\n                }\\n            }\\n        }\\n        if(res1==res2) return 0;\\n        else if(res1>res2) return 1;\\n        else return 2;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/0ad5c409-73f4-48cc-926f-43d0a26fed7e_1684829609.9895198.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n=player1.length;\\n        int res1=player1[0];\\n        int res2=player2[0];\\n        if(n==1){\\n            if(res1==res2) return 0;\\n            else if(res1>res2 ) return 1;\\n            else return 2;\\n        }\\n        else {\\n            if(player1[0]==10) res1+=player1[1]*2;\\n            else res1+=player1[1];\\n            if(player2[0]==10) res2+=player2[1]*2;\\n            else res2+=player2[1];\\n            if(n==2){\\n                if(res1==res2) return 0;\\n                else if(res1>res2) return 1;\\n                else return 2;\\n            }\\n            else{\\n                for(int i=2;i<n;i++){\\n                    if(player1[i-1]==10 || player1[i-2]==10) res1+=2*player1[i];\\n                    else res1+=player1[i];\\n                }\\n                for(int i=2;i<n;i++){\\n                    if(player2[i-1]==10 || player2[i-2]==10) res2+=2*player2[i];\\n                    else res2+=player2[i];\\n                }\\n            }\\n        }\\n        if(res1==res2) return 0;\\n        else if(res1>res2) return 1;\\n        else return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546710,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Jai Shree Ram\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr){\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i==0)sum+=arr[i];\\n            else if(i==1){\\n                if(arr[i-1]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n            else{\\n                if(arr[i-1]==10 || arr[i-2]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(solve(player1)>solve(player2))return 1;\\n        else if(solve(player1)<solve(player2))return 2;\\n        return 0;\\n    }\\n};\\n```\\n![leetcode upvote.jpg](https://assets.leetcode.com/users/images/25d70117-0e3e-4bd0-95ba-100c7345ff6c_1684641604.5223634.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr){\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i==0)sum+=arr[i];\\n            else if(i==1){\\n                if(arr[i-1]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n            else{\\n                if(arr[i-1]==10 || arr[i-2]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(solve(player1)>solve(player2))return 1;\\n        else if(solve(player1)<solve(player2))return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544657,
                "title": "least-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int s1=0, s2=0;\\n        int f1=0,f2=0;\\n        for(int i=0; i<player1.length;i++){\\n            if(f1>0){\\n                s1+=player1[i]*2;\\n                f1--;\\n            }else{\\n                s1+=player1[i];\\n            }\\n            if(player1[i]==10){\\n                    f1=2;\\n            }\\n            if(f2>0){\\n                s2+=player2[i]*2;\\n                f2--;\\n            }else{\\n                s2+=player2[i];\\n            }\\n            if(player2[i]==10){\\n                    f2=2;\\n            }\\n\\n        }\\n        if(s1<s2){\\n            return 2;\\n        }if(s1>s2){\\n            return 1;\\n        }else\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int s1=0, s2=0;\\n        int f1=0,f2=0;\\n        for(int i=0; i<player1.length;i++){\\n            if(f1>0){\\n                s1+=player1[i]*2;\\n                f1--;\\n            }else{\\n                s1+=player1[i];\\n            }\\n            if(player1[i]==10){\\n                    f1=2;\\n            }\\n            if(f2>0){\\n                s2+=player2[i]*2;\\n                f2--;\\n            }else{\\n                s2+=player2[i];\\n            }\\n            if(player2[i]==10){\\n                    f2=2;\\n            }\\n\\n        }\\n        if(s1<s2){\\n            return 2;\\n        }if(s1>s2){\\n            return 1;\\n        }else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540082,
                "title": "c-solution-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1 = 0;\\n        for(int i=0;i<player1.size();i++){\\n            if(i==1 && player1[i-1]==10){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else if(i>=2 && (player1[i-1]==10 || player1[i-2]==10)){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else{\\n                sum1 = sum1 + player1[i];\\n            }\\n        }\\n        int sum2 = 0;\\n        for(int i=0;i<player2.size();i++){\\n            if(i==1 && (player2[i-1]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else if(i>=2 && (player2[i-1]==10 || player2[i-2]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else{\\n                sum2 = sum2 + player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum2>sum1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1 = 0;\\n        for(int i=0;i<player1.size();i++){\\n            if(i==1 && player1[i-1]==10){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else if(i>=2 && (player1[i-1]==10 || player1[i-2]==10)){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else{\\n                sum1 = sum1 + player1[i];\\n            }\\n        }\\n        int sum2 = 0;\\n        for(int i=0;i<player2.size();i++){\\n            if(i==1 && (player2[i-1]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else if(i>=2 && (player2[i-1]==10 || player2[i-2]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else{\\n                sum2 = sum2 + player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum2>sum1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540076,
                "title": "java-solution-o-n-time-99-90-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        for(int i=0;i<player1.length;i++){\\n            if(i==1 && player1[i-1]==10){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else if(i>=2 && (player1[i-1]==10 || player1[i-2]==10)){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else{\\n                sum1 = sum1 + player1[i];\\n            }\\n        }\\n        int sum2 = 0;\\n        for(int i=0;i<player2.length;i++){\\n            if(i==1 && (player2[i-1]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else if(i>=2 && (player2[i-1]==10 || player2[i-2]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else{\\n                sum2 = sum2 + player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum2>sum1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        for(int i=0;i<player1.length;i++){\\n            if(i==1 && player1[i-1]==10){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else if(i>=2 && (player1[i-1]==10 || player1[i-2]==10)){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else{\\n                sum1 = sum1 + player1[i];\\n            }\\n        }\\n        int sum2 = 0;\\n        for(int i=0;i<player2.length;i++){\\n            if(i==1 && (player2[i-1]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else if(i>=2 && (player2[i-1]==10 || player2[i-2]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else{\\n                sum2 = sum2 + player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum2>sum1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539620,
                "title": "bowling-game-javascript-count-strikes-85-ms",
                "content": "```\\nvar isWinner = function(player1, player2) {\\n    p1_x2 = p2_x2 = 0\\n    sum1 = sum2 = 0\\n    \\n    for (let i = 0; i < player1.length; i++) {\\n        sum1 += p1_x2 > 0 ? player1[i] * 2 : player1[i] \\n        sum2 += p2_x2 > 0 ? player2[i] * 2 : player2[i] \\n\\n        p1_x2 = p1_x2 > 0 ? p1_x2 - 1 : p1_x2 \\n        p2_x2 = p2_x2 > 0 ? p2_x2 - 1 : p2_x2 \\n\\n        p1_x2 = player1[i] == 10 ? 2 : p1_x2\\n        p2_x2 = player2[i] == 10 ? 2 : p2_x2  \\n    }    \\n\\n    return sum1 > sum2 ? 1 : sum1 == sum2 ? 0 : 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isWinner = function(player1, player2) {\\n    p1_x2 = p2_x2 = 0\\n    sum1 = sum2 = 0\\n    \\n    for (let i = 0; i < player1.length; i++) {\\n        sum1 += p1_x2 > 0 ? player1[i] * 2 : player1[i] \\n        sum2 += p2_x2 > 0 ? player2[i] * 2 : player2[i] \\n\\n        p1_x2 = p1_x2 > 0 ? p1_x2 - 1 : p1_x2 \\n        p2_x2 = p2_x2 > 0 ? p2_x2 - 1 : p2_x2 \\n\\n        p1_x2 = player1[i] == 10 ? 2 : p1_x2\\n        p2_x2 = player2[i] == 10 ? 2 : p2_x2  \\n    }    \\n\\n    return sum1 > sum2 ? 1 : sum1 == sum2 ? 0 : 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539541,
                "title": "php-foreach-2n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $player1\\n     * @param Integer[] $player2\\n     * @return Integer\\n     */\\n    function isWinner($player1, $player2) {\\n        $score1 = 0;\\n        $score2 = 0;\\n\\n        foreach ($player1 as $key => $value) {\\n            $caf = 1;\\n            if (isset($player1[$key-1]) && $player1[$key-1] === 10) {\\n                $caf = 2;\\n            } elseif (isset($player1[$key-2]) && $player1[$key-2] === 10) {\\n                $caf = 2;\\n            }\\n            $score1 += ($value*$caf);\\n        }\\n\\n        foreach ($player2 as $key => $value) {\\n            $caf = 1;\\n            if (isset($player2[$key-1]) && $player2[$key-1] === 10) {\\n                $caf = 2;\\n            } elseif (isset($player2[$key-2]) && $player2[$key-2] === 10) {\\n                $caf = 2;\\n            }\\n            $score2 += ($value*$caf);\\n        }\\n\\n        if (($result = ($score1 <=> $score2)) === -1) {\\n            return 2;\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $player1\\n     * @param Integer[] $player2\\n     * @return Integer\\n     */\\n    function isWinner($player1, $player2) {\\n        $score1 = 0;\\n        $score2 = 0;\\n\\n        foreach ($player1 as $key => $value) {\\n            $caf = 1;\\n            if (isset($player1[$key-1]) && $player1[$key-1] === 10) {\\n                $caf = 2;\\n            } elseif (isset($player1[$key-2]) && $player1[$key-2] === 10) {\\n                $caf = 2;\\n            }\\n            $score1 += ($value*$caf);\\n        }\\n\\n        foreach ($player2 as $key => $value) {\\n            $caf = 1;\\n            if (isset($player2[$key-1]) && $player2[$key-1] === 10) {\\n                $caf = 2;\\n            } elseif (isset($player2[$key-2]) && $player2[$key-2] === 10) {\\n                $caf = 2;\\n            }\\n            $score2 += ($value*$caf);\\n        }\\n\\n        if (($result = ($score1 <=> $score2)) === -1) {\\n            return 2;\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537633,
                "title": "c-calculating-scores-110ms-95",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) \\n    {\\n        var diff = GetScore(player1) - GetScore(player2);\\n\\n        return diff == 0 ? 0 : (diff > 0 ? 1 : 2);\\n    }\\n\\n    int GetScore(int[] hits)\\n    {\\n        var doubling = 0;\\n\\n        var score = 0;\\n\\n        foreach(var h in hits)\\n        {\\n            score += (doubling-- > 0) ? 2 * h : h;\\n\\n            if(h == 10) doubling = 2;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) \\n    {\\n        var diff = GetScore(player1) - GetScore(player2);\\n\\n        return diff == 0 ? 0 : (diff > 0 ? 1 : 2);\\n    }\\n\\n    int GetScore(int[] hits)\\n    {\\n        var doubling = 0;\\n\\n        var score = 0;\\n\\n        foreach(var h in hits)\\n        {\\n            score += (doubling-- > 0) ? 2 * h : h;\\n\\n            if(h == 10) doubling = 2;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1878349,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1879196,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1878218,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877921,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877795,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1943431,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1879245,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1881378,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877747,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877717,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1878349,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1879196,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1878218,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877921,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877795,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1943431,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1879245,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1881378,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877747,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877717,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "I’m no expert here, since I failed this question miserably 🥲, but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            }
        ]
    },
    {
        "title": "First Completely Painted Row or Column",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>arr</code>, and an <code>m x n</code> integer <strong>matrix</strong> <code>mat</code>. <code>arr</code> and <code>mat</code> both contain <strong>all</strong> the integers in the range <code>[1, m * n]</code>.</p>\n\n<p>Go through each index <code>i</code> in <code>arr</code> starting from index <code>0</code> and paint the cell in <code>mat</code> containing the integer <code>arr[i]</code>.</p>\n\n<p>Return <em>the smallest index</em> <code>i</code> <em>at which either a row or a column will be completely painted in</em> <code>mat</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"image explanation for example 1\" /><img alt=\"image explanation for example 1\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg\" style=\"width: 321px; height: 81px;\" />\n<pre>\n<strong>Input:</strong> arr = [1,3,4,2], mat = [[1,4],[2,3]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"image explanation for example 2\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg\" style=\"width: 601px; height: 121px;\" />\n<pre>\n<strong>Input:</strong> arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The second column becomes fully painted at arr[3].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n = mat[i].length</code></li>\n\t<li><code>arr.length == m * n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], mat[r][c] &lt;= m * n</code></li>\n\t<li>All the integers of <code>arr</code> are <strong>unique</strong>.</li>\n\t<li>All the integers of <code>mat</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3468444,
                "title": "explained-using-map-very-simple-and-easy-to-understand-solution",
                "content": "\\n# Approach\\nWe will have two map for tracking the row and col of a number, so that we can get the row,col in O(1) time.\\nThen we have another two map ( mprc, mpcc) which basically count the no. elements seen in that row and no. of elements seen in that column.\\n\\n1. Map the row, col of each of elements\\n2. Travesrse the arr and keep updatinf row & col count \\n3. Once the row count equal to max or col count equal to max return index\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, int> mpr, mpc, mprc, mpcc;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j< mat[0].size(); ++j){\\n                mpr[mat[i][j]] = i;     mpc[mat[i][j]] = j;\\n            }\\n        }\\n        for(int i = 0; i < arr.size(); i++){\\n            int n = arr[i];\\n            mprc[mpr[n]]++;    mpcc[mpc[n]]++;\\n            if(mprc[mpr[n]] == mat[0].size() || mpcc[mpc[n]] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nSolution - 2: \\nI find the following solution interesting by @Tushar_aherwar\\n, with reverse mapping of the above solution: https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3469270/c-solution-space-complexity-o-n/?orderBy=most_votes\\n\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, int> mpr, mpc, mprc, mpcc;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j< mat[0].size(); ++j){\\n                mpr[mat[i][j]] = i;     mpc[mat[i][j]] = j;\\n            }\\n        }\\n        for(int i = 0; i < arr.size(); i++){\\n            int n = arr[i];\\n            mprc[mpr[n]]++;    mpcc[mpc[n]]++;\\n            if(mprc[mpr[n]] == mat[0].size() || mpcc[mpc[n]] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468260,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer, int[]> nm = new HashMap<>();\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++)\\n            {\\n                nm.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        int a[]=new int[m];\\n        int b[]=new int[n];\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            int c[] = nm.get(arr[i]);\\n            a[c[0]]++;\\n            b[c[1]]++;\\n            if(a[c[0]]==n||b[c[1]]==m)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer, int[]> nm = new HashMap<>();\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++)\\n            {\\n                nm.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        int a[]=new int[m];\\n        int b[]=new int[n];\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            int c[] = nm.get(arr[i]);\\n            a[c[0]]++;\\n            b[c[1]]++;\\n            if(a[c[0]]==n||b[c[1]]==m)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468252,
                "title": "day-395-easy-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tWe are given an array  arr and a matrix  mat.\\n##### \\u2022\\tWe first create a  HashMap called  map to store the coordinates of each element in  mat. The key of the  HashMap is the value of the element, and the value is an array of two integers representing the row and column indices of the element.\\n##### \\u2022\\tWe also create two arrays row and  col to keep track of the number of elements painted in each row and column of  mat.\\n##### \\u2022\\tWe then iterate over the elements of arr and for each element, we get its coordinates from the  map\\n##### \\u2022\\tWe increment the count of painted elements in the row and column corresponding to the coordinates of the current element.\\n##### \\u2022\\tWe then check if the count of painted elements in the row or column of the current element is equal to the length of the row or column, respectively. If either of these conditions is true, it means that the entire row or column has been painted, and we return the index of the current element.\\n##### \\u2022\\tIf we have iterated over all the elements of  arr and have not found any completely painted row or column, we return -1.\\n##### \\u2022\\tThe intuition behind this approach is that we can keep track of the number of painted elements in each row and column of mat as we iterate over the elements of  arr. If the count of painted elements in any row or column becomes equal to the length of the row or column, it means that the entire row or column has been painted, and we can return the index of the current element. If we have iterated over all the elements of  arr and have not found any completely painted row or column, it means that there is no completely painted row or column in  mat, and we return -1.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: o(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m= mat.length;\\n        int n = mat[0].length;\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                map.put(mat[i][j],new int[]{i,j});\\n        int row[] = new int[m];\\n        int col[] = new int[n];\\n        for(int i=0;i<arr.length;i++){\\n            int x[] = map.get(arr[i]);\\n            row[x[0]]++;\\n            col[x[1]]++;\\n            if(row[x[0]]==n || col[x[1]]==m) return i;            \\n        }\\n        return -1;\\n    }\\n```\\n\\n```python []\\ndef firstCompleteIndex(arr: List[int], mat: List[List[int]]) -> int:\\n    m = len(mat)\\n    n = len(mat[0])\\n    map = {}\\n    for i in range(m):\\n        for j in range(n):\\n            map[mat[i][j]] = [i, j]\\n    row = [0] * m\\n    col = [0] * n\\n    for i in range(len(arr)):\\n        x = map[arr[i]]\\n        row[x[0]] += 1\\n        col[x[1]] += 1\\n        if row[x[0]] == n or col[x[1]] == m:\\n            return i\\n    return -1\\n```\\n```c++ []\\n#include <unordered_map>\\n#include <vectorusing namespace std;\\n\\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int m = mat.size();\\n    int n = mat[0].size();\\n    unordered_map<int, vector<int>> map;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            map[mat[i][j]] = {i, j};\\n        }\\n    }\\n    vector<int> row(m);\\n    vector<int> col(n);\\n    for (int i = 0; i < arr.size(); i++) {\\n        vector<int> x = map[arr[i]];\\n        row[x[0]]++;\\n        col[x[1]]++;\\n        if (row[x[0]] == n || col[x[1]] == m) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n```\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m= mat.length;\\n        int n = mat[0].length;\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                map.put(mat[i][j],new int[]{i,j});\\n        int row[] = new int[m];\\n        int col[] = new int[n];\\n        for(int i=0;i<arr.length;i++){\\n            int x[] = map.get(arr[i]);\\n            row[x[0]]++;\\n            col[x[1]]++;\\n            if(row[x[0]]==n || col[x[1]]==m) return i;            \\n        }\\n        return -1;\\n    }\\n```\n```python []\\ndef firstCompleteIndex(arr: List[int], mat: List[List[int]]) -> int:\\n    m = len(mat)\\n    n = len(mat[0])\\n    map = {}\\n    for i in range(m):\\n        for j in range(n):\\n            map[mat[i][j]] = [i, j]\\n    row = [0] * m\\n    col = [0] * n\\n    for i in range(len(arr)):\\n        x = map[arr[i]]\\n        row[x[0]] += 1\\n        col[x[1]] += 1\\n        if row[x[0]] == n or col[x[1]] == m:\\n            return i\\n    return -1\\n```\n```c++ []\\n#include <unordered_map>\\n#include <vectorusing namespace std;\\n\\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int m = mat.size();\\n    int n = mat[0].size();\\n    unordered_map<int, vector<int>> map;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            map[mat[i][j]] = {i, j};\\n        }\\n    }\\n    vector<int> row(m);\\n    vector<int> col(n);\\n    for (int i = 0; i < arr.size(); i++) {\\n        vector<int> x = map[arr[i]];\\n        row[x[0]]++;\\n        col[x[1]]++;\\n        if (row[x[0]] == n || col[x[1]] == m) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468668,
                "title": "c-using-only-single-map-explained-easy-to-understand",
                "content": "**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int n = size(mat), m = size(mat[0]), res = m*n;\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int i = 0; i < m*n; i++)map[arr[i]] = i;\\n        \\n        for(int i = 0; i < n; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < m; j++) {\\n                maxIdx = max(maxIdx, map[mat[i][j]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n        }\\n        \\n        for(int i = 0; i < m; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < n; j++) {\\n                maxIdx = max(maxIdx, map[mat[j][i]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**Explanation**\\n\\n* unordered_map<int,int> map; - Here used to mark the order of arr items\\n* First loop iterates by row, to identify by each row the index of last marked arr item. Then get the min, which row marked(finished) first:\\n\\n```\\nfor(int i = 0; i < n; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < m; j++) {\\n                maxIdx = max(maxIdx, map[mat[i][j]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n}\\n```\\n* Second loop iterates by column and makes the same logic as first loop described above.\\n\\n* Let\\'s test in second example of the problem:\\n```Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]] Output: 3```\\n\\n* After mark the order of arr in map, we can draw second matrix that shows the mark position by arr:\\n\\n```\\n[5,0,6],\\n[4,3,7],\\n[1,2,8]\\n```\\n\\n* First loop iteration by row:\\n\\n```\\n[5,0,6], // maxIdx = 6\\n[4,3,7], // maxIdx = 7\\n[1,2,8] // maxIdx = 8\\n\\nmin of these is `6`, we can see by row first finished first row, by arr item index `6`\\n```\\n\\n* Second loop iteration by column:\\n```\\n[5,0,6], \\n[4,3,7], \\n[1,2,8] \\n\\nMax by col:\\n5 3 8\\n```\\n\\n* min of these(5,3,8) is 3, we can see by column first finished second column by arr item index 3. If we compare which one first finished by row or column, the answer is by column because arr value by index 3 becomes earlier than index 6\\n\\n*Thank you @Yerkon for explaining the code*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int n = size(mat), m = size(mat[0]), res = m*n;\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int i = 0; i < m*n; i++)map[arr[i]] = i;\\n        \\n        for(int i = 0; i < n; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < m; j++) {\\n                maxIdx = max(maxIdx, map[mat[i][j]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n        }\\n        \\n        for(int i = 0; i < m; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < n; j++) {\\n                maxIdx = max(maxIdx, map[mat[j][i]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\n```\\nfor(int i = 0; i < n; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < m; j++) {\\n                maxIdx = max(maxIdx, map[mat[i][j]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n}\\n```\n```Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]] Output: 3```\n```\\n[5,0,6],\\n[4,3,7],\\n[1,2,8]\\n```\n```\\n[5,0,6], // maxIdx = 6\\n[4,3,7], // maxIdx = 7\\n[1,2,8] // maxIdx = 8\\n\\nmin of these is `6`, we can see by row first finished first row, by arr item index `6`\\n```\n```\\n[5,0,6], \\n[4,3,7], \\n[1,2,8] \\n\\nMax by col:\\n5 3 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469270,
                "title": "c-dry-run-single-map",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/bdfd35b1-9880-466e-81ab-a997c64a08c7_1683038605.5310476.png)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n\\n    unordered_map<int,int>mp;\\n    for(int i = 0; i < arr.size(); i++) {\\n        mp[arr[i]] = i;\\n    }\\n\\n    int minIndex = INT_MAX , maxIndex = INT_MIN;\\n    int rowSize = mat.size();\\n    int colSize = mat[0].size();\\n\\n    for(int row = 0; row < rowSize; row++) {\\n        maxIndex = INT_MIN;\\n        for(int column = 0; column < colSize; column++) {\\n            int indexVal = mp[mat[row][column]];\\n            maxIndex = max(maxIndex , indexVal);\\n        }\\n        minIndex = min(minIndex , maxIndex);\\n    }\\n    \\n    for(int column = 0; column < colSize; column++) {\\n        maxIndex = INT_MIN;\\n        for(int row = 0; row < rowSize; row++) {\\n            int indexVal2 = mp[mat[row][column]];\\n            maxIndex = max(maxIndex , indexVal2);\\n        }\\n        minIndex = min(minIndex , maxIndex);\\n    }\\n    return minIndex;   \\n}\\n};    \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n\\n    unordered_map<int,int>mp;\\n    for(int i = 0; i < arr.size(); i++) {\\n        mp[arr[i]] = i;\\n    }\\n\\n    int minIndex = INT_MAX , maxIndex = INT_MIN;\\n    int rowSize = mat.size();\\n    int colSize = mat[0].size();\\n\\n    for(int row = 0; row < rowSize; row++) {\\n        maxIndex = INT_MIN;\\n        for(int column = 0; column < colSize; column++) {\\n            int indexVal = mp[mat[row][column]];\\n            maxIndex = max(maxIndex , indexVal);\\n        }\\n        minIndex = min(minIndex , maxIndex);\\n    }\\n    \\n    for(int column = 0; column < colSize; column++) {\\n        maxIndex = INT_MIN;\\n        for(int row = 0; row < rowSize; row++) {\\n            int indexVal2 = mp[mat[row][column]];\\n            maxIndex = max(maxIndex , indexVal2);\\n        }\\n        minIndex = min(minIndex , maxIndex);\\n    }\\n    return minIndex;   \\n}\\n};    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470314,
                "title": "c-don-t-use-a-hash-map-when-a-vector-or-an-array-does-the-trick",
                "content": "**TODO(heder): Insert cute cat meme to ask for up-votes. ;)**\\n\\n# Approach 1: vector (186ms)\\n\\nSeveral solutions are using an ```std::unordered_map``` for building an index, which is a waste as we know that the elements in ```mat``` are within $$[1, n * m]$$, hence we can just directly index into a ```std::vector```.\\n\\n```cpp\\n    static int firstCompleteIndex(const vector<int>& arr, const vector<vector<int>>& mat) {\\n        const int rows = size(mat);\\n        const int cols = size(mat[0]);\\n        \\n        // build index for |mat|.\\n        vector<pair<int,int>> index(rows * cols + 1);\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                index[mat[r][c]] = make_pair(r, c);\\n        \\n        // process |arr|.\\n        vector<int> rc(rows);\\n        vector<int> cc(cols);\\n        for (int i = 0; i < size(arr); ++i) {\\n            const auto [r, c] = index[arr[i]];\\n            if (++rc[r] == cols) return i;\\n            if (++cc[c] == rows) return i;\\n        }\\n        // unreachable.\\n        assert(false);\\n        return -1;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ and $$m$$ be the dimension of ```mat``` and $$n * m$$ the size of ```arr``` then the \\n  * Time complexity is $$O(n * m)$$ as we need to scan ```mat``` and ```arr``` and the\\n  * Space complexity is $$O(n * m)$$ for the index we build.\\n\\n\\n# Approach 2: dynamic array on stack (167ms, 100%?)\\nAs pointed out @Ajna2, why bother with a vector when an array might be even cheaper. The code is kinda interesting that clang generates for multiple dynamic arrays on the stack: https://godbolt.org/z/h1975ojhj Instead of on the heap the temporary working memory is created on the stack. There is still an indirection happening though.\\n\\n```cpp\\n    static int firstCompleteIndex(const vector<int>& arr, const vector<vector<int>>& mat) {\\n        const int rows = size(mat);\\n        const int cols = size(mat[0]);\\n        \\n        // build index for |mat|.\\n        pair<int,int> index[rows * cols + 1];\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                index[mat[r][c]] = make_pair(r, c);\\n        \\n        // process |arr|.   \\n        int rc[rows];\\n        fill(rc, rc + rows, 0);\\n        int cc[cols];\\n        fill(cc, cc + cols, 0);\\n        for (int i = 0; i < size(arr); ++i) {\\n            const auto [r, c] = index[arr[i]];\\n            if (++rc[r] == cols) return i;\\n            if (++cc[c] == rows) return i;\\n        }\\n        // unreachable.\\n        assert(false);\\n        return -1;\\n    }\\n```\\n\\nThe complexity analysis remains the same.\\n\\n**Pro-Tips**\\n\\nI always have a header like this in my solutions. This speeds-up I/O:\\n\\n```cpp\\n// https://leetcode.com/problems/first-completely-painted-row-or-column\\n// problem: 2661\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```std::unordered_map```\n```mat```\n```std::vector```\n```cpp\\n    static int firstCompleteIndex(const vector<int>& arr, const vector<vector<int>>& mat) {\\n        const int rows = size(mat);\\n        const int cols = size(mat[0]);\\n        \\n        // build index for |mat|.\\n        vector<pair<int,int>> index(rows * cols + 1);\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                index[mat[r][c]] = make_pair(r, c);\\n        \\n        // process |arr|.\\n        vector<int> rc(rows);\\n        vector<int> cc(cols);\\n        for (int i = 0; i < size(arr); ++i) {\\n            const auto [r, c] = index[arr[i]];\\n            if (++rc[r] == cols) return i;\\n            if (++cc[c] == rows) return i;\\n        }\\n        // unreachable.\\n        assert(false);\\n        return -1;\\n    }\\n```\n```mat```\n```arr```\n```mat```\n```arr```\n```cpp\\n    static int firstCompleteIndex(const vector<int>& arr, const vector<vector<int>>& mat) {\\n        const int rows = size(mat);\\n        const int cols = size(mat[0]);\\n        \\n        // build index for |mat|.\\n        pair<int,int> index[rows * cols + 1];\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                index[mat[r][c]] = make_pair(r, c);\\n        \\n        // process |arr|.   \\n        int rc[rows];\\n        fill(rc, rc + rows, 0);\\n        int cc[cols];\\n        fill(cc, cc + cols, 0);\\n        for (int i = 0; i < size(arr); ++i) {\\n            const auto [r, c] = index[arr[i]];\\n            if (++rc[r] == cols) return i;\\n            if (++cc[c] == rows) return i;\\n        }\\n        // unreachable.\\n        assert(false);\\n        return -1;\\n    }\\n```\n```cpp\\n// https://leetcode.com/problems/first-completely-painted-row-or-column\\n// problem: 2661\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468410,
                "title": "just-use-a-simple-map",
                "content": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int r[] = new int[m];\\n        int c[] = new int[n];\\n        \\n        Map<Integer, int[]> map = new HashMap<>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++)\\n        {\\n            int[] posi = map.get(arr[i]);\\n            int x = posi[0];\\n            int y = posi[1];\\n            r[x]++;\\n            c[y]++;\\n\\t\\t\\t// any index of r is storing painted columns of that particular row \\n\\t\\t\\t// any index of c is storing painted rows of that particular column.\\n            if(r[x] == n || c[y] == m)  // as any column size of a particular row is n and any row size of a particular column is m\\n                return i;\\n        }\\n        return arr.length - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int r[] = new int[m];\\n        int c[] = new int[n];\\n        \\n        Map<Integer, int[]> map = new HashMap<>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++)\\n        {\\n            int[] posi = map.get(arr[i]);\\n            int x = posi[0];\\n            int y = posi[1];\\n            r[x]++;\\n            c[y]++;\\n\\t\\t\\t// any index of r is storing painted columns of that particular row \\n\\t\\t\\t// any index of c is storing painted rows of that particular column.\\n            if(r[x] == n || c[y] == m)  // as any column size of a particular row is n and any row size of a particular column is m\\n                return i;\\n        }\\n        return arr.length - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468279,
                "title": "c-map-easy-to-understand",
                "content": "# Approach\\n\\nWe first create a map that maps each element in the matrix to its row and column position. Then, for each element in the array, we look up its row and column position in the map and increments the count of elements in that row and column.\\n\\nIf the count of elements in any row or column reaches the size of the matrix, it means that all the elements needed to complete that row or column have been found. In that case, return the index of the current element in the list.\\n\\nIf no element completes a row or column, the return -1.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n\\n        unordered_map<int, int> rowcount, colcount; \\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                mp[mat[i][j]]={i,j}; //store the coordinates of each number in the matrix\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();++i){\\n            int row=mp[arr[i]].first;\\n            int col=mp[arr[i]].second;\\n            \\n            // increment the row and column count for each occurrence\\n            ++rowcount[row];\\n            ++colcount[col];\\n            \\n            // if any row or column has all the numbers, return the current index          \\n            if(rowcount[row]==n || colcount[col]==m) return i;\\n        }      \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n\\n        unordered_map<int, int> rowcount, colcount; \\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                mp[mat[i][j]]={i,j}; //store the coordinates of each number in the matrix\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();++i){\\n            int row=mp[arr[i]].first;\\n            int col=mp[arr[i]].second;\\n            \\n            // increment the row and column count for each occurrence\\n            ++rowcount[row];\\n            ++colcount[col];\\n            \\n            // if any row or column has all the numbers, return the current index          \\n            if(rowcount[row]==n || colcount[col]==m) return i;\\n        }      \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468482,
                "title": "c-best-solution-100-faster-0-m-n-easy-to-understand-comments",
                "content": "# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, pair<int, int> > mp;   // this map stores  ::  value -> {row, column}\\n\\n        // map creation process\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<m; j++)  {\\n                mp[mat[i][j]] = {i, j};\\n            }\\n        }\\n        \\n        // initialy all row and column are not visited\\n        vector<int> row(n, 0);  \\n        vector<int> col(m, 0);\\n        \\n        // traversing the array and adding one element to the corresponding row and column\\n        for(int i=0; i<arr.size(); i++) {\\n            pair<int, int> p = mp[arr[i]];  // we get the row and column of the cuurent element by the help of our map in O(1) time\\n\\n            int r = p.first, c = p.second;\\n\\n            row[r]++;   // adding one element in the corresponding row\\n            if(row[r] >= m) return i;   // here the row is full if row contain m elements\\n            \\n            col[c]++;   // adding one element in the corresponding row\\n            if(col[c] >= n) return i;   // here the row is full if row contain m elements\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, pair<int, int> > mp;   // this map stores  ::  value -> {row, column}\\n\\n        // map creation process\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<m; j++)  {\\n                mp[mat[i][j]] = {i, j};\\n            }\\n        }\\n        \\n        // initialy all row and column are not visited\\n        vector<int> row(n, 0);  \\n        vector<int> col(m, 0);\\n        \\n        // traversing the array and adding one element to the corresponding row and column\\n        for(int i=0; i<arr.size(); i++) {\\n            pair<int, int> p = mp[arr[i]];  // we get the row and column of the cuurent element by the help of our map in O(1) time\\n\\n            int r = p.first, c = p.second;\\n\\n            row[r]++;   // adding one element in the corresponding row\\n            if(row[r] >= m) return i;   // here the row is full if row contain m elements\\n            \\n            col[c]++;   // adding one element in the corresponding row\\n            if(col[c] >= n) return i;   // here the row is full if row contain m elements\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468316,
                "title": "easy-to-understand-code-simple-mapping",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<int>rowFill(m, 0); //rowFill[i] => how much columns are filled in row = i\\n        vector<int>colFill(n, 0); //colFill[i] => how much rows are filled in col = i\\n        //=========================================================================\\n        vector<int>rowIdxMap((m * n) + 1); //mapping row index and col index for each value\\n        vector<int>colIdxMap((m * n) + 1);\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int val = mat[i][j];\\n                rowIdxMap[val] = i;\\n                colIdxMap[val] = j;\\n            }\\n        }\\n        //================================================================================\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            int val = arr[i];\\n            int rowIdx = rowIdxMap[val];\\n            int colIdx = colIdxMap[val];\\n            \\n            rowFill[rowIdx]++;\\n            colFill[colIdx]++;\\n            if (rowFill[rowIdx] == n || colFill[colIdx] == m) return i;\\n        }\\n        //===============================================================================\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<int>rowFill(m, 0); //rowFill[i] => how much columns are filled in row = i\\n        vector<int>colFill(n, 0); //colFill[i] => how much rows are filled in col = i\\n        //=========================================================================\\n        vector<int>rowIdxMap((m * n) + 1); //mapping row index and col index for each value\\n        vector<int>colIdxMap((m * n) + 1);\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int val = mat[i][j];\\n                rowIdxMap[val] = i;\\n                colIdxMap[val] = j;\\n            }\\n        }\\n        //================================================================================\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            int val = arr[i];\\n            int rowIdx = rowIdxMap[val];\\n            int colIdx = colIdxMap[val];\\n            \\n            rowFill[rowIdx]++;\\n            colFill[colIdx]++;\\n            if (rowFill[rowIdx] == n || colFill[colIdx] == m) return i;\\n        }\\n        //===============================================================================\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515361,
                "title": "binary-search-solution-single-set-no-hash-map-unique-approach",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem I have used Binary search and simple unordered set to solve the problem.\\n\\nThe problem wants us to find the minimum index such that atleast one of the row or column of the matrix is colored. \\n\\nIn my solution I have represented a colored cell using -1.\\n\\nInitially I have assumed that the index is at the middle of the array as we do in a binary search.\\n\\nFor that index = mid, I have put all the elements of array from 0 to mid in a set and called a function \"color\" which would color a cell if a the value present in the cell is also present in the set. Color would also check if any row or column is fully colored or not, as soon as a row or column is colored, it returns a true value else it returns false.\\n\\nNow, the main idea is, if at index == mid, atleast one cell is colored then the minimum value of the index for which atleast one cell is colored can only be towards the left of the mid.\\n\\nSo, now we store mid in our answer and check the left portion of the array like binary search does and update our answer as we go. \\n\\n\\n# Complexity\\n- Time complexity: $$O(log(n)*N*M)$$\\n- where n is size of array, N is no. of rows of matrix, M is no. of columns in matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n\\n    bool color(vvi mat, const unordered_set<int>& nums) {\\n        bool isColor = true;\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                if (nums.count(mat[i][j])) {\\n                    mat[i][j] = -1;\\n                } else {\\n                    isColor = false;\\n                }\\n            }\\n            if (isColor) return true;\\n            isColor = true;  // Reset for next row\\n        }\\n        \\n        for (int j = 0; j < mat[0].size(); j++) {\\n            bool isColor = true;\\n            for (int i = 0; i < mat.size(); i++) {\\n                if (mat[i][j] != -1) {\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if (isColor) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    int firstCompleteIndex(const vector<int>& arr, const vvi& mat) {\\n        int left = 0;\\n        int right = arr.size() - 1;\\n        int ans = INT_MAX;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            unordered_set<int> nums(arr.begin(), arr.begin() + mid + 1);\\n\\n            if (color(mat, nums)) {\\n                ans = min(ans, mid);\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n\\n            mid = left + (right - left) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n\\n    bool color(vvi mat, const unordered_set<int>& nums) {\\n        bool isColor = true;\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                if (nums.count(mat[i][j])) {\\n                    mat[i][j] = -1;\\n                } else {\\n                    isColor = false;\\n                }\\n            }\\n            if (isColor) return true;\\n            isColor = true;  // Reset for next row\\n        }\\n        \\n        for (int j = 0; j < mat[0].size(); j++) {\\n            bool isColor = true;\\n            for (int i = 0; i < mat.size(); i++) {\\n                if (mat[i][j] != -1) {\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if (isColor) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    int firstCompleteIndex(const vector<int>& arr, const vvi& mat) {\\n        int left = 0;\\n        int right = arr.size() - 1;\\n        int ans = INT_MAX;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            unordered_set<int> nums(arr.begin(), arr.begin() + mid + 1);\\n\\n            if (color(mat, nums)) {\\n                ans = min(ans, mid);\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n\\n            mid = left + (right - left) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468283,
                "title": "simple-clean-java-solution",
                "content": "\\n``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n//      Row-wise checking\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n//      Col-wise checking\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n//      Row-wise checking\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n//      Col-wise checking\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476307,
                "title": "python3-easy-understandable-explained",
                "content": "# Intuition\\nYou only need to keep track of how many zeroes are there.\\n\\n# Approach\\nFirst, map each item in `mat` to the row and column indicies so they can be accessed anywhere. Next, have a list for how many zeroes are in each row and column. Then, loop over `arr` and record the painted cells. Only the 2 recently painted cells can possibly be the last cell painted in a row or column.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr, mat):\\n        rowCols = {}\\n        ROWS = len(mat)\\n        COLS = len(mat[0])\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                rowCols[mat[r][c]] = [r, c] # mapping cells to their r and c\\n        # variables for keeping track of painted cells in a row or column\\n        rowZeroes = ROWS * [0]\\n        colZeroes = COLS * [0]\\n        for n in range(len(arr)):\\n            num = arr[n]\\n            # another 2 painted cells\\n            rowZeroes[rowCols[num][0]] += 1\\n            colZeroes[rowCols[num][1]] += 1\\n\\n\\n            if colZeroes[rowCols[num][1]] == ROWS: return n\\n            elif rowZeroes[rowCols[num][0]] == COLS: return n            \\n```\\nWhy did I compare the colZeroes item with ROWS and rowZeroes with COLS?\\nNotice that the length of C1 (items are wrapped in ()) is \\n                how many rows there are and the length of R1(in {}) is how \\n                many columns there are.\\n```\\n       C1     C2   C3\\nR1 [ ({N}) | {N} | {N} ]\\nR2 [  (N)  |  N  |  N  ]\\nR3 [  (N)  |  N  |  N  ]\\nR4 [  (N)  |  N  |  N  ]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr, mat):\\n        rowCols = {}\\n        ROWS = len(mat)\\n        COLS = len(mat[0])\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                rowCols[mat[r][c]] = [r, c] # mapping cells to their r and c\\n        # variables for keeping track of painted cells in a row or column\\n        rowZeroes = ROWS * [0]\\n        colZeroes = COLS * [0]\\n        for n in range(len(arr)):\\n            num = arr[n]\\n            # another 2 painted cells\\n            rowZeroes[rowCols[num][0]] += 1\\n            colZeroes[rowCols[num][1]] += 1\\n\\n\\n            if colZeroes[rowCols[num][1]] == ROWS: return n\\n            elif rowZeroes[rowCols[num][0]] == COLS: return n            \\n```\n```\\n       C1     C2   C3\\nR1 [ ({N}) | {N} | {N} ]\\nR2 [  (N)  |  N  |  N  ]\\nR3 [  (N)  |  N  |  N  ]\\nR4 [  (N)  |  N  |  N  ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471164,
                "title": "store-row-and-col",
                "content": "Go through the matrix and, for each number, remember the row and col using `mn`.\\n\\nThen, count how many elements are painted in each row and column using `mc` and `nc`.\\n\\n**C++**\\n```cpp\\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int m = mat.size(), n = mat[0].size(), k = 0;\\n    vector<int> mc(m), nc(n);\\n    vector<array<int, 2>> mn(m * n + 1);\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            mn[mat[i][j]] = {i, j};\\n    for (; ; ++k)\\n        if (++mc[mn[arr[k]][0]] == n || ++nc[mn[arr[k]][1]] == m)\\n            break;\\n    return k;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int m = mat.size(), n = mat[0].size(), k = 0;\\n    vector<int> mc(m), nc(n);\\n    vector<array<int, 2>> mn(m * n + 1);\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            mn[mat[i][j]] = {i, j};\\n    for (; ; ++k)\\n        if (++mc[mn[arr[k]][0]] == n || ++nc[mn[arr[k]][1]] == m)\\n            break;\\n    return k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468364,
                "title": "hashmap-well-explained-java-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, all we need to find is the index of the element from arr[i] in the matrix.\\nFor every element we need to find the index and to keep the count of number of elements in each row and each column, so the time complexity will be $$O(len*(m*n))$$ where len is length of array.\\nNow, let\\'s talk about the constraints.\\narr.length == m * n\\n1 <= m, n <= 10^5\\n1 <= m * n <= 10^5\\n\\nClearly, in the worst case there will be TLE error.\\n\\nSo, all we need a data structure which can be used to search the index of the arr[i] in a constant time.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHashMap is the only data structure which can help us to find the index of arr[i] in a constant time.\\nWe will be keep tracking the number of elements in each row and each column by using temporary arrays.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        int[] rows=new int[m];\\n        int[] cols=new int[n];\\n        \\n        \\n        HashMap<Integer,Pair> map=new HashMap<>();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map.put(mat[i][j],new Pair(i,j));\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            Pair p=map.get(arr[i]);\\n            \\n            int r=p.i;\\n            int c=p.j;\\n            \\n            rows[r]++;\\n            cols[c]++;            \\n            \\n            if(rows[r]==n || cols[c]==m)\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n\\nclass Pair\\n{\\n    int i,j;\\n    \\n    Pair(int i,int j)\\n    {\\n        this.i=i;\\n        this.j=j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        int[] rows=new int[m];\\n        int[] cols=new int[n];\\n        \\n        \\n        HashMap<Integer,Pair> map=new HashMap<>();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map.put(mat[i][j],new Pair(i,j));\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            Pair p=map.get(arr[i]);\\n            \\n            int r=p.i;\\n            int c=p.j;\\n            \\n            rows[r]++;\\n            cols[c]++;            \\n            \\n            if(rows[r]==n || cols[c]==m)\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n\\nclass Pair\\n{\\n    int i,j;\\n    \\n    Pair(int i,int j)\\n    {\\n        this.i=i;\\n        this.j=j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468354,
                "title": "fully-explained-simple-java-solution",
                "content": "\\n# Approach\\nImplement a HashMap and store row and column value for each item.\\n\\nNow make arrays of row and column of size column and row respectively for getting the filled size of that row or that column.\\n\\nFor each value of arr we increase the filled size by one and check if any row or col filled size equals to col or row size respectively and store the minimum index.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int size = arr.length;\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        //Implement a HashMap and store row and column value for each item\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                map.put(mat[i][j], new ArrayList<Integer>(Arrays.asList(i,j)));\\n            }\\n        }\\n        \\n        //now make arrays of row and column of size column and row respectively for getting the filled size of that row or that column.\\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n        int rval = Integer.MAX_VALUE;\\n        int cval =Integer.MAX_VALUE;\\n        \\n        // for each value of arr we increase the filled size by one and check if any row or col filled size equals to col or row size respectively and store the minimum index.\\n        for(int i = 0;i<size;i++)\\n        {\\n            int val = arr[i];\\n            int r=map.get(val).get(0);\\n            int c=map.get(val).get(1);\\n            row[r]++;\\n            if(row[r]==m) rval = Math.min(rval,i);\\n            col[c]++;\\n            if(col[c]==n) cval = Math.min(cval,i);\\n            \\n        }\\n        return Math.min(rval,cval);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int size = arr.length;\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        //Implement a HashMap and store row and column value for each item\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                map.put(mat[i][j], new ArrayList<Integer>(Arrays.asList(i,j)));\\n            }\\n        }\\n        \\n        //now make arrays of row and column of size column and row respectively for getting the filled size of that row or that column.\\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n        int rval = Integer.MAX_VALUE;\\n        int cval =Integer.MAX_VALUE;\\n        \\n        // for each value of arr we increase the filled size by one and check if any row or col filled size equals to col or row size respectively and store the minimum index.\\n        for(int i = 0;i<size;i++)\\n        {\\n            int val = arr[i];\\n            int r=map.get(val).get(0);\\n            int c=map.get(val).get(1);\\n            row[r]++;\\n            if(row[r]==m) rval = Math.min(rval,i);\\n            col[c]++;\\n            if(col[c]==n) cval = Math.min(cval,i);\\n            \\n        }\\n        return Math.min(rval,cval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468256,
                "title": "c-map-of-each-row-column",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        map<int,int> r,c;\\n        for(int i=0;i<arr.size();i++){\\n            auto x = mp[arr[i]];\\n            r[x.first] += 1;\\n            c[x.second] += 1;\\n            \\n            if(r[x.first] == mat[0].size() || c[x.second] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        map<int,int> r,c;\\n        for(int i=0;i<arr.size();i++){\\n            auto x = mp[arr[i]];\\n            r[x.first] += 1;\\n            c[x.second] += 1;\\n            \\n            if(r[x.first] == mat[0].size() || c[x.second] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492091,
                "title": "c-math-easy-to-understand",
                "content": "# Intuition\\nstore index{i,j} of every element of matrix \\n\\n# Approach\\nfor an element at index x of arr get{i,j} increment r[i] and c[j] by 1\\nif r[i] came n time than return index x\\nif c[j] came m time than return index x\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int i,j,m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> v(m*n);\\n        vector<int> r(m,0),c(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                v[mat[i][j]-1] = {i,j};\\n            }\\n        }\\n        for(i = 0; i < m*n; i++){\\n            r[v[arr[i]-1][0]]++;\\n            c[v[arr[i]-1][1]]++;\\n            // cout<<arr[i]<<\" \"<<v[arr[i]-1][0]<<\" \"<<v[arr[i]-1][1]<<\" \"<<r[v[arr[i]-1][0]]<<\" \"<<c[v[arr[i]-1][1]]<<endl;\\n            if(r[v[arr[i]-1][0]] == n)return i;\\n            if(c[v[arr[i]-1][1]] == m)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int i,j,m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> v(m*n);\\n        vector<int> r(m,0),c(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                v[mat[i][j]-1] = {i,j};\\n            }\\n        }\\n        for(i = 0; i < m*n; i++){\\n            r[v[arr[i]-1][0]]++;\\n            c[v[arr[i]-1][1]]++;\\n            // cout<<arr[i]<<\" \"<<v[arr[i]-1][0]<<\" \"<<v[arr[i]-1][1]<<\" \"<<r[v[arr[i]-1][0]]<<\" \"<<c[v[arr[i]-1][1]]<<endl;\\n            if(r[v[arr[i]-1][0]] == n)return i;\\n            if(c[v[arr[i]-1][1]] == m)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3472180,
                "title": "brute-force-to-optimal-easy-to-understand",
                "content": "```\\n//Brute Force :-  O(n^2) (will give TLE)\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(), n=mat[0].size(), size=arr.size(), idx=0;\\n        unordered_set<int>st;\\n        unordered_map<int, pair<int,int>>mp;\\n        \\n         for(int i=0;i<m;i++) {\\n             for(int j=0;j<n;j++) {\\n                    mp[mat[i][j]]={i,j};\\n                }\\n         }\\n        while(idx < size) {\\n            st.insert(arr[idx]);\\n            auto it = mp.find(arr[idx]);\\n            int i=(it->second).first, j=(it->second).second;\\n            bool valid1=true,valid2=true;\\n                \\n            for(int col=0;col<n;col++) {\\n                if(st.find(mat[i][col]) == st.end()) {\\n                     valid1=false;\\n                    break;\\n                }\\n\\n            }\\n            \\n            for(int row=0;row<m;row++) {\\n                if(st.find(mat[row][j]) == st.end()) {\\n                    valid2=false;\\n                    break;\\n                }\\n\\n            }\\n            if(valid2 || valid1)return idx;\\n\\n                idx++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n//Optimal :-  O(m*n)\\n\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int>mp;\\n        int maxIdx = 0, m = mat.size(), n = mat[0].size(), res = INT_MAX;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=i;\\n        \\n        for(int i=0;i<m;i++) {\\n            maxIdx = 0;\\n            for(int j=0;j<n;j++) {\\n                maxIdx = max(maxIdx, mp[mat[i][j]]);\\n            }\\n            res = min(res, maxIdx);\\n        }\\n         for(int i=0;i<n;i++) {\\n            maxIdx = 0;\\n            for(int j=0;j<m;j++) {\\n                maxIdx = max(maxIdx, mp[mat[j][i]]);\\n            }\\n            res = min(res, maxIdx);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//Brute Force :-  O(n^2) (will give TLE)\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(), n=mat[0].size(), size=arr.size(), idx=0;\\n        unordered_set<int>st;\\n        unordered_map<int, pair<int,int>>mp;\\n        \\n         for(int i=0;i<m;i++) {\\n             for(int j=0;j<n;j++) {\\n                    mp[mat[i][j]]={i,j};\\n                }\\n         }\\n        while(idx < size) {\\n            st.insert(arr[idx]);\\n            auto it = mp.find(arr[idx]);\\n            int i=(it->second).first, j=(it->second).second;\\n            bool valid1=true,valid2=true;\\n                \\n            for(int col=0;col<n;col++) {\\n                if(st.find(mat[i][col]) == st.end()) {\\n                     valid1=false;\\n                    break;\\n                }\\n\\n            }\\n            \\n            for(int row=0;row<m;row++) {\\n                if(st.find(mat[row][j]) == st.end()) {\\n                    valid2=false;\\n                    break;\\n                }\\n\\n            }\\n            if(valid2 || valid1)return idx;\\n\\n                idx++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n//Optimal :-  O(m*n)\\n\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int>mp;\\n        int maxIdx = 0, m = mat.size(), n = mat[0].size(), res = INT_MAX;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=i;\\n        \\n        for(int i=0;i<m;i++) {\\n            maxIdx = 0;\\n            for(int j=0;j<n;j++) {\\n                maxIdx = max(maxIdx, mp[mat[i][j]]);\\n            }\\n            res = min(res, maxIdx);\\n        }\\n         for(int i=0;i<n;i++) {\\n            maxIdx = 0;\\n            for(int j=0;j<m;j++) {\\n                maxIdx = max(maxIdx, mp[mat[j][i]]);\\n            }\\n            res = min(res, maxIdx);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468333,
                "title": "java-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int firstCompleteIndex(int[] arr, int[][] mat) {\\n    var m = mat.length;\\n    var n = mat[0].length;\\n    \\n    var rows = new int[m];\\n    var cols = new int[n];\\n    \\n    var map = new int[m*n][2];\\n    \\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        var a = mat[i][j] - 1;\\n\\n        map[a][0] = i;\\n        map[a][1] = j;\\n      }\\n    }\\n    for (var i=0; i < arr.length; i++) {\\n      var a = arr[i] - 1;\\n\\n      rows[map[a][0]]++;\\n      cols[map[a][1]]++;\\n      \\n      if (rows[map[a][0]] == n || cols[map[a][1]] == m)\\n        return i;\\n    }    \\n    return m*n;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int firstCompleteIndex(int[] arr, int[][] mat) {\\n    var m = mat.length;\\n    var n = mat[0].length;\\n    \\n    var rows = new int[m];\\n    var cols = new int[n];\\n    \\n    var map = new int[m*n][2];\\n    \\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        var a = mat[i][j] - 1;\\n\\n        map[a][0] = i;\\n        map[a][1] = j;\\n      }\\n    }\\n    for (var i=0; i < arr.length; i++) {\\n      var a = arr[i] - 1;\\n\\n      rows[map[a][0]]++;\\n      cols[map[a][1]]++;\\n      \\n      if (rows[map[a][0]] == n || cols[map[a][1]] == m)\\n        return i;\\n    }    \\n    return m*n;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660761,
                "title": "unordered-map-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThink brute force, but optimize brute force by tracking colored cells using a hash table.\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n,m;\\n    unordered_map<int,pair<int,int>> pos;\\n    unordered_map<int,int> rows,cols;\\n\\n    bool fillup(int x,int y)\\n    {\\n        rows[x]++;\\n        cols[y]++;\\n\\n        if(rows[x]>=m || cols[y]>=n)\\n        return true;\\n\\n        return false;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        n = mat.size(),m = mat[0].size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            pos[mat[i][j]] = {i,j};\\n        }\\n\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            int x = pos[arr[i]].first,y = pos[arr[i]].second;\\n\\n            if(fillup(x,y))\\n            return i;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/8592f1f7-c3a8-4941-8061-974069f1178b_1687252161.7047396.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n,m;\\n    unordered_map<int,pair<int,int>> pos;\\n    unordered_map<int,int> rows,cols;\\n\\n    bool fillup(int x,int y)\\n    {\\n        rows[x]++;\\n        cols[y]++;\\n\\n        if(rows[x]>=m || cols[y]>=n)\\n        return true;\\n\\n        return false;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        n = mat.size(),m = mat[0].size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            pos[mat[i][j]] = {i,j};\\n        }\\n\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            int x = pos[arr[i]].first,y = pos[arr[i]].second;\\n\\n            if(fillup(x,y))\\n            return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469348,
                "title": "accepted-c-solution-with-complete-explanation-using-map-100-successful",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we store all the elements of $$mat$$ in $$map$$ with its elements as key and their indexes as value. (We are storing to reduce the search complexity in matrix).\\n\\nWe create two more vector to store the count of the elements painted in the particular column and row. We named the vector as $$rowCount$$ and $$colCount$$.\\n\\nNow, we traversal through the $$arr$$ and check the row and column of that element in $$mat$$ using the $$map$$ we created.\\n\\nNow, further we increment the colCount for columnIndex and rowCount for the rowIndex respectively.\\n\\nNext, we check if the $$colCount$$ is at its max (the max of column can be the number of the i.e $$n$$). Incase, we set the value of $$ans$$ variable as the current Index and break the loop.\\nSimilarly, we check for $$rowCount$$ (for row max count will be the number of column i.e $$m$$).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFirst, $$O(n*m)$$ for storing elements and their corresponding indexes in map. Second, $$O(n*m)$$ for traversing of arr.\\nSo, overall time complexity is:\\n$$O(2*n*m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$ for map\\n$$O(n)$$ for rowCount.\\n$$O(m)$$ for colCount.\\nSo, overall space complexity is:\\n$$O(n*m + (n+m))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        map<int,pair<int,int>> mp;\\n        for(int i= 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        vector<int> colCount(m,0);\\n        vector<int> rowCount(n,0);\\n        int ans = INT_MAX;\\n        for(int i = 0; i<m*n; i++){\\n            auto pr = mp[arr[i]];\\n            colCount[pr.second]++;\\n            rowCount[pr.first]++;\\n        \\n            if(colCount[pr.second] == n && ans > i){\\n                ans = i;\\n                break;\\n            }\\n            \\n            if(rowCount[pr.first] == m && ans > i){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        map<int,pair<int,int>> mp;\\n        for(int i= 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        vector<int> colCount(m,0);\\n        vector<int> rowCount(n,0);\\n        int ans = INT_MAX;\\n        for(int i = 0; i<m*n; i++){\\n            auto pr = mp[arr[i]];\\n            colCount[pr.second]++;\\n            rowCount[pr.first]++;\\n        \\n            if(colCount[pr.second] == n && ans > i){\\n                ans = i;\\n                break;\\n            }\\n            \\n            if(rowCount[pr.first] == m && ans > i){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468348,
                "title": "easy-to-understand-c-simple-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int a = mat.size(),b = mat[0].size(),c = arr.size();\\n        vector<int> r1(a,0),c1(b,0);\\n        vector<vector<int>> ind(a*b+1);\\n        for(int i = 0; i < a; i++){\\n            for(int j = 0; j < b; j++){\\n                ind[mat[i][j]] = {i,j};\\n            }\\n        }\\n        // for(int k = 0; k < c; k++){\\n        //     cout<<arr[k]<<\" \"<<ind[arr[k]][0]<<\" \"<<ind[arr[k]][1]<<endl;\\n        // }\\n        for(int k = 0; k < c; k++){\\n            r1[ind[arr[k]][0]]++;\\n            c1[ind[arr[k]][1]]++;\\n            // cout<<arr[k]<<\" \"<<ind[arr[k]][0]<<\" \"<<r1[ind[arr[k]][0]]<<\" \"<<ind[arr[k]][1]<<\" \"<<c1[ind[arr[k]][1]]<<endl;\\n            if(r1[ind[arr[k]][0]]==b)return k;\\n            if(c1[ind[arr[k]][1]]==a)return k;\\n        }\\n        return -1;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int a = mat.size(),b = mat[0].size(),c = arr.size();\\n        vector<int> r1(a,0),c1(b,0);\\n        vector<vector<int>> ind(a*b+1);\\n        for(int i = 0; i < a; i++){\\n            for(int j = 0; j < b; j++){\\n                ind[mat[i][j]] = {i,j};\\n            }\\n        }\\n        // for(int k = 0; k < c; k++){\\n        //     cout<<arr[k]<<\" \"<<ind[arr[k]][0]<<\" \"<<ind[arr[k]][1]<<endl;\\n        // }\\n        for(int k = 0; k < c; k++){\\n            r1[ind[arr[k]][0]]++;\\n            c1[ind[arr[k]][1]]++;\\n            // cout<<arr[k]<<\" \"<<ind[arr[k]][0]<<\" \"<<r1[ind[arr[k]][0]]<<\" \"<<ind[arr[k]][1]<<\" \"<<c1[ind[arr[k]][1]]<<endl;\\n            if(r1[ind[arr[k]][0]]==b)return k;\\n            if(c1[ind[arr[k]][1]]==a)return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468331,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int r = mat.size(),c= mat[0].size();\\n        vector<pair<int,int> > ind(r*c+1);\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                ind[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        vector<int> szRow(r),szCol(c);\\n        for(int i=0;i<r*c;i++){\\n            int num = arr[i];\\n            int x= ind[num].first,y=ind[num].second;\\n            \\n            szRow[x]++;\\n            szCol[y]++;\\n            if(szRow[x] == c || szCol[y] == r)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int r = mat.size(),c= mat[0].size();\\n        vector<pair<int,int> > ind(r*c+1);\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                ind[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        vector<int> szRow(r),szCol(c);\\n        for(int i=0;i<r*c;i++){\\n            int num = arr[i];\\n            int x= ind[num].first,y=ind[num].second;\\n            \\n            szRow[x]++;\\n            szCol[y]++;\\n            if(szRow[x] == c || szCol[y] == r)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541615,
                "title": "o-m-n-time-o-m-n-space-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i < arr.size();i++)\\n            mp[arr[i]] = i;\\n\\n        int ans = 1e9,temp = -1;\\n        for(int r = 0;r < mat.size();r++){\\n            temp = -1;\\n            for(int c = 0;c < mat[0].size();c++){\\n                temp  = max({temp,mp[mat[r][c]]});\\n            }\\n            ans = min(temp,ans);\\n        }\\n        for(int r = 0;r < mat[0].size();r++){\\n            temp = -1;\\n            for(int c = 0;c < mat.size();c++){\\n                temp  = max({temp,mp[mat[c][r]]});\\n            }\\n            ans = min(temp,ans);\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i < arr.size();i++)\\n            mp[arr[i]] = i;\\n\\n        int ans = 1e9,temp = -1;\\n        for(int r = 0;r < mat.size();r++){\\n            temp = -1;\\n            for(int c = 0;c < mat[0].size();c++){\\n                temp  = max({temp,mp[mat[r][c]]});\\n            }\\n            ans = min(temp,ans);\\n        }\\n        for(int r = 0;r < mat[0].size();r++){\\n            temp = -1;\\n            for(int c = 0;c < mat.size();c++){\\n                temp  = max({temp,mp[mat[c][r]]});\\n            }\\n            ans = min(temp,ans);\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519669,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\\n    val all = arr.zipWithIndex.toMap\\n    val cols = mat.map(_.map(all.getOrElse(_, Int.MaxValue)).max)\\n    val rows = mat.transpose.map(_.map(all.getOrElse(_, Int.MaxValue)).max)\\n    cols.min min rows.min\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\\n    val all = arr.zipWithIndex.toMap\\n    val cols = mat.map(_.map(all.getOrElse(_, Int.MaxValue)).max)\\n    val rows = mat.transpose.map(_.map(all.getOrElse(_, Int.MaxValue)).max)\\n    cols.min min rows.min\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3495481,
                "title": "binbin-s-knight-taught-her-very-well",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        i = 0\\n        m = len(mat)\\n        n = len(mat[0])\\n       \\n        mark_r = [0 for i in range(m)]\\n        mark_c =  [0 for i in range(n)]\\n        mapping = {}\\n        \\n        for j in range (m*n):\\n            mapping.update({mat[j//n][j%n]: [j//n,j%n]})\\n  \\n        while i in range(m*n):\\n           \\n            mark_r[mapping[arr[i]][0]] += 1\\n            if mark_r[mapping[arr[i]][0]] ==n:\\n                return i\\n            mark_c[mapping[arr[i]][1]] += 1\\n            if mark_c[mapping[arr[i]][1]] == m:\\n                return i\\n\\n            \\n            i += 1\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        i = 0\\n        m = len(mat)\\n        n = len(mat[0])\\n       \\n        mark_r = [0 for i in range(m)]\\n        mark_c =  [0 for i in range(n)]\\n        mapping = {}\\n        \\n        for j in range (m*n):\\n            mapping.update({mat[j//n][j%n]: [j//n,j%n]})\\n  \\n        while i in range(m*n):\\n           \\n            mark_r[mapping[arr[i]][0]] += 1\\n            if mark_r[mapping[arr[i]][0]] ==n:\\n                return i\\n            mark_c[mapping[arr[i]][1]] += 1\\n            if mark_c[mapping[arr[i]][1]] == m:\\n                return i\\n\\n            \\n            i += 1\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479637,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n\\n- Space complexity:$$O(n)+O(m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int, int>m1, m2;\\n        vector<int>v1(mat.size(), 0), v2(mat[0].size(), 0);\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[0].size(); j++){\\n                m1[mat[i][j]]=i;\\n                m2[mat[i][j]]=j;\\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            v1[m1[arr[i]]]++;\\n            v2[m2[arr[i]]]++;\\n            if(v1[m1[arr[i]]]==mat[0].size() || v2[m2[arr[i]]]==mat.size()){return i;}\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int, int>m1, m2;\\n        vector<int>v1(mat.size(), 0), v2(mat[0].size(), 0);\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[0].size(); j++){\\n                m1[mat[i][j]]=i;\\n                m2[mat[i][j]]=j;\\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            v1[m1[arr[i]]]++;\\n            v2[m2[arr[i]]]++;\\n            if(v1[m1[arr[i]]]==mat[0].size() || v2[m2[arr[i]]]==mat.size()){return i;}\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478095,
                "title": "go-easy-to-understand-solution",
                "content": "# Intuition\\nKeep track of each row and col to remaining unpainted count, num2pos keep track each number to its position in mat, use number to represent the position row * colLen + col.\\n\\n# Approach\\nscan through arr and find element position in mat, reduce row2cnt and col2cnt until find first row or col remaining count to be 0, then it means the row or col has been painted.\\n\\n# Complexity\\n- Time complexity:\\nO(m * n) where m is the mat row len, n is col len\\n\\n- Space complexity:\\nO(m * n) where m is the mat row len, n is col len\\n\\n# Code\\n```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n    m, n := len(mat), len(mat[0])\\n    row2cnt := make([]int, m)\\n    col2cnt := make([]int, n)\\n    for i := range row2cnt {\\n        row2cnt[i] = n\\n    }\\n    for j := range col2cnt {\\n        col2cnt[j] = m\\n    }\\n    num2pos := make([]int, m * n + 1)\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            num2pos[mat[i][j]] = i * n + j\\n        }\\n    }\\n    for i, v := range arr {\\n        pos := num2pos[v]\\n        r, c := pos / n, pos % n\\n        row2cnt[r]--\\n        col2cnt[c]--\\n        if row2cnt[r] == 0 || col2cnt[c] == 0 {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n    m, n := len(mat), len(mat[0])\\n    row2cnt := make([]int, m)\\n    col2cnt := make([]int, n)\\n    for i := range row2cnt {\\n        row2cnt[i] = n\\n    }\\n    for j := range col2cnt {\\n        col2cnt[j] = m\\n    }\\n    num2pos := make([]int, m * n + 1)\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            num2pos[mat[i][j]] = i * n + j\\n        }\\n    }\\n    for i, v := range arr {\\n        pos := num2pos[v]\\n        r, c := pos / n, pos % n\\n        row2cnt[r]--\\n        col2cnt[c]--\\n        if row2cnt[r] == 0 || col2cnt[c] == 0 {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475169,
                "title": "python-counter-of-x-y-axes",
                "content": "```python\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        h, w = len(mat), len(mat[0])\\n        \\n        d = {}\\n        for y in range(h):\\n            for x in range(w):\\n                d[mat[y][x]] = (y, x)\\n        \\n        x_axis, y_axis = defaultdict(int), defaultdict(int)\\n\\n        for i, n in enumerate(arr):\\n            y, x = d[n]\\n            \\n            y_axis[y] += 1\\n            x_axis[x] += 1\\n\\n            if y_axis[y] == w or x_axis[x] == h:\\n                return i\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        h, w = len(mat), len(mat[0])\\n        \\n        d = {}\\n        for y in range(h):\\n            for x in range(w):\\n                d[mat[y][x]] = (y, x)\\n        \\n        x_axis, y_axis = defaultdict(int), defaultdict(int)\\n\\n        for i, n in enumerate(arr):\\n            y, x = d[n]\\n            \\n            y_axis[y] += 1\\n            x_axis[x] += 1\\n\\n            if y_axis[y] == w or x_axis[x] == h:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474742,
                "title": "c-easy-solution-with-explanation-hashtable-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo avoid repeatedly traversing the matrix, we can optimize the process by first traversing the matrix once and recording the position of each number in an unordered map. \\n\\nThen, we can traverse the array and for each index, we can look up the position of the corresponding number in the map. By subtracting 1 from the corresponding row and column in the matrix, we can keep track of which rows and columns have already been used. For example, if the number 3 is at mat[r][c], we would do rows[r]-- and cols[c]--. This is because we want to update the rows and columns to indicate that a column has been used in the \"row r\". \\n\\nInitially, each \"row r\" will have m columns available, but once rows[r] reaches 0, it means that the row has been occupied. We can then find the index to return, which is the same process we use for the columns.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMap + Count\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int R = mat.size();\\n        int C = mat[0].size();\\n        \\n        vector<int> rows(R, C);\\n        vector<int> cols(C, R);\\n        unordered_map<int, pair<int,int>> Map;\\n        \\n        for(int i=0; i<R; i++){\\n            for(int j=0; j<C; j++){\\n                Map[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<arr.size(); i++){\\n            auto [r,c] = Map[arr[i]]; \\n            \\n            rows[r]--;\\n            cols[c]--;\\n            if(rows[r]==0 || cols[c]==0){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int R = mat.size();\\n        int C = mat[0].size();\\n        \\n        vector<int> rows(R, C);\\n        vector<int> cols(C, R);\\n        unordered_map<int, pair<int,int>> Map;\\n        \\n        for(int i=0; i<R; i++){\\n            for(int j=0; j<C; j++){\\n                Map[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<arr.size(); i++){\\n            auto [r,c] = Map[arr[i]]; \\n            \\n            rows[r]--;\\n            cols[c]--;\\n            if(rows[r]==0 || cols[c]==0){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473725,
                "title": "hashmap-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n\\t{\\n\\t\\t//preprocessing \\n\\t\\tunordered_map<int,pair<int,int>>mp;\\n\\t\\tfor(int i=0;i<mat.size();i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<mat[i].size();j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[mat[i][j]] = make_pair(i,j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        int n = mat.size();\\n\\t\\tint m = mat[0].size();\\n\\t\\t\\n\\t\\tunordered_map<int,int>mp_row;   //to keep the track of the painted row\\n\\t\\tunordered_map<int,int>mp_col;   //to keep the track of the painted col\\n\\t\\t\\n\\t\\tfor(int i=0;i<arr.size();i++)\\n\\t\\t{\\n\\t\\t\\tint val = arr[i];\\n\\t\\t    int row = mp[val].first;\\n\\t\\t    int col = mp[val].second;\\n\\t\\t    \\n\\t\\t    mp_row[row]++;\\n\\t\\t    if(mp_row[row] == m) return i;\\n\\t\\t    \\n\\t\\t    mp_col[col]++;\\n\\t\\t    if(mp_col[col] == n) return i;\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n\\t{\\n\\t\\t//preprocessing \\n\\t\\tunordered_map<int,pair<int,int>>mp;\\n\\t\\tfor(int i=0;i<mat.size();i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<mat[i].size();j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[mat[i][j]] = make_pair(i,j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        int n = mat.size();\\n\\t\\tint m = mat[0].size();\\n\\t\\t\\n\\t\\tunordered_map<int,int>mp_row;   //to keep the track of the painted row\\n\\t\\tunordered_map<int,int>mp_col;   //to keep the track of the painted col\\n\\t\\t\\n\\t\\tfor(int i=0;i<arr.size();i++)\\n\\t\\t{\\n\\t\\t\\tint val = arr[i];\\n\\t\\t    int row = mp[val].first;\\n\\t\\t    int col = mp[val].second;\\n\\t\\t    \\n\\t\\t    mp_row[row]++;\\n\\t\\t    if(mp_row[row] == m) return i;\\n\\t\\t    \\n\\t\\t    mp_col[col]++;\\n\\t\\t    if(mp_col[col] == n) return i;\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473019,
                "title": "java-hashing-unoptimized-optimized-2-approaches-easy",
                "content": "\\nUnoptimized but still works\\n# Complexity\\n- Time complexity:O(k*m*n)\\n- Where k is the number of operation required to make one wall to be colored\\n- m is number of rows\\n- n is number of columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int ind=0;\\n        int m=mat.length,n=mat[0].length;\\n        int row[]=new int[m];\\n        int col[]=new int[n];\\n        boolean flag=true;;\\n        while(flag){\\n            int i=0;\\n            for(i=0;i<m;i++){\\n                int j=0;\\n                for(j=0;j<n;j++){\\n                    if(mat[i][j]==arr[ind]){\\n                        ind++;\\n                        row[i]++;\\n                        col[j]++;\\n                    }\\n                    if(row[i]==n || col[j]==m){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(!flag)   break;\\n            }\\n        }\\n       return ind-1;\\n    }\\n}\\n```\\nOptimized Version of the same:\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- m is number of rows\\n- n is number of columns\\n- Space complexity:O(m)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]>hm=new HashMap<>();\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                hm.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int row[]=new int[mat.length];\\n        int col[]=new int[mat[0].length];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            int curr[]=hm.get(arr[i]);\\n            row[curr[0]]++;\\n            col[curr[1]]++;\\n            if(row[curr[0]]==mat[0].length ||\\n                col[curr[1]]==mat.length){\\n                    break;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int ind=0;\\n        int m=mat.length,n=mat[0].length;\\n        int row[]=new int[m];\\n        int col[]=new int[n];\\n        boolean flag=true;;\\n        while(flag){\\n            int i=0;\\n            for(i=0;i<m;i++){\\n                int j=0;\\n                for(j=0;j<n;j++){\\n                    if(mat[i][j]==arr[ind]){\\n                        ind++;\\n                        row[i]++;\\n                        col[j]++;\\n                    }\\n                    if(row[i]==n || col[j]==m){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(!flag)   break;\\n            }\\n        }\\n       return ind-1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]>hm=new HashMap<>();\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                hm.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int row[]=new int[mat.length];\\n        int col[]=new int[mat[0].length];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            int curr[]=hm.get(arr[i]);\\n            row[curr[0]]++;\\n            col[curr[1]]++;\\n            if(row[curr[0]]==mat[0].length ||\\n                col[curr[1]]==mat.length){\\n                    break;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470232,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m = {}\\n        r,c = len(mat),len(mat[0])\\n        for i,n in enumerate(arr):\\n            m[n] = i\\n        ans=1000000000\\n        for i in range(r):\\n            curminind = 0\\n            for j in range(c):\\n                curminind = max(curminind , m[mat[i][j]])\\n            ans = min(ans , curminind)\\n        for i in range(c):\\n            curminind = 0\\n            for j in range(r):\\n                curminind = max(curminind , m[mat[j][i]])\\n            ans = min(ans , curminind)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m = {}\\n        r,c = len(mat),len(mat[0])\\n        for i,n in enumerate(arr):\\n            m[n] = i\\n        ans=1000000000\\n        for i in range(r):\\n            curminind = 0\\n            for j in range(c):\\n                curminind = max(curminind , m[mat[i][j]])\\n            ans = min(ans , curminind)\\n        for i in range(c):\\n            curminind = 0\\n            for j in range(r):\\n                curminind = max(curminind , m[mat[j][i]])\\n            ans = min(ans , curminind)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469856,
                "title": "c-solution-using-hashing-easy-solution",
                "content": "# Intuition\\n**Store the element row and column in a map and then make a vector of size of column and row and fill it with zero. Now iterarte through the given array and check for column and row in map. Increment the count of column and row by one. Now check if count of that particular column is equal to row or count of that particular row is equal to column. If it is true then return the index of array else continue the loop.**\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n- Space complexity:O(m*n)+ O(m) + O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        unordered_map<int,pair<int,int>> mp;\\n        vector<int> row(n+1,0);\\n        vector<int> col(m+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    mp[mat[i][j]]={i,j};\\n                }\\n            }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            row[mp[arr[i]].first]++;\\n            col[mp[arr[i]].second]++;\\n            if(row[mp[arr[i]].first]==m) return i;\\n            if( col[mp[arr[i]].second]==n) return i;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```\\n![7dr99c.jpg](https://assets.leetcode.com/users/images/70a88c3f-e92d-4a88-bd24-3535f3bc09be_1682857653.6323266.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        unordered_map<int,pair<int,int>> mp;\\n        vector<int> row(n+1,0);\\n        vector<int> col(m+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    mp[mat[i][j]]={i,j};\\n                }\\n            }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            row[mp[arr[i]].first]++;\\n            col[mp[arr[i]].second]++;\\n            if(row[mp[arr[i]].first]==m) return i;\\n            if( col[mp[arr[i]].second]==n) return i;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469674,
                "title": "java-beats-100-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[] counterForRow = new int[mat.length];\\n        int[] counterForColumn = new int[mat[0].length];\\n            \\n        Map<Integer, Integer> rowOfNumber = new HashMap<>();\\n        Map<Integer, Integer> colOfNumber = new HashMap<>();\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                rowOfNumber.put(mat[i][j], i);\\n                colOfNumber.put(mat[i][j], j);\\n            }\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            int row = rowOfNumber.get(arr[i]);\\n            int col = colOfNumber.get(arr[i]);\\n            \\n            counterForRow[row]++;\\n            counterForColumn[col]++;\\n            \\n            if(counterForRow[row] == mat[0].length || counterForColumn[col] == mat.length) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[] counterForRow = new int[mat.length];\\n        int[] counterForColumn = new int[mat[0].length];\\n            \\n        Map<Integer, Integer> rowOfNumber = new HashMap<>();\\n        Map<Integer, Integer> colOfNumber = new HashMap<>();\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                rowOfNumber.put(mat[i][j], i);\\n                colOfNumber.put(mat[i][j], j);\\n            }\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            int row = rowOfNumber.get(arr[i]);\\n            int col = colOfNumber.get(arr[i]);\\n            \\n            counterForRow[row]++;\\n            counterForColumn[col]++;\\n            \\n            if(counterForRow[row] == mat[0].length || counterForColumn[col] == mat.length) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469668,
                "title": "simple-easy-approach-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& matrix) {\\n        int m= matrix.size();\\n        int n= matrix[0].size();\\n        int t= arr.size();\\n        int ans= m*n-1;\\n        \\n        unordered_map<int, int>mp;\\n        for(int i=0; i<t; i++) mp[arr[i]]=i; // store the index of arr element in map\\n        \\n        //row wise check \\n        for(int i=0; i<m; i++) {\\n            int rowmax=0; //  maximum index required (have to traverse) to color that full row\\n            for(int j=0; j<n; j++) {\\n                rowmax= max(rowmax, mp[matrix[i][j]]);\\n            }\\n            ans= min(ans, rowmax); \\n        }\\n        \\n        //column wise check\\n        for(int i=0; i<n; i++) {\\n            int colmax=0;\\n            for(int j=0; j<m; j++) {\\n                colmax= max(colmax, mp[matrix[j][i]]); //  maximum index required (have to traverse) to color that full col\\n            }\\n            ans= min(ans, colmax);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& matrix) {\\n        int m= matrix.size();\\n        int n= matrix[0].size();\\n        int t= arr.size();\\n        int ans= m*n-1;\\n        \\n        unordered_map<int, int>mp;\\n        for(int i=0; i<t; i++) mp[arr[i]]=i; // store the index of arr element in map\\n        \\n        //row wise check \\n        for(int i=0; i<m; i++) {\\n            int rowmax=0; //  maximum index required (have to traverse) to color that full row\\n            for(int j=0; j<n; j++) {\\n                rowmax= max(rowmax, mp[matrix[i][j]]);\\n            }\\n            ans= min(ans, rowmax); \\n        }\\n        \\n        //column wise check\\n        for(int i=0; i<n; i++) {\\n            int colmax=0;\\n            for(int j=0; j<m; j++) {\\n                colmax= max(colmax, mp[matrix[j][i]]); //  maximum index required (have to traverse) to color that full col\\n            }\\n            ans= min(ans, colmax);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469429,
                "title": "first-completely-painted-row-or-column-c-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<int> I((m*n)+1,0);\\n        vector<int> J((m*n)+1,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                I[mat[i][j]]=i;\\n                J[mat[i][j]]=j;\\n            }\\n        }\\n        \\n        map<int,int> row;\\n        map<int,int> col;\\n        \\n        for(int i=0;i<m*n;i++)\\n        {\\n            int num=arr[i];\\n            row[I[num]]++;\\n            col[J[num]]++;\\n           if(row[I[num]]==n||col[J[num]]==m)\\n           {\\n               return i;\\n           }\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<int> I((m*n)+1,0);\\n        vector<int> J((m*n)+1,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                I[mat[i][j]]=i;\\n                J[mat[i][j]]=j;\\n            }\\n        }\\n        \\n        map<int,int> row;\\n        map<int,int> col;\\n        \\n        for(int i=0;i<m*n;i++)\\n        {\\n            int num=arr[i];\\n            row[I[num]]++;\\n            col[J[num]]++;\\n           if(row[I[num]]==n||col[J[num]]==m)\\n           {\\n               return i;\\n           }\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469181,
                "title": "c-hash-table",
                "content": "# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int row_Size , col_Size;\\n\\n    bool isFilled(vector<int>&rows,int curr_Row , vector<int>&columns , int curr_Col){\\n\\n        if(rows[curr_Row] == col_Size || columns[curr_Col] == row_Size) return true;\\n        return false;\\n        \\n    }\\n\\n    int firstCompleteIndex(vector<int>& nums, vector<vector<int>>& mat) {\\n        \\n        // length of 1D array\\n        int n = nums.size();\\n\\n\\n        // length of row & column in matrix\\n        row_Size = mat.size();\\n        col_Size = mat[0].size();\\n        \\n\\n        // vectors for tracking row & column are filled or not\\n        vector<int>rows(row_Size,0);\\n        vector<int>columns(col_Size,0);\\n        \\n\\n        // maps values with location in matrix\\n        unordered_map<int,pair<int,int>>mp;\\n        \\n\\n        for(int i=0;i<row_Size;i++){\\n            for(int j=0;j<col_Size;j++){\\n\\n                int value = mat[i][j];         // value\\n                pair<int,int>location = {i,j}; // location\\n\\n                mp[value] = location;          // mapping value with location\\n\\n            }\\n        }\\n        \\n\\n        for(int i=0;i<n;i++){\\n            \\n            int curr_Row = mp[nums[i]].first;  // getting current row\\n            int curr_Col = mp[nums[i]].second; // getting current column\\n            \\n            rows[curr_Row]++;    // filling current row \\n            columns[curr_Col]++; // filling current  column \\n            \\n            // return index if current row or column is filled\\n            if(isFilled(rows,curr_Row,columns,curr_Col)) return i;     \\n            \\n        }\\n        \\n        // dummy index\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int row_Size , col_Size;\\n\\n    bool isFilled(vector<int>&rows,int curr_Row , vector<int>&columns , int curr_Col){\\n\\n        if(rows[curr_Row] == col_Size || columns[curr_Col] == row_Size) return true;\\n        return false;\\n        \\n    }\\n\\n    int firstCompleteIndex(vector<int>& nums, vector<vector<int>>& mat) {\\n        \\n        // length of 1D array\\n        int n = nums.size();\\n\\n\\n        // length of row & column in matrix\\n        row_Size = mat.size();\\n        col_Size = mat[0].size();\\n        \\n\\n        // vectors for tracking row & column are filled or not\\n        vector<int>rows(row_Size,0);\\n        vector<int>columns(col_Size,0);\\n        \\n\\n        // maps values with location in matrix\\n        unordered_map<int,pair<int,int>>mp;\\n        \\n\\n        for(int i=0;i<row_Size;i++){\\n            for(int j=0;j<col_Size;j++){\\n\\n                int value = mat[i][j];         // value\\n                pair<int,int>location = {i,j}; // location\\n\\n                mp[value] = location;          // mapping value with location\\n\\n            }\\n        }\\n        \\n\\n        for(int i=0;i<n;i++){\\n            \\n            int curr_Row = mp[nums[i]].first;  // getting current row\\n            int curr_Col = mp[nums[i]].second; // getting current column\\n            \\n            rows[curr_Row]++;    // filling current row \\n            columns[curr_Col]++; // filling current  column \\n            \\n            // return index if current row or column is filled\\n            if(isFilled(rows,curr_Row,columns,curr_Col)) return i;     \\n            \\n        }\\n        \\n        // dummy index\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469082,
                "title": "go-my-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n.m)$$ \\n- Space complexity: $$O(n.m)$$ \\n\\n# Code\\n```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n\\tn, m := len(mat), len(mat[0])\\n\\trow := make([]int, n)\\n\\tcol := make([]int, m)\\n\\thm := make(map[int][2]int)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\thm[mat[i][j]] = [2]int{i, j}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tk := hm[arr[i]]\\n\\t\\trow[k[0]]++\\n\\t\\tif row[k[0]] == m {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\n\\t\\tcol[k[1]]++\\n\\t\\tif col[k[1]] == n {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n\\tn, m := len(mat), len(mat[0])\\n\\trow := make([]int, n)\\n\\tcol := make([]int, m)\\n\\thm := make(map[int][2]int)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\thm[mat[i][j]] = [2]int{i, j}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tk := hm[arr[i]]\\n\\t\\trow[k[0]]++\\n\\t\\tif row[k[0]] == m {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\n\\t\\tcol[k[1]]++\\n\\t\\tif col[k[1]] == n {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468955,
                "title": "map-solution-for-c-explanation-complexity",
                "content": "# Approach\\nThe problem can be divided into two sub-problems:\\n1. How to find the value in the matrix in a fast way\\n2. How to understand that a row or column is completely painted\\n\\nSo,\\n1. To solve the first problem, we will create a dictionary with cell values as a key and row/column indices as a value. It will cost us some space, but it allows us to get information about the cell for O(1) time.\\n2. Create two arrays assigned for each rows/columns indices and  increase their values during traversal of the arr array.\\n\\nWhen we fill a row or column, we can return the result.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n# Code\\n```\\npublic int FirstCompleteIndex(int[] arr, int[][] mat)\\n{\\n    var dict = new Dictionary<int, Tuple<int, int>>();\\n\\n    for (var i = 0; i < mat.Length; ++i)\\n    {\\n        for (var j = 0; j < mat[i].Length; ++j)\\n        {\\n            dict.Add(mat[i][j], new Tuple<int, int>(i, j));\\n        }\\n    }\\n\\n    if (dict.Count == 0)\\n    {\\n        return -1;\\n    }\\n\\n    var rows = new int[mat.Length];\\n    var cols = new int[mat[0].Length];\\n\\n    for (var i = 0; i < arr.Length; ++i)\\n    {\\n        var item = dict[arr[i]];\\n\\n        rows[item.Item1]++;\\n        cols[item.Item2]++;\\n        if (rows[item.Item1] == mat[0].Length || cols[item.Item2] == mat.Length)\\n        {\\n            return i;\\n        }\\n    }\\n\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int FirstCompleteIndex(int[] arr, int[][] mat)\\n{\\n    var dict = new Dictionary<int, Tuple<int, int>>();\\n\\n    for (var i = 0; i < mat.Length; ++i)\\n    {\\n        for (var j = 0; j < mat[i].Length; ++j)\\n        {\\n            dict.Add(mat[i][j], new Tuple<int, int>(i, j));\\n        }\\n    }\\n\\n    if (dict.Count == 0)\\n    {\\n        return -1;\\n    }\\n\\n    var rows = new int[mat.Length];\\n    var cols = new int[mat[0].Length];\\n\\n    for (var i = 0; i < arr.Length; ++i)\\n    {\\n        var item = dict[arr[i]];\\n\\n        rows[item.Item1]++;\\n        cols[item.Item2]++;\\n        if (rows[item.Item1] == mat[0].Length || cols[item.Item2] == mat.Length)\\n        {\\n            return i;\\n        }\\n    }\\n\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468950,
                "title": "simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n      unordered_map<int,vector<int>>row;\\n      unordered_map<int,vector<int>>col;\\n      unordered_map<int,pair<int,int>>grid;\\n      \\nfor(int i=0;i<m;i++)\\n{\\nfor(int j=0;j<n;j++)\\n{\\n    grid[mat[i][j]]={i,j};\\n}\\n\\n}\\n\\nint ans=0;\\nfor(int i=0;i<m*n;i++)\\n{\\n    pair<int,int> p=grid[arr[i]];\\n    int r=p.first;\\n    int c=p.second;\\n    row[r].push_back(arr[i]);\\n    if(row[r].size()==n)\\n    {\\nans=i;\\n    break;\\n    }\\n    col[c].push_back(arr[i]);\\n    if(col[c].size()==m)\\n    {\\n        ans=i;\\n        break;\\n    }\\n\\n}\\nreturn ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n      unordered_map<int,vector<int>>row;\\n      unordered_map<int,vector<int>>col;\\n      unordered_map<int,pair<int,int>>grid;\\n      \\nfor(int i=0;i<m;i++)\\n{\\nfor(int j=0;j<n;j++)\\n{\\n    grid[mat[i][j]]={i,j};\\n}\\n\\n}\\n\\nint ans=0;\\nfor(int i=0;i<m*n;i++)\\n{\\n    pair<int,int> p=grid[arr[i]];\\n    int r=p.first;\\n    int c=p.second;\\n    row[r].push_back(arr[i]);\\n    if(row[r].size()==n)\\n    {\\nans=i;\\n    break;\\n    }\\n    col[c].push_back(arr[i]);\\n    if(col[c].size()==m)\\n    {\\n        ans=i;\\n        break;\\n    }\\n\\n}\\nreturn ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468788,
                "title": "explained-step-by-step-implementation",
                "content": "# Intuition\\n<!--  -->\\nUse maps to keep track of count for row and columns.\\n# Approach\\n<!--  -->\\n1. Consider two maps for tracking index of row and col of particular element in the matrix.\\n2. Consider two more maps to count the number of elements seen in a particular row or col.\\n3. Map the row and col for each element\\n4. Traverse arr and update row and col count\\n5. When `row count = colSize` or `col count = rowSize` return the current idx `i`.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     \\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int rowSize = mat.size();\\n    int colSize = mat[0].size();\\n    unordered_map<int, int> rowIdx, colIdx, rowCount, colCount;\\n\\n    for(int i = 0; i < mat.size(); i++){\\n        for(int j = 0; j< mat[0].size(); ++j){\\n            int matEle = mat[i][j];\\n            rowIdx[matEle] = i; // store row index in the rowIdx map  \\n            colIdx[matEle] = j; // store column index in the colIdx map\\n        }\\n    }\\n    \\n    for(int i = 0; i < arr.size(); i++){\\n        int ele = arr[i];\\n        int row = rowIdx[ele]; //get row index of element from rowIdx map\\n        int col = colIdx[ele];// get col index of element from colIdx map\\n        rowCount[row]++;  // inc the row count for the row element belongs to\\n        colCount[col]++; // inc the col count for the col element belongs to\\n\\n        if(rowCount[row] == colSize || colCount[col] == rowSize){\\n          // if rowcount or colcount reaches size of the matrix return the current index\\n           return i;\\n        } \\n    }\\n    return -1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int rowSize = mat.size();\\n    int colSize = mat[0].size();\\n    unordered_map<int, int> rowIdx, colIdx, rowCount, colCount;\\n\\n    for(int i = 0; i < mat.size(); i++){\\n        for(int j = 0; j< mat[0].size(); ++j){\\n            int matEle = mat[i][j];\\n            rowIdx[matEle] = i; // store row index in the rowIdx map  \\n            colIdx[matEle] = j; // store column index in the colIdx map\\n        }\\n    }\\n    \\n    for(int i = 0; i < arr.size(); i++){\\n        int ele = arr[i];\\n        int row = rowIdx[ele]; //get row index of element from rowIdx map\\n        int col = colIdx[ele];// get col index of element from colIdx map\\n        rowCount[row]++;  // inc the row count for the row element belongs to\\n        colCount[col]++; // inc the col count for the col element belongs to\\n\\n        if(rowCount[row] == colSize || colCount[col] == rowSize){\\n          // if rowcount or colcount reaches size of the matrix return the current index\\n           return i;\\n        } \\n    }\\n    return -1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468505,
                "title": "fully-explained-rust-python-o-mn",
                "content": "# Intuition\\nCreate a mapping from numbers to their positions `number_to_pos`. This is needed to be able to find the position of any number in $O(1)$. Then for each row and column mark how many positions were previously marked `data_y, data_x`. This will allow you to mark them and check if full row/column is marked in $O(1)$\\n\\nAfterwards just iterate over all values in array mark corresponding row/column and check if they are fully marked.\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$\\n\\n```Rust []\\n#[derive(Copy, Clone)]\\nstruct Pos {\\n  y: usize,\\n  x: usize,\\n}\\n\\nimpl Solution {\\n  pub fn first_complete_index(arr: Vec<i32>, M: Vec<Vec<i32>>) -> i32 {\\n    let (Y, X) = (M.len(), M[0].len());\\n    let mut number_to_pos = vec![Pos{y: 0, x: 0}; arr.len() + 1];\\n    for i in 0 .. Y {\\n      for j in 0 .. X {\\n        number_to_pos[M[i][j] as usize] = Pos{y: i, x: j};\\n      }\\n    }\\n\\n    let mut data_y = vec![0; Y];\\n    let mut data_x = vec![0; X];\\n    for i in 0 .. arr.len() {\\n      let p = number_to_pos[arr[i] as usize];\\n      data_y[p.y] += 1;\\n      data_x[p.x] += 1;\\n\\n      if data_y[p.y] == X || data_x[p.x] == Y {\\n        return i as i32;\\n      }\\n    }\\n    return 0;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def firstCompleteIndex(self, arr: List[int], M: List[List[int]]) -> int:\\n    Y, X = len(M), len(M[0])\\n    number_to_pos = [() for _ in range(len(arr) + 1)]\\n    for i in range(Y):\\n      for j in range(X):\\n        number_to_pos[M[i][j]] = (i, j)\\n\\n    data_y, data_x = [0] * Y, [0] * X\\n    for i, v in enumerate(arr):\\n      y, x = number_to_pos[v]\\n      data_y[y] += 1\\n      data_x[x] += 1\\n\\n      if data_y[y] == X or data_x[x] == Y:\\n        return i\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\n#[derive(Copy, Clone)]\\nstruct Pos {\\n  y: usize,\\n  x: usize,\\n}\\n\\nimpl Solution {\\n  pub fn first_complete_index(arr: Vec<i32>, M: Vec<Vec<i32>>) -> i32 {\\n    let (Y, X) = (M.len(), M[0].len());\\n    let mut number_to_pos = vec![Pos{y: 0, x: 0}; arr.len() + 1];\\n    for i in 0 .. Y {\\n      for j in 0 .. X {\\n        number_to_pos[M[i][j] as usize] = Pos{y: i, x: j};\\n      }\\n    }\\n\\n    let mut data_y = vec![0; Y];\\n    let mut data_x = vec![0; X];\\n    for i in 0 .. arr.len() {\\n      let p = number_to_pos[arr[i] as usize];\\n      data_y[p.y] += 1;\\n      data_x[p.x] += 1;\\n\\n      if data_y[p.y] == X || data_x[p.x] == Y {\\n        return i as i32;\\n      }\\n    }\\n    return 0;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def firstCompleteIndex(self, arr: List[int], M: List[List[int]]) -> int:\\n    Y, X = len(M), len(M[0])\\n    number_to_pos = [() for _ in range(len(arr) + 1)]\\n    for i in range(Y):\\n      for j in range(X):\\n        number_to_pos[M[i][j]] = (i, j)\\n\\n    data_y, data_x = [0] * Y, [0] * X\\n    for i, v in enumerate(arr):\\n      y, x = number_to_pos[v]\\n      data_y[y] += 1\\n      data_x[x] += 1\\n\\n      if data_y[y] == X or data_x[x] == Y:\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468373,
                "title": "c-hashmap-storing-indexes-for-fastprocessing",
                "content": "# Code\\n```\\n# define ll long long\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& ma) {\\n        int n=ma.size(),m=ma[0].size();\\n        \\n        vector<ll>ri(n,0);\\n        vector<ll>ci(m,0);\\n        unordered_map<ll,pair<int,int>>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ci[j]+=ma[i][j];\\n                ri[i]+=ma[i][j];\\n                mp[ma[i][j]]={i,j};\\n            }\\n        }\\n        \\n          for(int i=0;i<arr.size();i++){\\n           int ni=mp[arr[i]].first,nj=mp[arr[i]].second;\\n              \\n              ri[ni]-=arr[i];\\n              if(ri[ni]==0)\\n                  return i;\\n              \\n               ci[nj]-=arr[i];\\n              if(ci[nj]==0)\\n                  return i;\\n        }\\n        \\n    \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n# define ll long long\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& ma) {\\n        int n=ma.size(),m=ma[0].size();\\n        \\n        vector<ll>ri(n,0);\\n        vector<ll>ci(m,0);\\n        unordered_map<ll,pair<int,int>>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ci[j]+=ma[i][j];\\n                ri[i]+=ma[i][j];\\n                mp[ma[i][j]]={i,j};\\n            }\\n        }\\n        \\n          for(int i=0;i<arr.size();i++){\\n           int ni=mp[arr[i]].first,nj=mp[arr[i]].second;\\n              \\n              ri[ni]-=arr[i];\\n              if(ri[ni]==0)\\n                  return i;\\n              \\n               ci[nj]-=arr[i];\\n              if(ci[nj]==0)\\n                  return i;\\n        }\\n        \\n    \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468322,
                "title": "c-solutions-easy-to-understand-full-explanaiton-line-by-line",
                "content": "# Intuition\\nThis code aims to find the index of the first element in a given sequence that completes a rectangular matrix.\\n\\nTo do this, it first constructs a vector of pairs loc that contains the location of each element in the rectangular matrix. It then iterates over the input sequence arr, incrementing the corresponding row and column counts in r and c for each element. If the count of any row or column becomes equal to the number of columns or rows in the matrix, then that row or column is complete, and the index of the current element is returned. If no such element is found, then -1 is returned.\\n \\n# Approach\\nThis problem can be solved by creating a mapping between the values in the matrix and their corresponding indices in the loc vector. This mapping can be created using a nested loop that iterates through all the elements of the matrix and stores their indices in the loc vector.\\n\\nOnce we have the loc vector, we can iterate through the arr vector and for each element, we can retrieve its index in the loc vector. We can then update the r and c arrays, which store the count of the elements in each row and column, respectively. If the count of an element in a row or column equals the size of the row or column, then we know that all the elements in that row or column have been seen, and we can return the index of the last element that was seen.\\n\\nIf we iterate through the entire arr vector and no row or column has been completely seen, we can return -1 to indicate that there is no complete row or column.\\n\\n# Complexity\\n# Time complexity:\\nThe time complexity of the firstCompleteIndex function is O(nm), where n is the number of rows in the matrix and m is the number of columns in the matrix. This is because the function first initializes a vector of pairs containing the location of each number in the matrix, which takes O(nm) time. Then, the function iterates through the given array and checks the corresponding row and column in the matrix for each number, which also takes O(nm) time in the worst case.\\n\\n# Space complexity:\\nThe space complexity of the function is O(nm) as well, because it stores the location of each number in the matrix in a vector of pairs, which requires O(nm) space. It also stores two additional vectors of size n and m to keep track of the count of numbers in each row and column, respectively.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size(); \\n        \\n        // Store the location of each number in the matrix\\n        vector<pair<int, int>> loc(m*n); \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                loc[mat[i][j]-1] = make_pair(i, j); \\n            }\\n        }\\n        \\n        // Count the number of occurrences of each row and column\\n        vector<int> r(m), c(n); \\n        for (int x = 0; x < arr.size(); ++x) {\\n            auto [i, j] = loc[arr[x]-1]; // Get the location of the current number\\n            if (++r[i] == n) return x; // If the row is complete, return the index\\n            if (++c[j] == m) return x; // If the column is complete, return the index\\n        }\\n        \\n        return -1; // If no row or column is complete, return -1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size(); \\n        \\n        // Store the location of each number in the matrix\\n        vector<pair<int, int>> loc(m*n); \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                loc[mat[i][j]-1] = make_pair(i, j); \\n            }\\n        }\\n        \\n        // Count the number of occurrences of each row and column\\n        vector<int> r(m), c(n); \\n        for (int x = 0; x < arr.size(); ++x) {\\n            auto [i, j] = loc[arr[x]-1]; // Get the location of the current number\\n            if (++r[i] == n) return x; // If the row is complete, return the index\\n            if (++c[j] == m) return x; // If the column is complete, return the index\\n        }\\n        \\n        return -1; // If no row or column is complete, return -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468267,
                "title": "easy-code-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\nPLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),size=m*n;\\n        vector<int> r(m,n),c(n,m);\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                mp[mat[i][j]].push_back(i);\\n                mp[mat[i][j]].push_back(j);\\n            }\\n        }\\n        for(int i=0;i<size;i++){\\n            int x = mp[arr[i]][0],y = mp[arr[i]][1];\\n            r[x] --;\\n            if(r[x] == 0)\\n                return i;\\n            c[y] --;\\n            if(c[y] == 0)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),size=m*n;\\n        vector<int> r(m,n),c(n,m);\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                mp[mat[i][j]].push_back(i);\\n                mp[mat[i][j]].push_back(j);\\n            }\\n        }\\n        for(int i=0;i<size;i++){\\n            int x = mp[arr[i]][0],y = mp[arr[i]][1];\\n            r[x] --;\\n            if(r[x] == 0)\\n                return i;\\n            c[y] --;\\n            if(c[y] == 0)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065916,
                "title": "simple-solution-o-n-m-hashmap",
                "content": "# Intuition\\nFor an \"optimized\" solution HashMaps are the only data structure that can return mat[i][j] in costant time. In order to find when a row or colun is full two count arrays need to be kept.\\n\\n# Approach\\nFirst the algorithm builds the Hashmap in O(n*m) time, using O(n+m) space. The we iterate through the array, getting the dimension of each element on the matrix. These dimensions are used as indexes in the arrays that hold the counts. If a column count has n painted cells or if a row count has m painted cells, the minimum required stephas been reached.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n+m)$$\\n\\n# Code\\n```\\nfunction firstCompleteIndex(arr: number[], mat: number[][]): number {\\n  // HashMaps are the only data structure that can give us mat[x][y] in constant time\\n  const patterns = new Map<number, [number, number]>()\\n\\n  const m = mat.length\\n  const n = mat[0].length\\n\\n  // Step 1; Create the HashMap. tc: O(n*m), sc: O(n+m)\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n        patterns.set(mat[i][j], [i, j])\\n    }\\n  }\\n\\n\\n  // Step 2; Keep counts of the painted row and columns\\n  const paintedInRow: number[] = Array(m).fill(0)\\n  const paintedInCol: number[] = Array(n).fill(0)\\n\\n  for (let i = 0; i < arr.length; i ++) { // tc: O(n+m), sc: O(1)\\n    // get row and col indexes\\n    const [x, y] = patterns.get(arr[i]) as [number, number]\\n    // increment\\n    paintedInRow[x]++;\\n    paintedInCol[y]++;\\n    // the loop stops if max(rows) = cols.length or max(cols) = rows.length\\n    // i.e. the counts and maxes are reversed.\\n    if(paintedInRow[x] === n || paintedInCol[y] === m) return i\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction firstCompleteIndex(arr: number[], mat: number[][]): number {\\n  // HashMaps are the only data structure that can give us mat[x][y] in constant time\\n  const patterns = new Map<number, [number, number]>()\\n\\n  const m = mat.length\\n  const n = mat[0].length\\n\\n  // Step 1; Create the HashMap. tc: O(n*m), sc: O(n+m)\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n        patterns.set(mat[i][j], [i, j])\\n    }\\n  }\\n\\n\\n  // Step 2; Keep counts of the painted row and columns\\n  const paintedInRow: number[] = Array(m).fill(0)\\n  const paintedInCol: number[] = Array(n).fill(0)\\n\\n  for (let i = 0; i < arr.length; i ++) { // tc: O(n+m), sc: O(1)\\n    // get row and col indexes\\n    const [x, y] = patterns.get(arr[i]) as [number, number]\\n    // increment\\n    paintedInRow[x]++;\\n    paintedInCol[y]++;\\n    // the loop stops if max(rows) = cols.length or max(cols) = rows.length\\n    // i.e. the counts and maxes are reversed.\\n    if(paintedInRow[x] === n || paintedInCol[y] === m) return i\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062783,
                "title": "beats-95-runtime-beats-80-memory-c-runtime-memory",
                "content": "# Intuition\\nSince all values in `arr` are unique, just keep count of how many remain in each row/column and return once any are empty\\n\\n# Approach\\nWe need to work backwards, since we want to be able to compute the validation (the actual computation) of first complete index quickly, spend time storing information that will speed that up.\\n## Passes\\n1) Pass through the whole matrix keeping track of where each value is. $O(MN)$\\n> since `mat` and `arr` are essentially permutations of $1-M*N$ where $M$ is the amount of rows and $N$ is the amount of columns, just keep the coordinates in 2 vectors of length $M*N+1$\\n\\n2) Pass through `arr`, decrementing row and col at `arr[i]`\\'s coordinates then check if either are 0, then return or continue. $O(MN)$\\n### Primitive Variables:\\n- m: Rows of mat, save on function overhead per access\\n- n: Columns of mat, save of function overhead per access\\n### Vectors:\\n- coordsx: X coordinate of any given number\\n- coordsy: Y coordinate of any given number\\n- row: keeps track of how many cells are left in each row\\n- col: keeps track of how many cells are left in each column\\n\\n# Complexity\\n- Time complexity:\\n$O(MN)$ - Always needs to traverse mat w/ 2 operations per iteration step, does up to 2 checks and operations per iteration step of the validation\\n\\n- Space complexity:\\n$O(MN)$ - needs 2 $M*N$ vectors/arrays for coordinates, needs 1 $M$ and 1 $N$ vector/array for validation\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<int> coordsx(m*n+1),coordsy(m*n+1),row(m,n),col(n,m);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){//store coordinates for later\\n                coordsx[mat[i][j]]=i;\\n                coordsy[mat[i][j]]=j;\\n            }\\n        }\\n        for(int i=0;i<m*n;i++){\\n            if(!--row[coordsx[arr[i]]]||!--col[coordsy[arr[i]]]){//decrement and check\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<int> coordsx(m*n+1),coordsy(m*n+1),row(m,n),col(n,m);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){//store coordinates for later\\n                coordsx[mat[i][j]]=i;\\n                coordsy[mat[i][j]]=j;\\n            }\\n        }\\n        for(int i=0;i<m*n;i++){\\n            if(!--row[coordsx[arr[i]]]||!--col[coordsy[arr[i]]]){//decrement and check\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051136,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[] arrLocations = new int[arr.length+1];\\n        for(int i=0; i<arr.length; i++)\\n            arrLocations[arr[i]] = i;\\n\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                mat[i][j] = arrLocations[mat[i][j]];\\n            }\\n        }\\n\\n        int sol = arr.length+1;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] > max)\\n                    max = mat[i][j];\\n            }\\n            sol = Math.min(sol, max);\\n        }\\n\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                if(mat[j][i] > max)\\n                    max = mat[j][i];\\n            }\\n            sol = Math.min(sol, max);\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[] arrLocations = new int[arr.length+1];\\n        for(int i=0; i<arr.length; i++)\\n            arrLocations[arr[i]] = i;\\n\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                mat[i][j] = arrLocations[mat[i][j]];\\n            }\\n        }\\n\\n        int sol = arr.length+1;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] > max)\\n                    max = mat[i][j];\\n            }\\n            sol = Math.min(sol, max);\\n        }\\n\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                if(mat[j][i] > max)\\n                    max = mat[j][i];\\n            }\\n            sol = Math.min(sol, max);\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993269,
                "title": "c-hashmap-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,pair<int, int>> umap_wall;\\n        vector<int> row_cell(m+n,0);\\n\\n        for (int i = 0; i<m; i++){\\n            for (int j = 0; j<n; j++){\\n                umap_wall[mat[i][j]] = {i,j};\\n            }\\n        }\\n\\n        for (int i = 0; i<arr.size(); i++){\\n            pair<int, int>& index = umap_wall[arr[i]];\\n            row_cell[index.first]++;\\n            row_cell[m+index.second]++;\\n\\n            if (row_cell[index.first]==n) return i;\\n            if (row_cell[m+index.second]==m) return i;\\n        }\\n        return arr.size()-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,pair<int, int>> umap_wall;\\n        vector<int> row_cell(m+n,0);\\n\\n        for (int i = 0; i<m; i++){\\n            for (int j = 0; j<n; j++){\\n                umap_wall[mat[i][j]] = {i,j};\\n            }\\n        }\\n\\n        for (int i = 0; i<arr.size(); i++){\\n            pair<int, int>& index = umap_wall[arr[i]];\\n            row_cell[index.first]++;\\n            row_cell[m+index.second]++;\\n\\n            if (row_cell[index.first]==n) return i;\\n            if (row_cell[m+index.second]==m) return i;\\n        }\\n        return arr.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991736,
                "title": "beginner-friendly-solution-unordered-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 0(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<long long int> row;\\n        vector<long long int> col;\\n        for(int i = 0;i<n;i++){\\n            long long int sum = 0;\\n            for(int j = 0;j<m;j++){\\n                sum+=mat[i][j];\\n            }\\n            row.push_back(sum);\\n        }\\n        for(int i = 0;i<m;i++){\\n            long long int sum = 0;\\n            for(int j = 0;j<n;j++){\\n                sum+=mat[j][i];\\n            }\\n            col.push_back(sum);\\n        }\\n        unordered_map<int,pair<int,int>> map;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                map[mat[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            pair<int,int> temp = map[arr[i]];\\n            int r = temp.first;\\n            int c = temp.second;\\n            row[r] = row[r]-arr[i];\\n            col[c] = col[c]-arr[i];\\n            if(row[r] == 0 || col[c] == 0) return i;\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<long long int> row;\\n        vector<long long int> col;\\n        for(int i = 0;i<n;i++){\\n            long long int sum = 0;\\n            for(int j = 0;j<m;j++){\\n                sum+=mat[i][j];\\n            }\\n            row.push_back(sum);\\n        }\\n        for(int i = 0;i<m;i++){\\n            long long int sum = 0;\\n            for(int j = 0;j<n;j++){\\n                sum+=mat[j][i];\\n            }\\n            col.push_back(sum);\\n        }\\n        unordered_map<int,pair<int,int>> map;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                map[mat[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            pair<int,int> temp = map[arr[i]];\\n            int r = temp.first;\\n            int c = temp.second;\\n            row[r] = row[r]-arr[i];\\n            col[c] = col[c]-arr[i];\\n            if(row[r] == 0 || col[c] == 0) return i;\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979575,
                "title": "step-by-step-solution-with-hash-tables-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        rowDic = {i:n for i in range(m) }\\n        colDic = {i:m for i in range(n) }\\n        vals = {}\\n        for i in range(m):\\n            for j in range(n):\\n                vals[mat[i][j]] = [i , j]\\n\\n\\n        for i in range(len(arr)):\\n            r = vals[arr[i]][0]\\n            c = vals[arr[i]][1]\\n\\n            rowDic[r] -= 1\\n            colDic[c] -= 1\\n            if rowDic[r] == 0 or colDic[c] == 0:\\n                return i\\n\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        rowDic = {i:n for i in range(m) }\\n        colDic = {i:m for i in range(n) }\\n        vals = {}\\n        for i in range(m):\\n            for j in range(n):\\n                vals[mat[i][j]] = [i , j]\\n\\n\\n        for i in range(len(arr)):\\n            r = vals[arr[i]][0]\\n            c = vals[arr[i]][1]\\n\\n            rowDic[r] -= 1\\n            colDic[c] -= 1\\n            if rowDic[r] == 0 or colDic[c] == 0:\\n                return i\\n\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970452,
                "title": "full-explanation-simple-easy-java-solution",
                "content": "# Intution\\nTraverse the modified map. Get maximum value from each row and column,\\nbut return the minimum among them as ans.  \\n# Approach\\nImplement a Hashmap and store all values of 1D array as key along with it\\'s index as value. \\n\\nNow, traverse the matrix and check for correspong matrix value as key in the Hashmap. Store the value corresponding to that key in matrix.\\n\\nCheck for the maximum value from each row and store the minimum among that values in a ans variable. Likewise traverse each column of matrix and get maximum from each column ans store the minimum among those maximum in a ans variable. Return ans. \\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                mat[i][j]=map.get(mat[i][j]);\\n            }\\n        }\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<mat.length;i++){\\n            int max=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                max=Math.max(max,mat[i][j]);\\n            }\\n            ans=Math.min(ans,max);\\n        } \\n        \\n        for(int i=0;i<mat[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<mat.length;j++){\\n                max=Math.max(max,mat[j][i]);\\n            }\\n            ans=Math.min(ans,max);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                mat[i][j]=map.get(mat[i][j]);\\n            }\\n        }\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<mat.length;i++){\\n            int max=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                max=Math.max(max,mat[i][j]);\\n            }\\n            ans=Math.min(ans,max);\\n        } \\n        \\n        for(int i=0;i<mat[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<mat.length;j++){\\n                max=Math.max(max,mat[j][i]);\\n            }\\n            ans=Math.min(ans,max);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935280,
                "title": "2661-first-completely-painted-row-or-column-python-solution",
                "content": "# Approach\\n- Create a dictionary `index` to get row and column for each unique element in **O(1)** time while iterating through `arr`.\\n- Create two list `row` and `column` to track number of element that needs to be painted.\\n- So, length of `row` will be equal to `m` with each value equal to `n` and length of `column` will be equal to `n` with each value equal to `m`.\\n- Now, while iterating through `arr`, get row `r` and column `c` for each `arr[i]` by `index[arr[i]]`.\\n-  Decrement the count of `row[r]` and `column[c]` as they are painted now.\\n- Check if the `row[r]` or `column[c]` is equal to `0`. If yes, return `i` else, continue the loop.\\n\\n# Complexity\\n- Time complexity: **O(m * n)**\\n\\n- Space complexity: **O(m * n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        index = dict()\\n        m, n = len(mat), len(mat[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                index[mat[i][j]] = (i, j)\\n\\n        row, column = [n for _ in range(m)], [m for _ in range(n)]\\n\\n        for i in range(len(arr)):\\n            r, c = index[arr[i]]\\n            row[r], column[c] = row[r] - 1, column[c] - 1\\n            if row[r] == 0 or column[c] == 0:\\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        index = dict()\\n        m, n = len(mat), len(mat[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                index[mat[i][j]] = (i, j)\\n\\n        row, column = [n for _ in range(m)], [m for _ in range(n)]\\n\\n        for i in range(len(arr)):\\n            r, c = index[arr[i]]\\n            row[r], column[c] = row[r] - 1, column[c] - 1\\n            if row[r] == 0 or column[c] == 0:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924554,
                "title": "typescript-matrix-hash-table-array",
                "content": "# Complexity\\n- Time complexity:\\n   $$O(m*n)$$ \\n\\n- Space complexity:\\n    $$O(m*n + m + n)$$\\n\\n# Code\\n```\\nfunction firstCompleteIndex(arr: number[], grid: number[][]): number {\\n    const ROW = grid.length;\\n    const COL = grid[0].length;\\n    \\n    const positionToPaintMap:Map<number, [number,number]> = new Map();\\n\\n\\n    let rowCounts: number[] = new Array(grid.length).fill(0)\\n    let colCounts: number[] = new Array(grid[0].length).fill(0)\\n\\n    for(let x = 0; x < ROW;x++){\\n        for(let y = 0; y < COL; y++){\\n            positionToPaintMap.set(grid[x][y],[x,y])\\n        }\\n    }\\n\\n\\n    for(let i = 0; i < arr.length; i++){\\n        const position = positionToPaintMap.get(arr[i])\\n        if(++rowCounts[position[0]] == COL){\\n            return i\\n        }\\n        if(++colCounts[position[1]] == ROW){\\n            return i\\n        }\\n    }\\n\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nfunction firstCompleteIndex(arr: number[], grid: number[][]): number {\\n    const ROW = grid.length;\\n    const COL = grid[0].length;\\n    \\n    const positionToPaintMap:Map<number, [number,number]> = new Map();\\n\\n\\n    let rowCounts: number[] = new Array(grid.length).fill(0)\\n    let colCounts: number[] = new Array(grid[0].length).fill(0)\\n\\n    for(let x = 0; x < ROW;x++){\\n        for(let y = 0; y < COL; y++){\\n            positionToPaintMap.set(grid[x][y],[x,y])\\n        }\\n    }\\n\\n\\n    for(let i = 0; i < arr.length; i++){\\n        const position = positionToPaintMap.get(arr[i])\\n        if(++rowCounts[position[0]] == COL){\\n            return i\\n        }\\n        if(++colCounts[position[1]] == ROW){\\n            return i\\n        }\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912209,
                "title": "c-solution-using-unordered-map-frequency-array-and-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n\\t\\t//declaring map that stores the element in arr array as key and position m,n in the matrix mat as pair value\\n        unordered_map<int,pair<int,int>> mp;\\n\\t\\t\\n\\t\\t//frequency arrays for rows and columns initialized with 0\\n        vector<int> row(m,0);\\n        vector<int> col(n,0);\\n        \\n\\t\\t//mapping values\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n              mp.insert({mat[i][j],{i,j}});\\n            }\\n        }\\n        \\n\\t\\t//adding values in frequency arrays \\n        for(int i=0;i<arr.size();i++)\\n        {\\n           row[mp.find(arr[i])->second.first]++;\\n           col[mp.find(arr[i])->second.second]++;\\n        }\\n        \\n\\t\\t//finding and subtracting based on rows and columns of current element in arr\\n\\t\\t//as soon as any number of row or column becomes 0 i.e it is fully painted we return index i as the answer\\n        for(int i=0;i<arr.size();i++)\\n        {\\n           int r = mp.find(arr[i])->second.first;\\n           int c = mp.find(arr[i])->second.second;\\n           row[r]--;\\n           col[c]--;\\n           if(row[r] == 0 || col[c] == 0) return i;\\n        }\\n        //return -1 just for the sake of returning value\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n\\t\\t//declaring map that stores the element in arr array as key and position m,n in the matrix mat as pair value\\n        unordered_map<int,pair<int,int>> mp;\\n\\t\\t\\n\\t\\t//frequency arrays for rows and columns initialized with 0\\n        vector<int> row(m,0);\\n        vector<int> col(n,0);\\n        \\n\\t\\t//mapping values\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n              mp.insert({mat[i][j],{i,j}});\\n            }\\n        }\\n        \\n\\t\\t//adding values in frequency arrays \\n        for(int i=0;i<arr.size();i++)\\n        {\\n           row[mp.find(arr[i])->second.first]++;\\n           col[mp.find(arr[i])->second.second]++;\\n        }\\n        \\n\\t\\t//finding and subtracting based on rows and columns of current element in arr\\n\\t\\t//as soon as any number of row or column becomes 0 i.e it is fully painted we return index i as the answer\\n        for(int i=0;i<arr.size();i++)\\n        {\\n           int r = mp.find(arr[i])->second.first;\\n           int c = mp.find(arr[i])->second.second;\\n           row[r]--;\\n           col[c]--;\\n           if(row[r] == 0 || col[c] == 0) return i;\\n        }\\n        //return -1 just for the sake of returning value\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894689,
                "title": "unordered-map-pair",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> m;\\n        int h=mat.size(),n=mat[0].size();\\n        vector<int> r(h+1,0);\\n        vector<int> c(n+1,0);\\n        for(int i=0;i<h;i++){\\n            for(int j=0;j<n;j++){\\n                m[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            int row=m[arr[i]].first;\\n            int col=m[arr[i]].second;\\n            r[row]++;\\n            if(r[row]==n)return i;\\n            c[col]++;\\n            if(c[col]==h)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> m;\\n        int h=mat.size(),n=mat[0].size();\\n        vector<int> r(h+1,0);\\n        vector<int> c(n+1,0);\\n        for(int i=0;i<h;i++){\\n            for(int j=0;j<n;j++){\\n                m[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            int row=m[arr[i]].first;\\n            int col=m[arr[i]].second;\\n            r[row]++;\\n            if(r[row]==n)return i;\\n            c[col]++;\\n            if(c[col]==h)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873729,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an array and and a matrix the ans would be the index when all index one of the row or column of the matrix is covered. So in a hashmap we will take all the values of the array and it\\'s index and we will travarse the matrix at first by row and take the max index of every being covered and will take minimum of all the max index same will do for column and between them the index where the minimum index I will get where all row are column are covered will be the answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        int m = mat.length;\\n        int k = mat[0].length;\\n        for(int i =0;i<n;i++){\\n            map.put(arr[i], i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i =0;i<m;i++){\\n            int max = 0;\\n            for(int j =0;j<k;j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min, max);\\n        }\\n\\n        for(int i =0;i<k;i++){\\n            int max = 0;\\n            for(int j =0;j<m;j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min, max);\\n        }\\n\\n        return min;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        int m = mat.length;\\n        int k = mat[0].length;\\n        for(int i =0;i<n;i++){\\n            map.put(arr[i], i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i =0;i<m;i++){\\n            int max = 0;\\n            for(int j =0;j<k;j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min, max);\\n        }\\n\\n        for(int i =0;i<k;i++){\\n            int max = 0;\\n            for(int j =0;j<m;j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min, max);\\n        }\\n\\n        return min;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865675,
                "title": "python-easy-to-read-and-understand-map",
                "content": "**Brute-force**\\n```\\nclass Solution:\\n    def find(self, matrix, val):\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == val:\\n                    return [i, j]\\n    \\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        row, col = collections.defaultdict(list), collections.defaultdict(list)\\n        m, n = len(mat), len(mat[0])\\n        \\n        for i in range(len(arr)):\\n            x, y = self.find(mat, arr[i])\\n            row[x].append(i)\\n            col[y].append(i)\\n            if len(row[x]) == n or len(col[y]) == m:\\n                return i\\n```\\n**Map**\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        row, col = collections.defaultdict(list), collections.defaultdict(list)\\n        d = collections.defaultdict(list)\\n        m, n = len(mat), len(mat[0])\\n        for i in range(m):\\n            for j in range(n):\\n                d[mat[i][j]] = [i, j]\\n        \\n        for i in range(len(arr)):\\n            x, y = d[arr[i]]\\n            row[x].append(i)\\n            col[y].append(i)\\n            if len(row[x]) == n or len(col[y]) == m:\\n                return i",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find(self, matrix, val):\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == val:\\n                    return [i, j]\\n    \\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        row, col = collections.defaultdict(list), collections.defaultdict(list)\\n        m, n = len(mat), len(mat[0])\\n        \\n        for i in range(len(arr)):\\n            x, y = self.find(mat, arr[i])\\n            row[x].append(i)\\n            col[y].append(i)\\n            if len(row[x]) == n or len(col[y]) == m:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859575,
                "title": "go-reverse-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor filling matrix type of problem, always try to think of going in reverse direction. Here, since it is asking for filling all rows and cols, this means that if we go from reverse direction, we would be deleting the rows and cols that are fully filled. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashSet<Integer> setRow = new HashSet<>();\\n        HashSet<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i<mat.length; i++)setRow.add(i);\\n        for(int i = 0; i<mat[0].length; i++)setCol.add(i);\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                map.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int res = -1;\\n        for(int i = arr.length-1; i>=0; i--){\\n            if((setRow.size()==1 && setCol.size()==0)||(setRow.size()==0 && setCol.size()==1))res = i;\\n            if(setRow.size()==1 && setCol.size()==1){\\n                res = i;\\n            }\\n            int[] coord = map.get(arr[i]);\\n            if(setRow.contains(coord[0]))setRow.remove(coord[0]);\\n            if(setCol.contains(coord[1]))setCol.remove(coord[1]);\\n            //check to see if setRow==1 || setCol==1\\n            //if(setRow==0 && setCol==0)return res;\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashSet<Integer> setRow = new HashSet<>();\\n        HashSet<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i<mat.length; i++)setRow.add(i);\\n        for(int i = 0; i<mat[0].length; i++)setCol.add(i);\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                map.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int res = -1;\\n        for(int i = arr.length-1; i>=0; i--){\\n            if((setRow.size()==1 && setCol.size()==0)||(setRow.size()==0 && setCol.size()==1))res = i;\\n            if(setRow.size()==1 && setCol.size()==1){\\n                res = i;\\n            }\\n            int[] coord = map.get(arr[i]);\\n            if(setRow.contains(coord[0]))setRow.remove(coord[0]);\\n            if(setCol.contains(coord[1]))setCol.remove(coord[1]);\\n            //check to see if setRow==1 || setCol==1\\n            //if(setRow==0 && setCol==0)return res;\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858915,
                "title": "c-easy-solution-unordered-map",
                "content": "# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, int> mpRow, mpCol;\\n        unordered_map<int, pair<int, int>> grid;\\n\\n        for(int i=0 ;i<mat.size() ;i++){\\n            for(int j=0 ;j<mat[0].size() ;j++)\\n            grid[mat[i][j]] = {i, j};\\n        }\\n\\n        for(int i=0 ;i<arr.size() ;i++){\\n            pair<int, int> index = grid[arr[i]];\\n\\n            mpRow[index.first]++;\\n            mpCol[index.second]++;\\n\\n            if(mpRow[index.first] == mat[0].size() || mpCol[index.second]==mat.size())\\n            return i;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, int> mpRow, mpCol;\\n        unordered_map<int, pair<int, int>> grid;\\n\\n        for(int i=0 ;i<mat.size() ;i++){\\n            for(int j=0 ;j<mat[0].size() ;j++)\\n            grid[mat[i][j]] = {i, j};\\n        }\\n\\n        for(int i=0 ;i<arr.size() ;i++){\\n            pair<int, int> index = grid[arr[i]];\\n\\n            mpRow[index.first]++;\\n            mpCol[index.second]++;\\n\\n            if(mpRow[index.first] == mat[0].size() || mpCol[index.second]==mat.size())\\n            return i;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856716,
                "title": "c-too-easy-clean-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& a, vector<vector<int>>& g) {\\n        map<int,int> r,c;\\n        int m=g.size(),n=g[0].size();\\n        map<int,pair<int,int>> p;\\n\\n        for(int i=0;i<m;i++)\\n         for(int j=0;j<n;j++)\\n          p[g[i][j]]={i,j};\\n\\n        for(int i=0;i<a.size();i++)\\n        {\\n            pair<int,int> q=p[a[i]];\\n            r[q.first]++;\\n            c[q.second]++;\\n            if(r[q.first]==n || c[q.second]==m) return i;\\n        }  \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& a, vector<vector<int>>& g) {\\n        map<int,int> r,c;\\n        int m=g.size(),n=g[0].size();\\n        map<int,pair<int,int>> p;\\n\\n        for(int i=0;i<m;i++)\\n         for(int j=0;j<n;j++)\\n          p[g[i][j]]={i,j};\\n\\n        for(int i=0;i<a.size();i++)\\n        {\\n            pair<int,int> q=p[a[i]];\\n            r[q.first]++;\\n            c[q.second]++;\\n            if(r[q.first]==n || c[q.second]==m) return i;\\n        }  \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842207,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n      Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n      Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824946,
                "title": "c-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n***$$O(m*n)$$*** \\n\\n- Space complexity:\\n***$$O(m*n)$$*** \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n      int m = mat.size(), n = mat[0].size();\\n        vector<pair<int,int>>mp((m*n) +1);\\n        for (int i = 0; i < m; i++)\\n        {\\n          for (int j = 0; j < n; j++)\\n          {\\n            mp[mat[i][j]] = {i,j};\\n          }\\n        }\\n        vector<int>is(m,0),js(n,0);\\n        for (int i = 0; i < m*n; i++)\\n        {\\n          int z = arr[i];\\n          int x = mp[z].first, y = mp[z].second;\\n          is[x]++;\\n          js[y]++;\\n          if(is[x]==n || js[y]==m){\\n            return i;\\n          }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n      int m = mat.size(), n = mat[0].size();\\n        vector<pair<int,int>>mp((m*n) +1);\\n        for (int i = 0; i < m; i++)\\n        {\\n          for (int j = 0; j < n; j++)\\n          {\\n            mp[mat[i][j]] = {i,j};\\n          }\\n        }\\n        vector<int>is(m,0),js(n,0);\\n        for (int i = 0; i < m*n; i++)\\n        {\\n          int z = arr[i];\\n          int x = mp[z].first, y = mp[z].second;\\n          is[x]++;\\n          js[y]++;\\n          if(is[x]==n || js[y]==m){\\n            return i;\\n          }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817472,
                "title": "c-intuitive",
                "content": "# Intuition\\n\\nCount each row and col to see whether it is completely covered.\\n\\n# Approach\\n\\nCreate a map from value to coordinate.\\nIterate arr array, for each value, get its coord, then check that point is covered by either row or column.\\n\\nIf I use visited mat, it would get TLE.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        // value -> coord map\\n        vector<pair<int, int>> mp(m*n+1, {-1,-1});\\n        \\n        // counters for each row and column.\\n        vector<int> row(m, 0);\\n        vector<int> col(n, 0);\\n\\n        // value -> cord\\n        for(int r = 0; r < m; r++) {\\n            for(int c=0; c< n; c++) {\\n                mp[mat[r][c]] = {r, c};\\n            }\\n        }\\n\\n        for(int i=0; i<arr.size(); i++) {\\n            auto& p = mp[arr[i]];\\n            row[p.first]++;\\n            col[p.second]++;\\n            if (row[p.first]==n || col[p.second]==m) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        // value -> coord map\\n        vector<pair<int, int>> mp(m*n+1, {-1,-1});\\n        \\n        // counters for each row and column.\\n        vector<int> row(m, 0);\\n        vector<int> col(n, 0);\\n\\n        // value -> cord\\n        for(int r = 0; r < m; r++) {\\n            for(int c=0; c< n; c++) {\\n                mp[mat[r][c]] = {r, c};\\n            }\\n        }\\n\\n        for(int i=0; i<arr.size(); i++) {\\n            auto& p = mp[arr[i]];\\n            row[p.first]++;\\n            col[p.second]++;\\n            if (row[p.first]==n || col[p.second]==m) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779514,
                "title": "simple-solution-using-map-clean-code-c-accepted",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- \\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int, pair<int, int>> mp;\\n        int n=mat.size(), m=mat[0].size();\\n        vector<int> row(n);\\n        vector<int> col(m);\\n        for (int i=0; i<n; i++)\\n        {\\n            for (int j=0; j<m; j++)\\n            {\\n                mp[mat[i][j]]={i, j};\\n            }\\n        }\\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            int r=mp[arr[i]].first;\\n            int c=mp[arr[i]].second;\\n            row[r]++;\\n            col[c]++;\\n            if (row[r]>=m || col[c]>=n)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int, pair<int, int>> mp;\\n        int n=mat.size(), m=mat[0].size();\\n        vector<int> row(n);\\n        vector<int> col(m);\\n        for (int i=0; i<n; i++)\\n        {\\n            for (int j=0; j<m; j++)\\n            {\\n                mp[mat[i][j]]={i, j};\\n            }\\n        }\\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            int r=mp[arr[i]].first;\\n            int c=mp[arr[i]].second;\\n            row[r]++;\\n            col[c]++;\\n            if (row[r]>=m || col[c]>=n)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771783,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, pair<int, int>> mp;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j)\\n                mp[mat[i][j]] = {i,j};\\n        }\\n\\n        vector<int> rows(n, 0), cols(m, 0);\\n        int count = 0;\\n        for(int i=0; i<arr.size(); ++i){\\n            rows[mp[arr[i]].first]++;\\n            cols[mp[arr[i]].second]++;\\n            if(rows[mp[arr[i]].first]==m)\\n                return count;\\n            \\n            if(cols[mp[arr[i]].second]==n)\\n                return count;\\n\\n            ++count;\\n        }\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, pair<int, int>> mp;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j)\\n                mp[mat[i][j]] = {i,j};\\n        }\\n\\n        vector<int> rows(n, 0), cols(m, 0);\\n        int count = 0;\\n        for(int i=0; i<arr.size(); ++i){\\n            rows[mp[arr[i]].first]++;\\n            cols[mp[arr[i]].second]++;\\n            if(rows[mp[arr[i]].first]==m)\\n                return count;\\n            \\n            if(cols[mp[arr[i]].second]==n)\\n                return count;\\n\\n            ++count;\\n        }\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766159,
                "title": "simple-greedy-python-solution-using-hashmap",
                "content": "\\n\\n# Complexity\\n- Time complexity:m*n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        mapi=defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mapi[mat[i][j]]=[i,j]\\n        \\n        mapiRow=[0]*(len(mat)*len(mat[0]))\\n        mapiColumn=[0]*(len(mat)*len(mat[0]))\\n        for i in range(len(arr)):\\n            s=arr[i]\\n            if s in mapi.keys():\\n                r=mapi[s][0]\\n                c=mapi[s][1]\\n                mapiRow[r]=mapiRow[r]+1\\n                mapiColumn[c]=mapiColumn[c]+1\\n            \\n                if mapiRow[r]==len(mat[0]) or mapiColumn[c]==len(mat):\\n                    return i\\n            \\n                \\n                    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        mapi=defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mapi[mat[i][j]]=[i,j]\\n        \\n        mapiRow=[0]*(len(mat)*len(mat[0]))\\n        mapiColumn=[0]*(len(mat)*len(mat[0]))\\n        for i in range(len(arr)):\\n            s=arr[i]\\n            if s in mapi.keys():\\n                r=mapi[s][0]\\n                c=mapi[s][1]\\n                mapiRow[r]=mapiRow[r]+1\\n                mapiColumn[c]=mapiColumn[c]+1\\n            \\n                if mapiRow[r]==len(mat[0]) or mapiColumn[c]==len(mat):\\n                    return i\\n            \\n                \\n                    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745799,
                "title": "java-solution-using-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> hmap = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            hmap.put(arr[i],i);\\n        }\\n        int result = Integer.MAX_VALUE;\\n\\n        //smallest index across every row\\n        for(int i = 0; i < mat.length; i++){\\n            int maxVal = 0;\\n            for(int j = 0; j < mat[0].length; j++){\\n                maxVal = Math.max(maxVal,hmap.get(mat[i][j]));\\n            }\\n            result = Math.min(result,maxVal); \\n        }\\n\\n        //smallest index across every column\\n        for(int i = 0; i < mat[0].length; i++){\\n            int maxVal = 0;\\n            for(int j = 0; j < mat.length; j++){\\n                maxVal = Math.max(maxVal,hmap.get(mat[j][i]));\\n            }\\n            result = Math.min(result,maxVal);\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> hmap = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            hmap.put(arr[i],i);\\n        }\\n        int result = Integer.MAX_VALUE;\\n\\n        //smallest index across every row\\n        for(int i = 0; i < mat.length; i++){\\n            int maxVal = 0;\\n            for(int j = 0; j < mat[0].length; j++){\\n                maxVal = Math.max(maxVal,hmap.get(mat[i][j]));\\n            }\\n            result = Math.min(result,maxVal); \\n        }\\n\\n        //smallest index across every column\\n        for(int i = 0; i < mat[0].length; i++){\\n            int maxVal = 0;\\n            for(int j = 0; j < mat.length; j++){\\n                maxVal = Math.max(maxVal,hmap.get(mat[j][i]));\\n            }\\n            result = Math.min(result,maxVal);\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727414,
                "title": "python-easy-solution-using-dict-beats-93-percent",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        indexes = {}\\n        m, n = len(mat), len(mat[0])\\n        for i in range(m):\\n            for j in range(n):\\n                indexes[mat[i][j]] = (i, j)\\n        rows = [0] * m\\n        cols = [0] * n\\n        #Search\\n        for i, num in enumerate(arr):\\n            x, y = indexes[num]\\n            rows[x] += 1\\n            cols[y] += 1\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        indexes = {}\\n        m, n = len(mat), len(mat[0])\\n        for i in range(m):\\n            for j in range(n):\\n                indexes[mat[i][j]] = (i, j)\\n        rows = [0] * m\\n        cols = [0] * n\\n        #Search\\n        for i, num in enumerate(arr):\\n            x, y = indexes[num]\\n            rows[x] += 1\\n            cols[y] += 1\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717731,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe just have to find which element in the whole row/column occurs farthest in the array because that would be the last element when the whole row/col gets painted\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<arr.size();i++){\\n            mp[arr[i]] = i;\\n        }\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<int> rmin(n),cmin(m);\\n        for(int i = 0;i<n;i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0;j<m;j++){\\n                maxi = max(maxi,mp[mat[i][j]]);\\n                cmin[j] = max(cmin[j],mp[mat[i][j]]);\\n            }\\n            rmin[i] = maxi;\\n        }\\n        int ans = INT_MAX;\\n        for(auto e:rmin)\\n            ans = min(e,ans);\\n        for(auto e:cmin){\\n            ans = min(e,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<arr.size();i++){\\n            mp[arr[i]] = i;\\n        }\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<int> rmin(n),cmin(m);\\n        for(int i = 0;i<n;i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0;j<m;j++){\\n                maxi = max(maxi,mp[mat[i][j]]);\\n                cmin[j] = max(cmin[j],mp[mat[i][j]]);\\n            }\\n            rmin[i] = maxi;\\n        }\\n        int ans = INT_MAX;\\n        for(auto e:rmin)\\n            ans = min(e,ans);\\n        for(auto e:cmin){\\n            ans = min(e,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675043,
                "title": "easiest-solution-java-o-m-n",
                "content": "\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int len = arr.length;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < len; i++){\\n            map.put(arr[i], i);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < m; i++){\\n            int curr = -1;\\n            for(int j = 0; j < n; j++){\\n                curr = Math.max(curr, map.get(mat[i][j]));\\n            }\\n            res = Math.min(res, curr);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int curr = -1;\\n            for(int j = 0; j < m; j++){\\n                curr = Math.max(curr, map.get(mat[j][i]));\\n            }\\n            res = Math.min(res, curr);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int len = arr.length;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < len; i++){\\n            map.put(arr[i], i);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < m; i++){\\n            int curr = -1;\\n            for(int j = 0; j < n; j++){\\n                curr = Math.max(curr, map.get(mat[i][j]));\\n            }\\n            res = Math.min(res, curr);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int curr = -1;\\n            for(int j = 0; j < m; j++){\\n                curr = Math.max(curr, map.get(mat[j][i]));\\n            }\\n            res = Math.min(res, curr);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642050,
                "title": "best-approach-with-explanation-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n\\n        int n = arr.length;\\n        int row_size = mat.length;\\n        int col_size = mat[0].length;\\n\\n        Map<Integer, Pair<Integer, Integer>> map = new HashMap<>();\\n\\n        for(int i=0; i<row_size; i++){\\n            for(int j=0; j<col_size; j++){\\n                map.put(mat[i][j], new Pair<>(i, j));\\n            }\\n        }\\n\\n        int[] row = new int[n];\\n        int[] col = new int[n];\\n\\n        for(int i=0; i<n; i++){\\n            int num = arr[i];\\n\\n            int row_indx = map.get(num).getKey(); // give i\\n            int col_indx = map.get(num).getValue(); // give j\\n\\n            row[row_indx]++;\\n            col[col_indx]++;\\n\\n            if(row[row_indx] == col_size || col[col_indx] == row_size){\\n                return i;\\n            }\\n\\n        }\\n        return -1;\\n\\n    }\\n}\\n\\n\\n// Create a Map object to store the mapping between the elements of arr and their corresponding coordinates in mat.\\n\\n// Initialize two arrays row and col to store the number of times each row and column in mat has been visited.\\n\\n// Iterate over the elements of arr and do the following:\\n     // Get the row and column coordinates of the current element from the Map object.\\n     // Increment the row and col arrays at the corresponding indices.\\n      // If either row or col is equal to the size of the corresponding dimension of mat, then return the current index.\\n\\n// If no index was found, then return -1.\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n\\n        int n = arr.length;\\n        int row_size = mat.length;\\n        int col_size = mat[0].length;\\n\\n        Map<Integer, Pair<Integer, Integer>> map = new HashMap<>();\\n\\n        for(int i=0; i<row_size; i++){\\n            for(int j=0; j<col_size; j++){\\n                map.put(mat[i][j], new Pair<>(i, j));\\n            }\\n        }\\n\\n        int[] row = new int[n];\\n        int[] col = new int[n];\\n\\n        for(int i=0; i<n; i++){\\n            int num = arr[i];\\n\\n            int row_indx = map.get(num).getKey(); // give i\\n            int col_indx = map.get(num).getValue(); // give j\\n\\n            row[row_indx]++;\\n            col[col_indx]++;\\n\\n            if(row[row_indx] == col_size || col[col_indx] == row_size){\\n                return i;\\n            }\\n\\n        }\\n        return -1;\\n\\n    }\\n}\\n\\n\\n// Create a Map object to store the mapping between the elements of arr and their corresponding coordinates in mat.\\n\\n// Initialize two arrays row and col to store the number of times each row and column in mat has been visited.\\n\\n// Iterate over the elements of arr and do the following:\\n     // Get the row and column coordinates of the current element from the Map object.\\n     // Increment the row and col arrays at the corresponding indices.\\n      // If either row or col is equal to the size of the corresponding dimension of mat, then return the current index.\\n\\n// If no index was found, then return -1.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638707,
                "title": "first-completely-painted-row-or-column-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        map<int,pair<int,int>> mp;\\n        vector<int> Row_cnt(r,0);\\n        vector<int> Col_cnt(c,0);\\n        int ans=INT_MAX;\\n        for(int i=0;i<r;++i){\\n            for(int j=0;j<c;++j){\\n                 mp[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<r*c;++i){\\n            auto it=mp[arr[i]];\\n            Row_cnt[it.first]++;\\n            Col_cnt[it.second]++;\\n            if(Row_cnt[it.first]==c && ans>i){\\n                ans=i;\\n                break;\\n            }\\n            if(Col_cnt[it.second]==r && ans>i){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        map<int,pair<int,int>> mp;\\n        vector<int> Row_cnt(r,0);\\n        vector<int> Col_cnt(c,0);\\n        int ans=INT_MAX;\\n        for(int i=0;i<r;++i){\\n            for(int j=0;j<c;++j){\\n                 mp[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<r*c;++i){\\n            auto it=mp[arr[i]];\\n            Row_cnt[it.first]++;\\n            Col_cnt[it.second]++;\\n            if(Row_cnt[it.first]==c && ans>i){\\n                ans=i;\\n                break;\\n            }\\n            if(Col_cnt[it.second]==r && ans>i){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636722,
                "title": "golang-keep-track-of-row-and-column-painted-count",
                "content": "# Code\\n```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n  m, n := len(mat), len(mat[0])\\n  // First we need to know which (row, col) each number refers to.\\n  positions := make([][2]int, len(arr)+1)\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      positions[mat[i][j]] = [2]int{i, j}\\n    }\\n  }\\n  // rowPainted keeps track of the number of cells painted in each row\\n  rowPainted := make([]int, m)\\n  // colPainted keeps track of the number of cells painted in each column\\n  colPainted := make([]int, n)\\n  var res int\\n  for idx, id := range arr {\\n    i, j := positions[id][0], positions[id][1]\\n    rowPainted[i]++\\n    colPainted[j]++\\n    if rowPainted[i] == n || colPainted[j] == m {\\n      res = idx\\n      break\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n  m, n := len(mat), len(mat[0])\\n  // First we need to know which (row, col) each number refers to.\\n  positions := make([][2]int, len(arr)+1)\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      positions[mat[i][j]] = [2]int{i, j}\\n    }\\n  }\\n  // rowPainted keeps track of the number of cells painted in each row\\n  rowPainted := make([]int, m)\\n  // colPainted keeps track of the number of cells painted in each column\\n  colPainted := make([]int, n)\\n  var res int\\n  for idx, id := range arr {\\n    i, j := positions[id][0], positions[id][1]\\n    rowPainted[i]++\\n    colPainted[j]++\\n    if rowPainted[i] == n || colPainted[j] == m {\\n      res = idx\\n      break\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3636402,
                "title": "bruteforce-code-to-map-freqarray-optimization",
                "content": "# 1. BruteForce Code, TLE\\n#### Complexity\\n- Time Complexity : **O(len * (Row * Col + Row + Col))**\\n- Space Complexity : **O(1)**\\n```\\nclass Solution {\\n    private static boolean isDone(int row, int col, int[][] mat){\\n        int Row = mat.length, Col = mat[0].length;\\n        boolean isColDone = true, isRowDone = true;\\n        for(int c=0;c<Col;c++){\\n            if(mat[row][c]!=-1){\\n                isColDone = false;\\n                break;\\n            }\\n        }\\n        for(int r=0;r<Row;r++){\\n            if(mat[r][col]!=-1){\\n                isRowDone = false;\\n                break;\\n            }\\n        }\\n        return isColDone || isRowDone;\\n    }\\n\\n    private static boolean paint(int value, int[][] mat){\\n        for(int row=0;row<mat.length;row++){\\n            for(int col=0;col<mat[0].length;col++){\\n                if(mat[row][col]==value){\\n                    mat[row][col] = -1;\\n                    if(isDone(row,col,mat)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private static int fun(int[] arr, int[][] mat){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length, limit = Row*Col;\\n        for(int index=0;index<len;index++){\\n            int value = arr[index];\\n            boolean isDone = paint(value,mat);\\n            if(isDone) return index;\\n            else continue;\\n        }\\n        return len-1;\\n    }\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        return fun(arr,mat);\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(len * (Row*Col + Row + Col))\\n// Space Complexity : O(1)\\n```\\n---\\n# 2. Optimized Code [Map + FreqArray], Accepted\\n#### Complexity\\n- Time Complexity : **O(Row * Col + Row * Col + len)**\\n- Space Complexity : **O(Row * Col + Row + Col)**\\n```\\nclass Pair{\\n    int row, col;\\n    Pair(int row, int col){\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n\\n    private static int paint(int[] arr, int[][] mat, Map<Integer,Pair> map,int[] rowFill,int[] colFill){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length;\\n        for(int index=0;index<len;index++){\\n            int value = arr[index];\\n            Pair curPair = map.get(value);\\n            int row = curPair.row, col = curPair.col;\\n            rowFill[row]--;\\n            colFill[col]--;\\n            mat[row][col] = -1;\\n            if(rowFill[row]==0 || colFill[col]==0) return index;\\n        }\\n        return len-1;\\n    }\\n\\n    private static int fun(int[] arr, int[][] mat){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length;\\n        Map<Integer,Pair> map = new HashMap<>();\\n        for(int row=0;row<Row;row++){\\n            for(int col=0;col<Col;col++){\\n                map.put(mat[row][col], new Pair(row,col));\\n            }\\n        }\\n        int[] rowFill = new int[Row], colFill = new int[Col];\\n        Arrays.fill(rowFill,Col);\\n        Arrays.fill(colFill,Row);\\n        return paint(arr,mat,map,rowFill,colFill);\\n    }\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        return fun(arr,mat);\\n    }\\n}\\n\\n// Optimized Code \\n// Time Complexity : O(Row*Col + Row*Col + len)\\n// Space Complexity : O(Row*Col + Row + Col)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    private static boolean isDone(int row, int col, int[][] mat){\\n        int Row = mat.length, Col = mat[0].length;\\n        boolean isColDone = true, isRowDone = true;\\n        for(int c=0;c<Col;c++){\\n            if(mat[row][c]!=-1){\\n                isColDone = false;\\n                break;\\n            }\\n        }\\n        for(int r=0;r<Row;r++){\\n            if(mat[r][col]!=-1){\\n                isRowDone = false;\\n                break;\\n            }\\n        }\\n        return isColDone || isRowDone;\\n    }\\n\\n    private static boolean paint(int value, int[][] mat){\\n        for(int row=0;row<mat.length;row++){\\n            for(int col=0;col<mat[0].length;col++){\\n                if(mat[row][col]==value){\\n                    mat[row][col] = -1;\\n                    if(isDone(row,col,mat)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private static int fun(int[] arr, int[][] mat){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length, limit = Row*Col;\\n        for(int index=0;index<len;index++){\\n            int value = arr[index];\\n            boolean isDone = paint(value,mat);\\n            if(isDone) return index;\\n            else continue;\\n        }\\n        return len-1;\\n    }\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        return fun(arr,mat);\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(len * (Row*Col + Row + Col))\\n// Space Complexity : O(1)\\n```\n```\\nclass Pair{\\n    int row, col;\\n    Pair(int row, int col){\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n\\n    private static int paint(int[] arr, int[][] mat, Map<Integer,Pair> map,int[] rowFill,int[] colFill){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length;\\n        for(int index=0;index<len;index++){\\n            int value = arr[index];\\n            Pair curPair = map.get(value);\\n            int row = curPair.row, col = curPair.col;\\n            rowFill[row]--;\\n            colFill[col]--;\\n            mat[row][col] = -1;\\n            if(rowFill[row]==0 || colFill[col]==0) return index;\\n        }\\n        return len-1;\\n    }\\n\\n    private static int fun(int[] arr, int[][] mat){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length;\\n        Map<Integer,Pair> map = new HashMap<>();\\n        for(int row=0;row<Row;row++){\\n            for(int col=0;col<Col;col++){\\n                map.put(mat[row][col], new Pair(row,col));\\n            }\\n        }\\n        int[] rowFill = new int[Row], colFill = new int[Col];\\n        Arrays.fill(rowFill,Col);\\n        Arrays.fill(colFill,Row);\\n        return paint(arr,mat,map,rowFill,colFill);\\n    }\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        return fun(arr,mat);\\n    }\\n}\\n\\n// Optimized Code \\n// Time Complexity : O(Row*Col + Row*Col + len)\\n// Space Complexity : O(Row*Col + Row + Col)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623170,
                "title": "java-solution-easy-to-understand-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhashing the arr array via its index\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nget max index of painting each row and col and getting min of all of them\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans = mat.length * mat[0].length ;\\n        for(int i = 0; i < arr.length; i++){\\n            map.put(arr[i], i);\\n        }\\n        \\n        for(int i = 0; i < mat.length ; i++){\\n            int maxV = 0;\\n            for(int j = 0; j < mat[0].length; j++){\\n                maxV = Math.max(maxV, map.get(mat[i][j]));\\n            }\\n            ans = Math.min(ans, maxV);\\n        }\\n        for(int i = 0; i < mat[0].length ; i++){\\n            int maxV = 0;\\n            for(int j = 0; j < mat.length; j++){\\n                maxV = Math.max(maxV, map.get(mat[j][i]));\\n            }\\n            ans = Math.min(ans, maxV);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans = mat.length * mat[0].length ;\\n        for(int i = 0; i < arr.length; i++){\\n            map.put(arr[i], i);\\n        }\\n        \\n        for(int i = 0; i < mat.length ; i++){\\n            int maxV = 0;\\n            for(int j = 0; j < mat[0].length; j++){\\n                maxV = Math.max(maxV, map.get(mat[i][j]));\\n            }\\n            ans = Math.min(ans, maxV);\\n        }\\n        for(int i = 0; i < mat[0].length ; i++){\\n            int maxV = 0;\\n            for(int j = 0; j < mat.length; j++){\\n                maxV = Math.max(maxV, map.get(mat[j][i]));\\n            }\\n            ans = Math.min(ans, maxV);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618000,
                "title": "java-map-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution { \\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length; int n = mat[0].length;\\n        Map<Integer,int[]> map = new HashMap<>();\\n \\n // these arrays values means how many grids are painted at particular row or col \\n        int[]rows = new int[m];\\n        int[]cols = new int[n];\\n\\n        for(int i = 0;i<m;i++){//map will store r,c of every value \\n            for(int j = 0;j<n;j++){\\n                map.put(mat[i][j],new int[]{i,j});\\n            }            \\n        }\\n\\n        for(int i = 0;i<m*n;i++){\\n           int[]curr =  map.get(arr[i]);// get curr num\\'s (r,c) from map\\n//when ever value is painted, just increment row and col at r and c index resp.\\n\\n           rows[curr[0]]++;   \\n           cols[curr[1]]++;\\n\\n// at last check is particular row or col fully painted?\\n// conditions are as follwing to check full painted row and col\\n           if(rows[curr[0]] == n){\\n               return i;\\n           }\\n           if(cols[curr[1]] == m){\\n               return i;\\n           } \\n            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length; int n = mat[0].length;\\n        Map<Integer,int[]> map = new HashMap<>();\\n \\n // these arrays values means how many grids are painted at particular row or col \\n        int[]rows = new int[m];\\n        int[]cols = new int[n];\\n\\n        for(int i = 0;i<m;i++){//map will store r,c of every value \\n            for(int j = 0;j<n;j++){\\n                map.put(mat[i][j],new int[]{i,j});\\n            }            \\n        }\\n\\n        for(int i = 0;i<m*n;i++){\\n           int[]curr =  map.get(arr[i]);// get curr num\\'s (r,c) from map\\n//when ever value is painted, just increment row and col at r and c index resp.\\n\\n           rows[curr[0]]++;   \\n           cols[curr[1]]++;\\n\\n// at last check is particular row or col fully painted?\\n// conditions are as follwing to check full painted row and col\\n           if(rows[curr[0]] == n){\\n               return i;\\n           }\\n           if(cols[curr[1]] == m){\\n               return i;\\n           } \\n            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617816,
                "title": "first-completely-painted-row-or-column-easy-approach-one-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        unordered_map<int,int>m;\\n        int a = mat.size();\\n        int b = mat[0].size();\\n\\n        for(int i = 0; i<arr.size(); i++)\\n        {\\n            m[arr[i]] = i;\\n        }\\n\\n        int res = a*b;\\n\\n        for(int i = 0; i<a; i++)\\n        {\\n            int maxi = 0;\\n            for(int j = 0; j<b; j++)\\n            {\\n                maxi = max(maxi,m[mat[i][j]]);\\n            }\\n            res = min(res,maxi);\\n        }\\n\\n        for(int i = 0; i<b; i++)\\n        {\\n            int maxi = 0;\\n            for(int j = 0; j<a; j++)\\n            {\\n                maxi = max(maxi,m[mat[j][i]]);\\n            }\\n            res = min(res,maxi);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        unordered_map<int,int>m;\\n        int a = mat.size();\\n        int b = mat[0].size();\\n\\n        for(int i = 0; i<arr.size(); i++)\\n        {\\n            m[arr[i]] = i;\\n        }\\n\\n        int res = a*b;\\n\\n        for(int i = 0; i<a; i++)\\n        {\\n            int maxi = 0;\\n            for(int j = 0; j<b; j++)\\n            {\\n                maxi = max(maxi,m[mat[i][j]]);\\n            }\\n            res = min(res,maxi);\\n        }\\n\\n        for(int i = 0; i<b; i++)\\n        {\\n            int maxi = 0;\\n            for(int j = 0; j<a; j++)\\n            {\\n                maxi = max(maxi,m[mat[j][i]]);\\n            }\\n            res = min(res,maxi);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617166,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605986,
                "title": "javascript-logic-w-map",
                "content": "# Code\\n```\\n// Time: O(m*n) | Space: O(m*n)\\nvar firstCompleteIndex = function(arr, mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const map = {};\\n    const cols = Array(n).fill(m);\\n    const rows = Array(m).fill(n);\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            map[mat[i][j]] = [i, j];\\n        }\\n    }\\n    for (let k = 0; k < arr.length; k++) {\\n        let [i, j] = map[arr[k]];\\n        rows[i]--;\\n        if (rows[i] === 0) return k;\\n        cols[j]--;\\n        if (cols[j] === 0) return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Time: O(m*n) | Space: O(m*n)\\nvar firstCompleteIndex = function(arr, mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const map = {};\\n    const cols = Array(n).fill(m);\\n    const rows = Array(m).fill(n);\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            map[mat[i][j]] = [i, j];\\n        }\\n    }\\n    for (let k = 0; k < arr.length; k++) {\\n        let [i, j] = map[arr[k]];\\n        rows[i]--;\\n        if (rows[i] === 0) return k;\\n        cols[j]--;\\n        if (cols[j] === 0) return k;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600542,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\n        num in paint[] is also contained in matrix[r][c] \\n        so paint[i] = matrix[r][c] = num and all the num value in both paint[]\\n        and matrix[][] are unique as num is one of these values [1 to ROW * COL]\\n        \\n        This question requires that we should return an index \\'i\\' from paint[]\\n        where uptil this i-th index either a row or col in matrix must have been\\n        completely painted.\\n        \\n        we know that we have rows = ROW and each contains cells that counts to COL\\n        similarly we have cols = COL and each contains cells that counts to ROW\\n        \\n        //hence each unpaintedCellsInEachRow has cell equals to COL\\n        row1 = [COL]\\n        row2 = [COL]\\n        row3 = [COL]\\n        \\n        //hence each unpaintedCellsInEachCol has cell equals to ROW\\n        col1    col2    col3\\n        [ROW]   [ROW]   [ROW]\\n        \\n        each time we get a num from paint[i] then num in matrix must be painted\\n        that num in matrix[][] is store in numCellsMap as int[]{row, col}\\n        \\n        then this num = matrix[][] = cells(row, col) should be painted in\\n        unpaintedCellsInEachRow on row\\n        and \\n        unpaintedCellsInEachCol on col\\n        \\n        if at any time\\n        unpaintedCellsInEachRow[row] == 0\\n        or unpaintedCellsInEachCol[col] == 0\\n        means we have painted either a row or col in matrix[][]\\n        return that \\'i\\'\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(ROW + COL + (ROW * COL) + Len) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n\\n        int len = arr.length;\\n\\n        int ROW = mat.length;\\n        int COL = mat[0].length;\\n        \\n        //each row have COL amount of cells to be painted\\n        /*\\n        row1 [COL]\\n        row2 [COL]\\n        */\\n        int[] unpaintedCellsInRows = new int[ROW];\\n        Arrays.fill(unpaintedCellsInRows, COL);\\n\\n        //each col have ROW amount of cells to be painted\\n        /*\\n        col1    col2\\n        [ROW]   [ROW]\\n        */\\n        int[] unpaintedCellsInCols = new int[COL];\\n        Arrays.fill(unpaintedCellsInCols, ROW);\\n\\n        Map<Integer, int[]> numCellMap = new HashMap<>();\\n\\n        for(int r = 0; r < ROW; r++){\\n            for(int c = 0; c < COL; c++){\\n                numCellMap.put(mat[r][c], new int[]{r, c});\\n            }\\n        }\\n\\n        for(int i = 0; i < len; i++){\\n\\n            int num = arr[i];\\n\\n            int[] currCell = numCellMap.get(num);\\n\\n            int row = currCell[0];\\n            int col = currCell[1];\\n\\n            unpaintedCellsInRows[row]--;\\n            if(unpaintedCellsInRows[row] == 0) return i;\\n\\n            unpaintedCellsInCols[col]--;\\n            if(unpaintedCellsInCols[col] == 0) return i;\\n        }\\n        return len - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        num in paint[] is also contained in matrix[r][c] \\n        so paint[i] = matrix[r][c] = num and all the num value in both paint[]\\n        and matrix[][] are unique as num is one of these values [1 to ROW * COL]\\n        \\n        This question requires that we should return an index \\'i\\' from paint[]\\n        where uptil this i-th index either a row or col in matrix must have been\\n        completely painted.\\n        \\n        we know that we have rows = ROW and each contains cells that counts to COL\\n        similarly we have cols = COL and each contains cells that counts to ROW\\n        \\n        //hence each unpaintedCellsInEachRow has cell equals to COL\\n        row1 = [COL]\\n        row2 = [COL]\\n        row3 = [COL]\\n        \\n        //hence each unpaintedCellsInEachCol has cell equals to ROW\\n        col1    col2    col3\\n        [ROW]   [ROW]   [ROW]\\n        \\n        each time we get a num from paint[i] then num in matrix must be painted\\n        that num in matrix[][] is store in numCellsMap as int[]{row, col}\\n        \\n        then this num = matrix[][] = cells(row, col) should be painted in\\n        unpaintedCellsInEachRow on row\\n        and \\n        unpaintedCellsInEachCol on col\\n        \\n        if at any time\\n        unpaintedCellsInEachRow[row] == 0\\n        or unpaintedCellsInEachCol[col] == 0\\n        means we have painted either a row or col in matrix[][]\\n        return that \\'i\\'\\n```\n```\\nclass Solution {\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n\\n        int len = arr.length;\\n\\n        int ROW = mat.length;\\n        int COL = mat[0].length;\\n        \\n        //each row have COL amount of cells to be painted\\n        /*\\n        row1 [COL]\\n        row2 [COL]\\n        */\\n        int[] unpaintedCellsInRows = new int[ROW];\\n        Arrays.fill(unpaintedCellsInRows, COL);\\n\\n        //each col have ROW amount of cells to be painted\\n        /*\\n        col1    col2\\n        [ROW]   [ROW]\\n        */\\n        int[] unpaintedCellsInCols = new int[COL];\\n        Arrays.fill(unpaintedCellsInCols, ROW);\\n\\n        Map<Integer, int[]> numCellMap = new HashMap<>();\\n\\n        for(int r = 0; r < ROW; r++){\\n            for(int c = 0; c < COL; c++){\\n                numCellMap.put(mat[r][c], new int[]{r, c});\\n            }\\n        }\\n\\n        for(int i = 0; i < len; i++){\\n\\n            int num = arr[i];\\n\\n            int[] currCell = numCellMap.get(num);\\n\\n            int row = currCell[0];\\n            int col = currCell[1];\\n\\n            unpaintedCellsInRows[row]--;\\n            if(unpaintedCellsInRows[row] == 0) return i;\\n\\n            unpaintedCellsInCols[col]--;\\n            if(unpaintedCellsInCols[col] == 0) return i;\\n        }\\n        return len - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598464,
                "title": "solution-using-java-and-hashmaps-with-intuition-and-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to know when a row/column is painted.\\nHow do we know if a cell is painted?\\n\\nWe can create a row and column identifiers and keep incrementing them by 1 when a cell gets painted in them.\\nWhenever the total for a row reaches \"m\" then we know that the row has been painted.\\nWhenever the total for a column reaches \"n\" then we know that the column has been painted.\\n\\nAt this moment we stop painting and return the index at which the column or row were painted.\\n\\nHow do we store the row and column identifiers? We could use a hashmap.\\n\\nHow do we name the identifiers? We could use the rx and cx where x would be the index/number of the row/column.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by iterating over the input array.\\nIn every iteration, we find the cell and paint it.\\nWhat do we mean paint it? We simply find its (row, column) identifier and increment the total of that column/row.\\n\\nHow do we find the cell location aka (row, column) identifier?\\nIterate over the 2-dimensional array and store the row, column identifier for each number in hashmap. The insertion and lookup will be O(1).\\n\\n# Complexity\\n## Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n) - this is the time complexity for pre-processing the matrix and storing the cell locations in the hashmap.\\nO(m * n) - this is the time complexity for traversing through the final array of numbers.\\nSince, insertion and lookup in hashmap is of complexity O(1), it can be ignored.\\n\\nTotal time complexity = O (m * n)\\n\\n## Space complexity:\\nO(m + n) - for storing the painted cells in rows and columns\\nO(m * n) - for storing the cell locations since there would be (m * n) cells.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        // A map that store the key as the number and value as its cell location in form (row, col).\\n        Map<Integer, String> cellLocations = new HashMap<>();\\n        // A map that will store the key as each individual row and column,\\n        // the value will be total cells in that row/column that have been painted.\\n        Map<String, Integer> totalCellsPaintedInRowCol = new HashMap<>();\\n        int totalRows = mat.length;\\n        int totalColumns = mat[0].length;\\n        int answer = 0;\\n\\n        for (int row = 0; row < mat.length; row++) {\\n            for (int col = 0; col < mat[row].length; col++) {\\n                cellLocations.put(mat[row][col], row + \",\" + col);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            String currentCellLocation = cellLocations.get(arr[i]);\\n            String row = \"r\" + currentCellLocation.split(\",\")[0];\\n            String col = \"c\" + currentCellLocation.split(\",\")[1];\\n\\n            // Update the total for the number\\'s row\\n            if (totalCellsPaintedInRowCol.containsKey(row)) {\\n                totalCellsPaintedInRowCol.put(row, totalCellsPaintedInRowCol.get(row) + 1);\\n            } else {\\n                totalCellsPaintedInRowCol.put(row, 1);\\n            }\\n            // Update the total for the number\\'s column\\n            if (totalCellsPaintedInRowCol.containsKey(col)) {\\n                totalCellsPaintedInRowCol.put(col, totalCellsPaintedInRowCol.get(col) + 1);\\n            } else {\\n                totalCellsPaintedInRowCol.put(col, 1);\\n            }\\n            // By updating the row and column total, we have completed painting the cell.\\n            // Now, we will check if that current row or column have been completely painted or not?\\n            // If they have then we simply return the current index as the answer or else we iterate to the next number is arr.\\n            if (totalCellsPaintedInRowCol.get(row) == totalColumns || totalCellsPaintedInRowCol.get(col) == totalRows) {\\n                answer = i;\\n                break;\\n            }\\n\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        // A map that store the key as the number and value as its cell location in form (row, col).\\n        Map<Integer, String> cellLocations = new HashMap<>();\\n        // A map that will store the key as each individual row and column,\\n        // the value will be total cells in that row/column that have been painted.\\n        Map<String, Integer> totalCellsPaintedInRowCol = new HashMap<>();\\n        int totalRows = mat.length;\\n        int totalColumns = mat[0].length;\\n        int answer = 0;\\n\\n        for (int row = 0; row < mat.length; row++) {\\n            for (int col = 0; col < mat[row].length; col++) {\\n                cellLocations.put(mat[row][col], row + \",\" + col);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            String currentCellLocation = cellLocations.get(arr[i]);\\n            String row = \"r\" + currentCellLocation.split(\",\")[0];\\n            String col = \"c\" + currentCellLocation.split(\",\")[1];\\n\\n            // Update the total for the number\\'s row\\n            if (totalCellsPaintedInRowCol.containsKey(row)) {\\n                totalCellsPaintedInRowCol.put(row, totalCellsPaintedInRowCol.get(row) + 1);\\n            } else {\\n                totalCellsPaintedInRowCol.put(row, 1);\\n            }\\n            // Update the total for the number\\'s column\\n            if (totalCellsPaintedInRowCol.containsKey(col)) {\\n                totalCellsPaintedInRowCol.put(col, totalCellsPaintedInRowCol.get(col) + 1);\\n            } else {\\n                totalCellsPaintedInRowCol.put(col, 1);\\n            }\\n            // By updating the row and column total, we have completed painting the cell.\\n            // Now, we will check if that current row or column have been completely painted or not?\\n            // If they have then we simply return the current index as the answer or else we iterate to the next number is arr.\\n            if (totalCellsPaintedInRowCol.get(row) == totalColumns || totalCellsPaintedInRowCol.get(col) == totalRows) {\\n                answer = i;\\n                break;\\n            }\\n\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598179,
                "title": "problem-2661-first-completely-painted-row-or-column-easy-solution-using-unordered-map-in-c",
                "content": "# Intuition\\nAn unordered map with three elements each can be used to tackle the problem here.\\n\\n# Approach\\nAt first, an unordered map is declared having values *int*, and *pair* of *ints*. Here, the first *int* represents the value of an element in the matrix and the *pair* represents the address of the element in the matrix.\\n\\nAlong with that, two arrays of sizes *m* and *n* are created to store the number of elements painted in each row and column of the matrix.\\n\\nThe unordered map is initialised with the address of all the elements in the matrix using the *for* loop.\\n\\nAfter that, the given array is traversed one by one, and corresponding to the address of the element in the unordered map, the values in *rows* and *columns* are incremented, marking the fact that one more element in that row/column has been painted.\\n\\nIf the number of rows or columns painted at any point matches the total number of rows/columns, the index of array at which this is achieved is simply returned.\\n\\n# Complexity\\n- Time complexity:\\nSince there are two *for* loops corresponding to the rows *m* and columns *n* of the matrix intertwined, the time complexity for this solution is **O(mn)**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int i=mat.size(), j=mat[0].size(), k=arr.size();\\n    vector<int> rows(i);\\n    vector<int> columns(j); \\n    unordered_map<int,pair<int,int>> map;\\n\\n    for(int n=0;n<i;n++)\\n        for(int p=0;p<j;p++)\\n        {\\n            map[mat[n][p]].first=n;\\n            map[mat[n][p]].second=p;\\n            \\n        }\\n\\n    for(int n=0;n<k;n++)\\n    {\\n        int x=arr[n];\\n        rows[map[x].first]++;\\n        columns[map[x].second]++;\\n\\n        if(rows[map[x].first]==j || columns[map[x].second]==i)\\n            return n;\\n    }\\n\\n    return 0;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int i=mat.size(), j=mat[0].size(), k=arr.size();\\n    vector<int> rows(i);\\n    vector<int> columns(j); \\n    unordered_map<int,pair<int,int>> map;\\n\\n    for(int n=0;n<i;n++)\\n        for(int p=0;p<j;p++)\\n        {\\n            map[mat[n][p]].first=n;\\n            map[mat[n][p]].second=p;\\n            \\n        }\\n\\n    for(int n=0;n<k;n++)\\n    {\\n        int x=arr[n];\\n        rows[map[x].first]++;\\n        columns[map[x].second]++;\\n\\n        if(rows[map[x].first]==j || columns[map[x].second]==i)\\n            return n;\\n    }\\n\\n    return 0;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592586,
                "title": "hash-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nusing hash, tracking paint count each rows and cols (aux space is M, N)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- 1 Make (key, value) hash to find (r,c) at each paint\\n- 2 feed-forward array query, and tracking rows and cols status\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        rows = [0] * m\\n        cols = [0] * n\\n\\n        paint = defaultdict(lambda :(-1,-1))\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                paint[mat[r][c]] = (r,c)\\n\\n        for i in range(len(arr)):\\n            r,c = paint[arr[i]]\\n\\n            rows[r] +=1\\n            cols[c] +=1\\n            \\n\\n            if rows[r] == n or cols[c] == m:\\n                return i\\n\\n        return m*n -1\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        rows = [0] * m\\n        cols = [0] * n\\n\\n        paint = defaultdict(lambda :(-1,-1))\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                paint[mat[r][c]] = (r,c)\\n\\n        for i in range(len(arr)):\\n            r,c = paint[arr[i]]\\n\\n            rows[r] +=1\\n            cols[c] +=1\\n            \\n\\n            if rows[r] == n or cols[c] == m:\\n                return i\\n\\n        return m*n -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589982,
                "title": "swift-tle-optimised-88-faster",
                "content": "# Intitial approach (TLE)\\n##### Complexity\\n- Time complexity: $$O(m^2*n^2)$$\\n- Space complexity: $$O(m + n)$$\\n```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let (m, n) = (mat.count, mat[0].count)\\n        var row = Array(repeating: 0, count: m)\\n        var col = Array(repeating: 0, count: n)\\n        for (k, target) in arr.enumerated() {\\n            for x in 0..<m {\\n                for y in 0..<n {\\n                    if mat[x][y] == target {\\n                        row[x] += 1\\n                        col[y] += 1\\n                        if row[x] == n || col[y] == m {\\n                            return k\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return arr.count\\n    }\\n}\\n```\\n\\n# Optimized approach \\n##### Complexity\\n- Time complexity: $$O(m*n)$$\\n- Space complexity: $$O(m + n + m*n)$$\\n```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let (m, n) = (mat.count, mat[0].count)\\n        var row = Array(repeating: 0, count: m)\\n        var col = Array(repeating: 0, count: n)\\n        var coord: [Int: (Int, Int)] = [:]\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                coord[mat[i][j]] = (i, j)\\n            }\\n        }\\n        for (k, target) in arr.enumerated() {\\n            let (x, y) = coord[target]!\\n            row[x] += 1\\n            col[y] += 1\\n            if row[x] == n || col[y] == m {\\n                return k\\n            }\\n        }\\n        return arr.count\\n    }\\n}",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let (m, n) = (mat.count, mat[0].count)\\n        var row = Array(repeating: 0, count: m)\\n        var col = Array(repeating: 0, count: n)\\n        for (k, target) in arr.enumerated() {\\n            for x in 0..<m {\\n                for y in 0..<n {\\n                    if mat[x][y] == target {\\n                        row[x] += 1\\n                        col[y] += 1\\n                        if row[x] == n || col[y] == m {\\n                            return k\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return arr.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589208,
                "title": "inefficient-but-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        set<int> rows[m];\\n        set<int> cols[n];\\n\\n        unordered_map<int, pair<int,int>> umap;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                umap[mat[i][j]] = {i,j};\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            rows[umap[arr[i]].first].insert(umap[arr[i]].second);\\n            cols[umap[arr[i]].second].insert(umap[arr[i]].first);\\n\\n            if(rows[umap[arr[i]].first].size()==n){\\n                return i;\\n            }\\n\\n            if(cols[umap[arr[i]].second].size()==m){\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        set<int> rows[m];\\n        set<int> cols[n];\\n\\n        unordered_map<int, pair<int,int>> umap;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                umap[mat[i][j]] = {i,j};\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            rows[umap[arr[i]].first].insert(umap[arr[i]].second);\\n            cols[umap[arr[i]].second].insert(umap[arr[i]].first);\\n\\n            if(rows[umap[arr[i]].first].size()==n){\\n                return i;\\n            }\\n\\n            if(cols[umap[arr[i]].second].size()==m){\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586420,
                "title": "fast-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        // const int size = arr.size();\\n        const int M = mat.size();\\n        if (M==0) return 0;\\n        const int N = mat[0].size();\\n\\n        vector<int> rows(M,0);\\n        vector<int> cols(N,0);\\n\\n        vector<tuple<int, int>> mat_proj(M*N, {0,0});\\n\\n        for (int m=0; m<M; m++) {\\n            for (int n=0; n<N; n++) {\\n                int el = mat[m][n];\\n                mat_proj[el-1] = {m,n};\\n            }\\n        }\\n\\n        int idx=0;\\n        for (const int a : arr) {\\n            tuple<int,int> tup = mat_proj[a-1];\\n            if (++rows[get<0>(tup)] == N || ++cols[get<1>(tup)] == M) return idx;\\n            idx++;\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        // const int size = arr.size();\\n        const int M = mat.size();\\n        if (M==0) return 0;\\n        const int N = mat[0].size();\\n\\n        vector<int> rows(M,0);\\n        vector<int> cols(N,0);\\n\\n        vector<tuple<int, int>> mat_proj(M*N, {0,0});\\n\\n        for (int m=0; m<M; m++) {\\n            for (int n=0; n<N; n++) {\\n                int el = mat[m][n];\\n                mat_proj[el-1] = {m,n};\\n            }\\n        }\\n\\n        int idx=0;\\n        for (const int a : arr) {\\n            tuple<int,int> tup = mat_proj[a-1];\\n            if (++rows[get<0>(tup)] == N || ++cols[get<1>(tup)] == M) return idx;\\n            idx++;\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580093,
                "title": "solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\\n    val (m, n) = (mat.size, mat.head.size)\\n    val (rows, cols) = (Array.fill(m)(n), Array.fill(n)(m))\\n    val ijs = mat.indices.flatMap(i => mat.head.indices.map(j => mat(i)(j) -> (i, j))).toMap\\n    arr.map(ijs).indexWhere { case (i, j) =>\\n      rows(i) = rows(i) - 1\\n      cols(j) = cols(j) - 1\\n      rows(i) == 0 || cols(j) == 0\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\\n    val (m, n) = (mat.size, mat.head.size)\\n    val (rows, cols) = (Array.fill(m)(n), Array.fill(n)(m))\\n    val ijs = mat.indices.flatMap(i => mat.head.indices.map(j => mat(i)(j) -> (i, j))).toMap\\n    arr.map(ijs).indexWhere { case (i, j) =>\\n      rows(i) = rows(i) - 1\\n      cols(j) = cols(j) - 1\\n      rows(i) == 0 || cols(j) == 0\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3576162,
                "title": "first-completely-painted-row-or-column",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> hmap = new HashMap<>();\\n\\n        int l = mat.length;\\n        int csize = mat[0].length;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i =0;i<arr.length;i++){\\n            hmap.put(arr[i],i);\\n        }\\n        for(int i=0;i<l;i++){\\n            int value =0;\\n            for(int j =0;j<csize;j++){\\n                value = Math.max(value,hmap.get(mat[i][j]));\\n            }\\n            ans = Math.min(ans,value);\\n        }\\n        for(int i=0;i<csize;i++){\\n            int value =0;\\n            for(int j=0;j<l;j++){\\n                value = Math.max(value,hmap.get(mat[j][i]));\\n            }\\n            ans = Math.min(ans,value);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> hmap = new HashMap<>();\\n\\n        int l = mat.length;\\n        int csize = mat[0].length;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i =0;i<arr.length;i++){\\n            hmap.put(arr[i],i);\\n        }\\n        for(int i=0;i<l;i++){\\n            int value =0;\\n            for(int j =0;j<csize;j++){\\n                value = Math.max(value,hmap.get(mat[i][j]));\\n            }\\n            ans = Math.min(ans,value);\\n        }\\n        for(int i=0;i<csize;i++){\\n            int value =0;\\n            for(int j=0;j<l;j++){\\n                value = Math.max(value,hmap.get(mat[j][i]));\\n            }\\n            ans = Math.min(ans,value);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568159,
                "title": "mapping",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<int> row(mat.size(), 0);\\n        vector<int> col(mat[0].size(), 0);\\n        map<int, vector<int>> mp;\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[0].size(); j++){\\n                mp[mat[i][j]].push_back(i);\\n                mp[mat[i][j]].push_back(j);\\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            row[mp[arr[i]][0]]++;\\n            col[mp[arr[i]][1]]++;\\n            if(row[mp[arr[i]][0]]==mat[0].size() || col[mp[arr[i]][1]]==mat.size()) return i;\\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<int> row(mat.size(), 0);\\n        vector<int> col(mat[0].size(), 0);\\n        map<int, vector<int>> mp;\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[0].size(); j++){\\n                mp[mat[i][j]].push_back(i);\\n                mp[mat[i][j]].push_back(j);\\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            row[mp[arr[i]][0]]++;\\n            col[mp[arr[i]][1]]++;\\n            if(row[mp[arr[i]][0]]==mat[0].size() || col[mp[arr[i]][1]]==mat.size()) return i;\\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565653,
                "title": "python-o-m-n-by-score-board-w-comment",
                "content": "# Intuition and approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMaintain a dictionary (i.e., hash table, or mapping table) to save **(x, y) location pair** for each number on the matrix.\\n\\nMaintain other two dictionaries as score board for each column as well as row.\\n\\nPaint matrix cell with given element value, given in input array.\\n\\nUpdate score board for corresponding row y and column x, from location pair(x, y) of current element value.\\n\\nOnce one of them, eitehr column #x or row #y, hits full score, then return current step count as index.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) : dictionary building of \"location\"\\nO(m*n) : time cost of for loop\\n\\nTo sum up, it is O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n) : space cost of dictionary \"location\"\\n\\nO(m) : space cost of dictionary \"row_score\"\\n\\nO(n) : space cost of dictionary \"col_score\"\\n\\nTo sum up, it is O(m*n)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n\\n        # h: height of matrix\\n        # w: width of matrix\\n        h, w = len(mat), len(mat[0])\\n\\n        # Mapping table\\n        # key: element value\\n        # value: (x, y) pair of that element\\n        location = { mat[y][x]: (x, y) for y in range(h) for x in range(w)}\\n\\n        # key: row index\\n        # value: score of of corresponding row\\n        row_score = defaultdict(int)\\n\\n        # key: column index\\n        # value: score of of corresponding column\\n        col_score = defaultdict(int)\\n\\n        # Paint with given number, with idx updaing on iteration\\n        for idx, number in enumerate(arr):\\n\\n            # Get location (x, y) of current number\\n            x, y = location[number]\\n\\n            # Update score of (x, y)\\n            row_score[y] += 1\\n            col_score[x] += 1\\n\\n            # Check if we\\'ve painted full row #y, or full column #x\\n            if (row_score[y] == w) or (col_score[x] == h):\\n                return idx\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n\\n        # h: height of matrix\\n        # w: width of matrix\\n        h, w = len(mat), len(mat[0])\\n\\n        # Mapping table\\n        # key: element value\\n        # value: (x, y) pair of that element\\n        location = { mat[y][x]: (x, y) for y in range(h) for x in range(w)}\\n\\n        # key: row index\\n        # value: score of of corresponding row\\n        row_score = defaultdict(int)\\n\\n        # key: column index\\n        # value: score of of corresponding column\\n        col_score = defaultdict(int)\\n\\n        # Paint with given number, with idx updaing on iteration\\n        for idx, number in enumerate(arr):\\n\\n            # Get location (x, y) of current number\\n            x, y = location[number]\\n\\n            # Update score of (x, y)\\n            row_score[y] += 1\\n            col_score[x] += 1\\n\\n            # Check if we\\'ve painted full row #y, or full column #x\\n            if (row_score[y] == w) or (col_score[x] == h):\\n                return idx\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554806,
                "title": "c-solution-simple-beginner-friendly",
                "content": "# Intuition\\nMaintain a map to store indexes according to value and maintain 2 vectors to track count of unmarked cells in each row and each col\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int,pair<int,int>> index;\\n        vector<int> cols(mat[0].size()+1,mat.size());\\n        vector<int> rows(mat.size()+1,mat[0].size());\\n        for(int i = 0;i<mat.size();i++){\\n            for(int j = 0;j<mat[0].size();j++){\\n                index[mat[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            int row = index[arr[i]].first;\\n            int col = index[arr[i]].second;\\n            rows[row]--;\\n            cols[col]--;\\n            if(rows[row]==0||cols[col]==0) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int,pair<int,int>> index;\\n        vector<int> cols(mat[0].size()+1,mat.size());\\n        vector<int> rows(mat.size()+1,mat[0].size());\\n        for(int i = 0;i<mat.size();i++){\\n            for(int j = 0;j<mat[0].size();j++){\\n                index[mat[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            int row = index[arr[i]].first;\\n            int col = index[arr[i]].second;\\n            rows[row]--;\\n            cols[col]--;\\n            if(rows[row]==0||cols[col]==0) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544183,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length, n= mat[0].length;\\n        int[] rowsBingo = new int[n], colsBingo = new int [m];\\n        Map<Integer,Pair<Integer,Integer>> map = new HashMap();\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                map.put(mat[i][j],new Pair<Integer,Integer>(i,j));\\n            }\\n        }\\n        for (int i=0;i<n*m;i++){\\n            Pair<Integer,Integer> cur = map.get(arr[i]);\\n            rowsBingo[cur.getValue()]++;\\n            colsBingo[cur.getKey()]++;\\n            if (rowsBingo[cur.getValue()]==m ||colsBingo[cur.getKey()]==n) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length, n= mat[0].length;\\n        int[] rowsBingo = new int[n], colsBingo = new int [m];\\n        Map<Integer,Pair<Integer,Integer>> map = new HashMap();\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                map.put(mat[i][j],new Pair<Integer,Integer>(i,j));\\n            }\\n        }\\n        for (int i=0;i<n*m;i++){\\n            Pair<Integer,Integer> cur = map.get(arr[i]);\\n            rowsBingo[cur.getValue()]++;\\n            colsBingo[cur.getKey()]++;\\n            if (rowsBingo[cur.getValue()]==m ||colsBingo[cur.getKey()]==n) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543869,
                "title": "easy-to-understand-javascript-hash-beats-100-runtime-beats-90-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction firstCompleteIndex(arr: number[], mat: number[][]): number {\\n    const hash = [];\\n    let smallest = 0;\\n    const n = mat[0].length;\\n    const m = mat.length;\\n    const rows = new Array(m).fill(0);\\n    const columns = new Array(n).fill(0);\\n\\n    for (let i = 0; i < mat.length; i++) {\\n        for (let j = 0; j < mat[i].length; j++) {\\n            hash[mat[i][j]] = { row: i, col: j};\\n        }\\n    }\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        const { row, col } = hash[arr[i]];\\n\\n        rows[row] += 1;\\n        columns[col] += 1;\\n\\n        if (rows[row] === n || columns[col] === m) {\\n            smallest = i;\\n            break;\\n        }\\n    }\\n\\n    return smallest;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction firstCompleteIndex(arr: number[], mat: number[][]): number {\\n    const hash = [];\\n    let smallest = 0;\\n    const n = mat[0].length;\\n    const m = mat.length;\\n    const rows = new Array(m).fill(0);\\n    const columns = new Array(n).fill(0);\\n\\n    for (let i = 0; i < mat.length; i++) {\\n        for (let j = 0; j < mat[i].length; j++) {\\n            hash[mat[i][j]] = { row: i, col: j};\\n        }\\n    }\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        const { row, col } = hash[arr[i]];\\n\\n        rows[row] += 1;\\n        columns[col] += 1;\\n\\n        if (rows[row] === n || columns[col] === m) {\\n            smallest = i;\\n            break;\\n        }\\n    }\\n\\n    return smallest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541912,
                "title": "simple-clean-math",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n\\n        vector<pair<int,int>> pos(m*n+1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pos[mat[i][j]]={i,j};\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            int x=pos[arr[i]].first,y=pos[arr[i]].second;\\n            mat[x][y]=-i;\\n        }\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            int mini=INT_MAX;\\n            for(int j=0;j<m;j++){\\n                mini=min(mini,mat[i][j]);\\n            }\\n            v.push_back(mini);\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            int mini=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                mini=min(mini,mat[j][i]);\\n            }\\n            v.push_back(mini);\\n        }\\n\\n        sort(v.rbegin(),v.rend());\\n\\n        return -v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n\\n        vector<pair<int,int>> pos(m*n+1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pos[mat[i][j]]={i,j};\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            int x=pos[arr[i]].first,y=pos[arr[i]].second;\\n            mat[x][y]=-i;\\n        }\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            int mini=INT_MAX;\\n            for(int j=0;j<m;j++){\\n                mini=min(mini,mat[i][j]);\\n            }\\n            v.push_back(mini);\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            int mini=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                mini=min(mini,mat[j][i]);\\n            }\\n            v.push_back(mini);\\n        }\\n\\n        sort(v.rbegin(),v.rend());\\n\\n        return -v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537970,
                "title": "simple-code-to-understand",
                "content": "In this question, just have a count of element appeared in particular row and column. When it reaches its row length or column length, that index would be the answer\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]> data = new HashMap<>();\\n        for(int i=0;i<mat.length;i++)\\n            for(int j=0;j<mat[0].length;j++){\\n                int temp[] = {i,j};\\n                data.put(mat[i][j],temp);\\n            }\\n        int row[] = new int[mat[0].length],col[] = new int[mat.length];\\n        for(int j=0;j<arr.length;j++){\\n            int i = arr[j],temp[] = data.get(i);\\n            row[temp[1]]++; col[temp[0]]++;\\n            if(row[temp[1]]==mat.length||col[temp[0]]==mat[0].length) return j;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]> data = new HashMap<>();\\n        for(int i=0;i<mat.length;i++)\\n            for(int j=0;j<mat[0].length;j++){\\n                int temp[] = {i,j};\\n                data.put(mat[i][j],temp);\\n            }\\n        int row[] = new int[mat[0].length],col[] = new int[mat.length];\\n        for(int j=0;j<arr.length;j++){\\n            int i = arr[j],temp[] = data.get(i);\\n            row[temp[1]]++; col[temp[0]]++;\\n            if(row[temp[1]]==mat.length||col[temp[0]]==mat[0].length) return j;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536408,
                "title": "c-mark-element-then-count-by-row-and-col",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        unordered_map<int, pair<int, int>> mp;\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                mp[mat[i][j]] = make_pair(i, j);\\n            }\\n        }\\n\\n        vector<int> rows(m), cols(n);\\n        for (int k = 0; k < arr.size(); ++k)\\n        {\\n            auto& [i, j] = mp[arr[k]];\\n            ++rows[i], ++cols[j];\\n\\n            if (rows[i] == n || cols[j] == m)\\n            {\\n                return k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        unordered_map<int, pair<int, int>> mp;\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                mp[mat[i][j]] = make_pair(i, j);\\n            }\\n        }\\n\\n        vector<int> rows(m), cols(n);\\n        for (int k = 0; k < arr.size(); ++k)\\n        {\\n            auto& [i, j] = mp[arr[k]];\\n            ++rows[i], ++cols[j];\\n\\n            if (rows[i] == n || cols[j] == m)\\n            {\\n                return k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533736,
                "title": "beats-100-java-c-python-2-approaches",
                "content": "# TL;DR\\n1. Beats 100% (3ms) solution:\\n``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        var ids = new int[arr.length + 1];\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            ids[arr[i]] = i;\\n        }\\n\\n        int minOpId = Integer.MAX_VALUE;\\n        for (int r = 0; r < n; r++) {\\n            int fullRowPaintOpId = -1;\\n            for (int c = 0; c < m; c++) {\\n                fullRowPaintOpId = Math.max(fullRowPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = Math.min(minOpId, fullRowPaintOpId);\\n        }\\n        \\n        for (int c = 0; c < m; c++) {\\n            int fullColPaintOpId = -1;\\n            for (int r = 0; r < n; r++) {\\n                fullColPaintOpId = Math.max(fullColPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = Math.min(minOpId, fullColPaintOpId);\\n        }\\n\\n        return minOpId;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        std::vector<int> ids(arr.size() + 1);\\n\\n        for (int i = 0; i < arr.size(); i++) {\\n            ids[arr[i]] = i;\\n        }\\n\\n        int minOpId = INT_MAX;\\n        for (int r = 0; r < n; r++) {\\n            int fullRowPaintOpId = -1;\\n            for (int c = 0; c < m; c++) {\\n                fullRowPaintOpId = std::max(fullRowPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = std::min(minOpId, fullRowPaintOpId);\\n        }\\n\\n        for (int c = 0; c < m; c++) {\\n            int fullColPaintOpId = -1;\\n            for (int r = 0; r < n; r++) {\\n                fullColPaintOpId = std::max(fullColPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = std::min(minOpId, fullColPaintOpId);\\n        }\\n\\n        return minOpId;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        m = len(mat[0])\\n        ids = [0]*(len(arr) + 1)\\n\\n        for i in range(len(arr)):\\n            ids[arr[i]] = i\\n\\n        minOpId = float(\\'inf\\')\\n        for r in range(n):\\n            fullRowPaintOpId = -1\\n            for c in range(m):\\n                fullRowPaintOpId = max(fullRowPaintOpId, ids[mat[r][c]])\\n            minOpId = min(minOpId, fullRowPaintOpId)\\n\\n        for c in range(m):\\n            fullColPaintOpId = -1\\n            for r in range(n):\\n                fullColPaintOpId = max(fullColPaintOpId, ids[mat[r][c]])\\n            minOpId = min(minOpId, fullColPaintOpId)\\n\\n        return minOpId\\n```\\n2. Beats 88% (18ms) solution:\\n``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        var coordinates = new int[n * m + 1][2];\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                coordinates[mat[r][c]] = new int[]{r, c};\\n            }\\n        }\\n\\n        var rows = new int[n];\\n        var columns = new int[m];\\n        for (int i = 0; i < arr.length; i++) {\\n            var cell = coordinates[arr[i]];\\n            if (++rows[cell[0]] == m | ++columns[cell[1]] == n) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        std::vector<std::vector<int>> coordinates(n * m + 1, std::vector<int>(2));\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                coordinates[mat[r][c]][0] = r;\\n                coordinates[mat[r][c]][1] = c;\\n            }\\n        }\\n\\n        std::vector<int> rows(n), columns(m);\\n        for (int i = 0; i < arr.size(); i++) {\\n            auto cell = coordinates[arr[i]];\\n            if (++rows[cell[0]] == m || ++columns[cell[1]] == n) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        m = len(mat[0])\\n        coordinates = [[0, 0] for _ in range(n * m + 1)]\\n\\n        for r in range(n):\\n            for c in range(m):\\n                coordinates[mat[r][c]][0] = r\\n                coordinates[mat[r][c]][1] = c\\n\\n        rows = [0]*n\\n        columns = [0]*m\\n        for i in range(len(arr)):\\n            cell = coordinates[arr[i]]\\n            rows[cell[0]] += 1\\n            columns[cell[1]] += 1\\n            if rows[cell[0]] == m or columns[cell[1]] == n:\\n                return i\\n\\n        return -1\\n```\\n\\n---\\n#### \\u26A0\\uFE0F Thank you for your upvote! \\uD83D\\uDE43\\n---\\n\\n# Intuition\\n\\nThe two provided solutions tackle the problem from different perspectives:\\n\\n### Tricky one\\nIn the first approach, we essentially map each value from the matrix to its corresponding index in the array. This mapping allows us to know at what point in the process each cell gets painted.\\n\\nThe for-loops over the rows and columns aim to determine the latest point at which a cell in a particular row or column gets painted. This is achieved by finding the maximum index among the cells in a row or column (which corresponds to the latest point in the painting process). This value is stored in `fullRowPaintOpId` and `fullColPaintOpId` respectively. \\n\\nThe rationale behind this is that for a row or column to be fully painted, even the cell that gets painted last (i.e., the cell with the maximum corresponding index in the array) must be painted. So the maximum index in a row or column represents the earliest point at which that row or column could be fully painted.\\n\\nFinally, we are interested in the earliest point at which ANY row or column gets fully painted. This is determined by finding the minimum value among all the `fullRowPaintOpId`s and `fullColPaintOpId`s.\\n\\n### Simulation\\nThe second approach takes a more direct route. It maps the cell values to their respective coordinates in the matrix. Then it simulates the painting process as described in the array. During the simulation, it keeps track of the number of cells painted in each row and column. As soon as a row or column gets completely painted, it returns the current index.\\n\\n\\n# Complexity Analysis\\n\\n- Time complexity: For both versions the time complexity is $$O(m*n)$$, where $$m$$ is the number of rows and $$n$$ is the number of columns in the matrix. \\n\\n- Space complexity: For both versions the space complexity is $$O(m*n)$$.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Simulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        var ids = new int[arr.length + 1];\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            ids[arr[i]] = i;\\n        }\\n\\n        int minOpId = Integer.MAX_VALUE;\\n        for (int r = 0; r < n; r++) {\\n            int fullRowPaintOpId = -1;\\n            for (int c = 0; c < m; c++) {\\n                fullRowPaintOpId = Math.max(fullRowPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = Math.min(minOpId, fullRowPaintOpId);\\n        }\\n        \\n        for (int c = 0; c < m; c++) {\\n            int fullColPaintOpId = -1;\\n            for (int r = 0; r < n; r++) {\\n                fullColPaintOpId = Math.max(fullColPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = Math.min(minOpId, fullColPaintOpId);\\n        }\\n\\n        return minOpId;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        std::vector<int> ids(arr.size() + 1);\\n\\n        for (int i = 0; i < arr.size(); i++) {\\n            ids[arr[i]] = i;\\n        }\\n\\n        int minOpId = INT_MAX;\\n        for (int r = 0; r < n; r++) {\\n            int fullRowPaintOpId = -1;\\n            for (int c = 0; c < m; c++) {\\n                fullRowPaintOpId = std::max(fullRowPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = std::min(minOpId, fullRowPaintOpId);\\n        }\\n\\n        for (int c = 0; c < m; c++) {\\n            int fullColPaintOpId = -1;\\n            for (int r = 0; r < n; r++) {\\n                fullColPaintOpId = std::max(fullColPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = std::min(minOpId, fullColPaintOpId);\\n        }\\n\\n        return minOpId;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        m = len(mat[0])\\n        ids = [0]*(len(arr) + 1)\\n\\n        for i in range(len(arr)):\\n            ids[arr[i]] = i\\n\\n        minOpId = float(\\'inf\\')\\n        for r in range(n):\\n            fullRowPaintOpId = -1\\n            for c in range(m):\\n                fullRowPaintOpId = max(fullRowPaintOpId, ids[mat[r][c]])\\n            minOpId = min(minOpId, fullRowPaintOpId)\\n\\n        for c in range(m):\\n            fullColPaintOpId = -1\\n            for r in range(n):\\n                fullColPaintOpId = max(fullColPaintOpId, ids[mat[r][c]])\\n            minOpId = min(minOpId, fullColPaintOpId)\\n\\n        return minOpId\\n```\n``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        var coordinates = new int[n * m + 1][2];\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                coordinates[mat[r][c]] = new int[]{r, c};\\n            }\\n        }\\n\\n        var rows = new int[n];\\n        var columns = new int[m];\\n        for (int i = 0; i < arr.length; i++) {\\n            var cell = coordinates[arr[i]];\\n            if (++rows[cell[0]] == m | ++columns[cell[1]] == n) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        std::vector<std::vector<int>> coordinates(n * m + 1, std::vector<int>(2));\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                coordinates[mat[r][c]][0] = r;\\n                coordinates[mat[r][c]][1] = c;\\n            }\\n        }\\n\\n        std::vector<int> rows(n), columns(m);\\n        for (int i = 0; i < arr.size(); i++) {\\n            auto cell = coordinates[arr[i]];\\n            if (++rows[cell[0]] == m || ++columns[cell[1]] == n) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        m = len(mat[0])\\n        coordinates = [[0, 0] for _ in range(n * m + 1)]\\n\\n        for r in range(n):\\n            for c in range(m):\\n                coordinates[mat[r][c]][0] = r\\n                coordinates[mat[r][c]][1] = c\\n\\n        rows = [0]*n\\n        columns = [0]*m\\n        for i in range(len(arr)):\\n            cell = coordinates[arr[i]]\\n            rows[cell[0]] += 1\\n            columns[cell[1]] += 1\\n            if rows[cell[0]] == m or columns[cell[1]] == n:\\n                return i\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528451,
                "title": "js-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  const hash = {}\\n\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      hash[mat[i][j]] = { i, j }\\n    }\\n  }\\n\\n  const rows = new Array(m).fill(0)\\n  const cols = new Array(n).fill(0)\\n\\n  let buff;\\n\\n  const last = m * n;\\n  for (let i = 0; i < last; i++) {\\n    buff = hash[arr[i]];\\n    rows[+buff.i]++\\n    cols[+buff.j]++\\n\\n    if (rows[+buff.i] === n || cols[+buff.j] === m) return i\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  const hash = {}\\n\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      hash[mat[i][j]] = { i, j }\\n    }\\n  }\\n\\n  const rows = new Array(m).fill(0)\\n  const cols = new Array(n).fill(0)\\n\\n  let buff;\\n\\n  const last = m * n;\\n  for (let i = 0; i < last; i++) {\\n    buff = hash[arr[i]];\\n    rows[+buff.i]++\\n    cols[+buff.j]++\\n\\n    if (rows[+buff.i] === n || cols[+buff.j] === m) return i\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519057,
                "title": "python-dictionary-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        dict_matrix = {}\\n\\n        row = len(mat)\\n        col = len(mat[0])\\n\\n        for r in range(row):\\n            for c in range(col):\\n                dict_matrix[mat[r][c]] = (r, c)\\n        \\n        r_ans = [0 for i in range(row)]\\n        c_ans = [0 for i in range(col)]\\n        \\n        for i in range(len(arr)):\\n            r, c = dict_matrix[arr[i]]\\n            r_ans[r] += 1\\n            c_ans[c] += 1\\n            if r_ans[r] == col or c_ans[c] == row:\\n                return i\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        dict_matrix = {}\\n\\n        row = len(mat)\\n        col = len(mat[0])\\n\\n        for r in range(row):\\n            for c in range(col):\\n                dict_matrix[mat[r][c]] = (r, c)\\n        \\n        r_ans = [0 for i in range(row)]\\n        c_ans = [0 for i in range(col)]\\n        \\n        for i in range(len(arr)):\\n            r, c = dict_matrix[arr[i]]\\n            r_ans[r] += 1\\n            c_ans[c] += 1\\n            if r_ans[r] == col or c_ans[c] == row:\\n                return i\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515076,
                "title": "hashing-preprocessing-everything-commented-easy-to-understand-c-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n/*This private section has 2 functions that checks the matrix\\'s specified row and column for colouring (zero) in other words. But it runs for 1021/1057 testcases and gives TLE right-after so we tackle this problem in a different way using hash-table for individual row and column after pre-processing the co-ordinates in another map.*/\\n\\n/*private: \\n    bool checkRow(vector<vector<int>> mat, int row)\\n    {\\n        int f=0, l=mat[0].size()-1;\\n        while(f<=l)  \\n        {\\n            if(mat[row][f++]!=0 || mat[row][l--]!=0 ){return false;}\\n        }\\n        return true;\\n    }\\n    bool checkColumn(vector<vector<int>> mat, int column)\\n    {\\n        int f=0, l=mat.size()-1;\\n        while(f<=l) \\n        {\\n            if(mat[f++][column]!=0 || mat[l--][column]!=0){return false;}\\n        }\\n        return true;\\n    }*/\\n\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n      int m = mat.size();\\n      int n = mat[0].size();\\n      //preprocessing co-ordinates using 2 maps\\n       map<pair<int,int>,int> m1; // pre-processing usage\\n       unordered_map<int,pair<int,int>> m2; // pre-processing usage\\n       unordered_map<int,int>row,column; //row & column map for x-axis & y-axis of the arr[i] respectively.\\n       //vector<vector<int>> x=mat; // we pass this 2D vector to that private function (TLE)\\n       for(int i=0;i<m;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               m1[{i,j}]=mat[i][j]; //map of pair of co-ordinates pre-processing\\n           }\\n       }\\n       for(auto it:m1)\\n    {\\n        m2.insert({it.second,{it.first.first,it.first.second}}); //same map but reversed for easier traversal\\n    }\\n    m1.clear();\\n    int a=0,b=0;\\n    for(int i=0;i<arr.size();i++)\\n    {\\n\\n        if(m2.find(arr[i])!=m2.end())\\n        {\\n             a = m2[arr[i]].first; //abscissa\\n             b = m2[arr[i]].second; //ordinate\\n            if(row[a]==n-1||column[b]==m-1){return i;}\\n            //x[a][b]=0; //TLE condition. This line colours the co-ordinates replacing the actual value with 0.\\n            row[a]++;column[b]++;\\n            //if(i>=m-1||i>=n-1){\\n            //if(checkRow(x,a)||checkColumn(x,b)){return i;}}//TLE CASE\\n        }\\n    }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n/*This private section has 2 functions that checks the matrix\\'s specified row and column for colouring (zero) in other words. But it runs for 1021/1057 testcases and gives TLE right-after so we tackle this problem in a different way using hash-table for individual row and column after pre-processing the co-ordinates in another map.*/\\n\\n/*private: \\n    bool checkRow(vector<vector<int>> mat, int row)\\n    {\\n        int f=0, l=mat[0].size()-1;\\n        while(f<=l)  \\n        {\\n            if(mat[row][f++]!=0 || mat[row][l--]!=0 ){return false;}\\n        }\\n        return true;\\n    }\\n    bool checkColumn(vector<vector<int>> mat, int column)\\n    {\\n        int f=0, l=mat.size()-1;\\n        while(f<=l) \\n        {\\n            if(mat[f++][column]!=0 || mat[l--][column]!=0){return false;}\\n        }\\n        return true;\\n    }*/\\n\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n      int m = mat.size();\\n      int n = mat[0].size();\\n      //preprocessing co-ordinates using 2 maps\\n       map<pair<int,int>,int> m1; // pre-processing usage\\n       unordered_map<int,pair<int,int>> m2; // pre-processing usage\\n       unordered_map<int,int>row,column; //row & column map for x-axis & y-axis of the arr[i] respectively.\\n       //vector<vector<int>> x=mat; // we pass this 2D vector to that private function (TLE)\\n       for(int i=0;i<m;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               m1[{i,j}]=mat[i][j]; //map of pair of co-ordinates pre-processing\\n           }\\n       }\\n       for(auto it:m1)\\n    {\\n        m2.insert({it.second,{it.first.first,it.first.second}}); //same map but reversed for easier traversal\\n    }\\n    m1.clear();\\n    int a=0,b=0;\\n    for(int i=0;i<arr.size();i++)\\n    {\\n\\n        if(m2.find(arr[i])!=m2.end())\\n        {\\n             a = m2[arr[i]].first; //abscissa\\n             b = m2[arr[i]].second; //ordinate\\n            if(row[a]==n-1||column[b]==m-1){return i;}\\n            //x[a][b]=0; //TLE condition. This line colours the co-ordinates replacing the actual value with 0.\\n            row[a]++;column[b]++;\\n            //if(i>=m-1||i>=n-1){\\n            //if(checkRow(x,a)||checkColumn(x,b)){return i;}}//TLE CASE\\n        }\\n    }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512181,
                "title": "javascript-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nconst firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  // create an array to store the coordinates of all elements in the matrix\\n  const coordinates = Array(m * n + 1);\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      coordinates[mat[i][j]] = [i, j];\\n    }\\n  }\\n\\n  // create two arrays to store the remaining count of elements in each row and column\\n  const rowCount = Array(m).fill(n);\\n  const colCount = Array(n).fill(m);\\n\\n  // iterate through the array of numbers and update the row and column counts\\n  for (let i = 0; i < m * n; i++) {\\n    const [row, col] = coordinates[arr[i]];\\n    if (--rowCount[row] === 0 || --colCount[col] === 0) {\\n      // if any row or column has no remaining elements, return the current index\\n      return i;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nconst firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  // create an array to store the coordinates of all elements in the matrix\\n  const coordinates = Array(m * n + 1);\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      coordinates[mat[i][j]] = [i, j];\\n    }\\n  }\\n\\n  // create two arrays to store the remaining count of elements in each row and column\\n  const rowCount = Array(m).fill(n);\\n  const colCount = Array(n).fill(m);\\n\\n  // iterate through the array of numbers and update the row and column counts\\n  for (let i = 0; i < m * n; i++) {\\n    const [row, col] = coordinates[arr[i]];\\n    if (--rowCount[row] === 0 || --colCount[col] === 0) {\\n      // if any row or column has no remaining elements, return the current index\\n      return i;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3511840,
                "title": "brute-force-method",
                "content": "### STORE EVERY MATRIX ELEMENT WITH ITS ROW AND COL AS A HEY VALUE PAIR ITERATE THROUGH THE GIVEN ARR AND KEEP A ROW_ARR AND COL_ARR TO VALUATE THE MAX_VAL IN THEM ,IF THE MAX VALUE IS ACHIEVED THEN THE ARR[I] IS THE ANSWER.\\n\\n#### DONT ASK ME WHY I USED DEFAULTDICT(LIST) , BECAUSE I WAS LEARING GRAPH PROBLEMS FOR ADJ_LIST ,IT BECAME HANDY\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        hash_map=defaultdict(list)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                hash_map[mat[i][j]].append([i,j])\\n        \\n        row_mat=[0 for i in range(m)]\\n        \\n        col_mat=[0 for i in range(n)]\\n        \\n        for i in range(len(arr)):\\n            k=hash_map[arr[i]]\\n            \\n            row_mat[k[0][0]]+=1\\n            col_mat[k[0][1]]+=1\\n            \\n            if row_mat[k[0][0]]==n or col_mat[k[0][1]]==m:\\n                return i\\n```\\n\\n# HAPPY  LEETCODING!",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        hash_map=defaultdict(list)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                hash_map[mat[i][j]].append([i,j])\\n        \\n        row_mat=[0 for i in range(m)]\\n        \\n        col_mat=[0 for i in range(n)]\\n        \\n        for i in range(len(arr)):\\n            k=hash_map[arr[i]]\\n            \\n            row_mat[k[0][0]]+=1\\n            col_mat[k[0][1]]+=1\\n            \\n            if row_mat[k[0][0]]==n or col_mat[k[0][1]]==m:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507625,
                "title": "java-solution-that-keeps-track-of-the-number-of-elements-colored-in-any-row-or-any-column",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially create a 2Darray that keeps record of row number and column number of a particular value that lies in the range 1 to m*n present in mat[][].\\nCreate two arrays that will keep track of the number of elements colored in ith row and ith column.\\nif ith row or ith column becomes fully colored, we stop our traversal.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[][] array = new int[arr.length+1][2];\\n        for(int i = 0 ; i<mat.length ; i++){\\n            for(int j = 0 ; j<mat[0].length ; j++){\\n                array[mat[i][j]][0] = i; \\n                array[mat[i][j]][1] = j; \\n            }\\n        }\\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n\\n        for(int i = 0 ; i<arr.length ; i++){\\n            int r = array[arr[i]][0];\\n            int c = array[arr[i]][1];\\n            rows[r]++;\\n            cols[c]++;\\n            if(rows[r] == mat[0].length || cols[c] == mat.length){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[][] array = new int[arr.length+1][2];\\n        for(int i = 0 ; i<mat.length ; i++){\\n            for(int j = 0 ; j<mat[0].length ; j++){\\n                array[mat[i][j]][0] = i; \\n                array[mat[i][j]][1] = j; \\n            }\\n        }\\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n\\n        for(int i = 0 ; i<arr.length ; i++){\\n            int r = array[arr[i]][0];\\n            int c = array[arr[i]][1];\\n            rows[r]++;\\n            cols[c]++;\\n            if(rows[r] == mat[0].length || cols[c] == mat.length){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503655,
                "title": "easy-hash-table-implementation-cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The solution starts by creating two vectors, rowsum and columnsum, that will store the sum of each row and column in the matrix, respectively.\\n\\nThe first for loop iterates through each row of the matrix, calculates the sum of the row elements and pushes the result into the rowsum vector.\\n\\nThe second for loop iterates through each column of the matrix, calculates the sum of the column elements and pushes the result into the columnsum vector.\\n\\nNext, the solution creates a vector of pairs v that stores the coordinates of each element in the matrix with respect to the original vector arr. The index of each element in arr is used as the key to store its coordinates in the matrix in the form of a pair of integers representing the row and column indices.\\n\\nFinally, the solution iterates through each element of arr. For each element, it subtracts its value from the corresponding row and column sums using the coordinates stored in the v vector. If the resulting row or column sum is zero, it means that the row or column is complete, and the index of the element in arr is returned. If no complete row or column is found, the function returns zero.\\n\\nOverall, the solution works by using the rowsum and columnsum vectors to efficiently check for complete rows and columns in the matrix and by using the v vector to quickly look up the coordinates of each element in arr in the matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The time complexity of the given solution is O(n^2), where n is the length of the input vector arr. This is because the solution involves iterating over all the elements in the matrix twice to calculate the row and column sums, and then iterating over all the elements in arr once to check for complete rows and columns.\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The space complexity of the solution is O(n+m), where m is the size of the matrix. This is because the solution creates two vectors, rowsum and columnsum, of size m to store the row and column sums, respectively. It also creates a vector of pairs v of size n+1 to store the coordinates of each element in arr. The overall space complexity is dominated by the v vector, which grows with the size of the input vector arr.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<long long>rowsum;\\n        for(int i=0;i<mat.size();i++){\\n            long long temp=0;\\n              for(int j=0;j<mat[i].size();j++){\\n                 temp+=mat[i][j];\\n            }\\n            rowsum.push_back(temp);\\n        }\\n          vector<long long>columnsum;\\n        for(int i=0;i<mat[0].size();i++){\\n            long long temp=0;\\n              for(int j=0;j<mat.size();j++){\\n                 temp+=mat[j][i];\\n            }\\n            columnsum.push_back(temp);\\n        }\\n        vector<pair<int,int>>v(arr.size()+1);\\n        for(int i=0;i<mat.size();i++){\\n              for(int j=0;j<mat[i].size();j++){\\n                 v[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            rowsum[v[arr[i]].first]-=arr[i];\\n            columnsum[v[arr[i]].second]-=arr[i];\\n           if(rowsum[v[arr[i]].first]==0 ||  columnsum[v[arr[i]].second]==0 ) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<long long>rowsum;\\n        for(int i=0;i<mat.size();i++){\\n            long long temp=0;\\n              for(int j=0;j<mat[i].size();j++){\\n                 temp+=mat[i][j];\\n            }\\n            rowsum.push_back(temp);\\n        }\\n          vector<long long>columnsum;\\n        for(int i=0;i<mat[0].size();i++){\\n            long long temp=0;\\n              for(int j=0;j<mat.size();j++){\\n                 temp+=mat[j][i];\\n            }\\n            columnsum.push_back(temp);\\n        }\\n        vector<pair<int,int>>v(arr.size()+1);\\n        for(int i=0;i<mat.size();i++){\\n              for(int j=0;j<mat[i].size();j++){\\n                 v[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            rowsum[v[arr[i]].first]-=arr[i];\\n            columnsum[v[arr[i]].second]-=arr[i];\\n           if(rowsum[v[arr[i]].first]==0 ||  columnsum[v[arr[i]].second]==0 ) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501710,
                "title": "very-solution-c",
                "content": "# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<int> row(mat.size(),0) , col(mat[0].size(),0);\\n        vector<pair<int,int>> ind(mat.size()*mat[0].size()+1);\\n        for(int i=0;i<mat.size();i++)\\n            for(int j=0;j<mat[0].size();j++) ind[mat[i][j]] = {i,j};\\n        // Now choose elements from arr and then update row and col\\n        for(int i=0;i<arr.size();i++){\\n            // we get elements\\n            row[ind[arr[i]].first]++;\\n            col[ind[arr[i]].second]++;\\n            if(row[ind[arr[i]].first] == mat[0].size() || col[ind[arr[i]].second] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<int> row(mat.size(),0) , col(mat[0].size(),0);\\n        vector<pair<int,int>> ind(mat.size()*mat[0].size()+1);\\n        for(int i=0;i<mat.size();i++)\\n            for(int j=0;j<mat[0].size();j++) ind[mat[i][j]] = {i,j};\\n        // Now choose elements from arr and then update row and col\\n        for(int i=0;i<arr.size();i++){\\n            // we get elements\\n            row[ind[arr[i]].first]++;\\n            col[ind[arr[i]].second]++;\\n            if(row[ind[arr[i]].first] == mat[0].size() || col[ind[arr[i]].second] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500821,
                "title": "hashmap-solution",
                "content": "```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let m = mat.count\\n        let n = mat[0].count\\n        \\n        var rows = Array(repeating: n, count: m)\\n        var cols = Array(repeating: m, count: n)\\n        \\n        var map = [Int: [Int]]()\\n        for r in 0..<m {\\n            for c in 0..<n {\\n                map[mat[r][c]] = [r,c]\\n            }\\n        }\\n        \\n        for i in 0..<m*n {\\n            if let pairs = map[arr[i]] {\\n                let r = pairs[0]\\n                let c = pairs[1]\\n                rows[r] -= 1\\n                if rows[r] == 0 { return i }\\n                cols[c] -= 1\\n                if cols[c] == 0 { return i }\\n            }\\n        }\\n        return m*n-1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let m = mat.count\\n        let n = mat[0].count\\n        \\n        var rows = Array(repeating: n, count: m)\\n        var cols = Array(repeating: m, count: n)\\n        \\n        var map = [Int: [Int]]()\\n        for r in 0..<m {\\n            for c in 0..<n {\\n                map[mat[r][c]] = [r,c]\\n            }\\n        }\\n        \\n        for i in 0..<m*n {\\n            if let pairs = map[arr[i]] {\\n                let r = pairs[0]\\n                let c = pairs[1]\\n                rows[r] -= 1\\n                if rows[r] == 0 { return i }\\n                cols[c] -= 1\\n                if cols[c] == 0 { return i }\\n            }\\n        }\\n        return m*n-1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500387,
                "title": "c-clean-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->        \\n    O(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->                  \\nO(M*N)+O(M*N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        map<string,int> mp;\\n        map<int,pair<string,string>>f;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                f[mat[i][j]]={to_string(i)+\\'R\\',to_string(j)+\\'C\\'};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            mp[f[arr[i]].first]++;\\n            mp[f[arr[i]].second]++;\\n            if(mp[f[arr[i]].first]==n || mp[f[arr[i]].second]==m){\\n                return i;\\n            }\\n            \\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        map<string,int> mp;\\n        map<int,pair<string,string>>f;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                f[mat[i][j]]={to_string(i)+\\'R\\',to_string(j)+\\'C\\'};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            mp[f[arr[i]].first]++;\\n            mp[f[arr[i]].second]++;\\n            if(mp[f[arr[i]].first]==n || mp[f[arr[i]].second]==m){\\n                return i;\\n            }\\n            \\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498981,
                "title": "simple-java-solution-by-creating-a-map-for-each-number-with-o-n2-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Simple Java Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Map the cordinates of each number in the mat array,\\n    Create a row and column array which will keep track of the number of element elements colored in that row or column.\\n    Traverse the array arr and keep increment the row and column values of the repective arrays and whenever any of them becomes equal to max return the index.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int len = n * m;\\n        final int RSUM = m;\\n        final int CSUM = n;\\n        int[][] cor = new int[len+1][2];\\n        \\n        int[] rowSum = new int[n];\\n        int[] colSum = new int[m];\\n\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val = mat[i][j];\\n                cor[val] = new int[]{i,j};\\n            }\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            int val = arr[i];\\n            int r = cor[val][0];\\n            int c = cor[val][1];\\n            \\n            rowSum[r]++;\\n            colSum[c]++;\\n            \\n            if(rowSum[r] >= RSUM || colSum[c] >= CSUM)\\n                return i;\\n        }\\n        return len-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int len = n * m;\\n        final int RSUM = m;\\n        final int CSUM = n;\\n        int[][] cor = new int[len+1][2];\\n        \\n        int[] rowSum = new int[n];\\n        int[] colSum = new int[m];\\n\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val = mat[i][j];\\n                cor[val] = new int[]{i,j};\\n            }\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            int val = arr[i];\\n            int r = cor[val][0];\\n            int c = cor[val][1];\\n            \\n            rowSum[r]++;\\n            colSum[c]++;\\n            \\n            if(rowSum[r] >= RSUM || colSum[c] >= CSUM)\\n                return i;\\n        }\\n        return len-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497147,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n\\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i = 0;i<mat.size();i++){\\n\\n            for(int j = 0;j<mat[i].size();j++){\\n\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        int res = 1e9;\\n\\n        for(int i = 0;i<arr.size();i++){\\n\\n            pair<int,int>p  = mp[arr[i]];\\n            \\n            row[p.first]++;\\n            col[p.second]++;\\n            if(row[p.first]==n || col[p.second]==m){\\n\\n                res = min(res,i);\\n            }\\n            \\n        }\\n\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n\\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i = 0;i<mat.size();i++){\\n\\n            for(int j = 0;j<mat[i].size();j++){\\n\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        int res = 1e9;\\n\\n        for(int i = 0;i<arr.size();i++){\\n\\n            pair<int,int>p  = mp[arr[i]];\\n            \\n            row[p.first]++;\\n            col[p.second]++;\\n            if(row[p.first]==n || col[p.second]==m){\\n\\n                res = min(res,i);\\n            }\\n            \\n        }\\n\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496407,
                "title": "java-4ms-beats-98-and-clean-code",
                "content": "# Approach\\n1. A brute force attempt would mean you traverse arr, find element i in matrix O (n*m), color it then check if whole row or column is painted O (n+m).\\n2. You can optimize it by knowing WHERE exactly where each element is in the matrix.\\n    - Declare an int[n*m + 1] and store the prefixed order of each element:\\n    The last element in a n*m matrix would be mapped against the position n*m in the position array.\\n    EG: mat [[4,3],[1,2]] => int[] pos of size 5\\n    - 4 will be mapped as pos 0: pos[4] = 0;\\n    - 3 -> pos 1:  pos[3] = 1\\n    - 1 -> pos 2: pos[1] = 2\\n    - 2 -> pos 3: pos[2] = 3\\n3. This way, if we want to color element 1, we look at pos[1] = 2.\\n    - 2 / 2 = 1 => row 1 (i) - see point #5 & 6\\n    - 2 % 2 = 0 => col 0. (j) - see point #5 & 6\\n4. Furthermore, we don\\'t really need to \"paint\" the matrix and traverse whole row/col and count the number of painted cells. We can keep track of how many painted cells are in each row/ column\\n5. Declare an int[mat.length] coloredRows and int[mat[0].length] coloredColumns.\\n6. Using the info from #3, increment coloredRows[1]++ and coloredColumns[0]++.\\n    If coloredRows[i] == numberOfColumns (all columns are painted on that row) OR coloredColumns[j] == numberOfRows (all rows are colored for that column) return index of arr. \\n\\n# Complexity\\n- Time complexity:$$O(n*m + a)$$ a - size of arr\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*m + n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int rows = mat.length, cols = mat[0].length;\\n        int[] coloredRows = new int[rows];\\n        int[] coloredColumns = new int[cols];\\n        int[] matPositions = getMatPositions(mat);\\n        int rowToPaint, colToPaint;\\n        for (int i = 0; i < arr.length; i++) {\\n            rowToPaint = matPositions[arr[i]] / cols;\\n            colToPaint = matPositions[arr[i]] % cols;\\n            if (++coloredRows[rowToPaint] == cols || ++coloredColumns[colToPaint] == rows) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] getMatPositions(int[][] mat) {\\n        int[] positions = new int[mat.length * mat[0].length + 1];\\n        int pos = 0;\\n        for (int[] row : mat) {\\n            for (int num : row) {\\n                positions[num] = pos++;      \\n            }\\n        }\\n        return positions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int rows = mat.length, cols = mat[0].length;\\n        int[] coloredRows = new int[rows];\\n        int[] coloredColumns = new int[cols];\\n        int[] matPositions = getMatPositions(mat);\\n        int rowToPaint, colToPaint;\\n        for (int i = 0; i < arr.length; i++) {\\n            rowToPaint = matPositions[arr[i]] / cols;\\n            colToPaint = matPositions[arr[i]] % cols;\\n            if (++coloredRows[rowToPaint] == cols || ++coloredColumns[colToPaint] == rows) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] getMatPositions(int[][] mat) {\\n        int[] positions = new int[mat.length * mat[0].length + 1];\\n        int pos = 0;\\n        for (int[] row : mat) {\\n            for (int num : row) {\\n                positions[num] = pos++;      \\n            }\\n        }\\n        return positions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494464,
                "title": "java-solution-with-integer-array-as-map",
                "content": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int numRows = mat.length, numCols = mat[0].length;\\n        int[] sumRows = new int[numRows];\\n        int[] sumCols = new int[numCols];\\n\\n        List<Integer>[] map = new ArrayList[(numRows * numCols) + 1];\\n        for (int i = 0; i < map.length; i++) {\\n            map[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                int value = mat[i][j];\\n                map[value] = new ArrayList<>();\\n                map[value].add(i);\\n                map[value].add(j);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int arrVal = arr[i];\\n            int rowOfArrVal = map[arrVal].get(0);\\n            int colOfArrVal = map[arrVal].get(1);\\n            sumRows[rowOfArrVal]++;\\n            sumCols[colOfArrVal]++;\\n            if (sumRows[rowOfArrVal] == numCols || sumCols[colOfArrVal] == numRows) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int numRows = mat.length, numCols = mat[0].length;\\n        int[] sumRows = new int[numRows];\\n        int[] sumCols = new int[numCols];\\n\\n        List<Integer>[] map = new ArrayList[(numRows * numCols) + 1];\\n        for (int i = 0; i < map.length; i++) {\\n            map[i] = new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3494130,
                "title": "ruby-solution-beats-100-100",
                "content": "```\\n# @param {Integer[]} arr\\n# @param {Integer[][]} mat\\n# @return {Integer}\\ndef first_complete_index(arr, mat)\\n  n = mat.size\\n  m = mat[0].size\\n  h = Array.new(n * m + 1)\\n\\n  mat.each_with_index do |r, i|\\n    r.each_with_index do |x, j|\\n      h[x] = i * m + j\\n    end\\n  end\\n\\n  rc = Array.new(m, n)\\n  cc = Array.new(n, m)\\n\\n  arr.find_index do |x|\\n    i, j = h[x].divmod(m)\\n    (rc[j] -= 1) == 0 || (cc[i] -= 1) == 0\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} arr\\n# @param {Integer[][]} mat\\n# @return {Integer}\\ndef first_complete_index(arr, mat)\\n  n = mat.size\\n  m = mat[0].size\\n  h = Array.new(n * m + 1)\\n\\n  mat.each_with_index do |r, i|\\n    r.each_with_index do |x, j|\\n      h[x] = i * m + j\\n    end\\n  end\\n\\n  rc = Array.new(m, n)\\n  cc = Array.new(n, m)\\n\\n  arr.find_index do |x|\\n    i, j = h[x].divmod(m)\\n    (rc[j] -= 1) == 0 || (cc[i] -= 1) == 0\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3494107,
                "title": "c-solution-using-hashmaps-faster-and-very-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> index;\\n        int m = mat.size(),n = mat[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                index[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        unordered_map<int,int> rowFilledCnt,colFilledCnt;\\n        int ans = -1;\\n        for(int i=0;i<arr.size();i++){\\n            int x = index[arr[i]].first, y = index[arr[i]].second;\\n            rowFilledCnt[x]++;\\n            colFilledCnt[y]++;\\n            \\n            if(rowFilledCnt[x] == n || colFilledCnt[y] == m){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> index;\\n        int m = mat.size(),n = mat[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                index[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        unordered_map<int,int> rowFilledCnt,colFilledCnt;\\n        int ans = -1;\\n        for(int i=0;i<arr.size();i++){\\n            int x = index[arr[i]].first, y = index[arr[i]].second;\\n            rowFilledCnt[x]++;\\n            colFilledCnt[y]++;\\n            \\n            if(rowFilledCnt[x] == n || colFilledCnt[y] == m){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494052,
                "title": "simple-c-map-solution-easily-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size() , n = mat[0].size() ;\\n        unordered_map<int , pair<int , int>> mp ;\\n        unordered_map<int , int> mp1 , mp2 ;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++)\\n            mp[mat[i][j]] = {i , j} ;\\n        }\\n\\n        for(int i = 0 ; i < arr.size() ; i++){\\n           int row = mp[arr[i]].first , col = mp[arr[i]].second ;\\n           mp1[row]++ ;\\n           mp2[col]++ ;\\n           if(mp1[row] == n || mp2[col] == m) return i ;\\n        }\\n        return arr.size() - 1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size() , n = mat[0].size() ;\\n        unordered_map<int , pair<int , int>> mp ;\\n        unordered_map<int , int> mp1 , mp2 ;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++)\\n            mp[mat[i][j]] = {i , j} ;\\n        }\\n\\n        for(int i = 0 ; i < arr.size() ; i++){\\n           int row = mp[arr[i]].first , col = mp[arr[i]].second ;\\n           mp1[row]++ ;\\n           mp2[col]++ ;\\n           if(mp1[row] == n || mp2[col] == m) return i ;\\n        }\\n        return arr.size() - 1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493472,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n       HashMap<Integer,Integer> hmc = new HashMap<>();\\n       HashMap<Integer,Integer> hmr = new HashMap<>();\\n       HashMap<Integer,int[]> hmElement = new HashMap<>();\\n       int sum=0;\\n\\n       //row\\n       for(int i=0;i<mat.length;i++)\\n       {\\n           for(int j=0;j<mat[0].length;j++)\\n           {\\n               sum=sum+mat[i][j];\\n               hmElement.put(mat[i][j],new int[]{i,j});\\n           }\\n           hmr.put(i,sum);\\n           sum=0;\\n       }\\n\\n        //col\\n        sum=0;\\n       for(int i=0;i<mat[0].length;i++)\\n       {\\n           for(int j=0;j<mat.length;j++)\\n           {\\n               sum=sum+mat[j][i];           }\\n           hmc.put(i,sum);\\n           sum=0;\\n       }\\n\\n       for(int i=0;i<arr.length;i++)\\n       {\\n           int[] temp = hmElement.get(arr[i]);\\n           int r = temp[0];\\n           int c = temp[1];\\n           int sumr = hmr.get(r);\\n           int sumc = hmc.get(c);\\n           sumr=sumr-arr[i];\\n           if(sumr==0)\\n           return i;\\n           sumc=sumc-arr[i];\\n           if(sumc==0)\\n           return i;\\n           hmr.put(r,sumr);\\n           hmc.put(c,sumc);\\n       }\\n       return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n       HashMap<Integer,Integer> hmc = new HashMap<>();\\n       HashMap<Integer,Integer> hmr = new HashMap<>();\\n       HashMap<Integer,int[]> hmElement = new HashMap<>();\\n       int sum=0;\\n\\n       //row\\n       for(int i=0;i<mat.length;i++)\\n       {\\n           for(int j=0;j<mat[0].length;j++)\\n           {\\n               sum=sum+mat[i][j];\\n               hmElement.put(mat[i][j],new int[]{i,j});\\n           }\\n           hmr.put(i,sum);\\n           sum=0;\\n       }\\n\\n        //col\\n        sum=0;\\n       for(int i=0;i<mat[0].length;i++)\\n       {\\n           for(int j=0;j<mat.length;j++)\\n           {\\n               sum=sum+mat[j][i];           }\\n           hmc.put(i,sum);\\n           sum=0;\\n       }\\n\\n       for(int i=0;i<arr.length;i++)\\n       {\\n           int[] temp = hmElement.get(arr[i]);\\n           int r = temp[0];\\n           int c = temp[1];\\n           int sumr = hmr.get(r);\\n           int sumc = hmc.get(c);\\n           sumr=sumr-arr[i];\\n           if(sumr==0)\\n           return i;\\n           sumc=sumc-arr[i];\\n           if(sumc==0)\\n           return i;\\n           hmr.put(r,sumr);\\n           hmc.put(c,sumc);\\n       }\\n       return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493362,
                "title": "c-simple-map-solution-with-explanation",
                "content": "# Intuition\\nThe given solution uses an unordered map mp to store the positions of all the elements of mat.\\n\\nThen, two vectors row and col are created to keep track of the count of painted cells in each row and column of mat.\\n\\nWe iterate through each element of arr, retrieves its position from mp, and increments the corresponding rows and columns in row and col. Then, we checks if any row or column is completely painted. If a row or column is completely painted, it returns the index of the current element of arr. Otherwise, it continues to the next element of arr.\\n\\n# Approach\\n1. Create an unordered map mp to store the positions of all the elements of mat as a pair of row and column indices.\\n2. Create two vectors row and col of size n and m respectively, initialized to 0.\\n3. Iterate through all the elements of mat and store their positions in mp.\\n4. Iterate through each element of arr.\\n5. Retrieve the position of the current element of arr from mp.\\n6. Increment the corresponding rows and columns in row and col.\\n7. Check if any row or column is completely painted. If a row or column is completely painted, return the index of the current element of arr.\\n8. If no row or column is completely painted after processing all the elements of arr, return -1.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, pair<int, int>> mp;\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row(n), col(m);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                mp[mat[i][j]] = {i, j};\\n            }\\n        }\\n        for(int i = 0, sz = arr.size(); i < sz; i++){\\n            auto [f, s] = mp[arr[i]];\\n            row[f]++;\\n            col[s]++;\\n            if(row[f] == m or col[s] == n) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, pair<int, int>> mp;\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row(n), col(m);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                mp[mat[i][j]] = {i, j};\\n            }\\n        }\\n        for(int i = 0, sz = arr.size(); i < sz; i++){\\n            auto [f, s] = mp[arr[i]];\\n            row[f]++;\\n            col[s]++;\\n            if(row[f] == m or col[s] == n) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493009,
                "title": "java-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) map.put(mat[i][j], new int[]{i, j});\\n        }\\n        int row[] = new int[m];\\n        int col[] = new int[n];\\n        for (int i = 0; i < arr.length; i++) {\\n            int position[] = map.get(arr[i]);\\n            int x = position[0];\\n            int y = position[1];\\n            row[x]++;\\n            col[y]++;\\n            if (row[x] == n || col[y] == m) return i;\\n        }\\n        return arr.length-1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) map.put(mat[i][j], new int[]{i, j});\\n        }\\n        int row[] = new int[m];\\n        int col[] = new int[n];\\n        for (int i = 0; i < arr.length; i++) {\\n            int position[] = map.get(arr[i]);\\n            int x = position[0];\\n            int y = position[1];\\n            row[x]++;\\n            col[y]++;\\n            if (row[x] == n || col[y] == m) return i;\\n        }\\n        return arr.length-1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492574,
                "title": "javascrip-map-solution",
                "content": "# Intuition\\nSimple iteration with optionmization\\n\\n# Approach\\nSotre indexes [i,j] for every element from matrix. For every element from array, get it\\'s position in matrix. Increase number of elements visited from ith row and jth column, check if row or column fully visited.\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n    const n = mat.length;\\n    const m = mat[0].length;\\n    let map = new Map();\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            map.set(mat[i][j], [i, j])\\n        }\\n    }\\n    \\n    let rows = (new Array(n)).fill(0);\\n    let cols = (new Array(m)).fill(0);\\n    \\n    for(let k = 0; k < arr.length; k++){\\n        let num = arr[k]\\n        let [i, j] = map.get(num);\\n        rows[i]++;\\n        if(rows[i] === m){\\n            return k\\n        }\\n        cols[j]++\\n        if(cols[j] === n){\\n            return k\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n    const n = mat.length;\\n    const m = mat[0].length;\\n    let map = new Map();\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            map.set(mat[i][j], [i, j])\\n        }\\n    }\\n    \\n    let rows = (new Array(n)).fill(0);\\n    let cols = (new Array(m)).fill(0);\\n    \\n    for(let k = 0; k < arr.length; k++){\\n        let num = arr[k]\\n        let [i, j] = map.get(num);\\n        rows[i]++;\\n        if(rows[i] === m){\\n            return k\\n        }\\n        cols[j]++\\n        if(cols[j] === n){\\n            return k\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492526,
                "title": "o-n-easy-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(N) where N is len of arr\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        __map_rc = defaultdict(int)\\n        __map = {}\\n        n = len(mat)\\n        m = len(mat[0])\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                __map[mat[i][j]] = (i,j)\\n        \\n        for i in range(len(arr)):\\n            num = arr[i]\\n            r, c = __map[num][0], __map[num][1]\\n\\n            __map_rc[\"r\" + str(r)] +=1\\n            __map_rc[\"c\" + str(c)] +=1\\n\\n            if  __map_rc[\"r\" + str(r)] == m or __map_rc[\"c\" + str(c)]== n:\\n                return i\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        __map_rc = defaultdict(int)\\n        __map = {}\\n        n = len(mat)\\n        m = len(mat[0])\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                __map[mat[i][j]] = (i,j)\\n        \\n        for i in range(len(arr)):\\n            num = arr[i]\\n            r, c = __map[num][0], __map[num][1]\\n\\n            __map_rc[\"r\" + str(r)] +=1\\n            __map_rc[\"c\" + str(c)] +=1\\n\\n            if  __map_rc[\"r\" + str(r)] == m or __map_rc[\"c\" + str(c)]== n:\\n                return i\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492067,
                "title": "hashmap-intuition-explained-java-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne way to approach this problem is to keep track of the number of painted cells in each row and column of the matrix `mat` as we iterate through the elements in `arr`. However, to determine the row and column of a given element in `mat`, we would need to search through the entire matrix each time, which would result in a time complexity of `O(k * m * n)`, where `k` is the length of `arr`.\\n\\nTo avoid this, we can use a `HashMap` to map each element in the matrix to its corresponding (row, column) pair. This way, we can quickly retrieve the (row, column) pair for a given element in `arr` by doing a constant-time lookup in the `HashMap`. Then, we can update the number of painted cells in the corresponding row and column of the matrix, and check if any row or column has been completely painted after each iteration through `arr`. If a row or column has been completely painted, we can return the index of the current iteration.\\n\\nOverall, this approach reduces the time complexity to `O(k + m * n)` by using a `HashMap` to avoid searching through the entire matrix for each element in `arr`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize integer variables `m` and `n` to the number of rows and columns in `mat`, respectively.\\n2. Initialize two integer arrays `rows` and `cols` of size `m` and `n`, respectively, to keep track of the number of painted cells in each row and column of `mat`.\\n3. Initialize a HashMap to map each element in `mat` to its corresponding (row, column) pair.\\n4. Iterate through the elements in `arr` using a for loop:\\n    1. Retrieve the corresponding (row, column) pair for the current element from the `HashMap`.\\n    2. Increment the count of the current row and column in the `rows` and `cols` arrays, respectively.\\n    3. Check if the count of the current row or column in the `rows` or `cols` arrays, respectively, is equal to the number of columns or rows in mat. If so, return the index of the current iteration.\\n5. If no row or column has been completely painted, return `-1`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(k + mn)$$, where `k` is the length of the `arr` array and `m` and `n` are the dimensions of the `mat` matrix. The time complexity is dominated by the for loop iterating through `arr`, which has a time complexity of $$O(k)$$. The `HashMap` lookup and array updates have a time complexity of $$O(1)$$ each, and iterating through the `mat` matrix to create the `HashMap` has a time complexity of $$O(mn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(mn)$$, for the `HashMap` to store the (row, column) pairs for each element in `mat`, and the `rows` and `cols` arrays to keep track of the number of painted cells in each row and column of `mat`.\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m =mat.length;\\n        int n= mat[0].length;\\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n\\n        HashMap<Integer, Pair> map =new HashMap<>();\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map.put(mat[i][j], new Pair(i,j));\\n            }\\n        }\\n\\n        for(int i =0;i<arr.length;i++){\\n            Pair p=map.get(arr[i]);\\n            int r = p.i;\\n            int c = p.j;\\n            rows[r]++;\\n            cols[c]++; \\n            if(rows[r]==n || cols[c]==m)\\n                return i;\\n        }\\n\\n        return -1;        \\n    }\\n}\\n\\nclass Pair {\\n    int i,j;\\n    Pair(){}\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m =mat.length;\\n        int n= mat[0].length;\\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n\\n        HashMap<Integer, Pair> map =new HashMap<>();\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map.put(mat[i][j], new Pair(i,j));\\n            }\\n        }\\n\\n        for(int i =0;i<arr.length;i++){\\n            Pair p=map.get(arr[i]);\\n            int r = p.i;\\n            int c = p.j;\\n            rows[r]++;\\n            cols[c]++; \\n            if(rows[r]==n || cols[c]==m)\\n                return i;\\n        }\\n\\n        return -1;        \\n    }\\n}\\n\\nclass Pair {\\n    int i,j;\\n    Pair(){}\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490791,
                "title": "easy-java-sol-easy-to-understand-code-hashtable",
                "content": "\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        int m = mat.length; int n = mat[0].length;\\n        for(int i = 1; i <= m*n; i++){\\n            map.put(i,new int[2]);\\n        }\\n\\n        for(int r = 0; r < mat.length; r++){\\n            for(int c = 0; c < mat[0].length; c++){\\n                map.get(mat[r][c])[0] = r;\\n                map.get(mat[r][c])[1] = c;\\n            }\\n        }\\n        \\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n        for(int i = 0; i < arr.length; i++){\\n            rows[map.get(arr[i])[0]]++;\\n            cols[map.get(arr[i])[1]]++;\\n            if(rows[map.get(arr[i])[0]] == n || cols[map.get(arr[i])[1]] == m){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        int m = mat.length; int n = mat[0].length;\\n        for(int i = 1; i <= m*n; i++){\\n            map.put(i,new int[2]);\\n        }\\n\\n        for(int r = 0; r < mat.length; r++){\\n            for(int c = 0; c < mat[0].length; c++){\\n                map.get(mat[r][c])[0] = r;\\n                map.get(mat[r][c])[1] = c;\\n            }\\n        }\\n        \\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n        for(int i = 0; i < arr.length; i++){\\n            rows[map.get(arr[i])[0]]++;\\n            cols[map.get(arr[i])[1]]++;\\n            if(rows[map.get(arr[i])[0]] == n || cols[map.get(arr[i])[1]] == m){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490027,
                "title": "simple-c-solution-using-map",
                "content": "# Intuition\\n###### In this problem we need to find the first row or column to be fully painted, so we can think of iterating over the array checking each time whether any row or column is fully painted or not.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First we declare 2 frequency vectors for checking whether the row or column is fully painted or not and a map.\\n\\n2. Now in order to check for every row or column for fully painted we can use a map to store the index of row and column simultaneouly corresponding to the element value. \\n\\nFor Eg.   m[1] = {0, 0} meaning for the value of element 1 we store the index of row and column i.e. 0.\\n\\n3. When iterating the array we keep updating the index of the row and the column in their corresponding frequency vectors.\\n\\n4. After each updation we check whether the frequency of any row vector element equals to column size or vice versa. \\n\\n5. After it becomes equal we just simply return the index of that particular iteration.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n) + O(n) + O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        map<int, pair<int, int>> mp;\\n        vector<int> r(n, 0), c(m, 0); //Frequency Array for checking completely painted row or column\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                mp[mat[i][j]] = {i, j}; //Mapping row and column value to the element\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<arr.size();i++){\\n            r[mp[arr[i]].first]++;\\n            c[mp[arr[i]].second]++;\\n\\n            if(r[mp[arr[i]].first] == m || c[mp[arr[i]].second] == n){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        map<int, pair<int, int>> mp;\\n        vector<int> r(n, 0), c(m, 0); //Frequency Array for checking completely painted row or column\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                mp[mat[i][j]] = {i, j}; //Mapping row and column value to the element\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<arr.size();i++){\\n            r[mp[arr[i]].first]++;\\n            c[mp[arr[i]].second]++;\\n\\n            if(r[mp[arr[i]].first] == m || c[mp[arr[i]].second] == n){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488887,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\n    struct helper{\\n        int row;\\n        int col;\\n    };\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        const int M = mat.size();\\n        const int N = mat[0].size();\\n        \\n        vector<int> rows(M, N);\\n        vector<int> columns(N, M);\\n                \\n        unordered_map<int, helper> lookup;\\n        for(int r = 0; r < M; ++r) {\\n            for(int c = 0; c < N; ++c) {\\n                lookup[mat[r][c]] = {r,c};\\n            }\\n        }\\n        \\n        for(int i = 0; i < M * N; ++i) {\\n            const auto &coord = lookup[arr[i]];\\n            if(--rows[coord.row] == 0 || --columns[coord.col] == 0) {\\n                return i;\\n            }\\n        }\\n        return M * N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct helper{\\n        int row;\\n        int col;\\n    };\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        const int M = mat.size();\\n        const int N = mat[0].size();\\n        \\n        vector<int> rows(M, N);\\n        vector<int> columns(N, M);\\n                \\n        unordered_map<int, helper> lookup;\\n        for(int r = 0; r < M; ++r) {\\n            for(int c = 0; c < N; ++c) {\\n                lookup[mat[r][c]] = {r,c};\\n            }\\n        }\\n        \\n        for(int i = 0; i < M * N; ++i) {\\n            const auto &coord = lookup[arr[i]];\\n            if(--rows[coord.row] == 0 || --columns[coord.col] == 0) {\\n                return i;\\n            }\\n        }\\n        return M * N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487440,
                "title": "simple-code-with-approach-and-step-by-step-explaination",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] rowCount = new int[m];\\n        int[] colCount = new int[n];\\n        var matLookup = new HashMap<Integer, int[]>();//number vs (mat -> row,col)\\n\\n        //let\\'s fill the map\\n        for(int row = 0; row < m; row++){\\n            for(int col = 0; col < n; col++){\\n                matLookup.put(mat[row][col], new int[]{row, col});\\n            }\\n        }\\n\\n        //let\\'s iterate over the num array and find out its occurance in the mat \\n        for(int i = 0; i < arr.length; i++){\\n            //fetch the position .i.e row and col pos in the mat for the curr num\\n            int currNum = arr[i];\\n            int rowIdx = matLookup.get(currNum)[0];\\n            int colIdx = matLookup.get(currNum)[1];\\n            //since we know we have to paint the cell\\n            //we also upadate the number of painted rows and cols at that specific row and col \\n            rowCount[rowIdx]++;\\n            colCount[colIdx]++;\\n            //now let\\'s try to see if at this time we have a fully painted row or a col\\n            if(rowCount[rowIdx] == n || colCount[colIdx] == m)\\n                return i;\\n        }\\n\\n        return -1;\\n\\n    }\\n}\\n\\n/**\\n\\nrow = [1,1,2]\\n       0,1,2\\ncol = [1,3,0]\\n       0,1,2\\n\\nif(col[i] == m(rowcount) || row[i] == n(col count))\\n    return the curr Idx\\n\\n\\nApproach: \\n* Since all the nums in mat is unique we fill a map of num vs tuple(row,col)\\n* we iterate over the arr\\n* we fetch the occurance of arr[i] from the map and update it row and col count by 1\\n* each time at the end of the loop we check if there is some col or row which are all painted\\n* if yes we return the i;\\n\\nTC: O(N) + O(Mat)\\nSC: O(Mat or m*n)\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] rowCount = new int[m];\\n        int[] colCount = new int[n];\\n        var matLookup = new HashMap<Integer, int[]>();//number vs (mat -> row,col)\\n\\n        //let\\'s fill the map\\n        for(int row = 0; row < m; row++){\\n            for(int col = 0; col < n; col++){\\n                matLookup.put(mat[row][col], new int[]{row, col});\\n            }\\n        }\\n\\n        //let\\'s iterate over the num array and find out its occurance in the mat \\n        for(int i = 0; i < arr.length; i++){\\n            //fetch the position .i.e row and col pos in the mat for the curr num\\n            int currNum = arr[i];\\n            int rowIdx = matLookup.get(currNum)[0];\\n            int colIdx = matLookup.get(currNum)[1];\\n            //since we know we have to paint the cell\\n            //we also upadate the number of painted rows and cols at that specific row and col \\n            rowCount[rowIdx]++;\\n            colCount[colIdx]++;\\n            //now let\\'s try to see if at this time we have a fully painted row or a col\\n            if(rowCount[rowIdx] == n || colCount[colIdx] == m)\\n                return i;\\n        }\\n\\n        return -1;\\n\\n    }\\n}\\n\\n/**\\n\\nrow = [1,1,2]\\n       0,1,2\\ncol = [1,3,0]\\n       0,1,2\\n\\nif(col[i] == m(rowcount) || row[i] == n(col count))\\n    return the curr Idx\\n\\n\\nApproach: \\n* Since all the nums in mat is unique we fill a map of num vs tuple(row,col)\\n* we iterate over the arr\\n* we fetch the occurance of arr[i] from the map and update it row and col count by 1\\n* each time at the end of the loop we check if there is some col or row which are all painted\\n* if yes we return the i;\\n\\nTC: O(N) + O(Mat)\\nSC: O(Mat or m*n)\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486124,
                "title": "java-simple-solution-hashmap-array-technique-o-n",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N * M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,List<int[]>> map = new HashMap<>();\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                map.putIfAbsent(mat[i][j],new ArrayList<>());\\n                map.get(mat[i][j]).add(new int[]{i,j});\\n            }\\n        }\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for(int i = 0;i < arr.length;i++){\\n            for(int[] loc : map.get(arr[i])){\\n                int r = loc[0];\\n                int c = loc[1];\\n                rows[r]++;\\n                cols[c]++;\\n\\n                if(rows[r] == m || cols[c] == n){\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,List<int[]>> map = new HashMap<>();\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                map.putIfAbsent(mat[i][j],new ArrayList<>());\\n                map.get(mat[i][j]).add(new int[]{i,j});\\n            }\\n        }\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for(int i = 0;i < arr.length;i++){\\n            for(int[] loc : map.get(arr[i])){\\n                int r = loc[0];\\n                int c = loc[1];\\n                rows[r]++;\\n                cols[c]++;\\n\\n                if(rows[r] == m || cols[c] == n){\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485972,
                "title": "first-completely-painted-row-or-column-hashmap-java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n\\n        int []row=new int[m];\\n        int []col=new int[n];\\n\\n        HashMap<Integer,Pos> hm=new HashMap<>();\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                hm.put(mat[i][j],new Pos(i,j));\\n            }\\n        }\\n\\n        for(int i=0;i<arr.length;i++){\\n            Pos p=hm.get(arr[i]);\\n            row[p.r]++;\\n            col[p.c]++;\\n\\n            if(row[p.r]==n || col[p.c]==m){\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pos{\\n    int r;\\n    int c;\\n\\n    public Pos(int r, int c){\\n        this.r=r;\\n        this.c=c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n\\n        int []row=new int[m];\\n        int []col=new int[n];\\n\\n        HashMap<Integer,Pos> hm=new HashMap<>();\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                hm.put(mat[i][j],new Pos(i,j));\\n            }\\n        }\\n\\n        for(int i=0;i<arr.length;i++){\\n            Pos p=hm.get(arr[i]);\\n            row[p.r]++;\\n            col[p.c]++;\\n\\n            if(row[p.r]==n || col[p.c]==m){\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pos{\\n    int r;\\n    int c;\\n\\n    public Pos(int r, int c){\\n        this.r=r;\\n        this.c=c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485268,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        Map<Integer,Integer> row_map = new HashMap<>();\\n        Map<Integer,Integer> col_map = new HashMap<>();\\n        for(int i = 0; i < mat.length; i++)\\n        {\\n            for(int j = 0; j < mat[0].length; j++)\\n            {\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        for(int i = 0; i < arr.length; i++)\\n        {\\n            int i_idx = map.get(arr[i])[0];\\n            int j_idx = map.get(arr[i])[1];\\n            int ct_i = row_map.getOrDefault(i_idx, 0) + 1;\\n            if(ct_i == mat[0].length)\\n            {\\n                return i;\\n            }\\n            int ct_j = col_map.getOrDefault(j_idx, 0) + 1;\\n            if(ct_j == mat.length)\\n            {\\n                return i;\\n            }\\n            row_map.put(i_idx, ct_i);\\n            col_map.put(j_idx, ct_j);\\n        }\\n        return arr.length - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        Map<Integer,Integer> row_map = new HashMap<>();\\n        Map<Integer,Integer> col_map = new HashMap<>();\\n        for(int i = 0; i < mat.length; i++)\\n        {\\n            for(int j = 0; j < mat[0].length; j++)\\n            {\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        for(int i = 0; i < arr.length; i++)\\n        {\\n            int i_idx = map.get(arr[i])[0];\\n            int j_idx = map.get(arr[i])[1];\\n            int ct_i = row_map.getOrDefault(i_idx, 0) + 1;\\n            if(ct_i == mat[0].length)\\n            {\\n                return i;\\n            }\\n            int ct_j = col_map.getOrDefault(j_idx, 0) + 1;\\n            if(ct_j == mat.length)\\n            {\\n                return i;\\n            }\\n            row_map.put(i_idx, ct_i);\\n            col_map.put(j_idx, ct_j);\\n        }\\n        return arr.length - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484352,
                "title": "python3-o-mn-row-or-col-max-index",
                "content": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        ans = len(arr) - 1\\n        idxs = {v : i for i, v in enumerate(arr)}\\n        for r, c in product(range(len(mat)), range(len(mat[0]))): mat[r][c] = idxs[mat[r][c]]\\n        for r in range(len(mat)): ans = min(ans, max(mat[r][c] for c in range(len(mat[0]))))\\n        for c in range(len(mat[0])): ans = min(ans, max(mat[r][c] for r in range(len(mat))))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        ans = len(arr) - 1\\n        idxs = {v : i for i, v in enumerate(arr)}\\n        for r, c in product(range(len(mat)), range(len(mat[0]))): mat[r][c] = idxs[mat[r][c]]\\n        for r in range(len(mat)): ans = min(ans, max(mat[r][c] for c in range(len(mat[0]))))\\n        for c in range(len(mat[0])): ans = min(ans, max(mat[r][c] for r in range(len(mat))))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484294,
                "title": "python3-easy-to-read-needs-improvement-in-time-consumption-though",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy original solution was TLE. this is inspired by this solution.\\nhttps://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468410/just-use-a-simple-map/?languageTags=java\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize `row` and `col` dictionaries. They will hold the number of house painted againt the index of row and column.\\n- Iterate through `mat` and store the ith and jth index (the x and y index) for each house number in a dictionary. The two indexes represent the index of the row and column.\\n- Iterate through `arr` and get the x,y index from the `position` dict (from above) and increment the integer value againt the index of `row` and `col` by 1.\\n- Check if value of integer against the row index `x` == n (length of column) or value of integer against the column index `y` == m (length of row). If yes, then that means that either the row at index `x` or the column at index `y` are completely painted. Return index ith count of iteration from here\\n\\n# Complexity\\n- Time complexity: O(N) N is total number of houses to paint\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2), a tuple is stored against each position.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        # Create a dictionary\\n        rows = {}\\n        cols = {}\\n\\n        positions = {}\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                positions[mat[i][j]] = (i,j)\\n                print(positions[mat[i][j]])\\n        \\n        for i,index in enumerate(arr):\\n            x,y = positions[index]\\n            rows[x] = (rows[x] + 1) if x in rows else 1\\n            cols[y] = (cols[y] + 1) if y in cols else 1\\n\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n        return len(arr) - 1\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        # Create a dictionary\\n        rows = {}\\n        cols = {}\\n\\n        positions = {}\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                positions[mat[i][j]] = (i,j)\\n                print(positions[mat[i][j]])\\n        \\n        for i,index in enumerate(arr):\\n            x,y = positions[index]\\n            rows[x] = (rows[x] + 1) if x in rows else 1\\n            cols[y] = (cols[y] + 1) if y in cols else 1\\n\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n        return len(arr) - 1\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484293,
                "title": "python3-easy-to-read-needs-improvement-in-time-consumption-though",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy original solution was TLE. this is inspired by this solution.\\nhttps://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468410/just-use-a-simple-map/?languageTags=java\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize `row` and `col` dictionaries. They will hold the number of house painted againt the index of row and column.\\n- Iterate through `mat` and store the ith and jth index (the x and y index) for each house number in a dictionary. The two indexes represent the index of the row and column.\\n- Iterate through `arr` and get the x,y index from the `position` dict (from above) and increment the integer value againt the index of `row` and `col` by 1.\\n- Check if value of integer against the row index `x` == n (length of column) or value of integer against the column index `y` == m (length of row). If yes, then that means that either the row at index `x` or the column at index `y` are completely painted. Return index ith count of iteration from here\\n\\n# Complexity\\n- Time complexity: O(N) N is total number of houses to paint\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2), a tuple is stored against each position.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        # Create a dictionary\\n        rows = {}\\n        cols = {}\\n\\n        positions = {}\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                positions[mat[i][j]] = (i,j)\\n                print(positions[mat[i][j]])\\n        \\n        for i,index in enumerate(arr):\\n            x,y = positions[index]\\n            rows[x] = (rows[x] + 1) if x in rows else 1\\n            cols[y] = (cols[y] + 1) if y in cols else 1\\n\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n        return len(arr) - 1\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        # Create a dictionary\\n        rows = {}\\n        cols = {}\\n\\n        positions = {}\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                positions[mat[i][j]] = (i,j)\\n                print(positions[mat[i][j]])\\n        \\n        for i,index in enumerate(arr):\\n            x,y = positions[index]\\n            rows[x] = (rows[x] + 1) if x in rows else 1\\n            cols[y] = (cols[y] + 1) if y in cols else 1\\n\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n        return len(arr) - 1\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484028,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++)\\n          map.put(arr[i], i);\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < mat.length; i++){\\n            int currMaxIndex = Integer.MIN_VALUE;\\n\\n            for(int j = 0; j < mat[0].length; j++)\\n              currMaxIndex = Math.max(currMaxIndex, map.get(mat[i][j]));\\n            \\n            ans = Math.min(ans, currMaxIndex);\\n        }\\n\\n        for(int j = 0; j < mat[0].length; j++){\\n            int currMaxIndex = Integer.MIN_VALUE;\\n\\n            for(int i = 0; i < mat.length; i++)\\n              currMaxIndex = Math.max(currMaxIndex, map.get(mat[i][j]));\\n\\n            ans = Math.min(ans, currMaxIndex);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++)\\n          map.put(arr[i], i);\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < mat.length; i++){\\n            int currMaxIndex = Integer.MIN_VALUE;\\n\\n            for(int j = 0; j < mat[0].length; j++)\\n              currMaxIndex = Math.max(currMaxIndex, map.get(mat[i][j]));\\n            \\n            ans = Math.min(ans, currMaxIndex);\\n        }\\n\\n        for(int j = 0; j < mat[0].length; j++){\\n            int currMaxIndex = Integer.MIN_VALUE;\\n\\n            for(int i = 0; i < mat.length; i++)\\n              currMaxIndex = Math.max(currMaxIndex, map.get(mat[i][j]));\\n\\n            ans = Math.min(ans, currMaxIndex);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483164,
                "title": "python-memory-44-9-mb-beats-93-52",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        indices=[None for i in range(len(mat)*len(mat[0])+2)]\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                indices[mat[i][j]]=(i, j)\\n        \\n        row=[0 for i in range(len(mat))]\\n        col=[0 for j in range(len(mat[0]))]\\n        for x in range(len(arr)):\\n            i, j=indices[arr[x]]\\n            row[i]+=1\\n            col[j]+=1\\n            # print(arr[x], \"--\")\\n            # print(i, row[i], len(mat))\\n            # print(j, col[j], len(mat[0]))\\n            # print(\"--\")\\n            if row[i]==len(mat[0]) or col[j]==len(mat):\\n                return x\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        indices=[None for i in range(len(mat)*len(mat[0])+2)]\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                indices[mat[i][j]]=(i, j)\\n        \\n        row=[0 for i in range(len(mat))]\\n        col=[0 for j in range(len(mat[0]))]\\n        for x in range(len(arr)):\\n            i, j=indices[arr[x]]\\n            row[i]+=1\\n            col[j]+=1\\n            # print(arr[x], \"--\")\\n            # print(i, row[i], len(mat))\\n            # print(j, col[j], len(mat[0]))\\n            # print(\"--\")\\n            if row[i]==len(mat[0]) or col[j]==len(mat):\\n                return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483074,
                "title": "only-1-iteration-over-both-the-arrays-using-java-easy-solution-bats-98",
                "content": "\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        var r=mat.length;\\n        var c=mat[0].length;\\n        var posr=new int[r*c];\\n        var posc=new int[c*r];\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                var curr=mat[i][j];\\n                posr[curr-1]=i;\\n                posc[curr-1]=j;\\n            }\\n        }\\n        \\n        var row=new int[r];\\n        var col=new int[c];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            var curr=arr[i];\\n            var cr=posr[curr-1];\\n            var cc=posc[curr-1];\\n            row[cr]++;\\n            col[cc]++;\\n            if(row[cr]>=c || col[cc]>=r)return i;\\n        }\\n        return i-1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        var r=mat.length;\\n        var c=mat[0].length;\\n        var posr=new int[r*c];\\n        var posc=new int[c*r];\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                var curr=mat[i][j];\\n                posr[curr-1]=i;\\n                posc[curr-1]=j;\\n            }\\n        }\\n        \\n        var row=new int[r];\\n        var col=new int[c];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            var curr=arr[i];\\n            var cr=posr[curr-1];\\n            var cc=posc[curr-1];\\n            row[cr]++;\\n            col[cc]++;\\n            if(row[cr]>=c || col[cc]>=r)return i;\\n        }\\n        return i-1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482925,
                "title": "java-time-o-m-n-space-o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore row and col index to map and return index once it hits row or col length return the current index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        if(mat.length == 1 || mat[0].length == 1)\\n            return 0;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n        for(int i = 0; i < mat.length; ++i){\\n            for(int j = 0; j < mat[0].length; ++j){\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        for(int i = 0; i < arr.length; ++i){\\n            int[] idx = map.get(arr[i]);\\n            rows[idx[0]]++;\\n            cols[idx[1]]++;\\n            if(rows[idx[0]] == mat[0].length || cols[idx[1]] == mat.length)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        if(mat.length == 1 || mat[0].length == 1)\\n            return 0;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n        for(int i = 0; i < mat.length; ++i){\\n            for(int j = 0; j < mat[0].length; ++j){\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        for(int i = 0; i < arr.length; ++i){\\n            int[] idx = map.get(arr[i]);\\n            rows[idx[0]]++;\\n            cols[idx[1]]++;\\n            if(rows[idx[0]] == mat[0].length || cols[idx[1]] == mat.length)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481464,
                "title": "java-map-solution-o-n-m-time-space",
                "content": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        Map<Integer, Integer>matrixPositions = new HashMap<>();\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                matrixPositions.put(mat[i][j], i*n+j);\\n            }\\n        }\\n        \\n        int[]columns = new int[n];\\n        int[]rows=new int[m];\\n        \\n        for (int i=0;i< arr.length;i++){\\n           int row= matrixPositions.get(arr[i])/n;\\n           int column = matrixPositions.get(arr[i])%n;\\n            columns[column]++;\\n            rows[row]++;\\n            if (columns[column]==m || rows[row]==n)return i;\\n        }\\n        return arr.length-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        Map<Integer, Integer>matrixPositions = new HashMap<>();\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                matrixPositions.put(mat[i][j], i*n+j);\\n            }\\n        }\\n        \\n        int[]columns = new int[n];\\n        int[]rows=new int[m];\\n        \\n        for (int i=0;i< arr.length;i++){\\n           int row= matrixPositions.get(arr[i])/n;\\n           int column = matrixPositions.get(arr[i])%n;\\n            columns[column]++;\\n            rows[row]++;\\n            if (columns[column]==m || rows[row]==n)return i;\\n        }\\n        return arr.length-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481292,
                "title": "c-single-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row(n, m);\\n        vector<int> col(m, n);\\n        unordered_map<int, pair<int, int>> hash;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++){\\n                hash[mat[i][j]] = {i, j};\\n            }\\n        int res;\\n        for(int i = 0; i < arr.size(); i++){\\n            int p = hash[arr[i]].first;\\n            int q = hash[arr[i]].second;\\n            if(--row[p] == 0){\\n                res = i;\\n                break;\\n            }\\n            if(--col[q] == 0){\\n                res = i;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row(n, m);\\n        vector<int> col(m, n);\\n        unordered_map<int, pair<int, int>> hash;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++){\\n                hash[mat[i][j]] = {i, j};\\n            }\\n        int res;\\n        for(int i = 0; i < arr.size(); i++){\\n            int p = hash[arr[i]].first;\\n            int q = hash[arr[i]].second;\\n            if(--row[p] == 0){\\n                res = i;\\n                break;\\n            }\\n            if(--col[q] == 0){\\n                res = i;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480857,
                "title": "c-counting-rows-and-columns",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs every array value will be unique and exist in `mat` matrix, we can use **Counter** arrray(rows, cols) to count the **value positions**. And if we reach: \\n- rows `count size == (matrix column).size` (C variable) OR\\n- cols `count size == (matrix rows).size` (R variable)\\n\\nReturn the arr `ith` index\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **int[] rows = new int[R];** - Count of arr item position in rows\\n- **int[] cols = new int[C];** - Count of arr item position in columns\\n- **(int r, int c)[] positions = new (int r, int c)[R * C + 1];** - Store the value position as **Value tuple** `(int r, int c)`\\n\\n\\n# Complexity\\n- Time complexity:$$O(R * C )$$, where R, C = total Rows and Columns size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(R * C)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\\n        int R = mat.Length;\\n        int C = mat[0].Length;\\n\\n        int[] rows = new int[R];\\n        int[] cols = new int[C];\\n        (int r, int c)[] positions = new (int r, int c)[R * C + 1];\\n\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                positions[mat[i][j]] = (i, j);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.Length; i++) {\\n            (int r, int c) = positions[arr[i]];\\n            rows[r]++;\\n            cols[c]++;\\n\\n            if (rows[r] == C || cols[c] == R) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Counting"
                ],
                "code": "```\\npublic class Solution {\\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\\n        int R = mat.Length;\\n        int C = mat[0].Length;\\n\\n        int[] rows = new int[R];\\n        int[] cols = new int[C];\\n        (int r, int c)[] positions = new (int r, int c)[R * C + 1];\\n\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                positions[mat[i][j]] = (i, j);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.Length; i++) {\\n            (int r, int c) = positions[arr[i]];\\n            rows[r]++;\\n            cols[c]++;\\n\\n            if (rows[r] == C || cols[c] == R) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480660,
                "title": "first-completely-painted-row-or-column-o-n-m-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n=len(mat)\\n        m=len(mat[0])\\n        d={}\\n        for i in range(n*m):\\n            d[arr[i]]=i\\n        row=[-1]*n\\n        col=[-1]*m\\n        for i in range(n):\\n            for j in range(m):\\n                row[i]=max(d[mat[i][j]],row[i])\\n                col[j]=max(d[mat[i][j]],col[j])\\n        return min(min(row),min(col))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n=len(mat)\\n        m=len(mat[0])\\n        d={}\\n        for i in range(n*m):\\n            d[arr[i]]=i\\n        row=[-1]*n\\n        col=[-1]*m\\n        for i in range(n):\\n            for j in range(m):\\n                row[i]=max(d[mat[i][j]],row[i])\\n                col[j]=max(d[mat[i][j]],col[j])\\n        return min(min(row),min(col))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480410,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check_row(pair<int, int> loc, vector<vector<int>>& mat){\\n        int flag = 1;\\n        for(int j=0; j < mat[0].size(); j++){\\n            if(mat[loc.first][j]!=-1){\\n                flag = 0;\\n                break;\\n            } \\n        } \\n        return flag;\\n    }\\n\\n    bool check_column(pair<int, int> loc, vector<vector<int>>& mat){\\n        int flag = 1;\\n        for(int i=0; i < mat.size(); i++){\\n            if(mat[i][loc.second]!=-1){\\n                flag = 0;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, pair<int, int>> mp;\\n        pair<int, int> loc;\\n        for(int i=0; i < mat.size(); i++){\\n            for(int j=0; j < mat[i].size(); j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        int count =0;\\n        for(int i=0; i < arr.size(); i++){\\n            loc = mp[arr[i]];\\n            mat[loc.first][loc.second] = -1;\\n            count++;\\n            if(count >= mat[0].size()){\\n                if(check_row(loc, mat)) return i;\\n            }\\n            if(count >= mat.size()){\\n                if(check_column(loc, mat)) return i;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check_row(pair<int, int> loc, vector<vector<int>>& mat){\\n        int flag = 1;\\n        for(int j=0; j < mat[0].size(); j++){\\n            if(mat[loc.first][j]!=-1){\\n                flag = 0;\\n                break;\\n            } \\n        } \\n        return flag;\\n    }\\n\\n    bool check_column(pair<int, int> loc, vector<vector<int>>& mat){\\n        int flag = 1;\\n        for(int i=0; i < mat.size(); i++){\\n            if(mat[i][loc.second]!=-1){\\n                flag = 0;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, pair<int, int>> mp;\\n        pair<int, int> loc;\\n        for(int i=0; i < mat.size(); i++){\\n            for(int j=0; j < mat[i].size(); j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        int count =0;\\n        for(int i=0; i < arr.size(); i++){\\n            loc = mp[arr[i]];\\n            mat[loc.first][loc.second] = -1;\\n            count++;\\n            if(count >= mat[0].size()){\\n                if(check_row(loc, mat)) return i;\\n            }\\n            if(count >= mat.size()){\\n                if(check_column(loc, mat)) return i;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479777,
                "title": "javascript-6-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n    let n = mat.length, m = mat[0].length, mp = new Map();\\n    let cntRow = new Array(n).fill(m), cntCol = new Array(m).fill(n);\\n    for(let i=0;i<n;i++) for(let j=0; j<m; j++) mp.set(mat[i][j], [i, j]);\\n    for(let k = 0; k<arr.length; k++){\\n        let [i, j] = mp.get(arr[k]);\\n        if(--cntRow[i] == 0 || --cntCol[j] == 0) return k; \\n    } \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n    let n = mat.length, m = mat[0].length, mp = new Map();\\n    let cntRow = new Array(n).fill(m), cntCol = new Array(m).fill(n);\\n    for(let i=0;i<n;i++) for(let j=0; j<m; j++) mp.set(mat[i][j], [i, j]);\\n    for(let k = 0; k<arr.length; k++){\\n        let [i, j] = mp.get(arr[k]);\\n        if(--cntRow[i] == 0 || --cntCol[j] == 0) return k; \\n    } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478663,
                "title": "c-using-hashmap-easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int row = mat.size(), col = mat[0].size();\\n        unordered_map<int, pair<int, int>> ump;\\n        vector<int> rowArr(row, col), colArr(col, row);\\n        \\n\\t\\t//Create Hash map with element as key and row & col as a value(pair)\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                ump[mat[i][j]] = {i, j};\\n            }\\n        }\\n        \\n\\t\\t//Pass through the array, fetch corresponding row & col and decrement the perticular row/col value from rowArr and colArr and when hit 0 return i \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pair<int, int> pr = ump[arr[i]];\\n            int r = pr.first;\\n            int c = pr.second;\\n            \\n            rowArr[r]--;\\n            colArr[c]--;\\n            if(rowArr[r]==0 || colArr[c]==0)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int row = mat.size(), col = mat[0].size();\\n        unordered_map<int, pair<int, int>> ump;\\n        vector<int> rowArr(row, col), colArr(col, row);\\n        \\n\\t\\t//Create Hash map with element as key and row & col as a value(pair)\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                ump[mat[i][j]] = {i, j};\\n            }\\n        }\\n        \\n\\t\\t//Pass through the array, fetch corresponding row & col and decrement the perticular row/col value from rowArr and colArr and when hit 0 return i \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pair<int, int> pr = ump[arr[i]];\\n            int r = pr.first;\\n            int c = pr.second;\\n            \\n            rowArr[r]--;\\n            colArr[c]--;\\n            if(rowArr[r]==0 || colArr[c]==0)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478615,
                "title": "java-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n\\n        Map<Integer, Pair> map = new HashMap<>();\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                map.put(mat[i][j], new Pair(i, j));\\n            }\\n        }   \\n        for(int i = 0; i < arr.length; i++){\\n            Pair p = map.get(arr[i]);\\n            row[p.i]++;\\n            col[p.j]++;\\n            if(row[p.i] == n || col[p.j] == m) return i;\\n        }\\n        return -1;\\n    }\\n}\\nclass Pair {\\n    int i;\\n    int j;\\n    Pair (int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n\\n        Map<Integer, Pair> map = new HashMap<>();\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                map.put(mat[i][j], new Pair(i, j));\\n            }\\n        }   \\n        for(int i = 0; i < arr.length; i++){\\n            Pair p = map.get(arr[i]);\\n            row[p.i]++;\\n            col[p.j]++;\\n            if(row[p.i] == n || col[p.j] == m) return i;\\n        }\\n        return -1;\\n    }\\n}\\nclass Pair {\\n    int i;\\n    int j;\\n    Pair (int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478012,
                "title": "java-time-complexity-o-n-2-space-complexity-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet the index of element and sum of row wise and column wise sum and subtarct element from both and when ever the row sum or and column sum will zero return that index....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst inserting all element with their index and then after also get the sum every row and column in seprate 2d vector and then when ever we subtract the from the sum of row and column and when erver the sum of the sum of either row of column become zero then just return that index.......\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>>m;\\n        int l=0;\\n        int n=mat.size(),k=mat[0].size();\\n        vector<vector<long long>>a(n+1,vector<long long>(k+1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<k;j++)\\n            {\\n                a[i][j]=mat[i][j];\\n                pair<int,int>p;\\n                p.first=i;\\n                p.second=j;\\n                m[mat[i][j]]=p;\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            long long  sum=0;\\n            for(int j=0;j<n;j++)\\n                sum+=mat[j][i];\\n            a[n][l]=sum;\\n            l++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            long long sum=0;\\n            for(int j=0;j<k;j++)\\n                sum+=mat[i][j];\\n            a[i][k]=sum;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pair<int,int>p=m[arr[i]];\\n            a[n][p.second]-=mat[p.first][p.second];\\n            a[p.first][k]-=mat[p.first][p.second];\\n            if(a[n][p.second]==0 or a[p.first][k]==0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\nfeel free to ask your doubt happy to help......\\nIf it help you than plz upvote it......Thanks!!!!\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>>m;\\n        int l=0;\\n        int n=mat.size(),k=mat[0].size();\\n        vector<vector<long long>>a(n+1,vector<long long>(k+1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<k;j++)\\n            {\\n                a[i][j]=mat[i][j];\\n                pair<int,int>p;\\n                p.first=i;\\n                p.second=j;\\n                m[mat[i][j]]=p;\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            long long  sum=0;\\n            for(int j=0;j<n;j++)\\n                sum+=mat[j][i];\\n            a[n][l]=sum;\\n            l++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            long long sum=0;\\n            for(int j=0;j<k;j++)\\n                sum+=mat[i][j];\\n            a[i][k]=sum;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pair<int,int>p=m[arr[i]];\\n            a[n][p.second]-=mat[p.first][p.second];\\n            a[p.first][k]-=mat[p.first][p.second];\\n            if(a[n][p.second]==0 or a[p.first][k]==0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\nfeel free to ask your doubt happy to help......\\nIf it help you than plz upvote it......Thanks!!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477531,
                "title": "c-faster-than-100",
                "content": "Simply maintain how many uncoloured cells there are in rows and columns. When it reaches zero return the number of nums seen.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat)\\n    {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> rowRemain(m, n);\\n        vector<int> colRemain(n, m);\\n        vector<pair<int,int>> num2coords(m*n+1);\\n        for(int row = 0; row<m; row++)\\n            for(int col = 0; col<n; col++)\\n                num2coords[mat[row][col]] = make_pair(row, col);\\n        int ret = 0;\\n        for(int num : arr)\\n        {\\n            rowRemain[num2coords[num].first] --;\\n            if(rowRemain[num2coords[num].first] == 0)\\n                return ret;\\n            colRemain[num2coords[num].second] --;\\n            if(colRemain[num2coords[num].second] == 0)\\n                return ret;\\n            ret ++;\\n        }\\n        return 0; // never happens\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat)\\n    {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> rowRemain(m, n);\\n        vector<int> colRemain(n, m);\\n        vector<pair<int,int>> num2coords(m*n+1);\\n        for(int row = 0; row<m; row++)\\n            for(int col = 0; col<n; col++)\\n                num2coords[mat[row][col]] = make_pair(row, col);\\n        int ret = 0;\\n        for(int num : arr)\\n        {\\n            rowRemain[num2coords[num].first] --;\\n            if(rowRemain[num2coords[num].first] == 0)\\n                return ret;\\n            colRemain[num2coords[num].second] --;\\n            if(colRemain[num2coords[num].second] == 0)\\n                return ret;\\n            ret ++;\\n        }\\n        return 0; // never happens\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3476474,
                "title": "simple-python-solution-w-comments",
                "content": "\\n\\n# Code\\n```\\n# the problem comes down to how do we know when a row or a column is filled\\n# record each number\\'s position in the matrix \\n# for each number in arr, that number row++ and col++\\n# return if row == m or col == n\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        mapRow, mapCol = {}, {}\\n        m, n = len(mat), len(mat[0])\\n        row, col = [0]*len(mat), [0]*len(mat[0])\\n        for i in range(len(mat)): \\n            for j in range(len(mat[0])): \\n                mapRow[mat[i][j]] = i\\n                mapCol[mat[i][j]] = j\\n        for index, num in enumerate(arr): \\n            row[mapRow[num]]+=1\\n            col[mapCol[num]]+=1\\n            if row[mapRow[num]]==n or col[mapCol[num]] == m:\\n                return index\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# the problem comes down to how do we know when a row or a column is filled\\n# record each number\\'s position in the matrix \\n# for each number in arr, that number row++ and col++\\n# return if row == m or col == n\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        mapRow, mapCol = {}, {}\\n        m, n = len(mat), len(mat[0])\\n        row, col = [0]*len(mat), [0]*len(mat[0])\\n        for i in range(len(mat)): \\n            for j in range(len(mat[0])): \\n                mapRow[mat[i][j]] = i\\n                mapCol[mat[i][j]] = j\\n        for index, num in enumerate(arr): \\n            row[mapRow[num]]+=1\\n            col[mapCol[num]]+=1\\n            if row[mapRow[num]]==n or col[mapCol[num]] == m:\\n                return index\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475677,
                "title": "c-dictionary",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\\n        var dic = new Dictionary<int, (int, int)>();\\n        for (var i = 0; i < mat.Length; i++) {\\n            for (var j = 0; j < mat[i].Length; j++) {\\n                dic.Add(mat[i][j], (i, j));\\n            }\\n        }\\n\\n        var row = new int[mat.Length];\\n        var col = new int[mat[0].Length];\\n        var rowIndex = 0;\\n        var colIndex = 0;\\n        for (var k = 0; k < arr.Length; k++) {\\n            rowIndex = dic[arr[k]].Item1;\\n            colIndex = dic[arr[k]].Item2;\\n            row[rowIndex]++;\\n            col[colIndex]++;\\n            if (row[rowIndex] == mat[0].Length || col[colIndex] == mat.Length)\\n                return k;\\n        }\\n\\n        return 0;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\\n        var dic = new Dictionary<int, (int, int)>();\\n        for (var i = 0; i < mat.Length; i++) {\\n            for (var j = 0; j < mat[i].Length; j++) {\\n                dic.Add(mat[i][j], (i, j));\\n            }\\n        }\\n\\n        var row = new int[mat.Length];\\n        var col = new int[mat[0].Length];\\n        var rowIndex = 0;\\n        var colIndex = 0;\\n        for (var k = 0; k < arr.Length; k++) {\\n            rowIndex = dic[arr[k]].Item1;\\n            colIndex = dic[arr[k]].Item2;\\n            row[rowIndex]++;\\n            col[colIndex]++;\\n            if (row[rowIndex] == mat[0].Length || col[colIndex] == mat.Length)\\n                return k;\\n        }\\n\\n        return 0;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475551,
                "title": "tracking-the-reamaining-cells-hashmap-for-lookups-o-m-n",
                "content": "# Intuition\\nSince the matrix contains all integers in the range from `1` to `m * n` the values are unique in each cell we just need to keep track of the number of remaining cells in each row and in each column \\n\\n# Approach\\n- keep track of the location of each integer in a map for constant lookups \\n- loop over the arr and reduce the corresponding row and column by 1 then check if either is `0` then return the integer \\n\\n# Complexity\\n- Time complexity: `O(m * n)`\\n\\n- Space complexity: `O(m * n)`\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function (arr, mat) {\\n    const locations = {};\\n    const M = mat.length\\n    const N = mat[0].length\\n    const cols = new Array(N).fill(M);\\n    const rows = new Array(M).fill(N);\\n    for (let i = 0; i < M; i++) {\\n        for (let j = 0; j < N; j++) {\\n            locations[mat[i][j]] = [i, j]\\n        }\\n    }\\n    for (let x = 0; x < arr.length; x++) {\\n        const [i, j] = locations[arr[x]];\\n        rows[i]--;\\n        cols[j]--;\\n        if (!rows[i] || !cols[j])\\n            return x;\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function (arr, mat) {\\n    const locations = {};\\n    const M = mat.length\\n    const N = mat[0].length\\n    const cols = new Array(N).fill(M);\\n    const rows = new Array(M).fill(N);\\n    for (let i = 0; i < M; i++) {\\n        for (let j = 0; j < N; j++) {\\n            locations[mat[i][j]] = [i, j]\\n        }\\n    }\\n    for (let x = 0; x < arr.length; x++) {\\n        const [i, j] = locations[arr[x]];\\n        rows[i]--;\\n        cols[j]--;\\n        if (!rows[i] || !cols[j])\\n            return x;\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1877980,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1917849,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1890968,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1889295,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1879192,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1878032,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1877688,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Cost of a Path With Special Roads",
        "question_content": "<p>You are given an array <code>start</code> where <code>start = [startX, startY]</code> represents your initial position <code>(startX, startY)</code> in a 2D space. You are also given the array <code>target</code> where <code>target = [targetX, targetY]</code> represents your target position <code>(targetX, targetY)</code>.</p>\n\n<p>The cost of going from a position <code>(x1, y1)</code> to any other position in the space <code>(x2, y2)</code> is <code>|x2 - x1| + |y2 - y1|</code>.</p>\n\n<p>There are also some special roads. You are given a 2D array <code>specialRoads</code> where <code>specialRoads[i] = [x1<sub>i</sub>, y1<sub>i</sub>, x2<sub>i</sub>, y2<sub>i</sub>, cost<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> special road can take you from <code>(x1<sub>i</sub>, y1<sub>i</sub>)</code> to <code>(x2<sub>i</sub>, y2<sub>i</sub>)</code> with a cost equal to <code>cost<sub>i</sub></code>. You can use each special road any number of times.</p>\n\n<p>Return <em>the minimum cost required to go from</em> <code>(startX, startY)</code> to <code>(targetX, targetY)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The optimal path from (1,1) to (4,5) is the following:\n- (1,1) -&gt; (1,2). This move has a cost of |1 - 1| + |2 - 1| = 1.\n- (1,2) -&gt; (3,3). This move uses the first special edge, the cost is 2.\n- (3,3) -&gt; (3,4). This move has a cost of |3 - 3| + |4 - 3| = 1.\n- (3,4) -&gt; (4,5). This move uses the second special edge, the cost is 1.\nSo the total cost is 1 + 2 + 1 + 1 = 5.\nIt can be shown that we cannot achieve a smaller total cost than 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> It is optimal to not use any special edges and go directly from the starting to the ending position with a cost |5 - 3| + |7 - 2| = 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>start.length == target.length == 2</code></li>\n\t<li><code>1 &lt;= startX &lt;= targetX &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= startY &lt;= targetY &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= specialRoads.length &lt;= 200</code></li>\n\t<li><code>specialRoads[i].length == 5</code></li>\n\t<li><code>startX &lt;= x1<sub>i</sub>, x2<sub>i</sub> &lt;= targetX</code></li>\n\t<li><code>startY &lt;= y1<sub>i</sub>, y2<sub>i</sub> &lt;= targetY</code></li>\n\t<li><code>1 &lt;= cost<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3468447,
                "title": "c-solutions-easy-to-understand-full-explanaiton-line-by-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach involves using Dijkstra\\'s algorithm to find the minimum cost path from the starting point to the target point. Initially, we set the distances to all the special roads from the starting point, and push them into a priority queue with the current distance as the priority. We then start extracting the minimum element from the priority queue and check if its distance is equal to the distance stored in the vector. If not, we ignore it and continue with the next element.\\n\\nWe calculate the distance to the target point via the current element and update the answer if it is less than the current answer. We then iterate over all the special roads and update their distance if it is less than the previously stored distance. We then push this special road onto the priority queue with the new distance as the priority.\\n\\nWe repeat this process until the priority queue is empty and return the final answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given problem can be solved using Dijkstra\\'s algorithm. We can think of each special road as a node in the graph and the weight of each edge as the cost of traveling between the two special roads. To compute the cost of traveling from start to target, we can first calculate the cost of traveling from the start to each special road and then use these costs to update the cost of traveling to other special roads. Finally, we can add the cost of traveling from the target to the special road with minimum total cost.\\n\\nSpecifically, we can first initialize a vector d of distances from the start to each special road. For each special road i, we can calculate d[i] as the sum of the Manhattan distance between the start and the special road and the cost of the special road. We can then use a min-heap to store the distances and the indices of the special roads. We can start with the distances and indices of the special roads as the source and use Dijkstra\\'s algorithm to update the distances and indices of the special roads. To update the distance of a special road i, we can consider all the special roads that are connected to it and update their distances if the distance to i plus the weight of the edge connecting i and another special road is less than their current distances. Finally, we can add the distance from the target to the special road with minimum total cost to the total cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^2 log n), where n is the number of special roads. The reason for this time complexity is the loop that iterates over all the special roads and the priority queue operations, which have a time complexity of O(log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n), which is due to the space occupied by the distance array. The priority queue takes O(n) space as well. Thus, the overall space complexity is O(n).\\n\\n# Code\\n```\\n// Define a min-heap priority queue to store pairs of distance and index\\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T>>;\\n\\nclass Solution {\\npublic:\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        \\n        const int INF = 1e9+10;\\n        int n = specialRoads.size();\\n\\n        // Initialize the distance of each special road to infinity\\n        vector<int> d(n, INF);\\n\\n        // Create a priority queue and push the distance from start to each special road\\n        min_pq<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++) {\\n            d[i] = abs(start[0] - specialRoads[i][0]) + abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];\\n            pq.push({d[i], i});\\n        }\\n        \\n        // Initialize the answer with the manhattan distance between start and target\\n        int ans = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n\\n        // Continue to search for the shortest path until the priority queue is empty\\n        while (pq.size()) {\\n            // Pop the pair with smallest distance\\n            auto [d_c, c] = pq.top(); pq.pop();\\n\\n            // If the distance stored in d is not equal to the current distance d_c, skip this node\\n            if (d_c != d[c]) continue;\\n\\n            // Update the answer by finding the distance from the current special road to the target\\n            ans = min(ans, d_c + abs(target[0] - specialRoads[c][2]) + abs(target[1] - specialRoads[c][3]));\\n\\n            // For each special road that can be reached from the current special road, update its distance\\n            for (int nxt = 0; nxt < n; nxt++) {\\n                int w = abs(specialRoads[c][2] - specialRoads[nxt][0]) + abs(specialRoads[c][3] - specialRoads[nxt][1]) + specialRoads[nxt][4];\\n                if (d_c + w < d[nxt]) {\\n                    d[nxt] = d_c + w;\\n                    pq.push({d[nxt], nxt});\\n                }\\n            }\\n        }\\n\\n        // Return the minimum cost of reaching the target\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Define a min-heap priority queue to store pairs of distance and index\\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T>>;\\n\\nclass Solution {\\npublic:\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        \\n        const int INF = 1e9+10;\\n        int n = specialRoads.size();\\n\\n        // Initialize the distance of each special road to infinity\\n        vector<int> d(n, INF);\\n\\n        // Create a priority queue and push the distance from start to each special road\\n        min_pq<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++) {\\n            d[i] = abs(start[0] - specialRoads[i][0]) + abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];\\n            pq.push({d[i], i});\\n        }\\n        \\n        // Initialize the answer with the manhattan distance between start and target\\n        int ans = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n\\n        // Continue to search for the shortest path until the priority queue is empty\\n        while (pq.size()) {\\n            // Pop the pair with smallest distance\\n            auto [d_c, c] = pq.top(); pq.pop();\\n\\n            // If the distance stored in d is not equal to the current distance d_c, skip this node\\n            if (d_c != d[c]) continue;\\n\\n            // Update the answer by finding the distance from the current special road to the target\\n            ans = min(ans, d_c + abs(target[0] - specialRoads[c][2]) + abs(target[1] - specialRoads[c][3]));\\n\\n            // For each special road that can be reached from the current special road, update its distance\\n            for (int nxt = 0; nxt < n; nxt++) {\\n                int w = abs(specialRoads[c][2] - specialRoads[nxt][0]) + abs(specialRoads[c][3] - specialRoads[nxt][1]) + specialRoads[nxt][4];\\n                if (d_c + w < d[nxt]) {\\n                    d[nxt] = d_c + w;\\n                    pq.push({d[nxt], nxt});\\n                }\\n            }\\n        }\\n\\n        // Return the minimum cost of reaching the target\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468268,
                "title": "dijkstra-s-algorithm-with-roads-as-edges",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        specialRoads = [[a, b, c, d, x] for a, b, c, d, x in specialRoads if x < abs(a - c) + abs(b - d)]\\n        dist = {(start[0], start[1]): 0}\\n        heap = [(0, start[0], start[1])]\\n        while len(heap) > 0:\\n            currdist, x, y = heapq.heappop(heap)\\n            for a, b, c, d, cost in specialRoads:\\n                if dist.get((c, d), float(\\'inf\\')) > currdist + abs(x - a) + abs(y - b) + cost:\\n                    dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\\n                    heapq.heappush(heap, (dist[(c, d)], c, d))\\n        res = abs(target[0] - start[0]) + abs(target[1] - start[1])\\n        for a, b, c, d, cost in specialRoads:\\n            res = min(res, dist.get((c, d), float(\\'inf\\')) + abs(target[0] - c) + abs(target[1] - d))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        specialRoads = [[a, b, c, d, x] for a, b, c, d, x in specialRoads if x < abs(a - c) + abs(b - d)]\\n        dist = {(start[0], start[1]): 0}\\n        heap = [(0, start[0], start[1])]\\n        while len(heap) > 0:\\n            currdist, x, y = heapq.heappop(heap)\\n            for a, b, c, d, cost in specialRoads:\\n                if dist.get((c, d), float(\\'inf\\')) > currdist + abs(x - a) + abs(y - b) + cost:\\n                    dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\\n                    heapq.heappush(heap, (dist[(c, d)], c, d))\\n        res = abs(target[0] - start[0]) + abs(target[1] - start[1])\\n        for a, b, c, d, cost in specialRoads:\\n            res = min(res, dist.get((c, d), float(\\'inf\\')) + abs(target[0] - c) + abs(target[1] - d))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470870,
                "title": "day-396-dijkstra-s-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\nThe problem is to find the minimum cost to travel from the start point to the target point, given a set of special roads that can be used to reduce the cost of travel.\\n\\nThe approach is to first filter out the special roads that are not useful, i.e., the roads that have a cost greater than the distance between their endpoints. This is because such roads cannot be used to reduce the cost of travel.\\nThen uses Dijkstra\\'s algorithm to find the shortest path from the start point to all other points in the graph, taking into account the special roads that were filtered in the previous step. The algorithm maintains a priority queue (heap) of nodes to visit, sorted by their distance from the start point. At each step, the algorithm visits the node with the smallest distance and updates the distances of its neighbors if a shorter path is found.\\nThe distances are stored in a map, where the keys are pairs of coordinates (as lists) and the values are the distances. The map is initialized with the start point having a distance of 0.\\nAfter the distances are computed, the code computes the minimum cost to travel from the start point to the target point, taking into account the special roads. It does this by iterating over the filtered special roads and computing the cost of traveling from the start point to one endpoint of the road, then from the other endpoint of the road to the target point, and adding the cost of the road itself. The minimum of these costs is returned as the answer.\\nThe intuition behind the approach is that by filtering out the useless special roads, the algorithm can focus on finding the shortest path using the useful special roads and the regular roads. By using Dijkstra\\'s algorithm, the algorithm can efficiently find the shortest path from the start point to all other points in the graph. Finally, by computing the cost of traveling through the special roads separately, the algorithm can find the minimum cost to travel from the start point to the target point.\\n\\n\\n# Code\\n```java []\\npublic int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n    // Step 1: Filter out useless special roads\\n    List<int[]> filteredRoads = new ArrayList<>();\\n    for (int[] road : specialRoads) {\\n        int a = road[0], b = road[1], c = road[2], d = road[3], cost = road[4];\\n        if (cost < Math.abs(a - c) + Math.abs(b - d)) {\\n            filteredRoads.add(new int[]{a, b, c, d, cost});\\n        }\\n    }\\n\\n    // Step 2: Initialize distance map and priority queue\\n    Map<List<Integer>, Integer> dist = new HashMap<>();\\n    dist.put(Arrays.asList(start[0], start[1]), 0);\\n    PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    heap.offer(new int[]{0, start[0], start[1]});\\n\\n    // Step 3: Run Dijkstra\\'s algorithm to find shortest path\\n    while (!heap.isEmpty()) {\\n        int[] curr = heap.poll();\\n        int currdist = curr[0], x = curr[1], y = curr[2];\\n        for (int[] road : filteredRoads) {\\n            int a = road[0], b = road[1], c = road[2], d = road[3], cost = road[4];\\n            if (dist.getOrDefault(Arrays.asList(c, d), Integer.MAX_VALUE) > currdist + Math.abs(x - a) + Math.abs(y - b) + cost) {\\n                dist.put(Arrays.asList(c, d), currdist + Math.abs(x - a) + Math.abs(y - b) + cost);\\n                heap.offer(new int[]{dist.get(Arrays.asList(c, d)), c, d});\\n            }\\n        }\\n    }\\n\\n    // Step 4: Compute minimum cost to travel from start to target\\n    int res = Math.abs(target[0] - start[0]) + Math.abs(target[1] - start[1]);\\n    for (int[] road : filteredRoads) {\\n        int a = road[0], b = road[1], c = road[2], d = road[3], cost = road[4];\\n        res = Math.min(res, dist.getOrDefault(Arrays.asList(c, d), Integer.MAX_VALUE) + Math.abs(target[0] - c) + Math.abs(target[1] - d));\\n    }\\n\\n    // Step 5: Return the minimum cost\\n    return res;\\n}\\n```\\n```python []\\nimport heapq\\ndef minimumCost(start, target, specialRoads):\\n    filteredRoads = []\\n    for road in specialRoads:\\n        a, b, c, d, cost = road\\n        if cost < abs(a - c) + abs(b - d):\\n            filteredRoads.append([a, b, c, d, cost])\\n    dist = {(start[0], start[1]): 0}\\n    heap = [(0, start[0], start[1])]\\n    while heap:\\n        currdist, x, y = heapq.heappop(heap)\\n        for road in filteredRoads:\\n            a, b, c, d, cost = road\\n            if dist.get((c, d), float(\\'inf\\')) > currdist + abs(x - a) + abs(y - b) + cost:\\n                dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\\n                heapq.heappush(heap, (dist[(c, d)], c, d))\\n    res = abs(target[0] - start[0]) + abs(target[1] - start[1])\\n    for road in filteredRoads:\\n        a, b, c, d, cost = road\\n        res = min(res, dist.get((c, d), float(\\'inf\\')) + abs(target[0] - c) + abs(target[1] - d))\\n    return res\\n```\\n\\nyou can refer c++ solution [here](https://leetcode.com/problems/minimum-cost-of-a-path-with-special-roads/solutions/3471212/dijkstras-map-based-solution-map-every-end-pt-of-spl-road/) @credits to bala\\n\\n\\n\\n# Complexity\\nTC: O(N log N), where N is the total number of vertices in the graph. This is because the code uses Dijkstra\\'s algorithm, which has a time complexity of O(N log N) when implemented using a priority queue. The filtering of useless special roads takes O(M) time, where M is the number of special roads, but since M is at most N^2, this can be considered negligible compared to the time complexity of Dijkstra\\'s algorithm.\\nSC: O(N), where N is the total number of vertices in the graph. This is because the code uses a map to store the distances of each vertex from the start vertex, and the map can have at most N entries. The priority queue used in Dijkstra\\'s algorithm can also have at most N entries. The space used by the filtered special roads and other variables is negligible compared to the space used by the map and priority queue.\\nOverall, the time and space complexity of the given code are reasonable and efficient for the problem size.\\n\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\npublic int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n    // Step 1: Filter out useless special roads\\n    List<int[]> filteredRoads = new ArrayList<>();\\n    for (int[] road : specialRoads) {\\n        int a = road[0], b = road[1], c = road[2], d = road[3], cost = road[4];\\n        if (cost < Math.abs(a - c) + Math.abs(b - d)) {\\n            filteredRoads.add(new int[]{a, b, c, d, cost});\\n        }\\n    }\\n\\n    // Step 2: Initialize distance map and priority queue\\n    Map<List<Integer>, Integer> dist = new HashMap<>();\\n    dist.put(Arrays.asList(start[0], start[1]), 0);\\n    PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    heap.offer(new int[]{0, start[0], start[1]});\\n\\n    // Step 3: Run Dijkstra\\'s algorithm to find shortest path\\n    while (!heap.isEmpty()) {\\n        int[] curr = heap.poll();\\n        int currdist = curr[0], x = curr[1], y = curr[2];\\n        for (int[] road : filteredRoads) {\\n            int a = road[0], b = road[1], c = road[2], d = road[3], cost = road[4];\\n            if (dist.getOrDefault(Arrays.asList(c, d), Integer.MAX_VALUE) > currdist + Math.abs(x - a) + Math.abs(y - b) + cost) {\\n                dist.put(Arrays.asList(c, d), currdist + Math.abs(x - a) + Math.abs(y - b) + cost);\\n                heap.offer(new int[]{dist.get(Arrays.asList(c, d)), c, d});\\n            }\\n        }\\n    }\\n\\n    // Step 4: Compute minimum cost to travel from start to target\\n    int res = Math.abs(target[0] - start[0]) + Math.abs(target[1] - start[1]);\\n    for (int[] road : filteredRoads) {\\n        int a = road[0], b = road[1], c = road[2], d = road[3], cost = road[4];\\n        res = Math.min(res, dist.getOrDefault(Arrays.asList(c, d), Integer.MAX_VALUE) + Math.abs(target[0] - c) + Math.abs(target[1] - d));\\n    }\\n\\n    // Step 5: Return the minimum cost\\n    return res;\\n}\\n```\n```python []\\nimport heapq\\ndef minimumCost(start, target, specialRoads):\\n    filteredRoads = []\\n    for road in specialRoads:\\n        a, b, c, d, cost = road\\n        if cost < abs(a - c) + abs(b - d):\\n            filteredRoads.append([a, b, c, d, cost])\\n    dist = {(start[0], start[1]): 0}\\n    heap = [(0, start[0], start[1])]\\n    while heap:\\n        currdist, x, y = heapq.heappop(heap)\\n        for road in filteredRoads:\\n            a, b, c, d, cost = road\\n            if dist.get((c, d), float(\\'inf\\')) > currdist + abs(x - a) + abs(y - b) + cost:\\n                dist[(c, d)] = currdist + abs(x - a) + abs(y - b) + cost\\n                heapq.heappush(heap, (dist[(c, d)], c, d))\\n    res = abs(target[0] - start[0]) + abs(target[1] - start[1])\\n    for road in filteredRoads:\\n        a, b, c, d, cost = road\\n        res = min(res, dist.get((c, d), float(\\'inf\\')) + abs(target[0] - c) + abs(target[1] - d))\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3468327,
                "title": "python-dijkstra-with-explanation",
                "content": "# Explanation\\nAt every point, there are 3 cases that we need to consider:\\nCase 1. The point is at the starting position of a special road, we use this special road.\\nCase 2. We can go from the point to a starting position of a special road.\\nCase 3. We can go from the point directly to the target.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        \\n        minHeap = [(0, start[0], start[1])] # cost, r, c\\n        edges = defaultdict(list)\\n        \\n        for x1, y1, x2, y2, cost in specialRoads:\\n            # get rid of those edges which are not useful at all since the cost is larger than the absolute distance\\n            if abs(x2 - x1) + abs(y2 - y1) < cost: \\n                continue\\n            edges[(x1, y1)].append((cost, x2, y2))\\n            \\n        visited = {}\\n        while minHeap:\\n            ccost, cr, cc = heappop(minHeap)\\n            if cr == target[0] and cc == target[1]:\\n                return ccost\\n            if (cr, cc) in visited:\\n                continue\\n            visited[(cr, cc)] = ccost\\n            # Case 1. The point is at the starting position of a special road, we use this special road.\\n            if (cr, cc) in edges:\\n                for ecost, er, ec in edges[(cr, cc)]:\\n                    if (er, ec) not in visited:\\n                        heappush(minHeap, (ccost + ecost, er, ec))\\n            # Case 2. We can go from the point to a starting position of a special road.\\n            for sr, sc in edges:\\n                if (sr, sc) not in visited:\\n                    heappush(minHeap, (ccost + abs(sr-cr) + abs(sc-cc), sr, sc))\\n            # Case 3. We can go from the point directly to the target.\\n            heappush(minHeap, (ccost + abs(target[0]-cr) + abs(target[1]-cc), target[0], target[1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        \\n        minHeap = [(0, start[0], start[1])] # cost, r, c\\n        edges = defaultdict(list)\\n        \\n        for x1, y1, x2, y2, cost in specialRoads:\\n            # get rid of those edges which are not useful at all since the cost is larger than the absolute distance\\n            if abs(x2 - x1) + abs(y2 - y1) < cost: \\n                continue\\n            edges[(x1, y1)].append((cost, x2, y2))\\n            \\n        visited = {}\\n        while minHeap:\\n            ccost, cr, cc = heappop(minHeap)\\n            if cr == target[0] and cc == target[1]:\\n                return ccost\\n            if (cr, cc) in visited:\\n                continue\\n            visited[(cr, cc)] = ccost\\n            # Case 1. The point is at the starting position of a special road, we use this special road.\\n            if (cr, cc) in edges:\\n                for ecost, er, ec in edges[(cr, cc)]:\\n                    if (er, ec) not in visited:\\n                        heappush(minHeap, (ccost + ecost, er, ec))\\n            # Case 2. We can go from the point to a starting position of a special road.\\n            for sr, sc in edges:\\n                if (sr, sc) not in visited:\\n                    heappush(minHeap, (ccost + abs(sr-cr) + abs(sc-cc), sr, sc))\\n            # Case 3. We can go from the point directly to the target.\\n            heappush(minHeap, (ccost + abs(target[0]-cr) + abs(target[1]-cc), target[0], target[1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468350,
                "title": "c-priority-queue-dp-dijkstra",
                "content": "# Approach\\n`dp[i]` is the minimum cost to go from the end of `specialRoads[i]` to the target. We use a Priority Queue to maintain the fringe.\\n\\nThink about the process as follows: First, we will find out which special road has the closest end point to the target. The minimum cost from the end of that road to the target is just the $L_1$ distance, i.e. $|x_1 - x_2| + |y_1 - y_2|$. Now, for the other roads, the minimum cost from their endpoint to the target is either just the $L_1$ distance, or we go through another road. So we will use a min heap `priority_queue<pair<int, int>, ...>` of `(cost, index_of_road)` to maintain the frontier (fringe) of search. **From the end of each special road, the minimum cost path to the target is to either go directly, or via another road that has a lower dp value, i.e. has been expanded before.** Each special road is expanded at most once, each expansion adds $n - 1$ `pair`s to the fringe, so total time complexity is $O(n^2 log(n))$. Finally, to go from start to target, we either go directly (cost = $L_1$ distance), or choose our first special road, and we need to add the cost and dp value of that road to the $L_1$ distance from start to startpoint of that road.\\n\\nYou can also think of this problem as graphs, but this may over-complicate things.\\n\\n# Complexity\\n\\n- Time complexity:\\n$O(n^2 log(n))$\\n\\n- Space complexity:\\n$O(n^2)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int sx = start[0];\\n        int sy = start[1];\\n        int tx = target[0];\\n        int ty = target[1];\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int n = specialRoads.size();\\n        vector<int> dp(n, INT_MAX);\\n        for (int i = 0; i != n; ++i){\\n            pq.emplace(abs(tx - specialRoads[i][2]) + abs(ty - specialRoads[i][3]), i);\\n        }\\n        while (!pq.empty()){\\n            int cost = pq.top().first;\\n            int i = pq.top().second;\\n            pq.pop();\\n            if (dp[i] != INT_MAX) { continue; }\\n            dp[i] = min(dp[i], cost);\\n            for (int j = 0; j != n; ++j){\\n                if (j == i) { continue; }\\n                pq.emplace(cost + specialRoads[i][4] + abs(specialRoads[j][2] - specialRoads[i][0]) + abs(specialRoads[j][3] - specialRoads[i][1]), j);\\n            }\\n        }\\n        int res = abs(sx - tx) + abs(sy - ty);\\n        for (int i = 0; i != n; ++i){\\n            res = min(res, abs(sx - specialRoads[i][0]) + abs(sy - specialRoads[i][1]) + specialRoads[i][4] + dp[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int sx = start[0];\\n        int sy = start[1];\\n        int tx = target[0];\\n        int ty = target[1];\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int n = specialRoads.size();\\n        vector<int> dp(n, INT_MAX);\\n        for (int i = 0; i != n; ++i){\\n            pq.emplace(abs(tx - specialRoads[i][2]) + abs(ty - specialRoads[i][3]), i);\\n        }\\n        while (!pq.empty()){\\n            int cost = pq.top().first;\\n            int i = pq.top().second;\\n            pq.pop();\\n            if (dp[i] != INT_MAX) { continue; }\\n            dp[i] = min(dp[i], cost);\\n            for (int j = 0; j != n; ++j){\\n                if (j == i) { continue; }\\n                pq.emplace(cost + specialRoads[i][4] + abs(specialRoads[j][2] - specialRoads[i][0]) + abs(specialRoads[j][3] - specialRoads[i][1]), j);\\n            }\\n        }\\n        int res = abs(sx - tx) + abs(sy - ty);\\n        for (int i = 0; i != n; ++i){\\n            res = min(res, abs(sx - specialRoads[i][0]) + abs(sy - specialRoads[i][1]) + specialRoads[i][4] + dp[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479468,
                "title": "java-dijkstra-s-algorithm-clean-code-15-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2*log(n^2))$$ where n is the number of special roads\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n    var visited = new HashSet<Pair<Integer, Integer>>();\\n\\n    var queue = new PriorityQueue<int[]>((a, b) -> Integer.compare(a[2], b[2]));\\n    queue.offer(new int[] {start[0], start[1], 0});\\n\\n    while (!queue.isEmpty()) {\\n      var a = queue.poll();\\n      int x = a[0], y = a[1], cost = a[2];\\n      var pos = new Pair(x, y);\\n\\n      if (visited.contains(pos)) continue;\\n\\n      if (x == target[0] && y == target[1])\\n        return cost;\\n\\n      visited.add(pos);\\n\\n      queue.offer(new int[] {target[0], target[1], cost + Math.abs(target[0] - x) + Math.abs(target[1] - y)});\\n\\n      for (var r : specialRoads)\\n        if (!visited.contains(new Pair(r[2], r[3])))\\n          queue.offer(new int[] {r[2], r[3], Math.abs(r[0] - x) + Math.abs(r[1] - y) + cost + r[4]});\\n\\n    }\\n    return -1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n    var visited = new HashSet<Pair<Integer, Integer>>();\\n\\n    var queue = new PriorityQueue<int[]>((a, b) -> Integer.compare(a[2], b[2]));\\n    queue.offer(new int[] {start[0], start[1], 0});\\n\\n    while (!queue.isEmpty()) {\\n      var a = queue.poll();\\n      int x = a[0], y = a[1], cost = a[2];\\n      var pos = new Pair(x, y);\\n\\n      if (visited.contains(pos)) continue;\\n\\n      if (x == target[0] && y == target[1])\\n        return cost;\\n\\n      visited.add(pos);\\n\\n      queue.offer(new int[] {target[0], target[1], cost + Math.abs(target[0] - x) + Math.abs(target[1] - y)});\\n\\n      for (var r : specialRoads)\\n        if (!visited.contains(new Pair(r[2], r[3])))\\n          queue.offer(new int[] {r[2], r[3], Math.abs(r[0] - x) + Math.abs(r[1] - y) + cost + r[4]});\\n\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471042,
                "title": "no-dijkstra-just-bfs",
                "content": "We can go straing from start to finish with the cost of the Manhattan distance.\\n\\nThis is the shortest path, and we do not need to consider any positions in the grid. Except when we can take a special road.\\n\\nFor each special road, we track the minimum cost to reach its destination.\\n\\nWe run BFS from the starting position. \\n\\n> Note that we add a sentinel \"road\" to represetn the start position, and we use that road as the starting point.\\n\\nThe current position in BFS is the destination of `i` road. From that position, we consider taking **all** roads. \\n\\nIf taking a road improves the minimal cost to reach its destination, we update the cost and the road into the queue.\\n\\nI tried a priority queue, but the runtime is already 28 ms and priority queue did not improve it.\\n\\n**C++**\\n```cpp\\nint minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& rs) {\\n    int res = t[0] - s[0] + t[1] - s[1], sz = rs.size();\\n    rs.push_back({s[0], s[1], s[0], s[1], 0});\\n    vector<int> dp(sz + 1, INT_MAX);\\n    vector<array<int, 2>> q{{sz, 0}}, q1;\\n    while (!q.empty()) {\\n        q1.clear();\\n        for (auto [i, cost_i] : q) {\\n            if (cost_i <= dp[i]) {\\n                int x2i = rs[i][2], y2i = rs[i][3];\\n                for (int j = 0; j < sz; ++j) {\\n                    int x1j = rs[j][0], y1j = rs[j][1], x2j = rs[j][2], y2j = rs[j][3], cost_j = rs[j][4];\\n                    dp[j] = min(dp[j], cost_i + abs(x2j - x2i) + abs(y2j - y2i));\\n                    int take = cost_i + cost_j + abs(x1j - x2i) + abs(y1j - y2i);\\n                    if (take < dp[j]) {\\n                        dp[j] = take;\\n                        q1.push_back({j, take});\\n                        res = min(res, take + abs(x2j - t[0]) + abs(y2j - t[1]));\\n                    }   \\n                }\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& rs) {\\n    int res = t[0] - s[0] + t[1] - s[1], sz = rs.size();\\n    rs.push_back({s[0], s[1], s[0], s[1], 0});\\n    vector<int> dp(sz + 1, INT_MAX);\\n    vector<array<int, 2>> q{{sz, 0}}, q1;\\n    while (!q.empty()) {\\n        q1.clear();\\n        for (auto [i, cost_i] : q) {\\n            if (cost_i <= dp[i]) {\\n                int x2i = rs[i][2], y2i = rs[i][3];\\n                for (int j = 0; j < sz; ++j) {\\n                    int x1j = rs[j][0], y1j = rs[j][1], x2j = rs[j][2], y2j = rs[j][3], cost_j = rs[j][4];\\n                    dp[j] = min(dp[j], cost_i + abs(x2j - x2i) + abs(y2j - y2i));\\n                    int take = cost_i + cost_j + abs(x1j - x2i) + abs(y1j - y2i);\\n                    if (take < dp[j]) {\\n                        dp[j] = take;\\n                        q1.push_back({j, take});\\n                        res = min(res, take + abs(x2j - t[0]) + abs(y2j - t[1]));\\n                    }   \\n                }\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471212,
                "title": "dijkstras-map-based-solution-map-every-end-pt-of-spl-road",
                "content": "# Idea\\n- Make the end pt of all special roads as some node.\\n- Calculate the min most dist from start --- end pt of spl road and store\\n- As Start --- spl1---spl2----splk---target is a generic path.\\n- Where k = 0,1,2,3,...N [N is total spl roads]\\n- Try all roads dist till end + manhattan dist of (end of road, target).\\n- Ans is the min of all those.\\n\\n# Approach\\n- Filter all spl roads that have cost >= manhattaten dist. \\n- As the purpose to have spl road is to have lesser cost from start --- end pt of road than comapred to manhatten dist of start and Endpt of road.\\n- ANS = MANHATTEN DIST(start, target)\\n- ANS = MIN(ANS, MinMost Dist of SPLROAD[i].End + Abs(End - Target) )\\n- Other Nuances of the code are told in form of **Comments**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<vector<int>, int> dist; // to store each point minmost dist\\n        dist[start] = 0;\\n\\n        //filter roads - those that have cost more than manhatten of themselves\\n        vector<vector<int>> filteredRoads;\\n        for(auto r : specialRoads){\\n            int a = r[0], b = r[1], c = r[2], d = r[3], cost = r[4];\\n            //a,b ...... c,d with edgecost as cost\\n            if(cost < abs(a-c) + abs(b-d)){\\n                filteredRoads.push_back({a,b,c,d,cost});\\n                dist[{c,d}] = abs(start[0] - c) + abs(start[1] - d);\\n            } \\n        }\\n\\n        //Dijstras to find the ans\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq; //minheap to pick min most dist\\n        pq.push({0, start[0], start[1]}); //dist, x, y\\n\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int mdist = it[0], x= it[1], y = it[2];\\n            //for reaching x,y from start d is the min most dist\\n\\n            //try taking any spl road to reach the pt some c,d from x,y\\n            for(auto r : filteredRoads){\\n                int a = r[0], b = r[1], c = r[2], d = r[3], rcost = r[4]; //road cost\\n                //x,y....a,b......c,d\\n\\n                if(dist[{c,d}] > mdist + abs(x-a) + abs(y-b) + rcost){\\n                    dist[{c,d}] = mdist + abs(x-a) + abs(y-b) + rcost;\\n                    pq.push({dist[{c,d}], c, d});\\n                    // we push c,d so that we can use other spl roads \\n                    //x,y...a1,b1....c1,d1....a2,b2....c2,d2\\n                }\\n            }\\n        }\\n\\n        //now we have the minmost dist to reach every end point of spl roads\\n        //c,d....target is the deciding factor - overall min is needed\\n        int ans = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n        \\n        for(auto r : filteredRoads){\\n            int tx = target[0], ty = target[1];\\n            int a = r[0], b = r[1], c = r[2], d = r[3], cost = r[4];\\n            ans = min(ans, dist[{c,d}] + abs(c-tx) + abs(d-ty));\\n            cout<<dist[{c,d}]<<\"\\\\n\";\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n### Guys if you feel the post worth it, kindly UPVOTE, it motivates me a lot to post more.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<vector<int>, int> dist; // to store each point minmost dist\\n        dist[start] = 0;\\n\\n        //filter roads - those that have cost more than manhatten of themselves\\n        vector<vector<int>> filteredRoads;\\n        for(auto r : specialRoads){\\n            int a = r[0], b = r[1], c = r[2], d = r[3], cost = r[4];\\n            //a,b ...... c,d with edgecost as cost\\n            if(cost < abs(a-c) + abs(b-d)){\\n                filteredRoads.push_back({a,b,c,d,cost});\\n                dist[{c,d}] = abs(start[0] - c) + abs(start[1] - d);\\n            } \\n        }\\n\\n        //Dijstras to find the ans\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq; //minheap to pick min most dist\\n        pq.push({0, start[0], start[1]}); //dist, x, y\\n\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int mdist = it[0], x= it[1], y = it[2];\\n            //for reaching x,y from start d is the min most dist\\n\\n            //try taking any spl road to reach the pt some c,d from x,y\\n            for(auto r : filteredRoads){\\n                int a = r[0], b = r[1], c = r[2], d = r[3], rcost = r[4]; //road cost\\n                //x,y....a,b......c,d\\n\\n                if(dist[{c,d}] > mdist + abs(x-a) + abs(y-b) + rcost){\\n                    dist[{c,d}] = mdist + abs(x-a) + abs(y-b) + rcost;\\n                    pq.push({dist[{c,d}], c, d});\\n                    // we push c,d so that we can use other spl roads \\n                    //x,y...a1,b1....c1,d1....a2,b2....c2,d2\\n                }\\n            }\\n        }\\n\\n        //now we have the minmost dist to reach every end point of spl roads\\n        //c,d....target is the deciding factor - overall min is needed\\n        int ans = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n        \\n        for(auto r : filteredRoads){\\n            int tx = target[0], ty = target[1];\\n            int a = r[0], b = r[1], c = r[2], d = r[3], cost = r[4];\\n            ans = min(ans, dist[{c,d}] + abs(c-tx) + abs(d-ty));\\n            cout<<dist[{c,d}]<<\"\\\\n\";\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468323,
                "title": "python-simple-dfs-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        def dist(x1,x2,y1,y2):\\n            return abs(x1-x2)+abs(y1-y2)      \\n  \\n        self.ans = abs(start[0]-target[0]) + abs(start[1]-target[1])\\n        hm = dict()\\n\\n        def helper(curX, curY, curDist):\\n            # Pruning 1\\n            if curDist >= self.ans: return\\n            self.ans = min(self.ans, dist(curX, target[0], curY, target[1]) + curDist)\\n            \\n            # Pruning 2\\n            if (curX, curY) in hm:\\n                if hm[(curX,curY)] <= curDist:\\n                    return\\n            hm[(curX,curY)] = curDist\\n            \\n            for next in specialRoads:\\n                helper(next[2], next[3], curDist + dist(curX, next[0], curY, next[1]) + next[4])\\n\\n        helper(start[0], start[1], 0)\\n\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        def dist(x1,x2,y1,y2):\\n            return abs(x1-x2)+abs(y1-y2)      \\n  \\n        self.ans = abs(start[0]-target[0]) + abs(start[1]-target[1])\\n        hm = dict()\\n\\n        def helper(curX, curY, curDist):\\n            # Pruning 1\\n            if curDist >= self.ans: return\\n            self.ans = min(self.ans, dist(curX, target[0], curY, target[1]) + curDist)\\n            \\n            # Pruning 2\\n            if (curX, curY) in hm:\\n                if hm[(curX,curY)] <= curDist:\\n                    return\\n            hm[(curX,curY)] = curDist\\n            \\n            for next in specialRoads:\\n                helper(next[2], next[3], curDist + dist(curX, next[0], curY, next[1]) + next[4])\\n\\n        helper(start[0], start[1], 0)\\n\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473079,
                "title": "simplest-implementation-to-this-tricky-problem-fully-commented",
                "content": "# Observation and Implementation\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot 2023-05-01 151730.png](https://assets.leetcode.com/users/images/8077c105-678f-4fda-b6bb-d99334ef0a5f_1682934548.7804344.png)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int dist(int ax,int ay,int bx,int by)\\n    {\\n        return abs(ax-bx)+abs(ay-by);\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& special) \\n    {\\n        \\n\\n        int sx=start[0],sy=start[1],tx=target[0],ty=target[1];\\n        //Trick: In case the special roads does not lead to the target so explicitly add the target in the special roads\\n        special.push_back({tx,ty,tx,ty,0});\\n        \\n        //we need a queue of [x][y][cost]\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{sx,sy},0});\\n\\n        //unordered map tp store the distances\\n        map<pair<int, int>, int> mp;\\n        //store all the ending positions in the map and set them as Infinity\\n        for(auto it:special)\\n            mp[{it[2],it[3]}]=INT_MAX;\\n        mp[{tx,ty}]=dist(sx,sy,tx,ty);\\n\\n        //implementg the Djikstra algorithm\\n        while(!q.empty())\\n        {\\n            int curr_x=q.front().first.first;\\n            int curr_y=q.front().first.second;\\n            int curr_dist=q.front().second;\\n            q.pop();\\n            //Iterating over all the special roads and checking ehich special road leads to an index in the minimum cost\\n            \\n            for(auto it:special)\\n            {\\n                int st_x=it[0];\\n                int st_y=it[1];\\n                int end_x=it[2];\\n                int end_y=it[3];\\n                int special_dist=it[4];\\n                //calculating the manhatten distance from the current pos to the start of the special road\\n                int dist_to_start=dist(curr_x,curr_y,st_x,st_y);\\n                int total_dist=curr_dist+dist_to_start+special_dist;\\n                if(mp[{end_x,end_y}]>total_dist)\\n                {\\n                    mp[{end_x,end_y}]=total_dist;\\n                    q.push({{end_x,end_y},total_dist});\\n                }\\n            }\\n        }\\n        return mp[{tx,ty}];\\n    }\\n};\\n```\\n**Please Upvote**\\uD83E\\uDD7A\\uD83E\\uDD7A\\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dist(int ax,int ay,int bx,int by)\\n    {\\n        return abs(ax-bx)+abs(ay-by);\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& special) \\n    {\\n        \\n\\n        int sx=start[0],sy=start[1],tx=target[0],ty=target[1];\\n        //Trick: In case the special roads does not lead to the target so explicitly add the target in the special roads\\n        special.push_back({tx,ty,tx,ty,0});\\n        \\n        //we need a queue of [x][y][cost]\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{sx,sy},0});\\n\\n        //unordered map tp store the distances\\n        map<pair<int, int>, int> mp;\\n        //store all the ending positions in the map and set them as Infinity\\n        for(auto it:special)\\n            mp[{it[2],it[3]}]=INT_MAX;\\n        mp[{tx,ty}]=dist(sx,sy,tx,ty);\\n\\n        //implementg the Djikstra algorithm\\n        while(!q.empty())\\n        {\\n            int curr_x=q.front().first.first;\\n            int curr_y=q.front().first.second;\\n            int curr_dist=q.front().second;\\n            q.pop();\\n            //Iterating over all the special roads and checking ehich special road leads to an index in the minimum cost\\n            \\n            for(auto it:special)\\n            {\\n                int st_x=it[0];\\n                int st_y=it[1];\\n                int end_x=it[2];\\n                int end_y=it[3];\\n                int special_dist=it[4];\\n                //calculating the manhatten distance from the current pos to the start of the special road\\n                int dist_to_start=dist(curr_x,curr_y,st_x,st_y);\\n                int total_dist=curr_dist+dist_to_start+special_dist;\\n                if(mp[{end_x,end_y}]>total_dist)\\n                {\\n                    mp[{end_x,end_y}]=total_dist;\\n                    q.push({{end_x,end_y},total_dist});\\n                }\\n            }\\n        }\\n        return mp[{tx,ty}];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468489,
                "title": "beats-100-dijkstra-s-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    struct hash_pair {\\n    template <class T1, class T2>\\n    size_t operator()(const pair<T1, T2>& p) const\\n    {\\n        auto hash1 = hash<T1>{}(p.first);\\n        auto hash2 = hash<T2>{}(p.second);\\n \\n        if (hash1 != hash2) {\\n            return hash1 ^ hash2;             \\n        }\\n         \\n          return hash1;\\n    }\\n};\\n    \\n    \\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& a) {\\n        \\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> p;\\n        unordered_map<pair<int,int>,int,hash_pair> m;\\n        p.push({0,s[0],s[1]});\\n        \\n        m[{s[0],s[1]}]=0;\\n        \\n        int cx,cy,cz;\\n        \\n        while(!p.empty()){\\n            int sx = p.top()[1];\\n            int sy = p.top()[2];\\n            int c = p.top()[0];\\n            \\n            p.pop();            \\n            \\n            if(sx==t[0] && sy==t[1]) return c;            \\n           \\n            p.push({c+abs(sx-t[0])+abs(sy-t[1]), t[0], t[1]});           \\n            \\n            for(int i=0; i<a.size(); i++){\\n                \\n                if(a[i][2]==sx && a[i][3]==sy) continue;\\n                \\n                cx = abs(sx-a[i][0]);\\n                cy = abs(sy-a[i][1]);\\n                cz = a[i][4];\\n                \\n                \\n                if((m[{a[i][2],a[i][3]}] ==0)  || (m[{a[i][2],a[i][3]}]>c+cx+cy+cz)){\\n                    m[{a[i][2],a[i][3]}]=c+cx+cy+cz;\\n                    p.push({c+cx+cy+cz,a[i][2],a[i][3]});                    \\n                }\\n            \\n            } \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct hash_pair {\\n    template <class T1, class T2>\\n    size_t operator()(const pair<T1, T2>& p) const\\n    {\\n        auto hash1 = hash<T1>{}(p.first);\\n        auto hash2 = hash<T2>{}(p.second);\\n \\n        if (hash1 != hash2) {\\n            return hash1 ^ hash2;             \\n        }\\n         \\n          return hash1;\\n    }\\n};\\n    \\n    \\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& a) {\\n        \\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> p;\\n        unordered_map<pair<int,int>,int,hash_pair> m;\\n        p.push({0,s[0],s[1]});\\n        \\n        m[{s[0],s[1]}]=0;\\n        \\n        int cx,cy,cz;\\n        \\n        while(!p.empty()){\\n            int sx = p.top()[1];\\n            int sy = p.top()[2];\\n            int c = p.top()[0];\\n            \\n            p.pop();            \\n            \\n            if(sx==t[0] && sy==t[1]) return c;            \\n           \\n            p.push({c+abs(sx-t[0])+abs(sy-t[1]), t[0], t[1]});           \\n            \\n            for(int i=0; i<a.size(); i++){\\n                \\n                if(a[i][2]==sx && a[i][3]==sy) continue;\\n                \\n                cx = abs(sx-a[i][0]);\\n                cy = abs(sy-a[i][1]);\\n                cz = a[i][4];\\n                \\n                \\n                if((m[{a[i][2],a[i][3]}] ==0)  || (m[{a[i][2],a[i][3]}]>c+cx+cy+cz)){\\n                    m[{a[i][2],a[i][3]}]=c+cx+cy+cz;\\n                    p.push({c+cx+cy+cz,a[i][2],a[i][3]});                    \\n                }\\n            \\n            } \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468545,
                "title": "spfa",
                "content": "# Intuition\\nConstruct a graph with only start, target and end points of special roads.\\n\\n# Approach\\nJust run SPFA.\\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 2logn) where n is the number of special roads.\\n\\n- Space complexity:\\nO(n ^ 2) where n is the number of special roads.\\n\\n# Code\\n```\\nclass Solution {\\n    long long make(long long x, long long y) {\\n        return (x << 20) | y;\\n    }\\n\\n    void maybe(long long state, int dist, \\n    priority_queue<pair<int, long long>> &q,\\n    unordered_map<long long, int> &d) {\\n        if (!d.count(state) || d[state] > dist) {\\n            d[state] = dist;\\n            q.push({-dist, state});\\n        }\\n    }\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        unordered_map<long long, vector<vector<int>>> con;\\n        unordered_set<long long> all = {make(target[0], target[1])};\\n        for (const auto& v : specialRoads) {\\n            con[make(v[0], v[1])].push_back({v[2], v[3], v[4]});\\n            all.insert(make(v[0], v[1]));\\n        }\\n\\n        unordered_map<long long, int> d;\\n        unordered_set<long long> have;\\n        d[make(start[0], start[1])] = 0;\\n        priority_queue<pair<int, long long>> q;\\n        q.push({0, make(start[0], start[1])});\\n        while (!q.empty()) {\\n            const long long state = q.top().second;\\n            const int x = state >> 20, y = state & 1048575, dist = -q.top().first;\\n            q.pop();\\n            if (have.count(state)) {\\n                continue;\\n            }\\n            have.insert(state);\\n            if (x == target[0] && y == target[1]) {\\n                return dist;\\n            }\\n            if (con.count(state)) {\\n                for (const auto& v : con[state]) {\\n                    maybe(make(v[0], v[1]), dist + v[2], q, d);\\n                }\\n            }\\n            for (long long s : all) {\\n                maybe(s, dist + abs((s >> 20) - x) + abs((s & 1048575) - y), q, d);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long make(long long x, long long y) {\\n        return (x << 20) | y;\\n    }\\n\\n    void maybe(long long state, int dist, \\n    priority_queue<pair<int, long long>> &q,\\n    unordered_map<long long, int> &d) {\\n        if (!d.count(state) || d[state] > dist) {\\n            d[state] = dist;\\n            q.push({-dist, state});\\n        }\\n    }\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        unordered_map<long long, vector<vector<int>>> con;\\n        unordered_set<long long> all = {make(target[0], target[1])};\\n        for (const auto& v : specialRoads) {\\n            con[make(v[0], v[1])].push_back({v[2], v[3], v[4]});\\n            all.insert(make(v[0], v[1]));\\n        }\\n\\n        unordered_map<long long, int> d;\\n        unordered_set<long long> have;\\n        d[make(start[0], start[1])] = 0;\\n        priority_queue<pair<int, long long>> q;\\n        q.push({0, make(start[0], start[1])});\\n        while (!q.empty()) {\\n            const long long state = q.top().second;\\n            const int x = state >> 20, y = state & 1048575, dist = -q.top().first;\\n            q.pop();\\n            if (have.count(state)) {\\n                continue;\\n            }\\n            have.insert(state);\\n            if (x == target[0] && y == target[1]) {\\n                return dist;\\n            }\\n            if (con.count(state)) {\\n                for (const auto& v : con[state]) {\\n                    maybe(make(v[0], v[1]), dist + v[2], q, d);\\n                }\\n            }\\n            for (long long s : all) {\\n                maybe(s, dist + abs((s >> 20) - x) + abs((s & 1048575) - y), q, d);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468518,
                "title": "java-dikstra-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    class Pair{\\n        int x;\\n        int y;\\n        int cost;\\n        Pair(int x,int y,int cost){\\n            this.x=x;\\n            this.y=y;\\n            this.cost=cost;\\n        }\\n    }\\n    \\n    \\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int m=specialRoads.length;\\n        int n=specialRoads[0].length;\\n        HashMap<Integer,HashSet<Integer>>map=new HashMap<>();\\n        \\n        \\n        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->a.cost-b.cost);;\\n        \\n        \\n        int fx=target[0],fy=target[1];\\n        int x1=start[0],y1=start[1];\\n        \\n        \\n        pq.add(new Pair(x1,y1,0));\\n        \\n        while(pq.size()!=0){\\n\\n              Pair rem=pq.remove();\\n            x1=rem.x;\\n            y1=rem.y;\\n\\n             if(map.containsKey(x1)&&map.get(x1).contains(y1)){\\n                        continue;\\n               }\\n\\n          \\n            \\n            if(map.containsKey(x1)==false){\\n                map.put(x1,new HashSet<Integer>());\\n            }\\n            map.get(x1).add(y1);\\n            \\n            \\n            if(rem.x==fx&&rem.y==fy){\\n                return rem.cost;\\n            }\\n            \\n            pq.add(new Pair(fx,fy,rem.cost+Math.abs(x1-fx)+Math.abs(y1-fy)));\\n            \\n            for(int i=0;i<specialRoads.length;i++){\\n                \\n                int x=specialRoads[i][0];\\n                int y=specialRoads[i][1];\\n                int x2=specialRoads[i][2];\\n                int y2=specialRoads[i][3];\\n                int ct=specialRoads[i][4];\\n                \\n               \\n                    if(map.containsKey(x2)&&map.get(x2).contains(y2)){\\n                        continue;\\n                    }\\n                    pq.add(new Pair(x2,y2,rem.cost+ct+Math.abs(x1-x)+Math.abs(y1-y)));\\n                    \\n                \\n                \\n            }\\n            \\n           \\n            \\n            \\n        }\\n        \\n        return -1;\\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Pair{\\n        int x;\\n        int y;\\n        int cost;\\n        Pair(int x,int y,int cost){\\n            this.x=x;\\n            this.y=y;\\n            this.cost=cost;\\n        }\\n    }\\n    \\n    \\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int m=specialRoads.length;\\n        int n=specialRoads[0].length;\\n        HashMap<Integer,HashSet<Integer>>map=new HashMap<>();\\n        \\n        \\n        PriorityQueue<Pair>pq=new PriorityQueue<>((a,b)->a.cost-b.cost);;\\n        \\n        \\n        int fx=target[0],fy=target[1];\\n        int x1=start[0],y1=start[1];\\n        \\n        \\n        pq.add(new Pair(x1,y1,0));\\n        \\n        while(pq.size()!=0){\\n\\n              Pair rem=pq.remove();\\n            x1=rem.x;\\n            y1=rem.y;\\n\\n             if(map.containsKey(x1)&&map.get(x1).contains(y1)){\\n                        continue;\\n               }\\n\\n          \\n            \\n            if(map.containsKey(x1)==false){\\n                map.put(x1,new HashSet<Integer>());\\n            }\\n            map.get(x1).add(y1);\\n            \\n            \\n            if(rem.x==fx&&rem.y==fy){\\n                return rem.cost;\\n            }\\n            \\n            pq.add(new Pair(fx,fy,rem.cost+Math.abs(x1-fx)+Math.abs(y1-fy)));\\n            \\n            for(int i=0;i<specialRoads.length;i++){\\n                \\n                int x=specialRoads[i][0];\\n                int y=specialRoads[i][1];\\n                int x2=specialRoads[i][2];\\n                int y2=specialRoads[i][3];\\n                int ct=specialRoads[i][4];\\n                \\n               \\n                    if(map.containsKey(x2)&&map.get(x2).contains(y2)){\\n                        continue;\\n                    }\\n                    pq.add(new Pair(x2,y2,rem.cost+ct+Math.abs(x1-x)+Math.abs(y1-y)));\\n                    \\n                \\n                \\n            }\\n            \\n           \\n            \\n            \\n        }\\n        \\n        return -1;\\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468795,
                "title": "c-solution-o-m-3-floyd-warshall-cordinate-compression-dp",
                "content": "```\\ntemplate<typename T> void unique(vector<T> &a){sort(a.begin(), a.end()); a.resize(unique(a.begin(), a.end()) - a.begin());}\\nclass Solution {\\npublic:\\n    const int N = 1e5 + 1;\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int sx = start[0], sy = start[1], ex = target[0], ey = target[1];\\n        vector<long long> point; point.push_back(sx * 1LL * N + sy), point.push_back(ex * 1LL * N + ey);\\n        for (auto &e : specialRoads){\\n            int fx = e[0], fy = e[1], tx = e[2], ty = e[3], c = e[4];\\n            point.push_back(fx * 1LL * N + fy), point.push_back(tx * 1LL * N + ty);\\n        }\\n        unique(point);\\n        map<long long, int> uu;\\n        int ID = 0;\\n        auto get = [&](long long x){return (!uu.count(x) ? uu[x] = ID++ : uu[x]);};   \\n        get(sx * 1LL * N + sy), get(ex * 1LL * N + ey);\\n        for (auto &e : specialRoads){\\n            int fx = e[0], fy = e[1], tx = e[2], ty = e[3], c = e[4];\\n            get(fx * 1LL * N + fy), get(tx * 1LL * N + ty);\\n        }\\n        int dp[ID][ID];\\n        for (auto &e : point){\\n            int x1 = e / N, y1 = e % N;\\n            for (auto &f : point){\\n                int x2 = f / N, y2 = f % N;\\n                int x = get(e), y = get(f);\\n                dp[x][y] = abs(x1 - x2) + abs(y1 - y2);\\n            }\\n        }\\n        for (auto &e : specialRoads){\\n            int fx = e[0], fy = e[1], tx = e[2], ty = e[3], c = e[4];\\n            int x = get(fx * 1LL * N + fy), y = get(tx * 1LL * N + ty);\\n            dp[x][y] = min(dp[x][y], c);\\n        }\\n        for (int k = 0; k < ID; k++) for (int i = 0; i < ID; i++) for (int j = 0; j < ID; j++) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\\n        int x = get(sx * 1LL * N + sy), y = get(ex * 1LL * N + ey);\\n        return dp[x][y];\\n    }\\n};\\n```\\n\\nPS: Upvote if you like :) feel free to ask any query :)",
                "solutionTags": [],
                "code": "```\\ntemplate<typename T> void unique(vector<T> &a){sort(a.begin(), a.end()); a.resize(unique(a.begin(), a.end()) - a.begin());}\\nclass Solution {\\npublic:\\n    const int N = 1e5 + 1;\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int sx = start[0], sy = start[1], ex = target[0], ey = target[1];\\n        vector<long long> point; point.push_back(sx * 1LL * N + sy), point.push_back(ex * 1LL * N + ey);\\n        for (auto &e : specialRoads){\\n            int fx = e[0], fy = e[1], tx = e[2], ty = e[3], c = e[4];\\n            point.push_back(fx * 1LL * N + fy), point.push_back(tx * 1LL * N + ty);\\n        }\\n        unique(point);\\n        map<long long, int> uu;\\n        int ID = 0;\\n        auto get = [&](long long x){return (!uu.count(x) ? uu[x] = ID++ : uu[x]);};   \\n        get(sx * 1LL * N + sy), get(ex * 1LL * N + ey);\\n        for (auto &e : specialRoads){\\n            int fx = e[0], fy = e[1], tx = e[2], ty = e[3], c = e[4];\\n            get(fx * 1LL * N + fy), get(tx * 1LL * N + ty);\\n        }\\n        int dp[ID][ID];\\n        for (auto &e : point){\\n            int x1 = e / N, y1 = e % N;\\n            for (auto &f : point){\\n                int x2 = f / N, y2 = f % N;\\n                int x = get(e), y = get(f);\\n                dp[x][y] = abs(x1 - x2) + abs(y1 - y2);\\n            }\\n        }\\n        for (auto &e : specialRoads){\\n            int fx = e[0], fy = e[1], tx = e[2], ty = e[3], c = e[4];\\n            int x = get(fx * 1LL * N + fy), y = get(tx * 1LL * N + ty);\\n            dp[x][y] = min(dp[x][y], c);\\n        }\\n        for (int k = 0; k < ID; k++) for (int i = 0; i < ID; i++) for (int j = 0; j < ID; j++) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\\n        int x = get(sx * 1LL * N + sy), y = get(ex * 1LL * N + ey);\\n        return dp[x][y];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468496,
                "title": "python-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        g = collections.defaultdict(list)\\n        s1, s2 = start\\n        s3, s4 = target\\n        g[(s1, s2)].append((s3, s4, abs(s1 - s3) + abs(s2 - s4)))\\n        for s1, s2, s3, s4, s5 in specialRoads:\\n            g[(s1, s2)].append((s3, s4, s5))\\n            g[(start[0], start[1])].append((s1, s2, abs(s1 - start[0]) + abs(s2 - start[1])))\\n            g[(s3, s4)].append((target[0], target[1], abs(s3 -target[0]) + abs(s4 - target[1])))\\n            for s1_n, s2_n, _, _, _ in specialRoads:\\n                g[(s3, s4)].append((s1_n, s2_n, abs(s1_n - s3) + abs(s2_n - s4)))\\n        \\n        cost = {(start[0], start[1]): float(\\'inf\\'), (target[0], target[1]): float(\\'inf\\')}\\n        for s1, s2, s3, s4, _ in specialRoads:\\n            cost[(s1, s2)] = float(\\'inf\\')\\n            cost[(s3, s4)] = float(\\'inf\\')\\n        pq = [(0, start[0], start[1])]\\n        while pq:\\n            c, x, y = heapq.heappop(pq)\\n            if [x, y] == target: return c\\n            \\n            for x_n, y_n, c_n in g[(x, y)]:\\n                if c + c_n < cost[(x_n, y_n)]:\\n                    cost[(x_n, y_n)] = c + c_n\\n                    heapq.heappush(pq, (c + c_n, x_n, y_n))\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        g = collections.defaultdict(list)\\n        s1, s2 = start\\n        s3, s4 = target\\n        g[(s1, s2)].append((s3, s4, abs(s1 - s3) + abs(s2 - s4)))\\n        for s1, s2, s3, s4, s5 in specialRoads:\\n            g[(s1, s2)].append((s3, s4, s5))\\n            g[(start[0], start[1])].append((s1, s2, abs(s1 - start[0]) + abs(s2 - start[1])))\\n            g[(s3, s4)].append((target[0], target[1], abs(s3 -target[0]) + abs(s4 - target[1])))\\n            for s1_n, s2_n, _, _, _ in specialRoads:\\n                g[(s3, s4)].append((s1_n, s2_n, abs(s1_n - s3) + abs(s2_n - s4)))\\n        \\n        cost = {(start[0], start[1]): float(\\'inf\\'), (target[0], target[1]): float(\\'inf\\')}\\n        for s1, s2, s3, s4, _ in specialRoads:\\n            cost[(s1, s2)] = float(\\'inf\\')\\n            cost[(s3, s4)] = float(\\'inf\\')\\n        pq = [(0, start[0], start[1])]\\n        while pq:\\n            c, x, y = heapq.heappop(pq)\\n            if [x, y] == target: return c\\n            \\n            for x_n, y_n, c_n in g[(x, y)]:\\n                if c + c_n < cost[(x_n, y_n)]:\\n                    cost[(x_n, y_n)] = c + c_n\\n                    heapq.heappush(pq, (c + c_n, x_n, y_n))\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468321,
                "title": "was-dp-not-the-way-to-approach-it",
                "content": "Hey can anybody tell me why this solution did not pass although it looks good to me\\nCan we even approach this question with DP?\\n\\n```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        return fun(start, target, start[0],start[1],specialRoads, new Integer[target[0]][target[1]]);\\n    }\\n    int fun(int[] st, int[] tar, int i, int j, int[][] sp, Integer[][] dp){\\n        if(i==tar[0] || j==tar[1])return 0;\\n        \\n        if(dp[i][j]!=null)return dp[i][j];\\n        // not take a special road\\n        int ans=dist(i,j,tar[0],tar[1])+fun(st,tar,tar[0],tar[1],sp,dp);\\n        for(int[] spp: sp){\\n            if(i<=spp[0] && j<=spp[1]){\\n                //take special road\\n                int chooseRoad = dist(i,j,spp[0],spp[1])+spp[4]+fun(st,tar,spp[2],spp[3],sp, dp);\\n                ans = Math.min(chooseRoad, ans);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int dist(int a, int b, int x, int y){\\n        return Math.abs(a-x)+Math.abs(b-y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        return fun(start, target, start[0],start[1],specialRoads, new Integer[target[0]][target[1]]);\\n    }\\n    int fun(int[] st, int[] tar, int i, int j, int[][] sp, Integer[][] dp){\\n        if(i==tar[0] || j==tar[1])return 0;\\n        \\n        if(dp[i][j]!=null)return dp[i][j];\\n        // not take a special road\\n        int ans=dist(i,j,tar[0],tar[1])+fun(st,tar,tar[0],tar[1],sp,dp);\\n        for(int[] spp: sp){\\n            if(i<=spp[0] && j<=spp[1]){\\n                //take special road\\n                int chooseRoad = dist(i,j,spp[0],spp[1])+spp[4]+fun(st,tar,spp[2],spp[3],sp, dp);\\n                ans = Math.min(chooseRoad, ans);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int dist(int a, int b, int x, int y){\\n        return Math.abs(a-x)+Math.abs(b-y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470014,
                "title": "javascript-dfs-map",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nconst getDist = (x1, y1, x2, y2) => Math.abs(x2-x1) + Math.abs(y2-y1)\\n\\nvar minimumCost = function(start, target, specialRoads) {\\n    let cost = Infinity\\n    const map = new Map()\\n    \\n    const dfs = (curDist, x, y) => {\\n        if (curDist > cost) return\\n        \\n        // without using any specialRoad\\n        const toTargetDist = getDist(x, y, target[0], target[1])\\n        cost = Math.min(toTargetDist + curDist, cost)\\n\\n        // recording the distance to get to [x, y]\\n        if (map.get(`${x}, ${y}`) && map.get(`${x}, ${y}`) <= curDist) return\\n        else map.set(`${x}, ${y}`, curDist)\\n        \\n        // using specialRoads\\n        for(let j=0 ; j<specialRoads.length ; j++) {\\n            const [x1, y1, x2, y2, d] = specialRoads[j]\\n            const toSpecialEndDist =  getDist(x, y, x1, y1) + d\\n            dfs(toSpecialEndDist + curDist, x2, y2)\\n        }\\n    }\\n\\n    dfs(0, start[0], start[1])\\n\\n    return cost\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nconst getDist = (x1, y1, x2, y2) => Math.abs(x2-x1) + Math.abs(y2-y1)\\n\\nvar minimumCost = function(start, target, specialRoads) {\\n    let cost = Infinity\\n    const map = new Map()\\n    \\n    const dfs = (curDist, x, y) => {\\n        if (curDist > cost) return\\n        \\n        // without using any specialRoad\\n        const toTargetDist = getDist(x, y, target[0], target[1])\\n        cost = Math.min(toTargetDist + curDist, cost)\\n\\n        // recording the distance to get to [x, y]\\n        if (map.get(`${x}, ${y}`) && map.get(`${x}, ${y}`) <= curDist) return\\n        else map.set(`${x}, ${y}`, curDist)\\n        \\n        // using specialRoads\\n        for(let j=0 ; j<specialRoads.length ; j++) {\\n            const [x1, y1, x2, y2, d] = specialRoads[j]\\n            const toSpecialEndDist =  getDist(x, y, x1, y1) + d\\n            dfs(toSpecialEndDist + curDist, x2, y2)\\n        }\\n    }\\n\\n    dfs(0, start[0], start[1])\\n\\n    return cost\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468509,
                "title": "c-graphs-dijkstras-explained",
                "content": "# Intuition\\nEpic example of how to visualize a problem as graphs. It must be noted that we cannot visualise the entire 2D space as graph, but only the specialRoads mentioned in the problem. \\nAfter this it is simple dijkstra and a pain in ass to write such a lengthy code. Haven\\'t seen any other approaches yet. \\n\\n# Approach\\nThe graph building process is also not that simple. \\n1. build edges from start to start of every specialRoad\\n2. build edges from start to end of every specialRoad\\n3. build edges from end of ith specialRoad to start of jth specialRoad\\n4. build edges from end of every specialRoad to target\\n\\nDont forget to build an edge frm start to target.\\nNow there is a trick in 1 and 2. \\nIf for a given specialRoad I travel straight(i.e is using manhattan distance) and the cost incurred is less than the cst of the specialRoad then I dont need to consider this road at all. As if the road did not even exist.  \\nSo dont build edges in 1, 2, 3 from this road. \\n\\nAfter the build process it is normal dijkstra. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int,int>,vector<vector<int>>>graph ; \\n        \\n        graph[{start[0],start[1]}].push_back(vector<int>{target[0],target[1],abs(target[0]-start[0])+abs(target[1]-start[1])});\\n        \\n        for(int i = 0 ; i < specialRoads.size() ; i++){\\n            int cost = specialRoads[i][4] ; \\n            int straight = abs(specialRoads[i][2]-specialRoads[i][0])+abs(specialRoads[i][3]-specialRoads[i][1]);\\n            if(straight > cost){\\n                graph[{specialRoads[i][0],specialRoads[i][1]}].push_back(vector<int>{specialRoads[i][2],specialRoads[i][3],cost});\\n                cost = abs(start[0]-specialRoads[i][0]) + abs(start[1]-specialRoads[i][1]);\\n                graph[{start[0],start[1]}].push_back(vector<int>{specialRoads[i][0],specialRoads[i][1],cost});\\n            }\\n            else continue ; \\n            for(int j = 0 ; j < specialRoads.size(); j++){\\n                if(i == j) continue ; \\n                cost = abs(specialRoads[j][0]-specialRoads[i][2]) + abs(specialRoads[j][1]-specialRoads[i][3]) ; \\n                graph[{specialRoads[i][2],specialRoads[i][3]}].push_back(vector<int>{specialRoads[j][0],specialRoads[j][1],cost}); \\n            }\\n        }\\n        \\n        for(auto v : specialRoads){\\n            int cost = abs(target[0]-v[2]) + abs(target[1]-v[3]) ; \\n            graph[{v[2],v[3]}].push_back(vector<int>{target[0],target[1],cost}); \\n        }\\n        \\n        map<pair<int,int>,int>dist; \\n        dist[{target[0],target[1]}] = INT_MAX ; \\n        for(auto v : specialRoads){\\n            dist[{v[0],v[1]}] = INT_MAX ; \\n            dist[{v[2],v[3]}] = INT_MAX ; \\n        }\\n        \\n        priority_queue<pair<int,pair<int,int>>>pq; \\n        pq.push({0,{start[0],start[1]}}); \\n        dist[{start[0],start[1]}] = 0 ;\\n        \\n        while(!pq.empty()){\\n            auto t = pq.top() ; pq.pop(); \\n            auto road = t.second ; \\n            for(auto x : graph[road]){\\n                int new_dist = -t.first + x[2] ; \\n                if(dist[{x[0],x[1]}] > new_dist){\\n                    dist[{x[0],x[1]}] = new_dist ; \\n                    pq.push({-dist[{x[0],x[1]}],{x[0],x[1]}}); \\n                }\\n            }\\n        }\\n        \\n        return dist[{target[0],target[1]}] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int,int>,vector<vector<int>>>graph ; \\n        \\n        graph[{start[0],start[1]}].push_back(vector<int>{target[0],target[1],abs(target[0]-start[0])+abs(target[1]-start[1])});\\n        \\n        for(int i = 0 ; i < specialRoads.size() ; i++){\\n            int cost = specialRoads[i][4] ; \\n            int straight = abs(specialRoads[i][2]-specialRoads[i][0])+abs(specialRoads[i][3]-specialRoads[i][1]);\\n            if(straight > cost){\\n                graph[{specialRoads[i][0],specialRoads[i][1]}].push_back(vector<int>{specialRoads[i][2],specialRoads[i][3],cost});\\n                cost = abs(start[0]-specialRoads[i][0]) + abs(start[1]-specialRoads[i][1]);\\n                graph[{start[0],start[1]}].push_back(vector<int>{specialRoads[i][0],specialRoads[i][1],cost});\\n            }\\n            else continue ; \\n            for(int j = 0 ; j < specialRoads.size(); j++){\\n                if(i == j) continue ; \\n                cost = abs(specialRoads[j][0]-specialRoads[i][2]) + abs(specialRoads[j][1]-specialRoads[i][3]) ; \\n                graph[{specialRoads[i][2],specialRoads[i][3]}].push_back(vector<int>{specialRoads[j][0],specialRoads[j][1],cost}); \\n            }\\n        }\\n        \\n        for(auto v : specialRoads){\\n            int cost = abs(target[0]-v[2]) + abs(target[1]-v[3]) ; \\n            graph[{v[2],v[3]}].push_back(vector<int>{target[0],target[1],cost}); \\n        }\\n        \\n        map<pair<int,int>,int>dist; \\n        dist[{target[0],target[1]}] = INT_MAX ; \\n        for(auto v : specialRoads){\\n            dist[{v[0],v[1]}] = INT_MAX ; \\n            dist[{v[2],v[3]}] = INT_MAX ; \\n        }\\n        \\n        priority_queue<pair<int,pair<int,int>>>pq; \\n        pq.push({0,{start[0],start[1]}}); \\n        dist[{start[0],start[1]}] = 0 ;\\n        \\n        while(!pq.empty()){\\n            auto t = pq.top() ; pq.pop(); \\n            auto road = t.second ; \\n            for(auto x : graph[road]){\\n                int new_dist = -t.first + x[2] ; \\n                if(dist[{x[0],x[1]}] > new_dist){\\n                    dist[{x[0],x[1]}] = new_dist ; \\n                    pq.push({-dist[{x[0],x[1]}],{x[0],x[1]}}); \\n                }\\n            }\\n        }\\n        \\n        return dist[{target[0],target[1]}] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468290,
                "title": "add-possible-edges-dijkstra-algo",
                "content": "```\\n#define ll long long\\n\\nint dx[4] = {0, 1, -1, 0};\\nint dy[4] = {1, 0, 0, -1};\\nconst long long N = 1e6;\\n\\nclass Solution {\\npublic:\\n    ll dist(ll x, ll y){\\n        return (abs(x/N - y/N) + abs(x%N - y%N));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& rds) {\\n        ll src = 1ll*start[0]*N + start[1];\\n        ll dest = 1ll*target[0]*N + target[1];\\n        if(src == dest) return 0;\\n        unordered_map<ll, vector<pair<ll, ll> > > mp; \\n        mp[src].push_back({abs(target[0] - start[0]) + abs(target[1] - start[1]), dest});\\n        for(auto vec: rds){\\n            ll u =  vec[0]*N + vec[1];\\n            ll v = vec[2]*N + vec[3];\\n            ll cost = vec[4];\\n            ll gCost = abs(vec[2] - vec[0]) + abs(vec[3] - vec[1]);\\n            mp[u].push_back({min(gCost, cost), v});\\n            mp[v].push_back({gCost, u});\\n            if(u != src){\\n                int dd = dist(u, src);\\n                mp[src].push_back({dd, u});\\n            }\\n            if(u != dest){\\n                int dd = dist(u, dest);\\n                mp[u].push_back({dd, dest});\\n            }\\n            if(v != src){\\n                int dd = dist(v, src);\\n                mp[src].push_back({dd, v});\\n            }\\n            if(v != dest){\\n                int dd = dist(v, dest);\\n                mp[v].push_back({dd, dest});\\n            }\\n        }\\n        for(int i = 0; i<rds.size(); i++){\\n            for(int j = 0; j<rds.size(); j++){\\n                if(i == j) continue;\\n                ll u = rds[i][2]*N + rds[i][3];\\n                ll v = rds[j][0]*N + rds[j][1];\\n                ll cst = abs(rds[i][2] - rds[j][0]) + abs(rds[i][3] - rds[j][1]);\\n                if(u != v){\\n                    mp[u].push_back({cst, v});\\n                    mp[v].push_back({cst, u});\\n                }\\n            }\\n        }\\n        unordered_map<ll, ll> dist;\\n        priority_queue<pair<ll, ll>, vector<pair<ll, ll> >, greater<pair<ll, ll> > > pqu;\\n        pqu.push({0ll, src});\\n        dist[src] = 0ll;\\n        while(!pqu.empty()){\\n            pair<ll, ll> pr = pqu.top(); pqu.pop();\\n            ll w = pr.first, f = pr.second;\\n            for(auto nbrPr: mp[f]){\\n                ll wt = nbrPr.first;\\n                ll nbr = nbrPr.second;\\n                if((dist.find(nbr) == dist.end()) or (dist[nbr] > dist[f] + wt)){\\n                    dist[nbr] = dist[f] + wt;\\n                    pqu.push({dist[nbr], nbr});\\n                }\\n            }\\n        }\\n        return dist[dest];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define ll long long\\n\\nint dx[4] = {0, 1, -1, 0};\\nint dy[4] = {1, 0, 0, -1};\\nconst long long N = 1e6;\\n\\nclass Solution {\\npublic:\\n    ll dist(ll x, ll y){\\n        return (abs(x/N - y/N) + abs(x%N - y%N));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& rds) {\\n        ll src = 1ll*start[0]*N + start[1];\\n        ll dest = 1ll*target[0]*N + target[1];\\n        if(src == dest) return 0;\\n        unordered_map<ll, vector<pair<ll, ll> > > mp; \\n        mp[src].push_back({abs(target[0] - start[0]) + abs(target[1] - start[1]), dest});\\n        for(auto vec: rds){\\n            ll u =  vec[0]*N + vec[1];\\n            ll v = vec[2]*N + vec[3];\\n            ll cost = vec[4];\\n            ll gCost = abs(vec[2] - vec[0]) + abs(vec[3] - vec[1]);\\n            mp[u].push_back({min(gCost, cost), v});\\n            mp[v].push_back({gCost, u});\\n            if(u != src){\\n                int dd = dist(u, src);\\n                mp[src].push_back({dd, u});\\n            }\\n            if(u != dest){\\n                int dd = dist(u, dest);\\n                mp[u].push_back({dd, dest});\\n            }\\n            if(v != src){\\n                int dd = dist(v, src);\\n                mp[src].push_back({dd, v});\\n            }\\n            if(v != dest){\\n                int dd = dist(v, dest);\\n                mp[v].push_back({dd, dest});\\n            }\\n        }\\n        for(int i = 0; i<rds.size(); i++){\\n            for(int j = 0; j<rds.size(); j++){\\n                if(i == j) continue;\\n                ll u = rds[i][2]*N + rds[i][3];\\n                ll v = rds[j][0]*N + rds[j][1];\\n                ll cst = abs(rds[i][2] - rds[j][0]) + abs(rds[i][3] - rds[j][1]);\\n                if(u != v){\\n                    mp[u].push_back({cst, v});\\n                    mp[v].push_back({cst, u});\\n                }\\n            }\\n        }\\n        unordered_map<ll, ll> dist;\\n        priority_queue<pair<ll, ll>, vector<pair<ll, ll> >, greater<pair<ll, ll> > > pqu;\\n        pqu.push({0ll, src});\\n        dist[src] = 0ll;\\n        while(!pqu.empty()){\\n            pair<ll, ll> pr = pqu.top(); pqu.pop();\\n            ll w = pr.first, f = pr.second;\\n            for(auto nbrPr: mp[f]){\\n                ll wt = nbrPr.first;\\n                ll nbr = nbrPr.second;\\n                if((dist.find(nbr) == dist.end()) or (dist[nbr] > dist[f] + wt)){\\n                    dist[nbr] = dist[f] + wt;\\n                    pqu.push({dist[nbr], nbr});\\n                }\\n            }\\n        }\\n        return dist[dest];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539336,
                "title": "beats-99-9-only-1-array-no-queues-java-c-python",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 99.9%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\n# TL;DR\\n``` java []\\nclass Solution {\\n    private static int dist(int x1, int y1, int x2, int y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int n = specialRoads.length;\\n        var dist = new int[n];\\n        int minDistIdx = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            dist[i] = dist(\\n                    start[0], start[1],\\n                    specialRoads[i][0], specialRoads[i][1]\\n            ) + specialRoads[i][4];\\n            if (dist[minDistIdx] > dist[i]) minDistIdx = i;\\n        }\\n\\n        int cost = dist(start[0], start[1], target[0], target[1]);\\n        while (minDistIdx != -1) {\\n            var cur = minDistIdx;\\n            minDistIdx = -1;\\n\\n            cost = Math.min(cost, dist[cur] + dist(\\n                    target[0], target[1],\\n                    specialRoads[cur][2], specialRoads[cur][3]\\n            ));\\n\\n            for (int i = 0; i < n; i++) {\\n                if (i == cur || dist[i] == -1) continue;\\n\\n                dist[i] = Math.min(dist[i], dist[cur] + dist(\\n                        specialRoads[cur][2], specialRoads[cur][3],\\n                        specialRoads[i][0], specialRoads[i][1]\\n                ) + specialRoads[i][4]);\\n\\n                if (minDistIdx == -1 || dist[minDistIdx] > dist[i]) {\\n                    minDistIdx = i;\\n                }\\n            }\\n\\n            dist[cur] = -1;\\n        }\\n\\n        return cost;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\nprivate:\\n    static int dist(int x1, int y1, int x2, int y2) {\\n        return abs(x1 - x2) + abs(y1 - y2);\\n    }\\n\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int n = specialRoads.size();\\n        vector<int> distance(n);\\n        int minDistIdx = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            distance[i] = dist(\\n                    start[0], start[1],\\n                    specialRoads[i][0], specialRoads[i][1]\\n            ) + specialRoads[i][4];\\n            if (distance[minDistIdx] > distance[i]) minDistIdx = i;\\n        }\\n\\n        int cost = dist(start[0], start[1], target[0], target[1]);\\n        while (minDistIdx != -1) {\\n            int cur = minDistIdx;\\n            minDistIdx = -1;\\n\\n            cost = min(cost, distance[cur] + dist(\\n                    target[0], target[1],\\n                    specialRoads[cur][2], specialRoads[cur][3]\\n            ));\\n\\n            for (int i = 0; i < n; i++) {\\n                if (i == cur || distance[i] == -1) continue;\\n\\n                distance[i] = min(distance[i], distance[cur] + dist(\\n                        specialRoads[cur][2], specialRoads[cur][3],\\n                        specialRoads[i][0], specialRoads[i][1]\\n                ) + specialRoads[i][4]);\\n\\n                if (minDistIdx == -1 || distance[minDistIdx] > distance[i]) {\\n                    minDistIdx = i;\\n                }\\n            }\\n\\n            distance[cur] = -1;\\n        }\\n\\n        return cost;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    \\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        def dist(x1: int, y1: int, x2: int, y2: int) -> int:\\n            return abs(x1 - x2) + abs(y1 - y2)\\n\\n        n = len(specialRoads)\\n        distance = [0] * n\\n        minDistIdx = 0\\n\\n        for i in range(n):\\n            distance[i] = dist(\\n                    start[0], start[1],\\n                    specialRoads[i][0], specialRoads[i][1]\\n            ) + specialRoads[i][4]\\n            if distance[minDistIdx] > distance[i]:\\n                minDistIdx = i\\n\\n        cost = dist(start[0], start[1], target[0], target[1])\\n        while minDistIdx != -1:\\n            cur = minDistIdx\\n            minDistIdx = -1\\n\\n            cost = min(cost, distance[cur] + dist(\\n                    target[0], target[1],\\n                    specialRoads[cur][2], specialRoads[cur][3]\\n            ))\\n\\n            for i in range(n):\\n                if i == cur or distance[i] == -1: \\n                    continue\\n\\n                distance[i] = min(distance[i], distance[cur] + dist(\\n                        specialRoads[cur][2], specialRoads[cur][3],\\n                        specialRoads[i][0], specialRoads[i][1]\\n                ) + specialRoads[i][4])\\n\\n                if minDistIdx == -1 or distance[minDistIdx] > distance[i]:\\n                    minDistIdx = i\\n\\n            distance[cur] = -1\\n\\n        return cost\\n```\\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n# Intuition\\nIf no special roads existed, the shortest path from the start to the target would be a direct one. However, we\\'re given these special roads that we can potentially use to shorten our journey.\\n\\nWe can model this situation as a directed graph where each special road, as well as the start and target, are nodes. The nodes corresponding to the special roads are a bit unique. When calculating the cost of a directed edge from any node **to** a special road node, we base our cost on the **start** of the special road. Conversely, when calculating the cost of a directed edge **from** a special road node, we use the **end** of the special road. This follows intuitively from the problem definition.\\n\\n#### Now, which edges do we need to include in our graph?\\n\\nThere should be an edge from the start to the target, as this is the upper bound of our answer and represents the shortest path without any special roads. Additionally, we need edges from the start to every special road\\'s start and from each special road\\'s end to both the target and other special road\\' start. This is because we may need to travel through one or multiple special roads in sequence to reach the target.\\n\\n#### How do we calculate it? \\nWe can take a direct route, use one special road, or use a combination of multiple special roads. We first calculate the direct cost from the start to the target and then look for ways to improve this cost by using the special roads. This involves checking whether it\\'s beneficial to use a particular special road and subsequently examining combinations of multiple special roads. This bears resemblance to **Dijkstra**\\'s algorithm where we need to find the minimum cost to reach the end of each road, while considering all other roads. As we do this, we also calculate the cost from each road to the target.\\n\\n# Approach\\n\\nFirst, we define a helper method, `dist()`, that computes the cost of moving from one position to another using the Manhattan distance.\\n\\nThen, in our main method, `minimumCost()`, we initialize an array `dist` that stores the total cost of reaching the end of each special road from `start`. We iterate over each special road, compute the cost of reaching the road\\'s start from our starting position, add the cost of using the special road, and store this total cost in the `dist` array.\\n\\nIn this loop we also maintain an index `minDistIdx` that points to the road with the minimum total cost.\\n\\nWe compute the direct cost of moving from `start` to `target` using the `dist()` method. This serves as an initial minimum cost that we\\'ll try to improve upon.\\n\\nThen, we enter a loop where we continue trying to improve our minimum cost. In each iteration, we update `minDistIdx` to point to the road with the current minimum total cost, excluding roads that have been marked as \\'visited\\' by setting their cost in `dist` to `-1`.\\n\\nWe then calculate the total cost of reaching `target` using the current road and compare it to our current minimum cost. If it\\'s lower, then we found a shorter path to `target` from this road.\\n\\nNext, we iterate over all other roads, update their total cost in `dist` if it\\'s beneficial to reach them via the current road, and adjust `minDistIdx` accordingly.\\n\\nAfter examining all other roads, we mark the current road as \\'visited\\' and repeat the process until there are no unvisited roads left.\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Graph"
                ],
                "code": "``` java []\\nclass Solution {\\n    private static int dist(int x1, int y1, int x2, int y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int n = specialRoads.length;\\n        var dist = new int[n];\\n        int minDistIdx = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            dist[i] = dist(\\n                    start[0], start[1],\\n                    specialRoads[i][0], specialRoads[i][1]\\n            ) + specialRoads[i][4];\\n            if (dist[minDistIdx] > dist[i]) minDistIdx = i;\\n        }\\n\\n        int cost = dist(start[0], start[1], target[0], target[1]);\\n        while (minDistIdx != -1) {\\n            var cur = minDistIdx;\\n            minDistIdx = -1;\\n\\n            cost = Math.min(cost, dist[cur] + dist(\\n                    target[0], target[1],\\n                    specialRoads[cur][2], specialRoads[cur][3]\\n            ));\\n\\n            for (int i = 0; i < n; i++) {\\n                if (i == cur || dist[i] == -1) continue;\\n\\n                dist[i] = Math.min(dist[i], dist[cur] + dist(\\n                        specialRoads[cur][2], specialRoads[cur][3],\\n                        specialRoads[i][0], specialRoads[i][1]\\n                ) + specialRoads[i][4]);\\n\\n                if (minDistIdx == -1 || dist[minDistIdx] > dist[i]) {\\n                    minDistIdx = i;\\n                }\\n            }\\n\\n            dist[cur] = -1;\\n        }\\n\\n        return cost;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\nprivate:\\n    static int dist(int x1, int y1, int x2, int y2) {\\n        return abs(x1 - x2) + abs(y1 - y2);\\n    }\\n\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int n = specialRoads.size();\\n        vector<int> distance(n);\\n        int minDistIdx = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            distance[i] = dist(\\n                    start[0], start[1],\\n                    specialRoads[i][0], specialRoads[i][1]\\n            ) + specialRoads[i][4];\\n            if (distance[minDistIdx] > distance[i]) minDistIdx = i;\\n        }\\n\\n        int cost = dist(start[0], start[1], target[0], target[1]);\\n        while (minDistIdx != -1) {\\n            int cur = minDistIdx;\\n            minDistIdx = -1;\\n\\n            cost = min(cost, distance[cur] + dist(\\n                    target[0], target[1],\\n                    specialRoads[cur][2], specialRoads[cur][3]\\n            ));\\n\\n            for (int i = 0; i < n; i++) {\\n                if (i == cur || distance[i] == -1) continue;\\n\\n                distance[i] = min(distance[i], distance[cur] + dist(\\n                        specialRoads[cur][2], specialRoads[cur][3],\\n                        specialRoads[i][0], specialRoads[i][1]\\n                ) + specialRoads[i][4]);\\n\\n                if (minDistIdx == -1 || distance[minDistIdx] > distance[i]) {\\n                    minDistIdx = i;\\n                }\\n            }\\n\\n            distance[cur] = -1;\\n        }\\n\\n        return cost;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    \\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        def dist(x1: int, y1: int, x2: int, y2: int) -> int:\\n            return abs(x1 - x2) + abs(y1 - y2)\\n\\n        n = len(specialRoads)\\n        distance = [0] * n\\n        minDistIdx = 0\\n\\n        for i in range(n):\\n            distance[i] = dist(\\n                    start[0], start[1],\\n                    specialRoads[i][0], specialRoads[i][1]\\n            ) + specialRoads[i][4]\\n            if distance[minDistIdx] > distance[i]:\\n                minDistIdx = i\\n\\n        cost = dist(start[0], start[1], target[0], target[1])\\n        while minDistIdx != -1:\\n            cur = minDistIdx\\n            minDistIdx = -1\\n\\n            cost = min(cost, distance[cur] + dist(\\n                    target[0], target[1],\\n                    specialRoads[cur][2], specialRoads[cur][3]\\n            ))\\n\\n            for i in range(n):\\n                if i == cur or distance[i] == -1: \\n                    continue\\n\\n                distance[i] = min(distance[i], distance[cur] + dist(\\n                        specialRoads[cur][2], specialRoads[cur][3],\\n                        specialRoads[i][0], specialRoads[i][1]\\n                ) + specialRoads[i][4])\\n\\n                if minDistIdx == -1 or distance[minDistIdx] > distance[i]:\\n                    minDistIdx = i\\n\\n            distance[cur] = -1\\n\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529435,
                "title": "no-dijkstra-bfs-with-pruning-easy-simple-map-queue",
                "content": "# Intuition\\nIf we have multiple paths then why not try all?\\n**A->B (A->start and B->target coordinates)\\nA->s1->B\\nA->s2->B**\\n... so on\\nand even after going till s1 we could also go to some other special road like:-\\n**A->s1->s3->s4->B**\\n\\n# Approach\\nFor implementing it use a hashmap for keeping track of visited positions with the cost **(such that we will only consider those paths which are leading to a position in minimum time or cost)**\\n\\nRest code is easy to understand. Please give it a read!! :)\\n**And consider upvoting if you like the approach**\\n\\n# Code\\n```\\nclass Solution {\\n    public int myWay(int[] start,int[] target,int[][] special)\\n    {\\n        HashMap<String,Integer> visited = new HashMap<>();\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.add(new int[]{start[0],start[1],0});//current row,col,cost so far till here\\n        visited.put(start[0]+\"-\"+start[1],0);//have reached till here with cost 0..so agar koi better hoga isse tohi lenge\\n        int minCost = Integer.MAX_VALUE;\\n        while(queue.isEmpty()==false)\\n        {\\n            int[] curr = queue.poll();\\n            if(curr[2] >= minCost) continue;\\n            \\n            //case 1 - reach target from here only\\n            int costTillTarget = curr[2]+Math.abs(target[0]-curr[0]) + Math.abs(target[1]-curr[1]);\\n            minCost = Math.min(minCost,costTillTarget);\\n            \\n            //case 2- reach other special roads\\n            for(int i=0;i<special.length;i++)\\n            {\\n                int x1 = special[i][0];\\n                int y1 = special[i][1];\\n                int x2 = special[i][2];\\n                int y2 = special[i][3];\\n                int cost = special[i][4];\\n                int costTillx2y2 = curr[2] + Math.abs(curr[0]-x1)+Math.abs(curr[1]-y1) + cost;\\n                String pos = x2+\" and \"+y2;\\n                if(visited.containsKey(pos) && visited.get(pos) <= costTillx2y2) continue;//as then no improvement is there \\n                //since we have reached till here with better price already at some point of time\\n                visited.put(pos,costTillx2y2);\\n                queue.offer(new int[]{x2,y2,costTillx2y2});\\n            }   \\n        }\\n        return minCost;\\n    }\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        return myWay(start,target,specialRoads);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int myWay(int[] start,int[] target,int[][] special)\\n    {\\n        HashMap<String,Integer> visited = new HashMap<>();\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.add(new int[]{start[0],start[1],0});//current row,col,cost so far till here\\n        visited.put(start[0]+\"-\"+start[1],0);//have reached till here with cost 0..so agar koi better hoga isse tohi lenge\\n        int minCost = Integer.MAX_VALUE;\\n        while(queue.isEmpty()==false)\\n        {\\n            int[] curr = queue.poll();\\n            if(curr[2] >= minCost) continue;\\n            \\n            //case 1 - reach target from here only\\n            int costTillTarget = curr[2]+Math.abs(target[0]-curr[0]) + Math.abs(target[1]-curr[1]);\\n            minCost = Math.min(minCost,costTillTarget);\\n            \\n            //case 2- reach other special roads\\n            for(int i=0;i<special.length;i++)\\n            {\\n                int x1 = special[i][0];\\n                int y1 = special[i][1];\\n                int x2 = special[i][2];\\n                int y2 = special[i][3];\\n                int cost = special[i][4];\\n                int costTillx2y2 = curr[2] + Math.abs(curr[0]-x1)+Math.abs(curr[1]-y1) + cost;\\n                String pos = x2+\" and \"+y2;\\n                if(visited.containsKey(pos) && visited.get(pos) <= costTillx2y2) continue;//as then no improvement is there \\n                //since we have reached till here with better price already at some point of time\\n                visited.put(pos,costTillx2y2);\\n                queue.offer(new int[]{x2,y2,costTillx2y2});\\n            }   \\n        }\\n        return minCost;\\n    }\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        return myWay(start,target,specialRoads);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488316,
                "title": "dp-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n     int dp[402][402];\\n    int f(vector<vector<int>>&s,int i,int prev,int a1,int b1,int a2,int b2){\\n        if(i==s.size()){\\n         if(prev==-1){\\n             return abs(a2-a1)+abs(b2-b1);\\n         }\\n            return abs(a2-s[prev][2])+abs(b2-s[prev][3])+s[prev][4];\\n         }\\n         if(dp[i][prev+1]!=-1){return dp[i][prev+1];}\\n        int nt=f(s,i+1,prev,a1,b1,a2,b2);\\n        int t=0;\\n        if(prev==-1){\\n           t=abs(a1-s[i][0])+abs(b1-s[i][1])+f(s,i+1,i,a1,b1,a2,b2); \\n        }\\n        else{\\n              t=abs(s[prev][2]-s[i][0])+abs(s[prev][3]-s[i][1])+s[prev][4]+f(s,i+1,i,a1,b1,a2,b2);\\n        }\\n        return dp[i][prev+1]=min(nt,t);\\n        }\\n    \\n    int minimumCost(vector<int>& s1, vector<int>&t, vector<vector<int>>&s){\\n        vector<vector<int>>v=s;\\n        for(int i=0;i<s.size();i++){\\n            v.push_back(s[i]);\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return f(v,0,-1,s1[0],s1[1],t[0],t[1]);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n     int dp[402][402];\\n    int f(vector<vector<int>>&s,int i,int prev,int a1,int b1,int a2,int b2){\\n        if(i==s.size()){\\n         if(prev==-1){\\n             return abs(a2-a1)+abs(b2-b1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3482879,
                "title": "c-solution-dijkstra-o-m-2logm",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int n = specialRoads.size();\\n        int sx = start[0], sy = start[1], ex = target[0], ey = target[1];\\n        int ans = abs(sx - ex) + abs(sy - ey);\\n        map<pair<int, int>, int> dist;\\n        set<array<int, 3>> pq; pq.insert({0, sx, sy});\\n        dist[{sx, sy}] = 0;\\n        while (!pq.empty()){\\n            auto [cost, x, y] = *pq.begin(); pq.erase(pq.begin());\\n            ans = min(ans, cost + abs(x - ex) + abs(y - ey));\\n            if (ans < cost) break;\\n            for (auto &e : specialRoads){\\n                int fx = e[0], fy = e[1], tx = e[2], ty = e[3], c = e[4];\\n                int ncost = cost + min(abs(fx - x) + abs(fy - y) + c, abs(x - tx) + abs(y - ty));\\n                int pcost = (dist.count({tx, ty}) ? dist[{tx, ty}] : INT_MAX);\\n                if (pcost > ncost){\\n                    if (pq.count({pcost, tx, ty})) pq.erase({pcost, tx, ty});\\n                    dist[{tx, ty}] = ncost;\\n                    pq.insert({ncost, tx, ty});\\n                }\\n            }\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int n = specialRoads.size();\\n        int sx = start[0], sy = start[1], ex = target[0], ey = target[1];\\n        int ans = abs(sx - ex) + abs(sy - ey);\\n        map<pair<int, int>, int> dist;\\n        set<array<int, 3>> pq; pq.insert({0, sx, sy});\\n        dist[{sx, sy}] = 0;\\n        while (!pq.empty()){\\n            auto [cost, x, y] = *pq.begin(); pq.erase(pq.begin());\\n            ans = min(ans, cost + abs(x - ex) + abs(y - ey));\\n            if (ans < cost) break;\\n            for (auto &e : specialRoads){\\n                int fx = e[0], fy = e[1], tx = e[2], ty = e[3], c = e[4];\\n                int ncost = cost + min(abs(fx - x) + abs(fy - y) + c, abs(x - tx) + abs(y - ty));\\n                int pcost = (dist.count({tx, ty}) ? dist[{tx, ty}] : INT_MAX);\\n                if (pcost > ncost){\\n                    if (pq.count({pcost, tx, ty})) pq.erase({pcost, tx, ty});\\n                    dist[{tx, ty}] = ncost;\\n                    pq.insert({ncost, tx, ty});\\n                }\\n            }\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481317,
                "title": "easy-c-solution-dijkstra-s-algorithm-graph-just-connect-nodes-and-find-shortest-pathgra",
                "content": "# Intuition\\nThe problem seems to use dynamic programming approach but is of graph.\\nWe are given source and target.We just have to connect nodes an teach the target with least distance possible.\\nSo we will be using Dijkastras Algorithm.\\n\\n# Approach\\nWe dont have to connect the graph for every single (row,col) as this is not needed\\nThe cost would be same if we travel 1 step or go directly\\nSo we either go directly for use special edge\\nWe can either use it or not(check for feasibility) .Now we have a graph remaning between start, end and speacial nodes. So connect all of them.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int n=specialRoads.size();\\n        \\n        //We dont have to connect the graph for every single (row,col) as this is not needed\\n        //The cost would be same if we travel 1 step or go directly\\n        //So we either go directly for use special edge\\n        //We can either use it or not(check for feasibility)\\n        //Now we have a graph remaning between start, end and speacial nodes.\\n        //So connect all of them.\\n        \\n        //Start by making a graph\\n        map<pair<int,int>,vector<pair<int,pair<int,int>>>> mp;\\n        \\n        //make the graph nodes connected bidirectionally from start and target\\n        mp[{start[0],start[1]}].push_back({(abs(target[0]-start[0])+abs(target[1]-start[1])),{target[0],target[1]}});\\n        mp[{target[0],target[1]}].push_back({(abs(target[0]-start[0])+abs(target[1]-start[1])),{start[0],start[1]}});\\n        \\n        //Now lets loop through special roads\\n        for(int i=0;i<n;i++){\\n            auto it=specialRoads[i];\\n            //Lets say we get special node from u->v\\n            //Connect node start to u(bidirectionally)\\n            mp[{it[0],it[1]}].push_back({(abs(start[0]-it[0])+abs(start[1]-it[1])),{start[0],start[1]}});\\n            mp[{start[0],start[1]}].push_back({(abs(start[0]-it[0])+abs(start[1]-it[1])),{it[0],it[1]}});\\n            \\n            //Connect node start to v(bidirectionally)\\n            mp[{it[2],it[3]}].push_back({(abs(start[0]-it[2])+abs(start[1]-it[3])),{start[0],start[1]}});\\n            mp[{start[0],start[1]}].push_back({(abs(start[0]-it[2])+abs(start[1]-it[3])),{it[2],it[3]}});\\n            \\n            //Connect node u to target(bidirectionally)\\n            mp[{it[0],it[1]}].push_back({(abs(target[0]-it[0])+abs(target[1]-it[1])),{target[0],target[1]}});\\n            mp[{target[0],target[1]}].push_back({(abs(target[0]-it[0])+abs(target[1]-it[1])),{it[0],it[1]}});\\n            \\n            //Connect node v to target(bidirectionally)\\n            mp[{it[2],it[3]}].push_back({(abs(target[0]-it[2])+abs(target[1]-it[3])),{target[0],target[1]}});\\n            mp[{target[0],target[1]}].push_back({(abs(target[0]-it[2])+abs(target[1]-it[3])),{it[2],it[3]}});\\n            \\n            //Now its time to connect the special road\\n            //i.e the node u->v\\n            //it is unidirectional as the question itself states \"special road can take you from (x1i, y1i) to (x2i, y2i)\" \\n            //and not the vice versa.\\n            //The special road can either take minimum cost or not(so take a condition.)\\n            mp[{it[0],it[1]}].push_back({(min(it[4],abs(it[0]-it[2])+abs(it[1]-it[3]))),{it[2],it[3]}});\\n            \\n            //Now lets connect other special roads to the current road\\n            for(int j=i+1;j<n;j++){\\n                auto nit=specialRoads[j];\\n                //Let\\'s say we get nit as other speacial road\\n                //Having node from u1->v1\\n                \\n                //So lets connect u to u1(bidirectionally)\\n                mp[{it[0],it[1]}].push_back({(abs(it[0]-nit[0])+abs(it[1]-nit[1])),{nit[0],nit[1]}});\\n                mp[{nit[0],nit[1]}].push_back({(abs(it[0]-nit[0])+abs(it[1]-nit[1])),{it[0],it[1]}});\\n                \\n                //Connect u to v1(bidirectionally)\\n                mp[{it[0],it[1]}].push_back({(abs(it[0]-nit[2])+abs(it[1]-nit[3])),{nit[2],nit[3]}});\\n                mp[{nit[2],nit[3]}].push_back({(abs(it[0]-nit[2])+abs(it[1]-nit[3])),{it[0],it[1]}});\\n                \\n                //Connect v to u1(bidirectionally)\\n                mp[{it[2],it[3]}].push_back({(abs(it[2]-nit[0])+abs(it[3]-nit[1])),{nit[0],nit[1]}});\\n                mp[{nit[0],nit[1]}].push_back({(abs(it[2]-nit[0])+abs(it[3]-nit[1])),{it[2],it[3]}});\\n                \\n                //Connect v to v1(bidirectionally)\\n                mp[{it[2],it[3]}].push_back({(abs(it[2]-nit[2])+abs(it[3]-nit[3])),{nit[2],nit[3]}});\\n                mp[{nit[2],nit[3]}].push_back({(abs(it[2]-nit[2])+abs(it[3]-nit[3])),{it[2],it[3]}}); \\n            }\\n        }\\n        \\n        //Now the graph is made\\n        //and we simply have to find shortest path\\n        //hence we use dijsktras algorithm.\\n        \\n        //Lets make visited and distance map \\n        map<pair<int,int>,int> vis;\\n        map<pair<int,int>,int> dis;\\n            \\n        //make a minHeap priorirty queue\\n        //Cost--{i,j} Sorted according to cost\\n        priority_queue<pair<int,pair<int,int>>,\\n            vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> que;\\n        \\n        que.push({0,{start[0],start[1]}});\\n        while(!que.empty()){\\n            auto node=que.top();\\n            que.pop();\\n            int cost=node.first;\\n            auto cord=node.second;\\n            if(vis[cord])continue;\\n            dis[cord]=cost;\\n            vis[cord]=1;\\n            for(auto it:mp[cord]){\\n                if(!vis[it.second])\\n                    que.push({cost+it.first,{it.second}});\\n            }\\n        }\\n        \\n        return dis[{target[0],target[1]}];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int n=specialRoads.size();\\n        \\n        //We dont have to connect the graph for every single (row,col) as this is not needed\\n        //The cost would be same if we travel 1 step or go directly\\n        //So we either go directly for use special edge\\n        //We can either use it or not(check for feasibility)\\n        //Now we have a graph remaning between start, end and speacial nodes.\\n        //So connect all of them.\\n        \\n        //Start by making a graph\\n        map<pair<int,int>,vector<pair<int,pair<int,int>>>> mp;\\n        \\n        //make the graph nodes connected bidirectionally from start and target\\n        mp[{start[0],start[1]}].push_back({(abs(target[0]-start[0])+abs(target[1]-start[1])),{target[0],target[1]}});\\n        mp[{target[0],target[1]}].push_back({(abs(target[0]-start[0])+abs(target[1]-start[1])),{start[0],start[1]}});\\n        \\n        //Now lets loop through special roads\\n        for(int i=0;i<n;i++){\\n            auto it=specialRoads[i];\\n            //Lets say we get special node from u->v\\n            //Connect node start to u(bidirectionally)\\n            mp[{it[0],it[1]}].push_back({(abs(start[0]-it[0])+abs(start[1]-it[1])),{start[0],start[1]}});\\n            mp[{start[0],start[1]}].push_back({(abs(start[0]-it[0])+abs(start[1]-it[1])),{it[0],it[1]}});\\n            \\n            //Connect node start to v(bidirectionally)\\n            mp[{it[2],it[3]}].push_back({(abs(start[0]-it[2])+abs(start[1]-it[3])),{start[0],start[1]}});\\n            mp[{start[0],start[1]}].push_back({(abs(start[0]-it[2])+abs(start[1]-it[3])),{it[2],it[3]}});\\n            \\n            //Connect node u to target(bidirectionally)\\n            mp[{it[0],it[1]}].push_back({(abs(target[0]-it[0])+abs(target[1]-it[1])),{target[0],target[1]}});\\n            mp[{target[0],target[1]}].push_back({(abs(target[0]-it[0])+abs(target[1]-it[1])),{it[0],it[1]}});\\n            \\n            //Connect node v to target(bidirectionally)\\n            mp[{it[2],it[3]}].push_back({(abs(target[0]-it[2])+abs(target[1]-it[3])),{target[0],target[1]}});\\n            mp[{target[0],target[1]}].push_back({(abs(target[0]-it[2])+abs(target[1]-it[3])),{it[2],it[3]}});\\n            \\n            //Now its time to connect the special road\\n            //i.e the node u->v\\n            //it is unidirectional as the question itself states \"special road can take you from (x1i, y1i) to (x2i, y2i)\" \\n            //and not the vice versa.\\n            //The special road can either take minimum cost or not(so take a condition.)\\n            mp[{it[0],it[1]}].push_back({(min(it[4],abs(it[0]-it[2])+abs(it[1]-it[3]))),{it[2],it[3]}});\\n            \\n            //Now lets connect other special roads to the current road\\n            for(int j=i+1;j<n;j++){\\n                auto nit=specialRoads[j];\\n                //Let\\'s say we get nit as other speacial road\\n                //Having node from u1->v1\\n                \\n                //So lets connect u to u1(bidirectionally)\\n                mp[{it[0],it[1]}].push_back({(abs(it[0]-nit[0])+abs(it[1]-nit[1])),{nit[0],nit[1]}});\\n                mp[{nit[0],nit[1]}].push_back({(abs(it[0]-nit[0])+abs(it[1]-nit[1])),{it[0],it[1]}});\\n                \\n                //Connect u to v1(bidirectionally)\\n                mp[{it[0],it[1]}].push_back({(abs(it[0]-nit[2])+abs(it[1]-nit[3])),{nit[2],nit[3]}});\\n                mp[{nit[2],nit[3]}].push_back({(abs(it[0]-nit[2])+abs(it[1]-nit[3])),{it[0],it[1]}});\\n                \\n                //Connect v to u1(bidirectionally)\\n                mp[{it[2],it[3]}].push_back({(abs(it[2]-nit[0])+abs(it[3]-nit[1])),{nit[0],nit[1]}});\\n                mp[{nit[0],nit[1]}].push_back({(abs(it[2]-nit[0])+abs(it[3]-nit[1])),{it[2],it[3]}});\\n                \\n                //Connect v to v1(bidirectionally)\\n                mp[{it[2],it[3]}].push_back({(abs(it[2]-nit[2])+abs(it[3]-nit[3])),{nit[2],nit[3]}});\\n                mp[{nit[2],nit[3]}].push_back({(abs(it[2]-nit[2])+abs(it[3]-nit[3])),{it[2],it[3]}}); \\n            }\\n        }\\n        \\n        //Now the graph is made\\n        //and we simply have to find shortest path\\n        //hence we use dijsktras algorithm.\\n        \\n        //Lets make visited and distance map \\n        map<pair<int,int>,int> vis;\\n        map<pair<int,int>,int> dis;\\n            \\n        //make a minHeap priorirty queue\\n        //Cost--{i,j} Sorted according to cost\\n        priority_queue<pair<int,pair<int,int>>,\\n            vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> que;\\n        \\n        que.push({0,{start[0],start[1]}});\\n        while(!que.empty()){\\n            auto node=que.top();\\n            que.pop();\\n            int cost=node.first;\\n            auto cord=node.second;\\n            if(vis[cord])continue;\\n            dis[cord]=cost;\\n            vis[cord]=1;\\n            for(auto it:mp[cord]){\\n                if(!vis[it.second])\\n                    que.push({cost+it.first,{it.second}});\\n            }\\n        }\\n        \\n        return dis[{target[0],target[1]}];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480223,
                "title": "c-priority-queue-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q;\\n        vector<int>v(specialRoads.size(), 1e9);\\n        int ans=abs(start[0]-target[0])+abs(start[1]-target[1]);\\n        for(int i=0; i<specialRoads.size(); i++){\\n            q.push({abs(specialRoads[i][2]-target[0])+abs(target[1]-specialRoads[i][3]), i});\\n        }\\n        while(!q.empty()){\\n            int weight=q.top().first, ind=q.top().second;\\n            q.pop();\\n            if(v[ind]==1e9){\\n                v[ind]=min(v[ind], weight);\\n                for(int i=0; i<specialRoads.size(); i++){\\n                    if(ind!=i){\\n                        q.push({weight+abs(specialRoads[ind][0]-specialRoads[i][2])+abs(specialRoads[ind][1]-specialRoads[i][3])+specialRoads[ind][4], i});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<specialRoads.size(); i++){\\n            ans=min(ans, abs(specialRoads[i][0]-start[0])+abs(specialRoads[i][1]-start[1])+specialRoads[i][4]+v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q;\\n        vector<int>v(specialRoads.size(), 1e9);\\n        int ans=abs(start[0]-target[0])+abs(start[1]-target[1]);\\n        for(int i=0; i<specialRoads.size(); i++){\\n            q.push({abs(specialRoads[i][2]-target[0])+abs(target[1]-specialRoads[i][3]), i});\\n        }\\n        while(!q.empty()){\\n            int weight=q.top().first, ind=q.top().second;\\n            q.pop();\\n            if(v[ind]==1e9){\\n                v[ind]=min(v[ind], weight);\\n                for(int i=0; i<specialRoads.size(); i++){\\n                    if(ind!=i){\\n                        q.push({weight+abs(specialRoads[ind][0]-specialRoads[i][2])+abs(specialRoads[ind][1]-specialRoads[i][3])+specialRoads[ind][4], i});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<specialRoads.size(); i++){\\n            ans=min(ans, abs(specialRoads[i][0]-start[0])+abs(specialRoads[i][1]-start[1])+specialRoads[i][4]+v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474580,
                "title": "dijstra-using-go",
                "content": "# Intuition\\nDijstra\\'s algorithm\\n\\n# Approach\\n1) Add one point which may shorten the distance from start(source) to target into the heap.\\n2) for any edge(road) in the specialRoads, e.g. for one road = [x1, y1, x2, y2, cost], if the road can help the above point(in the heap) reach (x2, y2) with a shorter distance, update the distance from start(source) to (x2, y2)\\n3) Then, add (x2, y2) into the heap, as the distance from start to target is shorter than before, (x2, y2) may helper shorten the distance from start to target.\\n\\n![image.png](https://assets.leetcode.com/users/images/07e97aa8-4c21-4e86-8faa-5abc83ed5c75_1682961197.6319954.png)\\n\\n\\n# Code\\n```\\ntype Heap [][]int\\nfunc(h Heap) Len() int {return len(h)}\\nfunc(h Heap) Less(i, j int)bool {return h[i][0]<h[j][0]}\\nfunc(h Heap) Swap(i, j int) {h[i],h[j] = h[j], h[i]}\\nfunc(h *Heap) Push(x interface{}) {\\n    *h = append(*h, x.([]int))\\n}\\nfunc(h *Heap) Pop() interface{} {\\n    v := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n    return v\\n}\\n\\nfunc minimumCost(start []int, target []int, specialRoads [][]int) int {\\n    dist := make(map[[2]int]int)\\n    ans := target[0]-start[0] + target[1]-start[1]\\n    h := &Heap{}\\n    heap.Push(h, []int{0, start[0], start[1]})\\n    for h.Len() > 0 {\\n        elem := heap.Pop(h).([]int)\\n        curDist, x, y := elem[0], elem[1], elem[2]\\n        for _, road := range specialRoads {\\n            x1, y1, x2, y2, cost := road[0], road[1], road[2], road[3], road[4]\\n            if _, ok := dist[[2]int{x2, y2}]; !ok {\\n                dist[[2]int{x2, y2}] = x2-start[0] + y2-start[1]\\n            }\\n            if  dist[[2]int{x2, y2}] > abs(x1-x)+abs(y1-y)+curDist+cost {\\n                dist[[2]int{x2, y2}] = abs(x1-x)+abs(y1-y)+curDist+cost\\n                heap.Push(h, []int{dist[[2]int{x2, y2}], x2, y2})               \\n            }\\n        }\\n    }\\n\\n    for _, road := range specialRoads {\\n        x2, y2, cost := road[2], road[3], dist[[2]int{road[2], road[3]}]\\n        ans = min2(ans, cost+target[0]-x2+target[1]-y2)\\n    }\\n    return ans\\n}\\nfunc abs(a int) int {if a < 0 {return -a} else {return a}}\\nfunc min2(a, b int) int{if a < b {return a} else {return b}}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Heap [][]int\\nfunc(h Heap) Len() int {return len(h)}\\nfunc(h Heap) Less(i, j int)bool {return h[i][0]<h[j][0]}\\nfunc(h Heap) Swap(i, j int) {h[i],h[j] = h[j], h[i]}\\nfunc(h *Heap) Push(x interface{}) {\\n    *h = append(*h, x.([]int))\\n}\\nfunc(h *Heap) Pop() interface{} {\\n    v := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n    return v\\n}\\n\\nfunc minimumCost(start []int, target []int, specialRoads [][]int) int {\\n    dist := make(map[[2]int]int)\\n    ans := target[0]-start[0] + target[1]-start[1]\\n    h := &Heap{}\\n    heap.Push(h, []int{0, start[0], start[1]})\\n    for h.Len() > 0 {\\n        elem := heap.Pop(h).([]int)\\n        curDist, x, y := elem[0], elem[1], elem[2]\\n        for _, road := range specialRoads {\\n            x1, y1, x2, y2, cost := road[0], road[1], road[2], road[3], road[4]\\n            if _, ok := dist[[2]int{x2, y2}]; !ok {\\n                dist[[2]int{x2, y2}] = x2-start[0] + y2-start[1]\\n            }\\n            if  dist[[2]int{x2, y2}] > abs(x1-x)+abs(y1-y)+curDist+cost {\\n                dist[[2]int{x2, y2}] = abs(x1-x)+abs(y1-y)+curDist+cost\\n                heap.Push(h, []int{dist[[2]int{x2, y2}], x2, y2})               \\n            }\\n        }\\n    }\\n\\n    for _, road := range specialRoads {\\n        x2, y2, cost := road[2], road[3], dist[[2]int{road[2], road[3]}]\\n        ans = min2(ans, cost+target[0]-x2+target[1]-y2)\\n    }\\n    return ans\\n}\\nfunc abs(a int) int {if a < 0 {return -a} else {return a}}\\nfunc min2(a, b int) int{if a < b {return a} else {return b}}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473663,
                "title": "brute-force-dijkstra",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int dijkstra(vector<int>& s, vector<int>& t,map<pair<int,int>,set<pair<pair<int,int>,int>>>&g){\\n        set<pair<int,pair<int,int>>> pq;\\n        pq.insert({0,{s[0],s[1]}});\\n        map<pair<int,int>,int> dist;\\n        dist[{s[0],s[1]}] = 0;\\n        while(!pq.empty()){\\n            auto top = *pq.begin();\\n            pq.erase(pq.begin());\\n            int wt = top.first;\\n            pair<int,int> par = top.second;\\n            for(auto&[child,weight]: g[par]){\\n                int newwt = dist[par] + weight;\\n                if(!dist.count(child)) dist[child] = 1e9;\\n                if(dist[child] > dist[par] + weight){\\n                    dist[child] = newwt;\\n                    pq.insert({newwt,child});\\n                }\\n            }\\n        }\\n        return dist[{t[0],t[1]}];\\n    }\\n    map<pair<int,int>,set<pair<pair<int,int>,int>>> buildGraph(vector<vector<int>>& sr){\\n        int n = size(sr);\\n        map<pair<int,int>,set<pair<pair<int,int>,int>>> g;\\n        for(int i=0; i<n; ++i){\\n            int a = sr[i][0], b = sr[i][1], c = sr[i][2], d = sr[i][3], wt = sr[i][4];\\n            g[{a,b}].insert({{c,d},wt});\\n            int wt2 = abs(a-c) + abs(b-d);\\n            if(wt2) g[{c,d}].insert({{a,b},wt2});\\n            for(int j=i+1; j<n; ++j){\\n                int w = sr[j][0], x = sr[j][1], y = sr[j][2], z = sr[j][3];\\n                int wt3 = abs(a-w) + abs(b-x);\\n                int wt4 = abs(a-y) + abs(b-z);\\n                if(wt3) g[{a,b}].insert({{w,x},wt3});\\n                if(wt4) g[{a,b}].insert({{y,z},wt4});\\n                if(wt3) g[{w,x}].insert({{a,b},wt3});\\n                if(wt4) g[{y,z}].insert({{a,b},wt4});\\n\\n                int wt5 = abs(c-y) + abs(d-z);\\n                int wt6 = abs(c-w) + abs(d-x);\\n                if(wt6) g[{c,d}].insert({{w,x},wt6});\\n                if(wt5) g[{c,d}].insert({{y,z},wt5});\\n                if(wt6) g[{w,x}].insert({{c,d},wt6});\\n                if(wt5) g[{y,z}].insert({{c,d},wt5});\\n            }\\n        }\\n        return g;\\n    }\\npublic:\\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& sr) {\\n        int dist = abs(t[0]-s[0]) + abs(t[1] - s[1]);\\n        sr.push_back({s[0],s[1],t[0],t[1],dist});\\n        map<pair<int,int>,set<pair<pair<int,int>,int>>> graph = buildGraph(sr);\\n        return dijkstra(s,t,graph);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dijkstra(vector<int>& s, vector<int>& t,map<pair<int,int>,set<pair<pair<int,int>,int>>>&g){\\n        set<pair<int,pair<int,int>>> pq;\\n        pq.insert({0,{s[0],s[1]}});\\n        map<pair<int,int>,int> dist;\\n        dist[{s[0],s[1]}] = 0;\\n        while(!pq.empty()){\\n            auto top = *pq.begin();\\n            pq.erase(pq.begin());\\n            int wt = top.first;\\n            pair<int,int> par = top.second;\\n            for(auto&[child,weight]: g[par]){\\n                int newwt = dist[par] + weight;\\n                if(!dist.count(child)) dist[child] = 1e9;\\n                if(dist[child] > dist[par] + weight){\\n                    dist[child] = newwt;\\n                    pq.insert({newwt,child});\\n                }\\n            }\\n        }\\n        return dist[{t[0],t[1]}];\\n    }\\n    map<pair<int,int>,set<pair<pair<int,int>,int>>> buildGraph(vector<vector<int>>& sr){\\n        int n = size(sr);\\n        map<pair<int,int>,set<pair<pair<int,int>,int>>> g;\\n        for(int i=0; i<n; ++i){\\n            int a = sr[i][0], b = sr[i][1], c = sr[i][2], d = sr[i][3], wt = sr[i][4];\\n            g[{a,b}].insert({{c,d},wt});\\n            int wt2 = abs(a-c) + abs(b-d);\\n            if(wt2) g[{c,d}].insert({{a,b},wt2});\\n            for(int j=i+1; j<n; ++j){\\n                int w = sr[j][0], x = sr[j][1], y = sr[j][2], z = sr[j][3];\\n                int wt3 = abs(a-w) + abs(b-x);\\n                int wt4 = abs(a-y) + abs(b-z);\\n                if(wt3) g[{a,b}].insert({{w,x},wt3});\\n                if(wt4) g[{a,b}].insert({{y,z},wt4});\\n                if(wt3) g[{w,x}].insert({{a,b},wt3});\\n                if(wt4) g[{y,z}].insert({{a,b},wt4});\\n\\n                int wt5 = abs(c-y) + abs(d-z);\\n                int wt6 = abs(c-w) + abs(d-x);\\n                if(wt6) g[{c,d}].insert({{w,x},wt6});\\n                if(wt5) g[{c,d}].insert({{y,z},wt5});\\n                if(wt6) g[{w,x}].insert({{c,d},wt6});\\n                if(wt5) g[{y,z}].insert({{c,d},wt5});\\n            }\\n        }\\n        return g;\\n    }\\npublic:\\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& sr) {\\n        int dist = abs(t[0]-s[0]) + abs(t[1] - s[1]);\\n        sr.push_back({s[0],s[1],t[0],t[1],dist});\\n        map<pair<int,int>,set<pair<pair<int,int>,int>>> graph = buildGraph(sr);\\n        return dijkstra(s,t,graph);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469046,
                "title": "c-o-n-2-log-n-dijkstra-97ms-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuild a fully-connected graph for all the mentioned coordinates including the starting point and target. Then run Dijkstra algorithm from the starting point to target.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTechnical detail on how to represent the graph: since the graph is fully connected, using a adjacency matrix of size `n x n` is feasible. We only have to update entries where the cost of the special road is smaller than the Manhattan distance between them.\\n\\nHow to get a fingerprint of a coordinate(x, y): since x and y range from 1 to 100000, we cannot generate a unique fingerprint using a 32-bit integer($10^{10} > (1<<32)$). However, we can use a size_t as the fingerprint by left shifting x coordinate by 32 bit and add y coordinate.\\n\\nOptimization: if the cost of a special road is less than the Manhattan distance, we don\\'t have to add this edge and need not to memorize the coordinate for them.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBuilding the graph: takes $O(n^2)$. The worst case is all the nodes are unique and the special roads are shorter than the Manhattan distance between them.\\n\\nRun Dijkstra: $O(n + n^2\\\\log(n)) = O(n^2\\\\log n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$ for the graph.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target,\\n                    vector<vector<int>>& specialRoads) {\\n        // Check trivial edge case.\\n        if (start == target) return 0;\\n        int res = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n\\n        // Add starting point and target.\\n        add_node(start[0], start[1]);\\n        add_node(target[0], target[1]);\\n\\n        // Add all unique points.\\n        for (auto & v: specialRoads) {\\n            int x = v[0], y = v[1], s = v[2], t = v[3], c = v[4];\\n            if (abs(x-s) + abs(y-t) <= c) continue;\\n            add_node(x, y);\\n            add_node(s, t);\\n        } \\n\\n        // Build the fully-connected graph.\\n        int n = node_list.size();\\n        graph = vector<vector<int>> (n, vector<int>(n, INT_MAX));\\n\\n        // Update the shortcuts for the uni-directed graph.\\n        for (auto & v: specialRoads) {\\n            int x = v[0], y = v[1], s = v[2], t = v[3], c = v[4];\\n            if (abs(x-s) + abs(y-t) <= c) continue;\\n            int id1 = node_map[make_key(x, y)];\\n            int id2 = node_map[make_key(s, t)];\\n            graph[id1][id2] = min(graph[id1][id2], c);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (graph[i][j] == INT_MAX) {\\n                    graph[i][j] = abs(node_list[i].first - node_list[j].first) +\\n                                  abs(node_list[i].second - node_list[j].second);\\n                }\\n            }\\n        }\\n        \\n        // Dijkstra Algorithm.\\n        dist.assign(n, INT_MAX);\\n        dist[0] = 0;\\n        \\n        // pq: (dist, id)\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, 0});\\n\\n        while (!pq.empty()) {\\n            auto [d, id] = pq.top(); pq.pop();\\n            // Check if popped coordinate is target.\\n            if (id == 1) return d;\\n            // Check if the current shortest distance is out of date.\\n            if (dist[id] < d) continue;\\n            // Check neighbors.\\n            for (int i = 0; i < n; ++i) {\\n                if (i == id) continue;\\n                if (dist[i] > d + graph[id][i]) {\\n                    dist[i] = d + graph[id][i];\\n                    pq.push({dist[i], i});\\n                }\\n            }\\n        }\\n        // Should not reach here.\\n        return res;\\n\\n    }\\n\\nprivate:\\n    \\n    // Generate fingerprint for the coordinate (x, y), left shift x by 32 bit and\\n    // add y.\\n    inline size_t make_key(size_t x, size_t y) {return (x<<32)|y;}\\n\\n    // Check if (x, y) already exists in the node_list.\\n    // If not, append (x, y) to the node list and assign the index to it.    \\n    void add_node(int x, int y) {\\n        size_t k = make_key(x, y);\\n        if (node_map.count(k)) return;\\n        int index = node_map[k] = node_list.size();\\n        node_list.push_back({x, y});\\n    }\\n\\n    vector<pair<int, int>> node_list;      // Store all the coordinates.\\n    unordered_map<size_t, int> node_map;   // From unique key to index.\\n    vector<vector<int>> graph;             // Store distances between node i and j.\\n    vector<int> dist;                      // Store minimal distance from the starting point.\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target,\\n                    vector<vector<int>>& specialRoads) {\\n        // Check trivial edge case.\\n        if (start == target) return 0;\\n        int res = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n\\n        // Add starting point and target.\\n        add_node(start[0], start[1]);\\n        add_node(target[0], target[1]);\\n\\n        // Add all unique points.\\n        for (auto & v: specialRoads) {\\n            int x = v[0], y = v[1], s = v[2], t = v[3], c = v[4];\\n            if (abs(x-s) + abs(y-t) <= c) continue;\\n            add_node(x, y);\\n            add_node(s, t);\\n        } \\n\\n        // Build the fully-connected graph.\\n        int n = node_list.size();\\n        graph = vector<vector<int>> (n, vector<int>(n, INT_MAX));\\n\\n        // Update the shortcuts for the uni-directed graph.\\n        for (auto & v: specialRoads) {\\n            int x = v[0], y = v[1], s = v[2], t = v[3], c = v[4];\\n            if (abs(x-s) + abs(y-t) <= c) continue;\\n            int id1 = node_map[make_key(x, y)];\\n            int id2 = node_map[make_key(s, t)];\\n            graph[id1][id2] = min(graph[id1][id2], c);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (graph[i][j] == INT_MAX) {\\n                    graph[i][j] = abs(node_list[i].first - node_list[j].first) +\\n                                  abs(node_list[i].second - node_list[j].second);\\n                }\\n            }\\n        }\\n        \\n        // Dijkstra Algorithm.\\n        dist.assign(n, INT_MAX);\\n        dist[0] = 0;\\n        \\n        // pq: (dist, id)\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, 0});\\n\\n        while (!pq.empty()) {\\n            auto [d, id] = pq.top(); pq.pop();\\n            // Check if popped coordinate is target.\\n            if (id == 1) return d;\\n            // Check if the current shortest distance is out of date.\\n            if (dist[id] < d) continue;\\n            // Check neighbors.\\n            for (int i = 0; i < n; ++i) {\\n                if (i == id) continue;\\n                if (dist[i] > d + graph[id][i]) {\\n                    dist[i] = d + graph[id][i];\\n                    pq.push({dist[i], i});\\n                }\\n            }\\n        }\\n        // Should not reach here.\\n        return res;\\n\\n    }\\n\\nprivate:\\n    \\n    // Generate fingerprint for the coordinate (x, y), left shift x by 32 bit and\\n    // add y.\\n    inline size_t make_key(size_t x, size_t y) {return (x<<32)|y;}\\n\\n    // Check if (x, y) already exists in the node_list.\\n    // If not, append (x, y) to the node list and assign the index to it.    \\n    void add_node(int x, int y) {\\n        size_t k = make_key(x, y);\\n        if (node_map.count(k)) return;\\n        int index = node_map[k] = node_list.size();\\n        node_list.push_back({x, y});\\n    }\\n\\n    vector<pair<int, int>> node_list;      // Store all the coordinates.\\n    unordered_map<size_t, int> node_map;   // From unique key to index.\\n    vector<vector<int>> graph;             // Store distances between node i and j.\\n    vector<int> dist;                      // Store minimal distance from the starting point.\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468779,
                "title": "network-flow-approach-bfs-beats-100-runtime",
                "content": "# Intuition\\nNetwork flow approach + BFS\\n# Approach\\nobservation: the minimum cost must be lower than the default manhattan distance hence, we must use a combination of the special roads to get to the target keep jumping from special roads to other special roads, stop if we are above the minimum cost \\n\\n# Complexity\\n- Time complexity:\\nO(E^2 * V) ??\\n\\n- Space complexity:\\nO(E) ??\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //observation: the minimum cost must be lower than the default manhattan distance \\n    //hence, we must use a combination of the special roads to get to the target\\n    //keep jumping from special roads to other special roads, stop if we are above the minimum cost \\n    struct Dis{\\n        int x;\\n        int y;\\n        int cost; \\n    };\\n    \\n    int mtn(int x1, int y1, int x2, int y2){\\n        return abs(x2 - x1) + abs(y2 - y1); \\n    }\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int x_t = target[0];\\n        int y_t = target[1]; \\n        int base_dis = mtn(start[0], start[1], target[0], target[1]);\\n        queue<Dis> specs; \\n        vector<int> min_costs(specialRoads.size(), INT_MAX); \\n        for (const auto& road: specialRoads){\\n            specs.push({road[0], road[1], mtn(start[0], start[1], road[0], road[1])});\\n        }\\n        while (!specs.empty()){\\n            Dis curr = specs.front();\\n            specs.pop();\\n            base_dis = min(base_dis, curr.cost + mtn(curr.x, curr.y, x_t, y_t));\\n            for (int i = 0; i < specialRoads.size(); ++i){\\n                int next_cost = mtn(curr.x, curr.y, specialRoads[i][0], specialRoads[i][1]);\\n                if (curr.cost + next_cost + specialRoads[i][4] >= base_dis){\\n                    continue; \\n                }\\n                if (curr.cost + next_cost >= min_costs[i]){\\n                    continue; \\n                }\\n                min_costs[i] = curr.cost + next_cost; \\n                specs.push({specialRoads[i][2], specialRoads[i][3], curr.cost + next_cost + specialRoads[i][4]});\\n            }\\n            // for (const auto& road: specialRoads){ \\n            //     int next_cost = mtn(curr.x, curr.y, road[0], road[1]);\\n            //     if (curr.cost + next_cost + road[4] >= base_dis){\\n            //         continue; \\n            //     }\\n            //     if (curr.cost + next_cost )\\n            //     specs.push({road[2], road[3], curr.cost + next_cost + road[4]});\\n            // }\\n        }\\n        return base_dis; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //observation: the minimum cost must be lower than the default manhattan distance \\n    //hence, we must use a combination of the special roads to get to the target\\n    //keep jumping from special roads to other special roads, stop if we are above the minimum cost \\n    struct Dis{\\n        int x;\\n        int y;\\n        int cost; \\n    };\\n    \\n    int mtn(int x1, int y1, int x2, int y2){\\n        return abs(x2 - x1) + abs(y2 - y1); \\n    }\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int x_t = target[0];\\n        int y_t = target[1]; \\n        int base_dis = mtn(start[0], start[1], target[0], target[1]);\\n        queue<Dis> specs; \\n        vector<int> min_costs(specialRoads.size(), INT_MAX); \\n        for (const auto& road: specialRoads){\\n            specs.push({road[0], road[1], mtn(start[0], start[1], road[0], road[1])});\\n        }\\n        while (!specs.empty()){\\n            Dis curr = specs.front();\\n            specs.pop();\\n            base_dis = min(base_dis, curr.cost + mtn(curr.x, curr.y, x_t, y_t));\\n            for (int i = 0; i < specialRoads.size(); ++i){\\n                int next_cost = mtn(curr.x, curr.y, specialRoads[i][0], specialRoads[i][1]);\\n                if (curr.cost + next_cost + specialRoads[i][4] >= base_dis){\\n                    continue; \\n                }\\n                if (curr.cost + next_cost >= min_costs[i]){\\n                    continue; \\n                }\\n                min_costs[i] = curr.cost + next_cost; \\n                specs.push({specialRoads[i][2], specialRoads[i][3], curr.cost + next_cost + specialRoads[i][4]});\\n            }\\n            // for (const auto& road: specialRoads){ \\n            //     int next_cost = mtn(curr.x, curr.y, road[0], road[1]);\\n            //     if (curr.cost + next_cost + road[4] >= base_dis){\\n            //         continue; \\n            //     }\\n            //     if (curr.cost + next_cost )\\n            //     specs.push({road[2], road[3], curr.cost + next_cost + road[4]});\\n            // }\\n        }\\n        return base_dis; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468727,
                "title": "dijkstra-s-a-code-quality-fully-commented-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int startX = start[0] , startY = start[1];\\n        int targetX = target[0] , targetY = target[1];\\n        if(startX == targetX && startY == targetY) return 0;\\n\\n        map<pair<int,int>,int> cost; /* {{X:CoOrdinate,Y:CoOrdinate},minCostToXY} */\\n\\n        cost[{startX,startY}] = 0; /* Starting Co-Ordinstes */\\n        cost[{targetX,targetY}] = 1e9 + 8621; /* Target Co-ordinates : Initially Unreachable */\\n        \\n        /* priority Queue (minHeap) -> {CostToReachXY,{X,Y}} */\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        pair<int,pair<int,int>> tuple = {0,{startX,startY}};\\n        pq.push(tuple);\\n        \\n        while(!pq.empty()){\\n            /* Always Get The Minimum Cost Path */\\n            tuple = pq.top(); pq.pop();\\n            int currX = tuple.second.first;\\n            int currY = tuple.second.second;\\n            int currCost = tuple.first;\\n            \\n            /* If Reached Target */\\n            if(currX == targetX && currY == targetY) return currCost;\\n            \\n            /* Directly to target */\\n            if(cost[{targetX,targetY}] > currCost + abs(currX-targetX)+abs(currY-targetY)){\\n                /* Total Cost = Current Cost + |X1-X2| + |Y1-Y2| */\\n                cost[{targetX,targetY}] = currCost + abs(currX-targetX) + abs(currY-targetY);\\n                pq.push({cost[{targetX,targetY}],{targetX,targetY}});\\n            }\\n\\n            /* Via Special Road */\\n            for(vector<int> &road : specialRoads){ \\n                /* Total Cost = Current Cost + Cost To Reach Special Road + Cost To Cross The Special Road */\\n                int toReachCost = currCost + abs(currX - road[0]) + abs(currY - road[1]) + road[4];\\n                if(cost.find({road[2],road[3]}) == cost.end() || cost[{road[2],road[3]}] > toReachCost){\\n                    cost[{road[2],road[3]}] = toReachCost;\\n                    pq.push({toReachCost,{road[2],road[3]}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int startX = start[0] , startY = start[1];\\n        int targetX = target[0] , targetY = target[1];\\n        if(startX == targetX && startY == targetY) return 0;\\n\\n        map<pair<int,int>,int> cost; /* {{X:CoOrdinate,Y:CoOrdinate},minCostToXY} */\\n\\n        cost[{startX,startY}] = 0; /* Starting Co-Ordinstes */\\n        cost[{targetX,targetY}] = 1e9 + 8621; /* Target Co-ordinates : Initially Unreachable */\\n        \\n        /* priority Queue (minHeap) -> {CostToReachXY,{X,Y}} */\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        pair<int,pair<int,int>> tuple = {0,{startX,startY}};\\n        pq.push(tuple);\\n        \\n        while(!pq.empty()){\\n            /* Always Get The Minimum Cost Path */\\n            tuple = pq.top(); pq.pop();\\n            int currX = tuple.second.first;\\n            int currY = tuple.second.second;\\n            int currCost = tuple.first;\\n            \\n            /* If Reached Target */\\n            if(currX == targetX && currY == targetY) return currCost;\\n            \\n            /* Directly to target */\\n            if(cost[{targetX,targetY}] > currCost + abs(currX-targetX)+abs(currY-targetY)){\\n                /* Total Cost = Current Cost + |X1-X2| + |Y1-Y2| */\\n                cost[{targetX,targetY}] = currCost + abs(currX-targetX) + abs(currY-targetY);\\n                pq.push({cost[{targetX,targetY}],{targetX,targetY}});\\n            }\\n\\n            /* Via Special Road */\\n            for(vector<int> &road : specialRoads){ \\n                /* Total Cost = Current Cost + Cost To Reach Special Road + Cost To Cross The Special Road */\\n                int toReachCost = currCost + abs(currX - road[0]) + abs(currY - road[1]) + road[4];\\n                if(cost.find({road[2],road[3]}) == cost.end() || cost[{road[2],road[3]}] > toReachCost){\\n                    cost[{road[2],road[3]}] = toReachCost;\\n                    pq.push({toReachCost,{road[2],road[3]}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468599,
                "title": "python-3-shortest-path-dijkstra-algorithm-full-explanation",
                "content": "This is in fact a *shortest path in weighted directed graph* problem which can be solved using *Dijkstra algorithm*.\\n\\nSince the cost of going from *(x1,y1)* to *(x2,y2)* is *abs(x1-x2)+abs(y1-y2)*, we won\\'t use any special road with cost *>=abs(x1-x2)+abs(y1-y2)*.\\n\\nWe treat each road as an edge in a weighted directed graph, and also record the sets of starting points and ending points of the roads.\\n```\\n        g,starts,ends = defaultdict(set),set(),set()\\n        for x1,y1,x2,y2,c in specialRoads:\\n            if c>=abs(x1-x2)+abs(y1-y2): continue\\n            g[(x1,y1)].add((x2,y2,c))\\n            starts.add((x1,y1))\\n            ends.add((x2,y2))\\n```\\n\\nSince we need to consider all possible combinations of using the roads, we add directed edges from each ending point to every starting points of the roads. We also need to consider all possible moves from *start* by adding directed egdes from *start* to every starting points. Similarly, we need to consider all possible moves to *target* by adding directed egdes to *target* from every ending points.\\n```\\n        starts.add(tuple(target))\\n        ends.add(tuple(start))\\n        for x1,y1 in ends:\\n            for x2,y2 in starts:\\n                g[(x1,y1)].add((x2,y2,abs(x1-x2)+abs(y1-y2)))\\n```\\n\\nThe given problem is now reduced to finding shortest path from *start* to *target* in the constructed graph, which can be solved by Dijkstra algorithm.\\n```\\n        dist = {}\\n        for x,y in starts:\\n            dist[(x,y)] = math.inf\\n        for x,y in ends:\\n            dist[(x,y)] = math.inf\\n        dist[tuple(start)] = 0\\n        pq = [(0,start[0],start[1])]\\n        while pq:\\n            dis1,x1,y1 = heapq.heappop(pq)\\n            for x2,y2,c in g[(x1,y1)]:\\n                dis2 = dis1+c\\n                if dis2<dist[(x2,y2)]:\\n                    dist[(x2,y2)] = dis2\\n                    heapq.heappush(pq,(dis2,x2,y2))\\n        return dist[tuple(target)]     \\n```\\n# Python 3\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        g,starts,ends = defaultdict(set),set(),set()\\n        for x1,y1,x2,y2,c in specialRoads:\\n            if c>=abs(x1-x2)+abs(y1-y2): continue\\n            g[(x1,y1)].add((x2,y2,c))\\n            starts.add((x1,y1))\\n            ends.add((x2,y2))\\n        starts.add(tuple(target))\\n        ends.add(tuple(start))\\n        for x1,y1 in ends:\\n            for x2,y2 in starts:\\n                g[(x1,y1)].add((x2,y2,abs(x1-x2)+abs(y1-y2)))\\n        dist = {}\\n        for x,y in starts:\\n            dist[(x,y)] = math.inf\\n        for x,y in ends:\\n            dist[(x,y)] = math.inf\\n        dist[tuple(start)] = 0\\n        pq = [(0,start[0],start[1])]\\n        while pq:\\n            dis1,x1,y1 = heapq.heappop(pq)\\n            for x2,y2,c in g[(x1,y1)]:\\n                dis2 = dis1+c\\n                if dis2<dist[(x2,y2)]:\\n                    dist[(x2,y2)] = dis2\\n                    heapq.heappush(pq,(dis2,x2,y2))\\n        return dist[tuple(target)]            \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n        g,starts,ends = defaultdict(set),set(),set()\\n        for x1,y1,x2,y2,c in specialRoads:\\n            if c>=abs(x1-x2)+abs(y1-y2): continue\\n            g[(x1,y1)].add((x2,y2,c))\\n            starts.add((x1,y1))\\n            ends.add((x2,y2))\\n```\n```\\n        starts.add(tuple(target))\\n        ends.add(tuple(start))\\n        for x1,y1 in ends:\\n            for x2,y2 in starts:\\n                g[(x1,y1)].add((x2,y2,abs(x1-x2)+abs(y1-y2)))\\n```\n```\\n        dist = {}\\n        for x,y in starts:\\n            dist[(x,y)] = math.inf\\n        for x,y in ends:\\n            dist[(x,y)] = math.inf\\n        dist[tuple(start)] = 0\\n        pq = [(0,start[0],start[1])]\\n        while pq:\\n            dis1,x1,y1 = heapq.heappop(pq)\\n            for x2,y2,c in g[(x1,y1)]:\\n                dis2 = dis1+c\\n                if dis2<dist[(x2,y2)]:\\n                    dist[(x2,y2)] = dis2\\n                    heapq.heappush(pq,(dis2,x2,y2))\\n        return dist[tuple(target)]     \\n```\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        g,starts,ends = defaultdict(set),set(),set()\\n        for x1,y1,x2,y2,c in specialRoads:\\n            if c>=abs(x1-x2)+abs(y1-y2): continue\\n            g[(x1,y1)].add((x2,y2,c))\\n            starts.add((x1,y1))\\n            ends.add((x2,y2))\\n        starts.add(tuple(target))\\n        ends.add(tuple(start))\\n        for x1,y1 in ends:\\n            for x2,y2 in starts:\\n                g[(x1,y1)].add((x2,y2,abs(x1-x2)+abs(y1-y2)))\\n        dist = {}\\n        for x,y in starts:\\n            dist[(x,y)] = math.inf\\n        for x,y in ends:\\n            dist[(x,y)] = math.inf\\n        dist[tuple(start)] = 0\\n        pq = [(0,start[0],start[1])]\\n        while pq:\\n            dis1,x1,y1 = heapq.heappop(pq)\\n            for x2,y2,c in g[(x1,y1)]:\\n                dis2 = dis1+c\\n                if dis2<dist[(x2,y2)]:\\n                    dist[(x2,y2)] = dis2\\n                    heapq.heappush(pq,(dis2,x2,y2))\\n        return dist[tuple(target)]            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468535,
                "title": "c-dijkstra-faster-than-100-so-far",
                "content": "The faster than X% figure is not accurate sometimes, I am sure faster solutions are out there.\\n```\\nclass Solution {\\npublic:\\n  struct Node {\\n    vector<pair<pair<int, int>, int>> neighbors;\\n  };\\n  unordered_map<int, unordered_map<int, Node>> tree;\\n  \\n  int getCost(pair<int, int> p1, pair<int, int> p2) {\\n    return abs(p1.first - p2.first) + abs(p1.second - p2.second);\\n  }\\n  \\n  int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n    for (auto& vec : specialRoads) {\\n      tree[vec[0]][vec[1]].neighbors.push_back({{vec[2], vec[3]}, vec[4]});\\n    }\\n    pair<int, int> s = {start[0], start[1]};\\n    pair<int, int> t = {target[0], target[1]};\\n    \\n    priority_queue<pair<int, pair<int, int>>> pq;\\n    unordered_map<int, unordered_set<int>> visited;\\n    pq.push({0, {s.first, s.second}});\\n    while (!pq.empty()) {\\n      auto info = pq.top(); pq.pop();\\n      int cost = -info.first;\\n      auto node = info.second;\\n      if (visited[node.first].count(node.second)) continue;\\n      visited[node.first].insert(node.second);\\n      if (node == t) return cost;\\n      pq.push({-cost - getCost(node, t), t});\\n      // Add special roads as edges.\\n      for (auto& vec : specialRoads) {\\n        pair<int, int> p = {vec[0], vec[1]};\\n        int c = getCost(node, p);\\n        pq.push({-c - cost, p});\\n      }\\n      // Add normal roads to special start points as edges.\\n      for (auto& child : tree[node.first][node.second].neighbors) {\\n        pq.push({-cost - child.second, {child.first.first, child.first.second}});\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  struct Node {\\n    vector<pair<pair<int, int>, int>> neighbors;\\n  };\\n  unordered_map<int, unordered_map<int, Node>> tree;\\n  \\n  int getCost(pair<int, int> p1, pair<int, int> p2) {\\n    return abs(p1.first - p2.first) + abs(p1.second - p2.second);\\n  }\\n  \\n  int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n    for (auto& vec : specialRoads) {\\n      tree[vec[0]][vec[1]].neighbors.push_back({{vec[2], vec[3]}, vec[4]});\\n    }\\n    pair<int, int> s = {start[0], start[1]};\\n    pair<int, int> t = {target[0], target[1]};\\n    \\n    priority_queue<pair<int, pair<int, int>>> pq;\\n    unordered_map<int, unordered_set<int>> visited;\\n    pq.push({0, {s.first, s.second}});\\n    while (!pq.empty()) {\\n      auto info = pq.top(); pq.pop();\\n      int cost = -info.first;\\n      auto node = info.second;\\n      if (visited[node.first].count(node.second)) continue;\\n      visited[node.first].insert(node.second);\\n      if (node == t) return cost;\\n      pq.push({-cost - getCost(node, t), t});\\n      // Add special roads as edges.\\n      for (auto& vec : specialRoads) {\\n        pair<int, int> p = {vec[0], vec[1]};\\n        int c = getCost(node, p);\\n        pq.push({-c - cost, p});\\n      }\\n      // Add normal roads to special start points as edges.\\n      for (auto& child : tree[node.first][node.second].neighbors) {\\n        pq.push({-cost - child.second, {child.first.first, child.first.second}});\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925611,
                "title": "dynammic-programming-approach-easy-to-understand-comments-to-explain",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& s) {\\n        \\n        // pushing special roads 2 time to consider backward movement also from any road.\\n        vector<vector<int>> sr(s.begin(), s.end());\\n        for(int i = 0; i < s.size(); ++i)\\n            sr.push_back(s[i]);\\n        int n = sr.size();\\n        vector<int> dp(n, INT_MAX);\\n        // dp[i] = min distance to go from i to target\\n        dp[n-1] = abs(target[0]-sr[n-1][2])+abs(target[1]-sr[n-1][3])+ sr[n-1][4];\\n        for(int i = n-2; i >= 0; --i) {\\n            for(int j = i+1; j < n; ++j) {\\n                int temp = sr[i][4] + abs(sr[j][0]-sr[i][2])+abs(sr[j][1]-sr[i][3])+dp[j];\\n                dp[i] = min(dp[i], temp);\\n            }\\n            dp[i] = min(dp[i], (sr[i][4]+abs(sr[i][2]-target[0])+abs(sr[i][3]-target[1])));\\n        }\\n        int mini = abs(start[0]-target[0])+abs(start[1]-target[1]);\\n        for(int i = 0; i < n/2; ++i) {\\n            int temp = abs(start[0]-sr[i][0])+abs(start[1]-sr[i][1])+dp[i];\\n            mini = min(mini, temp);\\n        }\\n        return mini;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& s) {\\n        \\n        // pushing special roads 2 time to consider backward movement also from any road.\\n        vector<vector<int>> sr(s.begin(), s.end());\\n        for(int i = 0; i < s.size(); ++i)\\n            sr.push_back(s[i]);\\n        int n = sr.size();\\n        vector<int> dp(n, INT_MAX);\\n        // dp[i] = min distance to go from i to target\\n        dp[n-1] = abs(target[0]-sr[n-1][2])+abs(target[1]-sr[n-1][3])+ sr[n-1][4];\\n        for(int i = n-2; i >= 0; --i) {\\n            for(int j = i+1; j < n; ++j) {\\n                int temp = sr[i][4] + abs(sr[j][0]-sr[i][2])+abs(sr[j][1]-sr[i][3])+dp[j];\\n                dp[i] = min(dp[i], temp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3685827,
                "title": "easy-implementation-using-dijkstra-s-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cost(int x1, int y1, int x2, int y2){\\n        return abs(x1-x2) + abs(y1-y2);\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& roads) {\\n        map<pair<int,int> , int>mp;\\n        mp[{start[0],start[1]}] = 0;\\n        vector<pair<int,int>>g[504];\\n        int cnt = 1;\\n        for(auto road : roads){\\n            int x1 = road[0], y1 = road[1];\\n            int x2 = road[2], y2 = road[3];\\n            if(mp.find({x1,y1}) == mp.end()){\\n                mp[{x1,y1}] = cnt;\\n                cnt++;\\n            }\\n            if(mp.find({x2,y2}) == mp.end()){\\n                mp[{x2,y2}] = cnt;\\n                cnt++;\\n            }\\n        }\\n        if(mp.find({target[0],target[1]}) == mp.end()){\\n            mp[{target[0],target[1]}] = cnt;\\n            cnt++;\\n        } \\n        // cout<<cnt<<endl;\\n    \\n        int tar = mp[{target[0],target[1]}];\\n        for(auto road : roads){\\n            int x1 = road[0], y1 = road[1];\\n            int x2 = road[2], y2 = road[3];\\n            int c = road[4];\\n            int u = mp[{x1,y1}];\\n            int v = mp[{x2,y2}];\\n            g[0].push_back({u,cost(start[0],start[1],x1,y1)});\\n            g[u].push_back({v,c});\\n            g[v].push_back({tar, cost(x2,y2,target[0],target[1])});\\n            for(auto r : roads){\\n                int xi = r[0], yi = r[1];\\n                int xj = r[2], yj = r[3];\\n                int pt1 = mp[{xi,yi}];\\n                int pt2 = mp[{xj,yj}];\\n                if(pt1 != u) g[pt1].push_back({u,cost(xi,yi,x1,y1)});\\n                if(pt1 != v) g[pt1].push_back({v,cost(xi,yi,x2,y2)});\\n                if(pt2 != u) g[pt2].push_back({u,cost(xj,yj,x1,y1)});\\n                if(pt2 != v) g[pt2].push_back({v,cost(xj,yj,x2,y2)});\\n            }\\n        }\\n        g[0].push_back({tar,cost(start[0],start[1],target[0],target[1])});\\n\\n\\n        vector<int>minDist(cnt,INT_MAX);\\n        minDist[0] = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist = pq.top().first;\\n            int pt = pq.top().second;\\n            pq.pop();\\n\\n            for(auto p : g[pt]){\\n                int node = p.first;\\n                int c = p.second;\\n                if(dist + c < minDist[node]){\\n                    minDist[node] = dist + c;\\n                    pq.push({dist+c,node});\\n                }\\n            }\\n        }\\n        \\n        return minDist[tar];\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(int x1, int y1, int x2, int y2){\\n        return abs(x1-x2) + abs(y1-y2);\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& roads) {\\n        map<pair<int,int> , int>mp;\\n        mp[{start[0],start[1]}] = 0;\\n        vector<pair<int,int>>g[504];\\n        int cnt = 1;\\n        for(auto road : roads){\\n            int x1 = road[0], y1 = road[1];\\n            int x2 = road[2], y2 = road[3];\\n            if(mp.find({x1,y1}) == mp.end()){\\n                mp[{x1,y1}] = cnt;\\n                cnt++;\\n            }\\n            if(mp.find({x2,y2}) == mp.end()){\\n                mp[{x2,y2}] = cnt;\\n                cnt++;\\n            }\\n        }\\n        if(mp.find({target[0],target[1]}) == mp.end()){\\n            mp[{target[0],target[1]}] = cnt;\\n            cnt++;\\n        } \\n        // cout<<cnt<<endl;\\n    \\n        int tar = mp[{target[0],target[1]}];\\n        for(auto road : roads){\\n            int x1 = road[0], y1 = road[1];\\n            int x2 = road[2], y2 = road[3];\\n            int c = road[4];\\n            int u = mp[{x1,y1}];\\n            int v = mp[{x2,y2}];\\n            g[0].push_back({u,cost(start[0],start[1],x1,y1)});\\n            g[u].push_back({v,c});\\n            g[v].push_back({tar, cost(x2,y2,target[0],target[1])});\\n            for(auto r : roads){\\n                int xi = r[0], yi = r[1];\\n                int xj = r[2], yj = r[3];\\n                int pt1 = mp[{xi,yi}];\\n                int pt2 = mp[{xj,yj}];\\n                if(pt1 != u) g[pt1].push_back({u,cost(xi,yi,x1,y1)});\\n                if(pt1 != v) g[pt1].push_back({v,cost(xi,yi,x2,y2)});\\n                if(pt2 != u) g[pt2].push_back({u,cost(xj,yj,x1,y1)});\\n                if(pt2 != v) g[pt2].push_back({v,cost(xj,yj,x2,y2)});\\n            }\\n        }\\n        g[0].push_back({tar,cost(start[0],start[1],target[0],target[1])});\\n\\n\\n        vector<int>minDist(cnt,INT_MAX);\\n        minDist[0] = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist = pq.top().first;\\n            int pt = pq.top().second;\\n            pq.pop();\\n\\n            for(auto p : g[pt]){\\n                int node = p.first;\\n                int c = p.second;\\n                if(dist + c < minDist[node]){\\n                    minDist[node] = dist + c;\\n                    pq.push({dist+c,node});\\n                }\\n            }\\n        }\\n        \\n        return minDist[tar];\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3504359,
                "title": "minimum-cost-of-a-path-with-special-roads",
                "content": "\\n```\\nvar minimumCost = function(start, target, specialRoads) {\\n    \\n    function dist(x1, x2, y1, y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n\\n    let ans = Math.abs(start[0] - target[0]) + Math.abs(start[1] - target[1]);\\n    let hm = {};\\n\\n    function helper(curX, curY, curDist) {\\n        // Pruning 1\\n        if (curDist >= ans) return;\\n        ans = Math.min(ans, dist(curX, target[0], curY, target[1]) + curDist);\\n\\n        // Pruning 2\\n        if (hm.hasOwnProperty(curX + \",\" + curY)) {\\n            if (hm[curX + \",\" + curY] <= curDist) return;\\n        }\\n        hm[curX + \",\" + curY] = curDist;\\n\\n        for (let i = 0; i < specialRoads.length; i++) {\\n            let next = specialRoads[i];\\n            helper(next[2], next[3], curDist + dist(curX, next[0], curY, next[1]) + next[4]);\\n        }\\n    }\\n\\n    helper(start[0], start[1], 0);\\n\\n    return ans;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumCost = function(start, target, specialRoads) {\\n    \\n    function dist(x1, x2, y1, y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n\\n    let ans = Math.abs(start[0] - target[0]) + Math.abs(start[1] - target[1]);\\n    let hm = {};\\n\\n    function helper(curX, curY, curDist) {\\n        // Pruning 1\\n        if (curDist >= ans) return;\\n        ans = Math.min(ans, dist(curX, target[0], curY, target[1]) + curDist);\\n\\n        // Pruning 2\\n        if (hm.hasOwnProperty(curX + \",\" + curY)) {\\n            if (hm[curX + \",\" + curY] <= curDist) return;\\n        }\\n        hm[curX + \",\" + curY] = curDist;\\n\\n        for (let i = 0; i < specialRoads.length; i++) {\\n            let next = specialRoads[i];\\n            helper(next[2], next[3], curDist + dist(curX, next[0], curY, next[1]) + next[4]);\\n        }\\n    }\\n\\n    helper(start[0], start[1], 0);\\n\\n    return ans;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489006,
                "title": "c-easy-solution-dijkastra-shortest-path-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        int n=specialRoads.size();\\n        vector<int> dist(n,INT_MAX);\\n        for(int i=0;i<specialRoads.size();i++){\\n            int manhat=abs(start[0]-specialRoads[i][0])+abs(start[1]-specialRoads[i][1])+specialRoads[i][4];\\n            q.push({manhat,i});\\n        }\\n        int ans=abs(start[0]-target[0])+abs(start[1]-target[1]);\\n        while(!q.empty()){\\n            int r=specialRoads[q.top().second][2];\\n            int c=specialRoads[q.top().second][3];\\n            int id=q.top().second;\\n            int d=q.top().first;\\n            q.pop();\\n            ans=min(ans,d+abs(r-target[0])+abs(c-target[1]));\\n            for(int i=0;i<n;i++){\\n                int manhat=abs(r-specialRoads[i][0])+abs(c-specialRoads[i][1])+specialRoads[i][4];\\n                if(d+manhat<dist[i]){\\n                    dist[i]=d+manhat;\\n                    q.push({dist[i],i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        int n=specialRoads.size();\\n        vector<int> dist(n,INT_MAX);\\n        for(int i=0;i<specialRoads.size();i++){\\n            int manhat=abs(start[0]-specialRoads[i][0])+abs(start[1]-specialRoads[i][1])+specialRoads[i][4];\\n            q.push({manhat,i});\\n        }\\n        int ans=abs(start[0]-target[0])+abs(start[1]-target[1]);\\n        while(!q.empty()){\\n            int r=specialRoads[q.top().second][2];\\n            int c=specialRoads[q.top().second][3];\\n            int id=q.top().second;\\n            int d=q.top().first;\\n            q.pop();\\n            ans=min(ans,d+abs(r-target[0])+abs(c-target[1]));\\n            for(int i=0;i<n;i++){\\n                int manhat=abs(r-specialRoads[i][0])+abs(c-specialRoads[i][1])+specialRoads[i][4];\\n                if(d+manhat<dist[i]){\\n                    dist[i]=d+manhat;\\n                    q.push({dist[i],i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482322,
                "title": "javascript-2662-minimum-cost-of-a-path-with-special-roads",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- 1 DFS\\n- 2 BFS with priority queue\\n\\nNotes\\n- Start can be in middle of all points, may need to back to get to target faster\\n- Always check with target & get min distance to target - ignore if other distances are greater\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1 - DFS\\n\\n```\\nconst getDist2PointCoord = (x1, y1, x2, y2) =>\\n    Math.abs(x2 - x1) + Math.abs(y2 - y1);\\n\\nvar minimumCost = function (startP, targetP, edges) {\\n    let [sx, sy] = startP;\\n    let [tx, ty] = targetP;\\n\\n    // optimization - not a must\\n    edges = edges.filter(\\n        ([x1, y1, x2, y2, d]) => d < getDist2PointCoord(x1, y1, x2, y2)\\n    );\\n\\n    let minDist2Target = getDist2PointCoord(sx, sy, tx, ty);\\n    let visited = new Array(edges.length);\\n    let minDist2vMap = new Map();\\n\\n    function dfs(xv, yv, dist2v) {\\n        if (dist2v >= minDist2Target) return;\\n\\n        let vKey = xv + \",\" + yv;\\n        if (minDist2vMap.get(vKey) <= dist2v) return;\\n        minDist2vMap.set(vKey, dist2v);\\n\\n        minDist2Target = Math.min(\\n            minDist2Target,\\n            dist2v + getDist2PointCoord(xv, yv, tx, ty)\\n        );\\n        if (xv == targetP[0] && yv == targetP[1]) return;\\n\\n        for (let i = 0; i < visited.length; i++) {\\n            if (visited[i]) continue;\\n            let [x1, y1, x2, y2, d] = edges[i];\\n            visited[i] = true;\\n            dfs(x2, y2, dist2v + getDist2PointCoord(xv, yv, x1, y1) + d);\\n            visited[i] = false;\\n        }\\n    }\\n\\n    dfs(sx, sy, 0);\\n    return minDist2Target;\\n};\\n```\\n\\n2 - BFS with priority queue\\n\\n```\\nconst getDist2PointCoord = (x1, y1, x2, y2) =>\\n    Math.abs(x2 - x1) + Math.abs(y2 - y1);\\n\\nvar minimumCost = function (startP, targetP, edges) {\\n    let [sx, sy] = startP;\\n    let [tx, ty] = targetP;\\n\\n    let minDist2Target = getDist2PointCoord(sx, sy, tx, ty);\\n    let visited = new Set();\\n\\n    const pq = new MinPriorityQueue({ compare: (a, b) => a[2] - b[2] });\\n    pq.enqueue([sx, sy, 0]);\\n    while (pq.size()) {\\n        let [xv, yv, dist2v] = pq.dequeue();\\n        if (dist2v > minDist2Target) continue;\\n\\n        let vKey = xv + \",\" + yv;\\n        if (visited.has(vKey)) continue;\\n        visited.add(vKey);\\n\\n        minDist2Target = Math.min(\\n            minDist2Target,\\n            dist2v + getDist2PointCoord(xv, yv, tx, ty)\\n        );\\n        if (xv === tx && yv === ty) {\\n            continue;\\n        }\\n        for (let [x1, y1, x2, y2, d] of edges) {\\n            pq.enqueue([\\n                x2,\\n                y2,\\n                dist2v + getDist2PointCoord(xv, yv, x1, y1) + d,\\n            ]);\\n        }\\n    }\\n    return minDist2Target;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getDist2PointCoord = (x1, y1, x2, y2) =>\\n    Math.abs(x2 - x1) + Math.abs(y2 - y1);\\n\\nvar minimumCost = function (startP, targetP, edges) {\\n    let [sx, sy] = startP;\\n    let [tx, ty] = targetP;\\n\\n    // optimization - not a must\\n    edges = edges.filter(\\n        ([x1, y1, x2, y2, d]) => d < getDist2PointCoord(x1, y1, x2, y2)\\n    );\\n\\n    let minDist2Target = getDist2PointCoord(sx, sy, tx, ty);\\n    let visited = new Array(edges.length);\\n    let minDist2vMap = new Map();\\n\\n    function dfs(xv, yv, dist2v) {\\n        if (dist2v >= minDist2Target) return;\\n\\n        let vKey = xv + \",\" + yv;\\n        if (minDist2vMap.get(vKey) <= dist2v) return;\\n        minDist2vMap.set(vKey, dist2v);\\n\\n        minDist2Target = Math.min(\\n            minDist2Target,\\n            dist2v + getDist2PointCoord(xv, yv, tx, ty)\\n        );\\n        if (xv == targetP[0] && yv == targetP[1]) return;\\n\\n        for (let i = 0; i < visited.length; i++) {\\n            if (visited[i]) continue;\\n            let [x1, y1, x2, y2, d] = edges[i];\\n            visited[i] = true;\\n            dfs(x2, y2, dist2v + getDist2PointCoord(xv, yv, x1, y1) + d);\\n            visited[i] = false;\\n        }\\n    }\\n\\n    dfs(sx, sy, 0);\\n    return minDist2Target;\\n};\\n```\n```\\nconst getDist2PointCoord = (x1, y1, x2, y2) =>\\n    Math.abs(x2 - x1) + Math.abs(y2 - y1);\\n\\nvar minimumCost = function (startP, targetP, edges) {\\n    let [sx, sy] = startP;\\n    let [tx, ty] = targetP;\\n\\n    let minDist2Target = getDist2PointCoord(sx, sy, tx, ty);\\n    let visited = new Set();\\n\\n    const pq = new MinPriorityQueue({ compare: (a, b) => a[2] - b[2] });\\n    pq.enqueue([sx, sy, 0]);\\n    while (pq.size()) {\\n        let [xv, yv, dist2v] = pq.dequeue();\\n        if (dist2v > minDist2Target) continue;\\n\\n        let vKey = xv + \",\" + yv;\\n        if (visited.has(vKey)) continue;\\n        visited.add(vKey);\\n\\n        minDist2Target = Math.min(\\n            minDist2Target,\\n            dist2v + getDist2PointCoord(xv, yv, tx, ty)\\n        );\\n        if (xv === tx && yv === ty) {\\n            continue;\\n        }\\n        for (let [x1, y1, x2, y2, d] of edges) {\\n            pq.enqueue([\\n                x2,\\n                y2,\\n                dist2v + getDist2PointCoord(xv, yv, x1, y1) + d,\\n            ]);\\n        }\\n    }\\n    return minDist2Target;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475765,
                "title": "dijkstra-template-for-solving-similar-problems-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s summarize what the question want us to do:\\n* 2D array, from **single start** to **single target** -> might be a **graph** problem.\\n* There is only **positive** cost in the graph.\\n* We want to find **minimum(shortest) cost path**\\n\\nBased on the condition above, we know that Dijkstra can work.\\n\\n### Quick summary of Graph problem:\\n* Shortest path problem:\\n    * Same weight -> BFS\\n    * Different weight\\n        * only positive weight -> Dijkstra\\n        * contains negitive weight -> Bellman- Ford\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt\\'s useful to save a template in your own notebook, and start from the template during a contrast. (or even an interview? I\\'m not sure if we could do that. It might depends on the company.)\\n\\n### Template of the Dijkstra:\\n1. Use a vector to store the current best cost for every node.\\n2. Use a priority queue to maintain all possible deges (So that you can always get the edge with the smallest cost.)\\n3. iterate through the priority queue and keep relax the edge. (\"Relax\" means to check if we can arrive a point with a smaller cost. Check the [tutorial](https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3885/) for more introduction.)\\n4. Finally, return the distance of the target point.\\n```\\nimport heapq\\n\\nclass Graph:\\n    def __init__(self, V: int): # Constructor\\n        self.V = V\\n        self.adj = [[] for _ in range(V)]\\n  \\n    def addEdge(self, u: int, v: int, w: int):\\n        self.adj[u].append((v, w))\\n        self.adj[v].append((u, w))\\n  \\n\\n    def shortestPath(self, src: int, dst: int):\\n        # Create a priority queue to store vertices that\\n        # are being preprocessed\\n        pq = []\\n        heapq.heappush(pq, (0, src))\\n  \\n        # Create a vector for distances and initialize all\\n        # distances as infinite (INF)\\n        dist = [float(\\'inf\\')] * self.V\\n        dist[src] = 0\\n  \\n        while pq:\\n            # The first vertex in pair is the minimum distance\\n            # vertex, extract it from priority queue.\\n            d, u = heapq.heappop(pq)\\n  \\n            for v, weight in self.adj[u]:\\n                # If there is shorted path to v through u.\\n                if dist[v] > dist[u] + weight:\\n                    # Updating distance of v\\n                    dist[v] = dist[u] + weight\\n                    heapq.heappush(pq, (dist[v], v))\\n\\n\\t\\t\\treturn dist[dst]\\n```\\n\\nSo, following the template, we can come up this the solution as shown in the Code session.\\n\\n\\nThe most different part between the solution and the template is the part to construct all the edges. You can draw some examples on the paper, and try to think about \"how many possible ways to go from the start and the target?\\n\\nOnce you\\'ve construct all the edges, the left thing to do is relaxation, which remains the same with the template.\\n\\n\\n# Complexity\\nSuppose `n` is the number of the special roads:\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n    * construct edges: O(n^2)\\n    * iterate through the priority queue: O(n^2 logn)\\n    * Total: O(n^2 logn)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    * For the distance vector: O(n)\\n    * priority queue: O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n\\n        from collections import defaultdict\\n        from heapq import heappush, heappush\\n\\n        def getDistance(x1, y1, x2, y2):\\n            return abs(x2 - x1) + abs(y2 - y1)\\n\\n        #init: distance, minHeap, result\\n        startX, startY   = start\\n        targetX, targetY = target\\n\\n        distance = defaultdict(lambda: float(\\'inf\\'))\\n        distance[(startX, startY)] = 0\\n        minHeap = []\\n        heappush(minHeap, (0, startX, startY))\\n        distance[(targetX, targetY)] = getDistance(startX, startY, targetX, targetY)\\n\\n        #add adjs\\n        adjs = defaultdict(list)\\n        \\n        for fromX, fromY, toX, toY, cost in specialRoads:\\n            #filter out unuseful roads\\n            if getDistance(fromX, fromY, toX, toY) < cost:\\n                continue\\n            #from \"start\" to all special road\\n            adjs[(startX, startY)].append([fromX, fromY, getDistance(startX, startY, fromX, fromY)])\\n            #all special road\\n            adjs[(fromX, fromY)].append([toX, toY, cost])\\n            #all special road to target\\n            adjs[(toX, toY)].append([targetX, targetY, getDistance(toX, toY, targetX, targetY)])\\n            #all special road to another road\\n            for anotherFromX, anotherFromY, anotherToX, anotherToY, anotherCost in specialRoads[1:]:\\n                adjs[(toX, toY)].append([anotherFromX, anotherFromY, getDistance(toX, toY, anotherFromX, anotherFromY)])\\n                adjs[(anotherToX, anotherToY)].append([fromX, fromY, getDistance(anotherToX, anotherToY, fromX, fromY)])\\n\\n\\n        #iterate the minHeap, update the edge\\n        while minHeap:\\n            curCost, curX, curY = heappop(minHeap)\\n\\n            for adjX, adjY, adjCost in adjs[(curX, curY)]:\\n                \\n                if distance[(adjX, adjY)] > distance[(curX, curY)] + adjCost:\\n                    # Updating distance of v\\n                    distance[(adjX, adjY)] = distance[(curX, curY)] + adjCost\\n                    heappush(minHeap, (distance[(adjX, adjY)], adjX, adjY))\\n                    \\n\\n\\n        return distance[(targetX, targetY)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Graph:\\n    def __init__(self, V: int): # Constructor\\n        self.V = V\\n        self.adj = [[] for _ in range(V)]\\n  \\n    def addEdge(self, u: int, v: int, w: int):\\n        self.adj[u].append((v, w))\\n        self.adj[v].append((u, w))\\n  \\n\\n    def shortestPath(self, src: int, dst: int):\\n        # Create a priority queue to store vertices that\\n        # are being preprocessed\\n        pq = []\\n        heapq.heappush(pq, (0, src))\\n  \\n        # Create a vector for distances and initialize all\\n        # distances as infinite (INF)\\n        dist = [float(\\'inf\\')] * self.V\\n        dist[src] = 0\\n  \\n        while pq:\\n            # The first vertex in pair is the minimum distance\\n            # vertex, extract it from priority queue.\\n            d, u = heapq.heappop(pq)\\n  \\n            for v, weight in self.adj[u]:\\n                # If there is shorted path to v through u.\\n                if dist[v] > dist[u] + weight:\\n                    # Updating distance of v\\n                    dist[v] = dist[u] + weight\\n                    heapq.heappush(pq, (dist[v], v))\\n\\n\\t\\t\\treturn dist[dst]\\n```\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n\\n        from collections import defaultdict\\n        from heapq import heappush, heappush\\n\\n        def getDistance(x1, y1, x2, y2):\\n            return abs(x2 - x1) + abs(y2 - y1)\\n\\n        #init: distance, minHeap, result\\n        startX, startY   = start\\n        targetX, targetY = target\\n\\n        distance = defaultdict(lambda: float(\\'inf\\'))\\n        distance[(startX, startY)] = 0\\n        minHeap = []\\n        heappush(minHeap, (0, startX, startY))\\n        distance[(targetX, targetY)] = getDistance(startX, startY, targetX, targetY)\\n\\n        #add adjs\\n        adjs = defaultdict(list)\\n        \\n        for fromX, fromY, toX, toY, cost in specialRoads:\\n            #filter out unuseful roads\\n            if getDistance(fromX, fromY, toX, toY) < cost:\\n                continue\\n            #from \"start\" to all special road\\n            adjs[(startX, startY)].append([fromX, fromY, getDistance(startX, startY, fromX, fromY)])\\n            #all special road\\n            adjs[(fromX, fromY)].append([toX, toY, cost])\\n            #all special road to target\\n            adjs[(toX, toY)].append([targetX, targetY, getDistance(toX, toY, targetX, targetY)])\\n            #all special road to another road\\n            for anotherFromX, anotherFromY, anotherToX, anotherToY, anotherCost in specialRoads[1:]:\\n                adjs[(toX, toY)].append([anotherFromX, anotherFromY, getDistance(toX, toY, anotherFromX, anotherFromY)])\\n                adjs[(anotherToX, anotherToY)].append([fromX, fromY, getDistance(anotherToX, anotherToY, fromX, fromY)])\\n\\n\\n        #iterate the minHeap, update the edge\\n        while minHeap:\\n            curCost, curX, curY = heappop(minHeap)\\n\\n            for adjX, adjY, adjCost in adjs[(curX, curY)]:\\n                \\n                if distance[(adjX, adjY)] > distance[(curX, curY)] + adjCost:\\n                    # Updating distance of v\\n                    distance[(adjX, adjY)] = distance[(curX, curY)] + adjCost\\n                    heappush(minHeap, (distance[(adjX, adjY)], adjX, adjY))\\n                    \\n\\n\\n        return distance[(targetX, targetY)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475675,
                "title": "c-version-of-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust implemented the idea of other [solution](https://leetcode.com/problems/minimum-cost-of-a-path-with-special-roads/solutions/3468366/python3-dijkstra-s-algo/) with C# version + description\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Dictionary<(int x1, int y1), List<(int x2, int y2, int cost)>> map** - consist of positions from-to with cost.\\n- **var dist = new Dictionary<(int x, int y), int>()** - consist min distance for each (int x, int y) we have found from `x1, y1 and x2, y2` from special roads\\n- **var pq = new PriorityQueue<(int curDist, int x, int y), int>();** - if found min distance for `[x,y]`, store for next processing by min distance priority. As starting point for calculate min distance for other `[x1, y1, x2, y2]` special roads(nodes).\\n\\nWhen current position is our target, we don\\'t need to calculate distance for other nodes from this. Return this as answer. \\n```\\nif (x == target[0] && y == target[1]) {\\n    return curDist;\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2logn)$$, where n - specialRoads size.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where n - specialRoads size + uniq (x,y) nodes.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        var map = new Dictionary<(int x1, int y1), List<(int x2, int y2, int cost)>>() {\\n            [(target[0], target[1])] = new List<(int x, int y, int cost)>() { (0, 0, 0) }\\n        };\\n\\n        foreach (var road in specialRoads) {\\n            int x1 = road[0], y1 = road[1], x2 = road[2], y2 = road[3], cost = road[4];\\n            map[(x1, y1)] = map.GetValueOrDefault((x1, y1), new List<(int x2, int y2, int cost)>());\\n            map[(x1, y1)].Add((x2, y2, cost));\\n        }\\n\\n        var dist = new Dictionary<(int x, int y), int>();\\n        dist[(start[0], start[1])] = 0;\\n\\n        var pq = new PriorityQueue<(int curDist, int x, int y), int>();\\n        pq.Enqueue((0, start[0], start[1]), 0);\\n\\n        while (pq.Count > 0) {\\n            var (curDist, x, y) = pq.Dequeue();\\n            // Console.WriteLine(x + \" \" + y + \" \" + curDist);\\n            if (x == target[0] && y == target[1]) {\\n                return curDist;\\n            }\\n\\n            foreach (var (x2, y2, cost) in map.GetValueOrDefault((x, y), new List<(int x2, int y2, int cost)>())) {\\n                int distanceX2Y2 = curDist + cost;\\n                if (distanceX2Y2 < dist.GetValueOrDefault((x2, y2), int.MaxValue)) {\\n                    dist[(x2, y2)] = distanceX2Y2;\\n                    pq.Enqueue((distanceX2Y2, x2, y2), distanceX2Y2);\\n                }\\n            }\\n\\n            foreach ((int x1, int y1) in map.Keys) {\\n                int distanceX1Y1 = curDist + Math.Abs(x - x1) + Math.Abs(y - y1);\\n                // Console.WriteLine(x1 + \" \" + y1 + \" : \" + distanceX1Y1);\\n                if (dist.GetValueOrDefault((x1, y1), int.MaxValue) > distanceX1Y1) {\\n                    dist[(x1, y1)] = distanceX1Y1;\\n                    pq.Enqueue((distanceX1Y1, x1, y1), distanceX1Y1);\\n                }\\n            }\\n            // Console.WriteLine();\\n        }\\n\\n        return Math.Abs(start[0] - target[0]) + Math.Abs(start[1] - target[1]);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nif (x == target[0] && y == target[1]) {\\n    return curDist;\\n}\\n```\n```\\npublic class Solution {\\n    public int MinimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        var map = new Dictionary<(int x1, int y1), List<(int x2, int y2, int cost)>>() {\\n            [(target[0], target[1])] = new List<(int x, int y, int cost)>() { (0, 0, 0) }\\n        };\\n\\n        foreach (var road in specialRoads) {\\n            int x1 = road[0], y1 = road[1], x2 = road[2], y2 = road[3], cost = road[4];\\n            map[(x1, y1)] = map.GetValueOrDefault((x1, y1), new List<(int x2, int y2, int cost)>());\\n            map[(x1, y1)].Add((x2, y2, cost));\\n        }\\n\\n        var dist = new Dictionary<(int x, int y), int>();\\n        dist[(start[0], start[1])] = 0;\\n\\n        var pq = new PriorityQueue<(int curDist, int x, int y), int>();\\n        pq.Enqueue((0, start[0], start[1]), 0);\\n\\n        while (pq.Count > 0) {\\n            var (curDist, x, y) = pq.Dequeue();\\n            // Console.WriteLine(x + \" \" + y + \" \" + curDist);\\n            if (x == target[0] && y == target[1]) {\\n                return curDist;\\n            }\\n\\n            foreach (var (x2, y2, cost) in map.GetValueOrDefault((x, y), new List<(int x2, int y2, int cost)>())) {\\n                int distanceX2Y2 = curDist + cost;\\n                if (distanceX2Y2 < dist.GetValueOrDefault((x2, y2), int.MaxValue)) {\\n                    dist[(x2, y2)] = distanceX2Y2;\\n                    pq.Enqueue((distanceX2Y2, x2, y2), distanceX2Y2);\\n                }\\n            }\\n\\n            foreach ((int x1, int y1) in map.Keys) {\\n                int distanceX1Y1 = curDist + Math.Abs(x - x1) + Math.Abs(y - y1);\\n                // Console.WriteLine(x1 + \" \" + y1 + \" : \" + distanceX1Y1);\\n                if (dist.GetValueOrDefault((x1, y1), int.MaxValue) > distanceX1Y1) {\\n                    dist[(x1, y1)] = distanceX1Y1;\\n                    pq.Enqueue((distanceX1Y1, x1, y1), distanceX1Y1);\\n                }\\n            }\\n            // Console.WriteLine();\\n        }\\n\\n        return Math.Abs(start[0] - target[0]) + Math.Abs(start[1] - target[1]);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473781,
                "title": "dikstra-algo-c",
                "content": "collect all the points then apply standard dikstra algo to find the shortest path\\n\\n```\\n#define INF INT_MAX;\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n\\n        set<vector<int>>     points;\\n        map<vector<int>,int> distance;\\n        map<vector<int>,int> specialDis;\\n         \\n        points.insert(start);   distance[start]=INF;\\n        points.insert(target);  distance[target]=INF;\\n        \\n        \\n        for(int i=0;i<specialRoads.size();++i){\\n            \\n            int x1=specialRoads[i][0];\\n            int y1=specialRoads[i][1];\\n            int x2=specialRoads[i][2];\\n            int y2=specialRoads[i][3];\\n            int dis=specialRoads[i][4];\\n            \\n            points.insert({x1,y1});\\n            points.insert({x2,y2});\\n            \\n            if(specialDis.find({x1,y1,x2,y2})==specialDis.end())             \\n            specialDis[{x1,y1,x2,y2}]=dis;\\n            else\\n            specialDis[{x1,y1,x2,y2}]=min(specialDis[{x1,y1,x2,y2}],dis);\\n                \\n            distance[{x1,y1}]=INF;\\n            distance[{x2,y2}]=INF;       \\n        }\\n        \\n        priority_queue<vector<int>,vector<vector<int>>, greater<vector<int>>> q;\\n        q.push({0,start[0],start[1]});\\n        \\n        while(!q.empty()){\\n              \\n            vector<int> u=q.top(); q.pop();\\n            int x1=u[1];\\n            int y1=u[2];\\n            int curr_dis=u[0];\\n        \\n            if(x1==target[0] && y1==target[1]) return curr_dis;\\n            \\n            for(auto itr=points.begin();itr!=points.end();itr++){\\n                \\n                vector<int> v=(*itr);\\n                if(u==v) continue;\\n                \\n                int x2=v[0];\\n                int y2=v[1];\\n                int cost1=(abs(x2-x1) + abs(y2-y1)); \\n                int cost2=INT_MAX;\\n                \\n                // checking is this any special road\\n                if(specialDis.find({x1,y1,x2,y2})!=specialDis.end()){\\n                   cost2=specialDis[{x1,y1,x2,y2}];\\n                }\\n                \\n                int weight=min(cost1,cost2);\\n                 \\n                if(curr_dis + weight < distance[{x2,y2}] ){ \\n                    distance[{x2,y2}]=curr_dis + weight;\\n                    q.push({distance[{x2,y2}],x2,y2});\\n                }                 \\n            }\\n         }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define INF INT_MAX;\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n\\n        set<vector<int>>     points;\\n        map<vector<int>,int> distance;\\n        map<vector<int>,int> specialDis;\\n         \\n        points.insert(start);   distance[start]=INF;\\n        points.insert(target);  distance[target]=INF;\\n        \\n        \\n        for(int i=0;i<specialRoads.size();++i){\\n            \\n            int x1=specialRoads[i][0];\\n            int y1=specialRoads[i][1];\\n            int x2=specialRoads[i][2];\\n            int y2=specialRoads[i][3];\\n            int dis=specialRoads[i][4];\\n            \\n            points.insert({x1,y1});\\n            points.insert({x2,y2});\\n            \\n            if(specialDis.find({x1,y1,x2,y2})==specialDis.end())             \\n            specialDis[{x1,y1,x2,y2}]=dis;\\n            else\\n            specialDis[{x1,y1,x2,y2}]=min(specialDis[{x1,y1,x2,y2}],dis);\\n                \\n            distance[{x1,y1}]=INF;\\n            distance[{x2,y2}]=INF;       \\n        }\\n        \\n        priority_queue<vector<int>,vector<vector<int>>, greater<vector<int>>> q;\\n        q.push({0,start[0],start[1]});\\n        \\n        while(!q.empty()){\\n              \\n            vector<int> u=q.top(); q.pop();\\n            int x1=u[1];\\n            int y1=u[2];\\n            int curr_dis=u[0];\\n        \\n            if(x1==target[0] && y1==target[1]) return curr_dis;\\n            \\n            for(auto itr=points.begin();itr!=points.end();itr++){\\n                \\n                vector<int> v=(*itr);\\n                if(u==v) continue;\\n                \\n                int x2=v[0];\\n                int y2=v[1];\\n                int cost1=(abs(x2-x1) + abs(y2-y1)); \\n                int cost2=INT_MAX;\\n                \\n                // checking is this any special road\\n                if(specialDis.find({x1,y1,x2,y2})!=specialDis.end()){\\n                   cost2=specialDis[{x1,y1,x2,y2}];\\n                }\\n                \\n                int weight=min(cost1,cost2);\\n                 \\n                if(curr_dis + weight < distance[{x2,y2}] ){ \\n                    distance[{x2,y2}]=curr_dis + weight;\\n                    q.push({distance[{x2,y2}],x2,y2});\\n                }                 \\n            }\\n         }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471732,
                "title": "dijkstra-s-algorithm",
                "content": "# Intuition\\n\\n\\n# Approach\\nDijkstra\\'s algorithm => processing the special roads as weighted edges to the starting node and considering the travel cost from the starting node to the road starting node in the edge weight\\n# Complexity\\n- Time complexity: `O(n^2 log n)`\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nvar minimumCost = function (start, target, specialRoads) {\\n    const N = specialRoads.length;\\n    const dist = new Array(N).fill(Infinity)\\n    const heap = new Heap((a, b) => a[2] < b[2])\\n\\n    let min = Math.abs(start[0] - target[0]) + Math.abs(start[1] - target[1])\\n\\n    heap.add([start[0], start[1], 0]);\\n\\n    while (heap.getSize()) {\\n        const [i, j, cost] = heap.poll();\\n\\n        const costToTarget = cost + Math.abs(i - target[0]) + Math.abs(j - target[1]);\\n                            \\n        min = Math.min(min, costToTarget);\\n\\n        for (let x = 0; x < N; x++) {\\n            const [x1, y1, x2, y2, c] = specialRoads[x];\\n\\n            const costTodist = cost + Math.abs(i - x1) + Math.abs(j - y1) + c;\\n\\n            if (costTodist < dist[x]) {\\n                dist[x] = costTodist\\n                heap.add([x2, y2, costTodist]);\\n            }\\n        }\\n    }\\n    return min\\n};\\n\\n\\n// ====================================\\n// HEAP IMPLEMENTATION\\n// ====================================\\n\\nclass Heap {\\n    constructor(predicate = (a, b) => a < b) {\\n        this.heap = [];\\n        this.predicate = predicate\\n    }\\n\\n\\n    add(value) {\\n        this.heap.push(value)\\n        this.heapifyUp();\\n    }\\n\\n    poll() {\\n        this.swap(0, this.heap.length - 1)\\n        const item = this.heap.pop();\\n        this.heapifyDown()\\n        return item\\n    }\\n\\n    peak() {\\n        return this.heap[0];\\n    }\\n\\n    heapifyDown() {\\n        let idx = 0;\\n        while (this.hasLeftChild(idx)) {\\n            let first = this.getLeftChildIdx(idx);\\n            if (this.hasRightChild(idx) && this.compare(this.getRightChildIdx(idx), first)) {\\n                first = this.getRightChildIdx(idx);\\n            }\\n            if (this.compare(idx, first)) break;\\n            this.swap(idx, first)\\n            idx = first;\\n        }\\n    }\\n\\n\\n    heapifyUp() {\\n        let idx = this.heap.length - 1\\n        while (this.hasParent(idx) && this.compare(idx, this.getParentIdx(idx))) {\\n            this.swap(this.getParentIdx(idx), idx);\\n            idx = this.getParentIdx(idx);\\n        }\\n    }\\n\\n    getSize() {\\n        return this.heap.length;\\n    }\\n\\n\\n    hasLeftChild(idx) {\\n        return this.getLeftChildIdx(idx) < this.heap.length\\n    }\\n    hasRightChild(idx) {\\n        return this.getRightChildIdx(idx) < this.heap.length\\n    }\\n    hasParent(idx) {\\n        return this.getParentIdx(idx) >= 0\\n    }\\n\\n    getLeftChildIdx(idx) {\\n        return idx * 2 + 1\\n    }\\n    getRightChildIdx(idx) {\\n        return idx * 2 + 2\\n    }\\n    getParentIdx(idx) {\\n        return Math.trunc((idx - 1) / 2);\\n    }\\n\\n    getLeftChild(idx) {\\n        return this.heap[getLeftChildIdx(idx)]\\n    }\\n    getRightChild(idx) {\\n        return this.heap[getRightChildIdx(idx)]\\n\\n    }\\n    getParent(idx) {\\n        return this.heap[getParentIdx(idx)]\\n\\n    }\\n\\n    compare(first, second) {\\n        return this.predicate(this.heap[first], this.heap[second])\\n    }\\n\\n    swap(idx1, idx2) {\\n        const temp = this.heap[idx1];\\n        this.heap[idx1] = this.heap[idx2]\\n        this.heap[idx2] = temp\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nvar minimumCost = function (start, target, specialRoads) {\\n    const N = specialRoads.length;\\n    const dist = new Array(N).fill(Infinity)\\n    const heap = new Heap((a, b) => a[2] < b[2])\\n\\n    let min = Math.abs(start[0] - target[0]) + Math.abs(start[1] - target[1])\\n\\n    heap.add([start[0], start[1], 0]);\\n\\n    while (heap.getSize()) {\\n        const [i, j, cost] = heap.poll();\\n\\n        const costToTarget = cost + Math.abs(i - target[0]) + Math.abs(j - target[1]);\\n                            \\n        min = Math.min(min, costToTarget);\\n\\n        for (let x = 0; x < N; x++) {\\n            const [x1, y1, x2, y2, c] = specialRoads[x];\\n\\n            const costTodist = cost + Math.abs(i - x1) + Math.abs(j - y1) + c;\\n\\n            if (costTodist < dist[x]) {\\n                dist[x] = costTodist\\n                heap.add([x2, y2, costTodist]);\\n            }\\n        }\\n    }\\n    return min\\n};\\n\\n\\n// ====================================\\n// HEAP IMPLEMENTATION\\n// ====================================\\n\\nclass Heap {\\n    constructor(predicate = (a, b) => a < b) {\\n        this.heap = [];\\n        this.predicate = predicate\\n    }\\n\\n\\n    add(value) {\\n        this.heap.push(value)\\n        this.heapifyUp();\\n    }\\n\\n    poll() {\\n        this.swap(0, this.heap.length - 1)\\n        const item = this.heap.pop();\\n        this.heapifyDown()\\n        return item\\n    }\\n\\n    peak() {\\n        return this.heap[0];\\n    }\\n\\n    heapifyDown() {\\n        let idx = 0;\\n        while (this.hasLeftChild(idx)) {\\n            let first = this.getLeftChildIdx(idx);\\n            if (this.hasRightChild(idx) && this.compare(this.getRightChildIdx(idx), first)) {\\n                first = this.getRightChildIdx(idx);\\n            }\\n            if (this.compare(idx, first)) break;\\n            this.swap(idx, first)\\n            idx = first;\\n        }\\n    }\\n\\n\\n    heapifyUp() {\\n        let idx = this.heap.length - 1\\n        while (this.hasParent(idx) && this.compare(idx, this.getParentIdx(idx))) {\\n            this.swap(this.getParentIdx(idx), idx);\\n            idx = this.getParentIdx(idx);\\n        }\\n    }\\n\\n    getSize() {\\n        return this.heap.length;\\n    }\\n\\n\\n    hasLeftChild(idx) {\\n        return this.getLeftChildIdx(idx) < this.heap.length\\n    }\\n    hasRightChild(idx) {\\n        return this.getRightChildIdx(idx) < this.heap.length\\n    }\\n    hasParent(idx) {\\n        return this.getParentIdx(idx) >= 0\\n    }\\n\\n    getLeftChildIdx(idx) {\\n        return idx * 2 + 1\\n    }\\n    getRightChildIdx(idx) {\\n        return idx * 2 + 2\\n    }\\n    getParentIdx(idx) {\\n        return Math.trunc((idx - 1) / 2);\\n    }\\n\\n    getLeftChild(idx) {\\n        return this.heap[getLeftChildIdx(idx)]\\n    }\\n    getRightChild(idx) {\\n        return this.heap[getRightChildIdx(idx)]\\n\\n    }\\n    getParent(idx) {\\n        return this.heap[getParentIdx(idx)]\\n\\n    }\\n\\n    compare(first, second) {\\n        return this.predicate(this.heap[first], this.heap[second])\\n    }\\n\\n    swap(idx1, idx2) {\\n        const temp = this.heap[idx1];\\n        this.heap[idx1] = this.heap[idx2]\\n        this.heap[idx2] = temp\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471669,
                "title": "java-easy-to-understand-self-explanatory-code",
                "content": "\\n```\\nclass Solution {\\n    record Point(int x, int y) {}\\n    private int manhattenDistance(Point a, Point b){\\n        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\\n    }\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        Point st = new Point(start[0], start[1]), ed = new Point(target[0], target[1]);\\n        Map<Point, Integer> map = new HashMap<>();\\n        Queue<Point> que = new PriorityQueue<>((a, b) -> Integer.compare(map.get(a), map.get(b)));\\n        map.put(st, 0);\\n        que.offer(st);\\n        int res = manhattenDistance(st, ed);\\n        while(!que.isEmpty()){\\n            Point cur = que.poll();\\n            int curCost = map.get(cur);\\n            res = Math.min(res, curCost + manhattenDistance(cur, ed));\\n            if(cur == ed) return res;\\n            for(int[] road: specialRoads){\\n                Point s = new Point(road[0], road[1]);\\n                Point e = new Point(road[2], road[3]);\\n                int cost = Math.min(road[4], manhattenDistance(s, e)) + manhattenDistance(cur, s) + curCost;\\n                if(cost >= res || cost >= map.getOrDefault(e, Integer.MAX_VALUE)) continue;\\n                map.put(e, cost);\\n                que.offer(e);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    record Point(int x, int y) {}\\n    private int manhattenDistance(Point a, Point b){\\n        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\\n    }\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        Point st = new Point(start[0], start[1]), ed = new Point(target[0], target[1]);\\n        Map<Point, Integer> map = new HashMap<>();\\n        Queue<Point> que = new PriorityQueue<>((a, b) -> Integer.compare(map.get(a), map.get(b)));\\n        map.put(st, 0);\\n        que.offer(st);\\n        int res = manhattenDistance(st, ed);\\n        while(!que.isEmpty()){\\n            Point cur = que.poll();\\n            int curCost = map.get(cur);\\n            res = Math.min(res, curCost + manhattenDistance(cur, ed));\\n            if(cur == ed) return res;\\n            for(int[] road: specialRoads){\\n                Point s = new Point(road[0], road[1]);\\n                Point e = new Point(road[2], road[3]);\\n                int cost = Math.min(road[4], manhattenDistance(s, e)) + manhattenDistance(cur, s) + curCost;\\n                if(cost >= res || cost >= map.getOrDefault(e, Integer.MAX_VALUE)) continue;\\n                map.put(e, cost);\\n                que.offer(e);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471287,
                "title": "c-step-by-step-dijkstra-easy-to-understand-100-fast",
                "content": "# Intuition\\nWe will follow dijkstra algo to solve the problem and mark the (x,y) coordinates as nodes of the graph.\\nAll the nodes are the start point, end point, roads begin end points\\nRoads are edges. \\nWe will connect all the nodes by edges. The wt of edge is\\ncost of special road( if special road present) else manhattan distance\\nTotal nodes in worst case =  2(start,end) + 2*200(roads begin & end);\\nno of edges = 402*402 =  1.6 * 10^5\\n\\nThen simple Dijkstra on the graph with src as start.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nspecial roads will be useful if cost < abs(x1-x2) + abs(y1-y2)\\nelse remove them \\n\\n**We will use map<pair<int,int> , int>  to converge unique Pt(x,y) -> unique(id): i.e. from (x,y) get an id**\\n**reverse_map<int, pair<int,int>>  :: to extract (x,y) from id**  \\nFor indexing our nodes\\nMark start point node 1\\ntarget point node 2 and rest of the points of special roads with unique index \\n    \\n\\n# Complexity\\n- Time complexity:\\n- O(n^2 log(n)) where n = roads.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n^2) for making graph\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void indexing (vector<vector<int>>& specialRoads, map<pair<int,int>,int> &mp1,\\n                    map<int, pair<int,int>> &rev_mp1, int &index)\\n    {\\n        int x1, y1, x2, y2;\\n        for(int i=0; i<specialRoads.size(); i++)\\n        {\\n            x1 = specialRoads[i][0];\\n            y1 = specialRoads[i][1];\\n            x2 = specialRoads[i][2];\\n            y2 = specialRoads[i][3];\\n        \\n            if(mp1.find({x1, y1}) == mp1.end()){\\n                mp1[{x1, y1}] = index;\\n                rev_mp1[index] = {x1, y1};\\n                index++;\\n            }      \\n            if(mp1.find({x2, y2}) == mp1.end())\\n            {\\n                mp1[{x2, y2}] = index;\\n                rev_mp1[index] = {x2, y2};\\n                index++;\\n            }\\n        }\\n    }\\n\\n/*\\n    void printDistance(vector<int> &dist)\\n    {\\n        for(int i=0; i<dist.size(); i++)\\n            cout << \" i:\" << i << \", \"<< dist[i] <<\" :: \";\\n        cout << endl;\\n    }\\n*/    \\n\\n    int minimumCost(vector<int>& start, vector<int>& end, vector<vector<int>>& specialRoads) {\\n\\n        int x1, x2, y1, y2, cost;\\n        // remove unwanted roads with cost > manhattan distance\\n        for(int i=specialRoads.size()-1; i>=0; i--)\\n        {\\n            x1 = specialRoads[i][0];\\n            y1 = specialRoads[i][1];\\n            x2 = specialRoads[i][2];\\n            y2 = specialRoads[i][3];\\n            cost = specialRoads[i][4];\\n            if(cost >= abs(x2-x1) + abs(y2-y1))\\n                specialRoads.erase(specialRoads.begin() + i);\\n        }\\n\\n        //indexing the (x,y) n nodes to ind: 0 1 ... n\\n        x1 = start[0]; x2 = end[0];\\n        y1 = start[1]; y2 = end[1];\\n\\n        if(x1==x2 && y1==y2)\\n            return 0;\\n\\n        map<pair<int,int>, int> mp1;\\n        map<int, pair<int,int>> rev_mp1;\\n        mp1[{x1,y1}] = 0; rev_mp1[0] = {x1, y1};\\n        mp1[{x2,y2}] = 1; rev_mp1[1] = {x2, y2};\\n\\n        int index = 2;\\n        indexing(specialRoads, mp1, rev_mp1, index);\\n    //    cout << endl << \" Total nodes :\" << index << endl;\\n        int n = index;\\n                        // cost, v\\n        vector<vector<pair<int,int>> >graph(n); \\n        // connect all special roads to form graph 0:st 1:target\\n        for(int i=0; i<specialRoads.size(); i++)\\n        {\\n            x1 = specialRoads[i][0];\\n            y1 = specialRoads[i][1];\\n            x2 = specialRoads[i][2];\\n            y2 = specialRoads[i][3];\\n            cost = specialRoads[i][4];\\n            int u = mp1[{x1, y1}], v = mp1[{x2, y2}];\\n            graph[u].push_back({cost, v});\\n           // graph[v].push_back({cost, u});\\n        }\\n\\n        // connect all nodes with each other by weighted edge = manhattan distance\\n        for(int i=0; i<n; i++)\\n        {\\n            x1 = rev_mp1[i].first;\\n            y1 = rev_mp1[i].second;\\n            for(int j = i+1; j<n; j++)\\n            {\\n                x2 = rev_mp1[j].first;\\n                y2 = rev_mp1[j].second;\\n                int val = abs(x1-x2) + abs(y1-y2);\\n                graph[i].push_back({val, j});\\n                graph[j].push_back({val, i});\\n            }\\n        }\\n\\n        // Dijkstra \\n        int src = 0, destination = 1;\\n        // distance[i] : denotes distance from src to i \\n        vector<int> dist(n, INT_MAX);\\n        priority_queue< pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n        pq.push({0, src});\\n        dist[src] = 0;\\n    \\n        while(!pq.empty())\\n        {\\n            int u = pq.top().second;\\n            pq.pop();\\n            \\n            for(int i=0; i<graph[u].size(); i++)\\n            {\\n                pair p2 = graph[u][i];\\n                int v = p2.second, cost = p2.first;\\n                \\n                if(dist[v] > dist[u] + cost)\\n                {\\n                    dist[v] = dist[u] + cost;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n    //        printDistance(dist);\\n        }\\n\\n        return dist[destination];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void indexing (vector<vector<int>>& specialRoads, map<pair<int,int>,int> &mp1,\\n                    map<int, pair<int,int>> &rev_mp1, int &index)\\n    {\\n        int x1, y1, x2, y2;\\n        for(int i=0; i<specialRoads.size(); i++)\\n        {\\n            x1 = specialRoads[i][0];\\n            y1 = specialRoads[i][1];\\n            x2 = specialRoads[i][2];\\n            y2 = specialRoads[i][3];\\n        \\n            if(mp1.find({x1, y1}) == mp1.end()){\\n                mp1[{x1, y1}] = index;\\n                rev_mp1[index] = {x1, y1};\\n                index++;\\n            }      \\n            if(mp1.find({x2, y2}) == mp1.end())\\n            {\\n                mp1[{x2, y2}] = index;\\n                rev_mp1[index] = {x2, y2};\\n                index++;\\n            }\\n        }\\n    }\\n\\n/*\\n    void printDistance(vector<int> &dist)\\n    {\\n        for(int i=0; i<dist.size(); i++)\\n            cout << \" i:\" << i << \", \"<< dist[i] <<\" :: \";\\n        cout << endl;\\n    }\\n*/    \\n\\n    int minimumCost(vector<int>& start, vector<int>& end, vector<vector<int>>& specialRoads) {\\n\\n        int x1, x2, y1, y2, cost;\\n        // remove unwanted roads with cost > manhattan distance\\n        for(int i=specialRoads.size()-1; i>=0; i--)\\n        {\\n            x1 = specialRoads[i][0];\\n            y1 = specialRoads[i][1];\\n            x2 = specialRoads[i][2];\\n            y2 = specialRoads[i][3];\\n            cost = specialRoads[i][4];\\n            if(cost >= abs(x2-x1) + abs(y2-y1))\\n                specialRoads.erase(specialRoads.begin() + i);\\n        }\\n\\n        //indexing the (x,y) n nodes to ind: 0 1 ... n\\n        x1 = start[0]; x2 = end[0];\\n        y1 = start[1]; y2 = end[1];\\n\\n        if(x1==x2 && y1==y2)\\n            return 0;\\n\\n        map<pair<int,int>, int> mp1;\\n        map<int, pair<int,int>> rev_mp1;\\n        mp1[{x1,y1}] = 0; rev_mp1[0] = {x1, y1};\\n        mp1[{x2,y2}] = 1; rev_mp1[1] = {x2, y2};\\n\\n        int index = 2;\\n        indexing(specialRoads, mp1, rev_mp1, index);\\n    //    cout << endl << \" Total nodes :\" << index << endl;\\n        int n = index;\\n                        // cost, v\\n        vector<vector<pair<int,int>> >graph(n); \\n        // connect all special roads to form graph 0:st 1:target\\n        for(int i=0; i<specialRoads.size(); i++)\\n        {\\n            x1 = specialRoads[i][0];\\n            y1 = specialRoads[i][1];\\n            x2 = specialRoads[i][2];\\n            y2 = specialRoads[i][3];\\n            cost = specialRoads[i][4];\\n            int u = mp1[{x1, y1}], v = mp1[{x2, y2}];\\n            graph[u].push_back({cost, v});\\n           // graph[v].push_back({cost, u});\\n        }\\n\\n        // connect all nodes with each other by weighted edge = manhattan distance\\n        for(int i=0; i<n; i++)\\n        {\\n            x1 = rev_mp1[i].first;\\n            y1 = rev_mp1[i].second;\\n            for(int j = i+1; j<n; j++)\\n            {\\n                x2 = rev_mp1[j].first;\\n                y2 = rev_mp1[j].second;\\n                int val = abs(x1-x2) + abs(y1-y2);\\n                graph[i].push_back({val, j});\\n                graph[j].push_back({val, i});\\n            }\\n        }\\n\\n        // Dijkstra \\n        int src = 0, destination = 1;\\n        // distance[i] : denotes distance from src to i \\n        vector<int> dist(n, INT_MAX);\\n        priority_queue< pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n        pq.push({0, src});\\n        dist[src] = 0;\\n    \\n        while(!pq.empty())\\n        {\\n            int u = pq.top().second;\\n            pq.pop();\\n            \\n            for(int i=0; i<graph[u].size(); i++)\\n            {\\n                pair p2 = graph[u][i];\\n                int v = p2.second, cost = p2.first;\\n                \\n                if(dist[v] > dist[u] + cost)\\n                {\\n                    dist[v] = dist[u] + cost;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n    //        printDistance(dist);\\n        }\\n\\n        return dist[destination];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3470247,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        mp = defaultdict(list, {tuple(target) : [(0, 0, 0)]})\\n        for x, y, xx, yy, cost in specialRoads: \\n            mp[x, y].append((xx, yy, cost))\\n        dist = defaultdict(lambda : inf)\\n        dist[tuple(start)] = 0 \\n        pq = [(0, *start)]\\n        while pq: \\n            d, x, y = heappop(pq)\\n            if [x, y] == target: return d \\n            for xx, yy, cost in mp[x, y]: \\n                if d+cost < dist[xx, yy]: \\n                    dist[xx, yy] = d+cost\\n                    heappush(pq, (d+cost, xx, yy))\\n            for x1, y1 in mp: \\n                dd = d + abs(x1-x) + abs(y1-y)\\n                if dd < dist[x1, y1]: \\n                    dist[x1, y1] = dd\\n                    heappush(pq, (dd, x1, y1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        mp = defaultdict(list, {tuple(target) : [(0, 0, 0)]})\\n        for x, y, xx, yy, cost in specialRoads: \\n            mp[x, y].append((xx, yy, cost))\\n        dist = defaultdict(lambda : inf)\\n        dist[tuple(start)] = 0 \\n        pq = [(0, *start)]\\n        while pq: \\n            d, x, y = heappop(pq)\\n            if [x, y] == target: return d \\n            for xx, yy, cost in mp[x, y]: \\n                if d+cost < dist[xx, yy]: \\n                    dist[xx, yy] = d+cost\\n                    heappush(pq, (d+cost, xx, yy))\\n            for x1, y1 in mp: \\n                dd = d + abs(x1-x) + abs(y1-y)\\n                if dd < dist[x1, y1]: \\n                    dist[x1, y1] = dd\\n                    heappush(pq, (dd, x1, y1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469675,
                "title": "kotlin-solution-with-enhanced-readability",
                "content": "# Intuition\\n1. Convert to nodes : start, target, node of edges \\n2. Remove duplicates and sort the nodes \\n3. Use priority queue to get the minimum distance from start to taget\\n\\n# Approach\\n1. Create a list of nodes \\n2. Remove duplicates and sort the nodes \\n3. Add an map that maps node position(x, y) to index in list: Map[(x, y)] = (index in list) \\n4. Add a map that tracks costs: Map[(nodeIdx1, nodeIdx2)] = cost \\n5. Use priority queue to find the minimum distance to target \\n\\n# Complexity\\n- Time complexity:\\nO(N * N)\\n\\n- Space complexity:\\nO(N * N)\\n\\n# Code\\n```\\nimport java.util.*\\nimport kotlin.math.abs\\nimport kotlin.math.cos\\n\\nclass Solution {\\n    fun minimumCost(start: IntArray, target: IntArray, specialRoads: Array<IntArray>): Int {\\n        val nodes = mutableListOf<Pair<Int, Int>>()\\n        nodes.add(Pair(start[0], start[1]))\\n        nodes.add(Pair(target[0], target[1]))\\n        for ((x1, y1, x2, y2, cost) in specialRoads) {\\n            nodes.add(Pair(x1, y1))\\n            nodes.add(Pair(x2, y2))\\n        }\\n\\n        val sortedNodes = nodes.distinct().sortedWith(compareBy({ it.first }, { it.second }))\\n        val indexes = HashMap<Pair<Int, Int>, Int>()\\n        for ((idx, pos) in sortedNodes.withIndex()) {\\n            indexes[pos] = idx\\n        }\\n\\n        val costs = HashMap<Pair<Int, Int>, Int>() // pair(nodeIdx1, nodeIdx2) = cost\\n        for ((x1, y1, x2, y2, cost) in specialRoads) {\\n            val idx1 = indexes[Pair(x1, y1)]!!\\n            val idx2 = indexes[Pair(x2, y2)]!!\\n            val pair = Pair(idx1, idx2)\\n            costs[pair] = minOf(costs[pair] ?: Int.MAX_VALUE, cost)\\n        }\\n\\n        val pq = PriorityQueue<Pair<Int, Int>>(compareBy({ it.first }, { it.second }))\\n        pq.add(Pair(0, 0))\\n        val visited = HashSet<Int>() // nodeIdx\\n\\n        while (pq.isNotEmpty()) {\\n            val (cumulativeDis, nodeIdx) = pq.poll()\\n//            println(\"node: ${sortedNodes[nodeIdx]}, dis: $cumulativeDis\")\\n            if (nodeIdx == sortedNodes.lastIndex) return cumulativeDis\\n\\n            if (visited.contains(nodeIdx)) continue\\n            visited.add(nodeIdx)\\n\\n            for (j in 0 until sortedNodes.size) {\\n                if (visited.contains(j)) continue\\n\\n                val checkPair = Pair(nodeIdx, j)\\n                var dis = getCost(sortedNodes[nodeIdx], sortedNodes[j])\\n                if (costs.containsKey(checkPair)) {\\n//                    println(\"${sortedNodes[nodeIdx]} --> ${sortedNodes[j]}: ${dis}\")\\n                    dis = minOf(dis, costs[checkPair]!!)\\n                }\\n                pq.add(Pair(cumulativeDis + dis, j))\\n            }\\n        }\\n\\n        return -1\\n    }\\n\\n\\n    fun getCost(p1: Pair<Int, Int>, p2: Pair<Int, Int>): Int {\\n        return abs(p1.first - p2.first) + abs(p1.second - p2.second)\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport java.util.*\\nimport kotlin.math.abs\\nimport kotlin.math.cos\\n\\nclass Solution {\\n    fun minimumCost(start: IntArray, target: IntArray, specialRoads: Array<IntArray>): Int {\\n        val nodes = mutableListOf<Pair<Int, Int>>()\\n        nodes.add(Pair(start[0], start[1]))\\n        nodes.add(Pair(target[0], target[1]))\\n        for ((x1, y1, x2, y2, cost) in specialRoads) {\\n            nodes.add(Pair(x1, y1))\\n            nodes.add(Pair(x2, y2))\\n        }\\n\\n        val sortedNodes = nodes.distinct().sortedWith(compareBy({ it.first }, { it.second }))\\n        val indexes = HashMap<Pair<Int, Int>, Int>()\\n        for ((idx, pos) in sortedNodes.withIndex()) {\\n            indexes[pos] = idx\\n        }\\n\\n        val costs = HashMap<Pair<Int, Int>, Int>() // pair(nodeIdx1, nodeIdx2) = cost\\n        for ((x1, y1, x2, y2, cost) in specialRoads) {\\n            val idx1 = indexes[Pair(x1, y1)]!!\\n            val idx2 = indexes[Pair(x2, y2)]!!\\n            val pair = Pair(idx1, idx2)\\n            costs[pair] = minOf(costs[pair] ?: Int.MAX_VALUE, cost)\\n        }\\n\\n        val pq = PriorityQueue<Pair<Int, Int>>(compareBy({ it.first }, { it.second }))\\n        pq.add(Pair(0, 0))\\n        val visited = HashSet<Int>() // nodeIdx\\n\\n        while (pq.isNotEmpty()) {\\n            val (cumulativeDis, nodeIdx) = pq.poll()\\n//            println(\"node: ${sortedNodes[nodeIdx]}, dis: $cumulativeDis\")\\n            if (nodeIdx == sortedNodes.lastIndex) return cumulativeDis\\n\\n            if (visited.contains(nodeIdx)) continue\\n            visited.add(nodeIdx)\\n\\n            for (j in 0 until sortedNodes.size) {\\n                if (visited.contains(j)) continue\\n\\n                val checkPair = Pair(nodeIdx, j)\\n                var dis = getCost(sortedNodes[nodeIdx], sortedNodes[j])\\n                if (costs.containsKey(checkPair)) {\\n//                    println(\"${sortedNodes[nodeIdx]} --> ${sortedNodes[j]}: ${dis}\")\\n                    dis = minOf(dis, costs[checkPair]!!)\\n                }\\n                pq.add(Pair(cumulativeDis + dis, j))\\n            }\\n        }\\n\\n        return -1\\n    }\\n\\n\\n    fun getCost(p1: Pair<Int, Int>, p2: Pair<Int, Int>): Int {\\n        return abs(p1.first - p2.first) + abs(p1.second - p2.second)\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469380,
                "title": "missing-test-case",
                "content": "\\nSince I didn\\'t find the Discussion section, I post my question here.\\n\\nI found the following code can be accepted but cannot pass the test case\\n```\\n[25474,6807]\\n[79990,8721]\\n[[30685,7016,52496,8390,12865],[64755,8203,77992,7465,465],[58580,7494,63156,8591,1915]]\\n```\\n\\nI think the reason is we shouldn\\'t update the dp array direction by direction \\n(i.e. sometimes road[2]->road[0] may depend on road[0]->road[1] or vice versa)\\n\\nLet me know if there is anything missing.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    inline int getDist(int x1, int y1, int x2, int y2){\\n        return (int)(abs(x1-x2) + abs(y1-y2));\\n    }\\n    \\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        // dp[i] keeps the min distance from (specialRoads[i][0], specialRoads[i][1]) to (target[0], target[1]) \\n        vector<int> dp(specialRoads.size(), INT_MAX);\\n        \\n        // Get the default value of dp matrix\\n        for(int i=0; i<dp.size(); ++i){\\n            int origin = getDist(specialRoads[i][0], specialRoads[i][1], target[0], target[1]);\\n            int shortcut = specialRoads[i][4] + getDist(specialRoads[i][2], specialRoads[i][3], target[0], target[1]);\\n            dp[i] = min(origin, shortcut);\\n        }\\n\\n        // Update matrix by specialRoads with a lower index \\n        // i.e. specialRoads[2] is only updated by specialRoads[1] and specialRoads[0], and so on...\\n        for(int i=dp.size()-1; i>=0; --i){\\n            for(int j=dp.size()-1; j>i; --j){\\n                int another = specialRoads[i][4] + getDist(specialRoads[i][2], specialRoads[i][3], specialRoads[j][0], specialRoads[j][1]);\\n                dp[i] = min(dp[i], dp[j]+another);\\n            }\\n        }\\n\\n        // Update matrix by specialRoads with a larger index \\n        // i.e. specialRoads[specialRoads.size()-2] only is only updated by specialRoads[specialRoads.size()-1], and so on...\\n        for(int i=0; i<dp.size(); ++i){\\n            for(int j=0; j<i; ++j){\\n                int another = specialRoads[i][4] + getDist(specialRoads[i][2], specialRoads[i][3], specialRoads[j][0], specialRoads[j][1]);\\n                dp[i] = min(dp[i], dp[j]+another);\\n            }\\n        }\\n        \\n        // Calculate the distance between source to target \\n        // i.e. min( dist(start, (specialRoads[i][0], specialRoads[i][1])) + dp[i] )\\n        int min_cost = getDist(start[0], start[1], target[0], target[1]);\\n        for(int i=0; i<dp.size(); ++i){\\n            min_cost = min(min_cost, \\n                          getDist(start[0], start[1], specialRoads[i][0], specialRoads[i][1]) + dp[i]);\\n        }\\n        return min_cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n[25474,6807]\\n[79990,8721]\\n[[30685,7016,52496,8390,12865],[64755,8203,77992,7465,465],[58580,7494,63156,8591,1915]]\\n```\n```\\nclass Solution {\\nprivate:\\n    inline int getDist(int x1, int y1, int x2, int y2){\\n        return (int)(abs(x1-x2) + abs(y1-y2));\\n    }\\n    \\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        // dp[i] keeps the min distance from (specialRoads[i][0], specialRoads[i][1]) to (target[0], target[1]) \\n        vector<int> dp(specialRoads.size(), INT_MAX);\\n        \\n        // Get the default value of dp matrix\\n        for(int i=0; i<dp.size(); ++i){\\n            int origin = getDist(specialRoads[i][0], specialRoads[i][1], target[0], target[1]);\\n            int shortcut = specialRoads[i][4] + getDist(specialRoads[i][2], specialRoads[i][3], target[0], target[1]);\\n            dp[i] = min(origin, shortcut);\\n        }\\n\\n        // Update matrix by specialRoads with a lower index \\n        // i.e. specialRoads[2] is only updated by specialRoads[1] and specialRoads[0], and so on...\\n        for(int i=dp.size()-1; i>=0; --i){\\n            for(int j=dp.size()-1; j>i; --j){\\n                int another = specialRoads[i][4] + getDist(specialRoads[i][2], specialRoads[i][3], specialRoads[j][0], specialRoads[j][1]);\\n                dp[i] = min(dp[i], dp[j]+another);\\n            }\\n        }\\n\\n        // Update matrix by specialRoads with a larger index \\n        // i.e. specialRoads[specialRoads.size()-2] only is only updated by specialRoads[specialRoads.size()-1], and so on...\\n        for(int i=0; i<dp.size(); ++i){\\n            for(int j=0; j<i; ++j){\\n                int another = specialRoads[i][4] + getDist(specialRoads[i][2], specialRoads[i][3], specialRoads[j][0], specialRoads[j][1]);\\n                dp[i] = min(dp[i], dp[j]+another);\\n            }\\n        }\\n        \\n        // Calculate the distance between source to target \\n        // i.e. min( dist(start, (specialRoads[i][0], specialRoads[i][1])) + dp[i] )\\n        int min_cost = getDist(start[0], start[1], target[0], target[1]);\\n        for(int i=0; i<dp.size(); ++i){\\n            min_cost = min(min_cost, \\n                          getDist(start[0], start[1], specialRoads[i][0], specialRoads[i][1]) + dp[i]);\\n        }\\n        return min_cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468464,
                "title": "can-someone-check-if-this-approach-is-valid-dynamic-programming",
                "content": "# Approach\\nDynamic Programming where the minimum cost from the ending position of each special road is recorded. Initially the \"minimum cost\", or the `dp` array, stores the cost from the ending position to the target normally. Then I loop through the whole thing trying to make optimizations going through the specialRoads. After `specialRoads.length` loops, it should have had the chance, if necessary, to go through every possible combination of specialRoads. Thus now we have the minimum cost. \\n\\nHowever, it looks like everyone else is using Dijkstra\\'s Algorithm, so I am not positive that this code does find the minimum cost every single time (although it does pass every test case).\\n\\nNote I am not asking if this is the most optimized algorithm, because it definitely isn\\'t. I am just asking if it works at all.\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere $n=\\\\text{specialRoads.length}$.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/4de1a97e-77c5-4f8c-b4d7-be24f0edae42_1682828579.2375252.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int[] dp = new int[specialRoads.length]; // the min cost from (x2i, y2i) to destination\\n        \\n        for (int i = 0; i < specialRoads.length; i++) {\\n            dp[i] = cost(target[0], specialRoads[i][2], target[1], specialRoads[i][3]);\\n        }\\n        \\n        for (int loop = 0; loop < specialRoads.length; loop++) {\\n            for (int i = 0; i < specialRoads.length; i++) {\\n                for (int j = 0; j < specialRoads.length; j++) {\\n                    dp[i] = Math.min(\\n                        dp[i], \\n                        cost(specialRoads[i][2], specialRoads[j][0], specialRoads[i][3], specialRoads[j][1]) + specialRoads[j][4] + dp[j]\\n                    );\\n                }\\n            }\\n        }\\n        \\n        int minCost = cost(start[0], target[0], start[1], target[1]);\\n        \\n        for (int i = 0; i < specialRoads.length; i++) {\\n            minCost = Math.min(\\n                minCost,\\n                cost(start[0], specialRoads[i][0], start[1], specialRoads[i][1]) + specialRoads[i][4] + dp[i]\\n            );\\n        }\\n        \\n        return minCost;\\n    }\\n    \\n    private int cost(int x1, int x2, int y1, int y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int[] dp = new int[specialRoads.length]; // the min cost from (x2i, y2i) to destination\\n        \\n        for (int i = 0; i < specialRoads.length; i++) {\\n            dp[i] = cost(target[0], specialRoads[i][2], target[1], specialRoads[i][3]);\\n        }\\n        \\n        for (int loop = 0; loop < specialRoads.length; loop++) {\\n            for (int i = 0; i < specialRoads.length; i++) {\\n                for (int j = 0; j < specialRoads.length; j++) {\\n                    dp[i] = Math.min(\\n                        dp[i], \\n                        cost(specialRoads[i][2], specialRoads[j][0], specialRoads[i][3], specialRoads[j][1]) + specialRoads[j][4] + dp[j]\\n                    );\\n                }\\n            }\\n        }\\n        \\n        int minCost = cost(start[0], target[0], start[1], target[1]);\\n        \\n        for (int i = 0; i < specialRoads.length; i++) {\\n            minCost = Math.min(\\n                minCost,\\n                cost(start[0], specialRoads[i][0], start[1], specialRoads[i][1]) + specialRoads[i][4] + dp[i]\\n            );\\n        }\\n        \\n        return minCost;\\n    }\\n    \\n    private int cost(int x1, int x2, int y1, int y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468460,
                "title": "dp-accepted-but-probably-wrong-add-testcases",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI think my solution is wrong .There may be a test case where my solution will be wrong . \\nI think if you add a test case where simply sorting the special roads based on x coordiates and y coordinates won\\'t work then this solution may get rejected.\\nPlease let me know if i am wrong.\\nSo leetcode, add testcases so that this gets rejected\\uD83E\\uDD72\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<unordered_map<int,unordered_map<int,int>>> mp;\\n    int dp(vector<int>& st, vector<int>& tar, vector<vector<int>>& spr,int cur,int cx,int cy)\\n    {\\n        if(spr.size()==cur){return abs(tar[0]-cx)+abs(tar[1]-cy);}// at the end but did\\'nt reach target\\n        if(mp[cur][cx][cy]){return mp[cur][cx][cy];}\\n        //no use because we can go directly at cheaper cost\\n        if(abs(spr[cur][2]-spr[cur][0])+abs(spr[cur][3]-spr[cur][1])<=spr[cur][4]){return mp[cur][cx][cy]=dp(st,tar,spr,cur+1,cx,cy);}\\n       // either use this special road or leave it\\n        return mp[cur][cx][cy]=min(spr[cur][4]+abs(cx-spr[cur][0])+abs(cy-spr[cur][1])+dp(st,tar,spr,cur+1,spr[cur][2],spr[cur][3]),dp(st,tar,spr,cur+1,cx,cy));\\n    }\\n    int minimumCost(vector<int>& st, vector<int>& tar, vector<vector<int>>& spr) {\\n        sort(spr.begin(),spr.end());// sort based on x coordinates\\n        mp.resize(spr.size());\\n        int x=dp(st,tar,spr,0,st[0],st[1]);\\n        mp.clear();\\n        sort(spr.begin(),spr.end(),[&](vector<int> a,vector<int> b){\\n            return a[1]<b[1];\\n        });//sort based on y coordinates\\n        mp.resize(spr.size());\\n        int y=dp(st,tar,spr,0,st[0],st[1]);\\n        return min(x,y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<unordered_map<int,unordered_map<int,int>>> mp;\\n    int dp(vector<int>& st, vector<int>& tar, vector<vector<int>>& spr,int cur,int cx,int cy)\\n    {\\n        if(spr.size()==cur){return abs(tar[0]-cx)+abs(tar[1]-cy);}// at the end but did\\'nt reach target\\n        if(mp[cur][cx][cy]){return mp[cur][cx][cy];}\\n        //no use because we can go directly at cheaper cost\\n        if(abs(spr[cur][2]-spr[cur][0])+abs(spr[cur][3]-spr[cur][1])<=spr[cur][4]){return mp[cur][cx][cy]=dp(st,tar,spr,cur+1,cx,cy);}\\n       // either use this special road or leave it\\n        return mp[cur][cx][cy]=min(spr[cur][4]+abs(cx-spr[cur][0])+abs(cy-spr[cur][1])+dp(st,tar,spr,cur+1,spr[cur][2],spr[cur][3]),dp(st,tar,spr,cur+1,cx,cy));\\n    }\\n    int minimumCost(vector<int>& st, vector<int>& tar, vector<vector<int>>& spr) {\\n        sort(spr.begin(),spr.end());// sort based on x coordinates\\n        mp.resize(spr.size());\\n        int x=dp(st,tar,spr,0,st[0],st[1]);\\n        mp.clear();\\n        sort(spr.begin(),spr.end(),[&](vector<int> a,vector<int> b){\\n            return a[1]<b[1];\\n        });//sort based on y coordinates\\n        mp.resize(spr.size());\\n        int y=dp(st,tar,spr,0,st[0],st[1]);\\n        return min(x,y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468394,
                "title": "1002-out-of-1040",
                "content": "![image.png](https://assets.leetcode.com/users/images/0e3d78a2-10f0-4184-9eb1-79725ed63a2a_1682827887.6624808.png)\\n\\n# Code\\n```\\nfrom queue import PriorityQueue\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        \\n        # Create the graph\\n        adj = defaultdict(list)\\n        for i, j, x, y, w in specialRoads:\\n            adj[(i,j)].append(((x,y), w))\\n            \\n        for i in range(start[0], target[0]+1):\\n            for j in range(start[1], target[1]+1):\\n                for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                    r, c = i+x, j+y\\n                    if r >= start[0] and r <= target[0] and c >= start[1] and c <= target[1]:\\n                        adj[(i,j)].append(((r, c), abs(i-r)+abs(j-c)))\\n                        \\n        # Run Dijkstra\\'s algorithm\\n        pq = PriorityQueue()\\n        pq.put((0, tuple(start)))\\n        dist = {tuple(start): 0}\\n        \\n        while not pq.empty():\\n            d, u = pq.get()\\n            if u == tuple(target):\\n                return d\\n            for v, w in adj[u]:\\n                alt = d + w\\n                if v not in dist:\\n                    dist[v] = float(\\'inf\\')\\n                if alt < dist[v]:\\n                    dist[v] = alt\\n                    pq.put((alt, v))\\n\\n                    \\n        return -1  # target not reachable\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        \\n        # Create the graph\\n        adj = defaultdict(list)\\n        for i, j, x, y, w in specialRoads:\\n            adj[(i,j)].append(((x,y), w))\\n            \\n        for i in range(start[0], target[0]+1):\\n            for j in range(start[1], target[1]+1):\\n                for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                    r, c = i+x, j+y\\n                    if r >= start[0] and r <= target[0] and c >= start[1] and c <= target[1]:\\n                        adj[(i,j)].append(((r, c), abs(i-r)+abs(j-c)))\\n                        \\n        # Run Dijkstra\\'s algorithm\\n        pq = PriorityQueue()\\n        pq.put((0, tuple(start)))\\n        dist = {tuple(start): 0}\\n        \\n        while not pq.empty():\\n            d, u = pq.get()\\n            if u == tuple(target):\\n                return d\\n            for v, w in adj[u]:\\n                alt = d + w\\n                if v not in dist:\\n                    dist[v] = float(\\'inf\\')\\n                if alt < dist[v]:\\n                    dist[v] = alt\\n                    pq.put((alt, v))\\n\\n                    \\n        return -1  # target not reachable\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077723,
                "title": "clean-and-most-concise-code-dijkastra-algo-beats-90-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public static class Pair\\n    {\\n        int x, y, dist;\\n\\n        public Pair(int x, int y, int dist)\\n        {\\n            this.x = x;\\n            this.y = y;\\n            this.dist = dist;\\n        }\\n\\n        @Override\\n        public String toString()\\n        {\\n            return \"[\" + x + \", \" + y + \", \" + dist + \"]\";\\n        }\\n    }\\n\\n    public static int inf = (int) 1e9;\\n\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) \\n    {\\n        final int n = specialRoads.length;\\n        final int[] dist = new int[n];\\n        final PriorityQueue<Pair> queue = new PriorityQueue<>((a, b) -> a.dist - b.dist);\\n\\n        int targetDist = inf;\\n        Arrays.fill(dist, inf);\\n        queue.add(new Pair(start[0], start[1], 0));\\n\\n        while(!queue.isEmpty())\\n        {\\n            final Pair curPair = queue.remove();\\n\\n            if (curPair.x == target[0] && curPair.y == target[1]) return curPair.dist;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                int tempDist = Math.abs(curPair.x - specialRoads[i][0]) + Math.abs(curPair.y - specialRoads[i][1]) + specialRoads[i][4];\\n\\n                if (curPair.dist + tempDist < dist[i])\\n                {\\n                    dist[i] = curPair.dist + tempDist;\\n\\n                    queue.add(new Pair(specialRoads[i][2], specialRoads[i][3], dist[i]));\\n                }\\n            }\\n\\n            int tempDist = Math.abs(curPair.x - target[0]) + Math.abs(curPair.y - target[1]);\\n\\n            if (curPair.dist + tempDist < targetDist)\\n            {\\n                targetDist = curPair.dist + tempDist;\\n\\n                queue.add(new Pair(target[0], target[1], targetDist));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public static class Pair\\n    {\\n        int x, y, dist;\\n\\n        public Pair(int x, int y, int dist)\\n        {\\n            this.x = x;\\n            this.y = y;\\n            this.dist = dist;\\n        }\\n\\n        @Override\\n        public String toString()\\n        {\\n            return \"[\" + x + \", \" + y + \", \" + dist + \"]\";\\n        }\\n    }\\n\\n    public static int inf = (int) 1e9;\\n\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) \\n    {\\n        final int n = specialRoads.length;\\n        final int[] dist = new int[n];\\n        final PriorityQueue<Pair> queue = new PriorityQueue<>((a, b) -> a.dist - b.dist);\\n\\n        int targetDist = inf;\\n        Arrays.fill(dist, inf);\\n        queue.add(new Pair(start[0], start[1], 0));\\n\\n        while(!queue.isEmpty())\\n        {\\n            final Pair curPair = queue.remove();\\n\\n            if (curPair.x == target[0] && curPair.y == target[1]) return curPair.dist;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                int tempDist = Math.abs(curPair.x - specialRoads[i][0]) + Math.abs(curPair.y - specialRoads[i][1]) + specialRoads[i][4];\\n\\n                if (curPair.dist + tempDist < dist[i])\\n                {\\n                    dist[i] = curPair.dist + tempDist;\\n\\n                    queue.add(new Pair(specialRoads[i][2], specialRoads[i][3], dist[i]));\\n                }\\n            }\\n\\n            int tempDist = Math.abs(curPair.x - target[0]) + Math.abs(curPair.y - target[1]);\\n\\n            if (curPair.dist + tempDist < targetDist)\\n            {\\n                targetDist = curPair.dist + tempDist;\\n\\n                queue.add(new Pair(target[0], target[1], targetDist));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077297,
                "title": "clear-explanation-using-dijkstra",
                "content": "# Intuition\\nShortest Path -> Dijkstra \\n\\n# Approach\\nFilter the special roads to only keep the ones that actually are less expensives than the traditional route.\\nApply Dijkstra considering the following for a given vertex:\\nIf the vertex is the beginning of a shortcut:\\n- Add the shortcut to the queue\\nOtherwise \\n- Add an edge to the beginning of all the shortcuts\\n- Add an edge to the target\\n\\nDue to the greedy nature of the algorithm we can return when we hit the target\\n\\n# Complexity\\n- Time complexity:\\n$$O(VlogV +ElgV)$$\\n\\nV corresponds to the number 2 * the number of elements in the filtered roads (each road is two vertices)\\nE is the number of edges, there are up to two for vertex (one to the target, one to the next shortcut)\\n\\n- Space complexity:\\n$$O(V)$$ \\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        minHeap = [(0, start[0], start[1])]\\n        visited = set()\\n        filteredRoads = []\\n        for road in specialRoads:\\n            startx, starty, endx, endy, cost = road\\n            if abs(endx - startx) + abs(endy - starty) > cost:\\n                filteredRoads.append(road)\\n        while len(minHeap) > 0:\\n            source_cost, source_startx, source_starty = heappop(minHeap)\\n            if source_startx == target[0] and source_starty == target[1]:\\n                return source_cost\\n            if (source_startx, source_starty) in visited:\\n                continue\\n            \\n            visited.add((source_startx, source_starty))\\n\\n            for road in filteredRoads:\\n                startx, starty, endx, endy, cost = road\\n                if source_startx == startx and source_starty == starty:\\n                    heappush(minHeap, (source_cost + cost, endx, endy))\\n                    continue\\n                else:\\n                    distance = abs(startx - source_startx) + abs(starty - source_starty) + source_cost\\n                    heappush(minHeap, (distance, startx, starty))\\n            distance_to_target = abs(target[0] - source_startx) + abs(target[1] - source_starty) + source_cost\\n            heappush(minHeap, (distance_to_target, target[0], target[1]))\\n                \\n\\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        minHeap = [(0, start[0], start[1])]\\n        visited = set()\\n        filteredRoads = []\\n        for road in specialRoads:\\n            startx, starty, endx, endy, cost = road\\n            if abs(endx - startx) + abs(endy - starty) > cost:\\n                filteredRoads.append(road)\\n        while len(minHeap) > 0:\\n            source_cost, source_startx, source_starty = heappop(minHeap)\\n            if source_startx == target[0] and source_starty == target[1]:\\n                return source_cost\\n            if (source_startx, source_starty) in visited:\\n                continue\\n            \\n            visited.add((source_startx, source_starty))\\n\\n            for road in filteredRoads:\\n                startx, starty, endx, endy, cost = road\\n                if source_startx == startx and source_starty == starty:\\n                    heappush(minHeap, (source_cost + cost, endx, endy))\\n                    continue\\n                else:\\n                    distance = abs(startx - source_startx) + abs(starty - source_starty) + source_cost\\n                    heappush(minHeap, (distance, startx, starty))\\n            distance_to_target = abs(target[0] - source_startx) + abs(target[1] - source_starty) + source_cost\\n            heappush(minHeap, (distance_to_target, target[0], target[1]))\\n                \\n\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069665,
                "title": "using-dijstra-s-dry-run",
                "content": "# Dry Run\\n\\n![image.png](https://assets.leetcode.com/users/images/e7d8f032-6c12-40e4-a4c8-45fa702216d4_1695232904.1437755.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/0805023e-7349-4a5e-9c18-8cc204ae021c_1695232938.197809.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/2adba8b7-38c4-45dc-b0df-dfc4ea9a22f4_1695232958.9601674.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/8b6d721b-9dca-45d9-a4d2-e74884f0a6d4_1695232981.6489341.png)\\n\\n# Code\\n```\\nclass Solution {\\n    using ipii = pair<int, pair<int, int>>;\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n\\n        map<pair<int, int>, int> spr; //    storing min distances\\n        spr[{start[0], start[1]}] = 0; //   src node\\n        vector<vector<int>> roads; //   storing only valid specialRoads\\n        for(auto i : specialRoads) {\\n            int a = i[0], b = i[1], c = i[2], d = i[3], cost = i[4];\\n\\n            if(cost < abs(a - c) + abs(b - d)) { //If valid then only it counts\\n                roads.push_back({a, b, c, d, cost});\\n                spr[{c, d}] = abs(c - start[0]) + abs(d - start[1]);\\n            }\\n        }\\n        priority_queue<ipii, vector<ipii>, greater<ipii>> pq; \\n        //  ipii defined above\\n\\n        pq.push({0, {start[0], start[1]}}); //Src node pushed\\n\\n        while(!pq.empty()) {\\n            auto curr = pq.top(); pq.pop();\\n            int dist = curr.first, x = curr.second.first, y = curr.second.second;\\n\\n            for(auto &i : roads) {\\n                int a = i[0], b = i[1], c = i[2], d = i[3], cost = i[4];\\n                //  If the already present distance is larger then update\\n                if(spr[{c, d}] > dist + abs(a - x) + abs(b - y) + cost) {\\n                    spr[{c, d}] = dist + abs(a - x) + abs(b - y) + cost;\\n                    pq.push({spr[{c, d}], {c, d}});\\n                }\\n            }\\n        }\\n\\n        int tx = target[0], ty = target[1];\\n        int ans = abs(tx - start[0]) + abs(ty - start[1]);\\n\\n        //  Calculation of the min distance (this works because we have the min distances till {i[2], i[3]} )\\n        // and we just need to find min distance from that\\n        for(auto &i : roads) {\\n            int c1 = abs(tx - i[2]), d1 = abs(ty - i[3]);\\n            ans = min(ans, c1 + d1 + spr[{i[2], i[3]}]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    using ipii = pair<int, pair<int, int>>;\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n\\n        map<pair<int, int>, int> spr; //    storing min distances\\n        spr[{start[0], start[1]}] = 0; //   src node\\n        vector<vector<int>> roads; //   storing only valid specialRoads\\n        for(auto i : specialRoads) {\\n            int a = i[0], b = i[1], c = i[2], d = i[3], cost = i[4];\\n\\n            if(cost < abs(a - c) + abs(b - d)) { //If valid then only it counts\\n                roads.push_back({a, b, c, d, cost});\\n                spr[{c, d}] = abs(c - start[0]) + abs(d - start[1]);\\n            }\\n        }\\n        priority_queue<ipii, vector<ipii>, greater<ipii>> pq; \\n        //  ipii defined above\\n\\n        pq.push({0, {start[0], start[1]}}); //Src node pushed\\n\\n        while(!pq.empty()) {\\n            auto curr = pq.top(); pq.pop();\\n            int dist = curr.first, x = curr.second.first, y = curr.second.second;\\n\\n            for(auto &i : roads) {\\n                int a = i[0], b = i[1], c = i[2], d = i[3], cost = i[4];\\n                //  If the already present distance is larger then update\\n                if(spr[{c, d}] > dist + abs(a - x) + abs(b - y) + cost) {\\n                    spr[{c, d}] = dist + abs(a - x) + abs(b - y) + cost;\\n                    pq.push({spr[{c, d}], {c, d}});\\n                }\\n            }\\n        }\\n\\n        int tx = target[0], ty = target[1];\\n        int ans = abs(tx - start[0]) + abs(ty - start[1]);\\n\\n        //  Calculation of the min distance (this works because we have the min distances till {i[2], i[3]} )\\n        // and we just need to find min distance from that\\n        for(auto &i : roads) {\\n            int c1 = abs(tx - i[2]), d1 = abs(ty - i[3]);\\n            ans = min(ans, c1 + d1 + spr[{i[2], i[3]}]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051335,
                "title": "c-simple-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Define a min-heap priority queue to store pairs of distance and index\\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T>>;\\nclass Solution {\\n    public:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        const int INF = 1e9+10;\\n        int n = specialRoads.size();\\n        vector<int> d(n, INF);\\n        min_pq<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++) {\\n            d[i] = abs(start[0] - specialRoads[i][0]) + abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];\\n            pq.push({d[i], i});\\n        }\\n        int ans = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n        while (pq.size()) {\\n            auto [d_c, c] = pq.top(); pq.pop();\\n            if (d_c != d[c]) continue;\\n            ans = min(ans, d_c + abs(target[0] - specialRoads[c][2]) + abs(target[1] - specialRoads[c][3]));\\n            for (int nxt = 0; nxt < n; nxt++) {\\n                int w = abs(specialRoads[c][2] - specialRoads[nxt][0]) + abs(specialRoads[c][3] - specialRoads[nxt][1]) + specialRoads[nxt][4];\\n                if (d_c + w < d[nxt]) {\\n                    d[nxt] = d_c + w;\\n                    pq.push({d[nxt], nxt});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Define a min-heap priority queue to store pairs of distance and index\\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T>>;\\nclass Solution {\\n    public:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        const int INF = 1e9+10;\\n        int n = specialRoads.size();\\n        vector<int> d(n, INF);\\n        min_pq<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++) {\\n            d[i] = abs(start[0] - specialRoads[i][0]) + abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];\\n            pq.push({d[i], i});\\n        }\\n        int ans = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n        while (pq.size()) {\\n            auto [d_c, c] = pq.top(); pq.pop();\\n            if (d_c != d[c]) continue;\\n            ans = min(ans, d_c + abs(target[0] - specialRoads[c][2]) + abs(target[1] - specialRoads[c][3]));\\n            for (int nxt = 0; nxt < n; nxt++) {\\n                int w = abs(specialRoads[c][2] - specialRoads[nxt][0]) + abs(specialRoads[c][3] - specialRoads[nxt][1]) + specialRoads[nxt][4];\\n                if (d_c + w < d[nxt]) {\\n                    d[nxt] = d_c + w;\\n                    pq.push({d[nxt], nxt});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034787,
                "title": "c-dijkstras-solution-commented-easy-to-undrestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void create_adj(map<vector<int>, set<vector<int>>> &adj, vector<vector<int>> &sr_starts, vector<vector<int>> &sr_ends,\\n                    vector<int> &sr_dist, vector<int>& start, vector<int>& target)\\n    {\\n        // start-> target & special road starts\\n        vector<int> x = target;\\n        x.push_back(abs(start[0]-target[0])+abs(start[1]-target[1]));\\n        adj[start].insert(x);\\n        for(int i = 0 ; i < sr_starts.size() ; i++)\\n        {\\n            vector<int> t = sr_starts[i];\\n            t.push_back(abs(start[0]-sr_starts[i][0]) + abs(start[1]-sr_starts[i][1]));\\n            adj[start].insert(t);\\n        }\\n\\n        //special road starts-> special road ends\\n\\n        for(int i = 0 ; i < sr_starts.size() ; i++)\\n        {\\n            vector<int> t = sr_ends[i];\\n            t.push_back(sr_dist[i]);\\n            adj[sr_starts[i]].insert(t);\\n        }\\n\\n        // special road ends -> special road starts & target\\n\\n        for(int i = 0 ; i < sr_ends.size() ; i++)\\n        {\\n            vector<int> t = target;\\n            t.push_back(abs(target[0]-sr_ends[i][0]) + abs(target[1]-sr_ends[i][1]));\\n            adj[sr_ends[i]].insert(t);\\n\\n            for(int j = 0 ; j < sr_starts.size() ; j++)\\n            {\\n                vector<int> x = sr_starts[j];\\n                x.push_back(abs(sr_starts[j][0]-sr_ends[i][0]) + abs(sr_starts[j][1]-sr_ends[i][1]));\\n                adj[sr_ends[i]].insert(x);\\n            }\\n        }        \\n\\n    }\\n\\n\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        vector<vector<int>> sr_starts;\\n        vector<vector<int>> sr_ends;\\n        vector<int> sr_dist;\\n\\n// Adding only effective special roads to lists. (ones which gives better path than manhattan)\\n        for(int i = 0 ; i < sr.size() ; i++)\\n        {\\n            if(abs(sr[i][0]-sr[i][2]) + abs(sr[i][1]-sr[i][3]) > sr[i][4])\\n            {\\n                sr_starts.push_back({sr[i][0], sr[i][1]});\\n                sr_ends.push_back({sr[i][2], sr[i][3]});\\n                sr_dist.push_back(sr[i][4]);\\n            }\\n        }\\n\\n        map<vector<int>, set<vector<int>>> adj;\\n        create_adj(adj, sr_starts, sr_ends, sr_dist, start, target); // creating adjacency list\\n\\n\\n// applying normal Dijkstras\\n        map<vector<int>, int> dist;\\n        dist[start] = 0;\\n        dist[target] = INT_MAX;\\n        for(int i = 0 ; i < sr_starts.size() ; i++)\\n        {\\n            dist[sr_starts[i]] = INT_MAX;\\n            dist[sr_ends[i]] = INT_MAX;\\n        }\\n\\n        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<pair<int, vector<int>>>> pq;\\n        pq.push({0, start});\\n\\n        while(!pq.empty())\\n        {\\n            pair<int, vector<int>> p = pq.top();\\n            int d = p.first;\\n            vector<int> node = p.second;\\n            pq.pop();\\n\\n            for(auto it: adj[node])\\n            {\\n                if(d + it[2] < dist[{it[0], it[1]}])\\n                {\\n                    pq.push({d + it[2], {it[0], it[1]}});\\n                    dist[{it[0], it[1]}] = d + it[2];\\n                }\\n            }\\n        }\\n        return dist[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void create_adj(map<vector<int>, set<vector<int>>> &adj, vector<vector<int>> &sr_starts, vector<vector<int>> &sr_ends,\\n                    vector<int> &sr_dist, vector<int>& start, vector<int>& target)\\n    {\\n        // start-> target & special road starts\\n        vector<int> x = target;\\n        x.push_back(abs(start[0]-target[0])+abs(start[1]-target[1]));\\n        adj[start].insert(x);\\n        for(int i = 0 ; i < sr_starts.size() ; i++)\\n        {\\n            vector<int> t = sr_starts[i];\\n            t.push_back(abs(start[0]-sr_starts[i][0]) + abs(start[1]-sr_starts[i][1]));\\n            adj[start].insert(t);\\n        }\\n\\n        //special road starts-> special road ends\\n\\n        for(int i = 0 ; i < sr_starts.size() ; i++)\\n        {\\n            vector<int> t = sr_ends[i];\\n            t.push_back(sr_dist[i]);\\n            adj[sr_starts[i]].insert(t);\\n        }\\n\\n        // special road ends -> special road starts & target\\n\\n        for(int i = 0 ; i < sr_ends.size() ; i++)\\n        {\\n            vector<int> t = target;\\n            t.push_back(abs(target[0]-sr_ends[i][0]) + abs(target[1]-sr_ends[i][1]));\\n            adj[sr_ends[i]].insert(t);\\n\\n            for(int j = 0 ; j < sr_starts.size() ; j++)\\n            {\\n                vector<int> x = sr_starts[j];\\n                x.push_back(abs(sr_starts[j][0]-sr_ends[i][0]) + abs(sr_starts[j][1]-sr_ends[i][1]));\\n                adj[sr_ends[i]].insert(x);\\n            }\\n        }        \\n\\n    }\\n\\n\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        vector<vector<int>> sr_starts;\\n        vector<vector<int>> sr_ends;\\n        vector<int> sr_dist;\\n\\n// Adding only effective special roads to lists. (ones which gives better path than manhattan)\\n        for(int i = 0 ; i < sr.size() ; i++)\\n        {\\n            if(abs(sr[i][0]-sr[i][2]) + abs(sr[i][1]-sr[i][3]) > sr[i][4])\\n            {\\n                sr_starts.push_back({sr[i][0], sr[i][1]});\\n                sr_ends.push_back({sr[i][2], sr[i][3]});\\n                sr_dist.push_back(sr[i][4]);\\n            }\\n        }\\n\\n        map<vector<int>, set<vector<int>>> adj;\\n        create_adj(adj, sr_starts, sr_ends, sr_dist, start, target); // creating adjacency list\\n\\n\\n// applying normal Dijkstras\\n        map<vector<int>, int> dist;\\n        dist[start] = 0;\\n        dist[target] = INT_MAX;\\n        for(int i = 0 ; i < sr_starts.size() ; i++)\\n        {\\n            dist[sr_starts[i]] = INT_MAX;\\n            dist[sr_ends[i]] = INT_MAX;\\n        }\\n\\n        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<pair<int, vector<int>>>> pq;\\n        pq.push({0, start});\\n\\n        while(!pq.empty())\\n        {\\n            pair<int, vector<int>> p = pq.top();\\n            int d = p.first;\\n            vector<int> node = p.second;\\n            pq.pop();\\n\\n            for(auto it: adj[node])\\n            {\\n                if(d + it[2] < dist[{it[0], it[1]}])\\n                {\\n                    pq.push({d + it[2], {it[0], it[1]}});\\n                    dist[{it[0], it[1]}] = d + it[2];\\n                }\\n            }\\n        }\\n        return dist[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029136,
                "title": "python-dijkstra-s-algorithm-finding-the-shortest-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can image there are paths between the start, tartget, and the ends of each special road. Then the problem becomes to find the shortest path inside this connected graph. To solve this question, we can use dijkstra\\'s algorithm intuitively.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        specials = collections.defaultdict(list)\\n        for x1, y1, x2, y2, dist in specialRoads:\\n            specials[(x1, y1)].append([x2, y2, dist])\\n        dist_dic = collections.defaultdict(int)\\n        dist_dic[(start[0], start[1])] = 0\\n        heap = [[0, start[0], start[1]]]\\n        heapq.heapify(heap)\\n        while heap:\\n            current_dist, x, y = heapq.heappop(heap)\\n            if x == target[0] and y == target[1]:\\n                return current_dist\\n            # move to special road\\'s beginning\\n            for start_x, start_y in specials.keys():\\n                cost = abs(start_x - x) + abs(start_y - y)\\n                if (start_x, start_y) not in dist_dic or cost + current_dist < dist_dic[(start_x, start_y)]:\\n                    dist_dic[(start_x, start_y)] = cost + current_dist\\n                    heapq.heappush(heap, [cost + current_dist, start_x, start_y])\\n            # move in special roads\\n            for [end_x, end_y, cost] in specials[(x, y)]:\\n                cost = min(cost, abs(x - end_x) + abs(y - end_y))\\n                if (end_x, end_y) not in dist_dic or current_dist + cost < dist_dic[(end_x, end_y)]:\\n                    dist_dic[(end_x, end_y)] = current_dist + cost\\n                    heapq.heappush(heap, [current_dist + cost, end_x, end_y])\\n            # move to target directly\\n            if (target[0], target[1]) not in dist_dic or dist_dic[(target[0], target[1])] > current_dist + abs(x - target[0]) + abs(y - target[1]):\\n                dist_dic[(target[0], target[1])] = current_dist + abs(x - target[0]) + abs(y - target[1])\\n                heapq.heappush(heap, [current_dist + abs(x - target[0]) + abs(y - target[1]), target[0], target[1]])\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        specials = collections.defaultdict(list)\\n        for x1, y1, x2, y2, dist in specialRoads:\\n            specials[(x1, y1)].append([x2, y2, dist])\\n        dist_dic = collections.defaultdict(int)\\n        dist_dic[(start[0], start[1])] = 0\\n        heap = [[0, start[0], start[1]]]\\n        heapq.heapify(heap)\\n        while heap:\\n            current_dist, x, y = heapq.heappop(heap)\\n            if x == target[0] and y == target[1]:\\n                return current_dist\\n            # move to special road\\'s beginning\\n            for start_x, start_y in specials.keys():\\n                cost = abs(start_x - x) + abs(start_y - y)\\n                if (start_x, start_y) not in dist_dic or cost + current_dist < dist_dic[(start_x, start_y)]:\\n                    dist_dic[(start_x, start_y)] = cost + current_dist\\n                    heapq.heappush(heap, [cost + current_dist, start_x, start_y])\\n            # move in special roads\\n            for [end_x, end_y, cost] in specials[(x, y)]:\\n                cost = min(cost, abs(x - end_x) + abs(y - end_y))\\n                if (end_x, end_y) not in dist_dic or current_dist + cost < dist_dic[(end_x, end_y)]:\\n                    dist_dic[(end_x, end_y)] = current_dist + cost\\n                    heapq.heappush(heap, [current_dist + cost, end_x, end_y])\\n            # move to target directly\\n            if (target[0], target[1]) not in dist_dic or dist_dic[(target[0], target[1])] > current_dist + abs(x - target[0]) + abs(y - target[1]):\\n                dist_dic[(target[0], target[1])] = current_dist + abs(x - target[0]) + abs(y - target[1])\\n                heapq.heappush(heap, [current_dist + abs(x - target[0]) + abs(y - target[1]), target[0], target[1]])\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017833,
                "title": "c-priority-queue-dijkstra-dp-with-comments-easy-understanding-intuition",
                "content": "Intuition ->   We treat the special roads as nodes in  a graph and we are here performing minimum cost finding function ofr each node i.e. each special road\\nUsing prioriy_queue firstly we push each specialRoads manhattan distance and then queue will help in maintaining the shortest path to target on top \\nThen  We will like usual iterate all {cost, node} pair and update every speciaRoads\\'s dp value where dp[i] = min cost required to  reach target coordinates from where the special Road ends\\n\\nNow while we have a top  entry of queue we will try to update all special Roads links to current Node and push their respective cost to reach target using current Special Road help\\n\\nAfter all node cost updation we will have in dp all specialRoads cost req. to reach target\\nWE utilise and find our min cost using \\n1-  manhattan distance from start to ith specialRoad + \\n2 - specialRoad\\'s cost (i.e. specialRoads[i][4])+ \\n3- dp[i] (i.e.cost to reach target from current SpecialROad)\\n\\n\\n```\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        \\n        int sx = start[0];\\n        int sy =start[1];\\n        int tx = target[0];\\n        int ty = target[1];\\n        \\n        //now for structures we will use specialRoads  array and priority queue to push the manhattan distance of target coordinates \\n        //from every specialroads endpoint in order to keep closest ones at top in minHeap\\n        \\n        priority_queue< pair<int,int> , vector<pair<int,int>> ,greater<pair<int,int>>>pq;\\n       \\n        int n = specialRoads.size();\\n        //for every especialroad i.e. ith road we push its corrdinated distance from target and cost requierd\\n        for(int i =0 ; i<n;i++){\\n            //{manhttan distance, ith specialRoad taken}\\n            pq.emplace(  abs(tx- specialRoads[i][2]) + abs(ty - specialRoads[i][3]), i ); \\n        }\\n         \\n        // From the end of each special road, the minimum cost path to the target is to either go directly, or via another road that has a lower dp value, i.e. has been expanded before.\\n        \\n        // It pops the road with the smallest distance f/rom the priority queue and updates its cost in the dp vector.\\n        \\n        vector<int>dp(n,INT_MAX);\\n        \\n        while(!pq.empty()){\\n            //take evey special road and update its cost to reach target\\n            // or search for other roads that might lower its cost to reach target and those in pq so we can consider them too\\n            int cost = pq.top().first;\\n            int i = pq.top().second;//or i road\\n            \\n            pq.pop();\\n            //use dp to store its road reaching end target cost\\n            if(dp[i]!=INT_MAX) continue;\\n            dp[i] = min(dp[i],cost);\\n            \\n            //iterate all roads and update this road\\'s connection cost to others and since being pushed to priority queue it will update dp[road] value only if its lower\\n            \\n             for(int j = 0;j <n;j++){ \\n                  \\n                 if(j!= i){\\n                     //cost of connecting j\\'s end to i\\'s road;s start\\n                    pq.emplace(cost+ specialRoads[i][4] + abs(specialRoads[j][2] - specialRoads[i][0] )+ abs(specialRoads[j][3] - specialRoads[i][1]) ,j );  \\n                 }\\n             }\\n                \\n        }\\n        \\n        //now consider taking direct path\\n        int res = abs(sx - tx) + abs(sy - ty);\\n        \\n        for(int i = 0; i<n;i++){\\n            //compare with every pecial roads distance frmo start + its cost of path + distance to reach target i.e. dp[i]\\n                res = min(res, abs(sx-specialRoads[i][0] )+ abs(sy - specialRoads[i][1]) + specialRoads[i][4] + dp[i] );\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "Intuition ->   We treat the special roads as nodes in  a graph and we are here performing minimum cost finding function ofr each node i.e. each special road\\nUsing prioriy_queue firstly we push each specialRoads manhattan distance and then queue will help in maintaining the shortest path to target on top \\nThen  We will like usual iterate all {cost, node} pair and update every speciaRoads\\'s dp value where dp[i] = min cost required to  reach target coordinates from where the special Road ends\\n\\nNow while we have a top  entry of queue we will try to update all special Roads links to current Node and push their respective cost to reach target using current Special Road help\\n\\nAfter all node cost updation we will have in dp all specialRoads cost req. to reach target\\nWE utilise and find our min cost using \\n1-  manhattan distance from start to ith specialRoad + \\n2 - specialRoad\\'s cost (i.e. specialRoads[i][4])+ \\n3- dp[i] (i.e.cost to reach target from current SpecialROad)\\n\\n\\n```\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        \\n        int sx = start[0];\\n        int sy =start[1];\\n        int tx = target[0];\\n        int ty = target[1];\\n        \\n        //now for structures we will use specialRoads  array and priority queue to push the manhattan distance of target coordinates \\n        //from every specialroads endpoint in order to keep closest ones at top in minHeap\\n        \\n        priority_queue< pair<int,int> , vector<pair<int,int>> ,greater<pair<int,int>>>pq;\\n       \\n        int n = specialRoads.size();\\n        //for every especialroad i.e. ith road we push its corrdinated distance from target and cost requierd\\n        for(int i =0 ; i<n;i++){\\n            //{manhttan distance, ith specialRoad taken}\\n            pq.emplace(  abs(tx- specialRoads[i][2]) + abs(ty - specialRoads[i][3]), i ); \\n        }\\n         \\n        // From the end of each special road, the minimum cost path to the target is to either go directly, or via another road that has a lower dp value, i.e. has been expanded before.\\n        \\n        // It pops the road with the smallest distance f/rom the priority queue and updates its cost in the dp vector.\\n        \\n        vector<int>dp(n,INT_MAX);\\n        \\n        while(!pq.empty()){\\n            //take evey special road and update its cost to reach target\\n            // or search for other roads that might lower its cost to reach target and those in pq so we can consider them too\\n            int cost = pq.top().first;\\n            int i = pq.top().second;//or i road\\n            \\n            pq.pop();\\n            //use dp to store its road reaching end target cost\\n            if(dp[i]!=INT_MAX) continue;\\n            dp[i] = min(dp[i],cost);\\n            \\n            //iterate all roads and update this road\\'s connection cost to others and since being pushed to priority queue it will update dp[road] value only if its lower\\n            \\n             for(int j = 0;j <n;j++){ \\n                  \\n                 if(j!= i){\\n                     //cost of connecting j\\'s end to i\\'s road;s start\\n                    pq.emplace(cost+ specialRoads[i][4] + abs(specialRoads[j][2] - specialRoads[i][0] )+ abs(specialRoads[j][3] - specialRoads[i][1]) ,j );  \\n                 }\\n             }\\n                \\n        }\\n        \\n        //now consider taking direct path\\n        int res = abs(sx - tx) + abs(sy - ty);\\n        \\n        for(int i = 0; i<n;i++){\\n            //compare with every pecial roads distance frmo start + its cost of path + distance to reach target i.e. dp[i]\\n                res = min(res, abs(sx-specialRoads[i][0] )+ abs(sy - specialRoads[i][1]) + specialRoads[i][4] + dp[i] );\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3930240,
                "title": "c-simple-dijkstra-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads)\\n    {\\n        int ans = abs(target[1]-start[1])+abs(target[0]-start[0]);\\n        vector<vector<int>> req;\\n        for(vector<int>&sr: specialRoads)\\n        {\\n            if(abs(sr[3]-sr[1])+abs(sr[2]-sr[0])>sr[4]){req.push_back(sr);}\\n        }\\n        int m = req.size();\\n        if(m==0){return ans;}\\n        sort(req.begin(), req.end());\\n        vector<int> dis(m);\\n        for(int i=0;i<m;i++){dis[i]=abs(req[i][0]-start[0])+abs(req[i][1]-start[1]);}\\n        int a1 = dis[0];int a2 = 0;\\n        for(int i=1;i<m;i++){if(dis[i]<a1){a1=dis[i];a2=i;}}\\n        vector<bool> comp(m, false);\\n        queue<int> q;\\n        q.push(a2);\\n        while(q.empty()==false)\\n        {\\n            int b = q.front();\\n            q.pop();\\n            comp[b]=true;\\n            int b1 = INT_MAX;int b2 = -1;\\n            for(int i=0;i<m;i++)\\n            {\\n                if(comp[i]==false)\\n                {\\n                    int c = dis[b]+req[b][4]+abs(req[i][0]-req[b][2])+abs(req[i][1]-req[b][3]);\\n                    if(dis[i]>c)\\n                    {\\n                        dis[i]=c;\\n                    }\\n                    if(dis[i]<b1){b1=dis[i];b2=i;}\\n                }\\n            }\\n            if(b2!=-1){q.push(b2);}\\n        }\\n\\n        vector<int> dit(m);\\n        for(int i=0;i<m;i++){dit[i]=abs(req[i][2]-target[0])+abs(req[i][3]-target[1]);}\\n        int a3 = dit[0];int a4 = 0;\\n        for(int i=1;i<m;i++){if(dit[i]<a3){a3=dit[i];a4=i;}}\\n        vector<bool> comq(m, false);\\n        queue<int> qt;\\n        qt.push(a4);\\n        while(qt.empty()==false)\\n        {\\n            int b = qt.front();\\n            qt.pop();\\n            comq[b]=true;\\n            int b1 = INT_MAX;int b2 = -1;\\n            for(int i=0;i<m;i++)\\n            {\\n                if(comq[i]==false)\\n                {\\n                    int c = dit[b]+req[b][4]+abs(req[i][2]-req[b][0])+abs(req[i][3]-req[b][1]);\\n                    if(dit[i]>c)\\n                    {\\n                        dit[i]=c;\\n                    }\\n                    if(dit[i]<b1){b1=dis[i];b2=i;}\\n                }\\n            }\\n            if(b2!=-1){qt.push(b2);}\\n        }\\n        \\n        for(int i=0;i<m;i++){ans=min(ans, dis[i]+dit[i]+req[i][4]);}\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads)\\n    {\\n        int ans = abs(target[1]-start[1])+abs(target[0]-start[0]);\\n        vector<vector<int>> req;\\n        for(vector<int>&sr: specialRoads)\\n        {\\n            if(abs(sr[3]-sr[1])+abs(sr[2]-sr[0])>sr[4]){req.push_back(sr);}\\n        }\\n        int m = req.size();\\n        if(m==0){return ans;}\\n        sort(req.begin(), req.end());\\n        vector<int> dis(m);\\n        for(int i=0;i<m;i++){dis[i]=abs(req[i][0]-start[0])+abs(req[i][1]-start[1]);}\\n        int a1 = dis[0];int a2 = 0;\\n        for(int i=1;i<m;i++){if(dis[i]<a1){a1=dis[i];a2=i;}}\\n        vector<bool> comp(m, false);\\n        queue<int> q;\\n        q.push(a2);\\n        while(q.empty()==false)\\n        {\\n            int b = q.front();\\n            q.pop();\\n            comp[b]=true;\\n            int b1 = INT_MAX;int b2 = -1;\\n            for(int i=0;i<m;i++)\\n            {\\n                if(comp[i]==false)\\n                {\\n                    int c = dis[b]+req[b][4]+abs(req[i][0]-req[b][2])+abs(req[i][1]-req[b][3]);\\n                    if(dis[i]>c)\\n                    {\\n                        dis[i]=c;\\n                    }\\n                    if(dis[i]<b1){b1=dis[i];b2=i;}\\n                }\\n            }\\n            if(b2!=-1){q.push(b2);}\\n        }\\n\\n        vector<int> dit(m);\\n        for(int i=0;i<m;i++){dit[i]=abs(req[i][2]-target[0])+abs(req[i][3]-target[1]);}\\n        int a3 = dit[0];int a4 = 0;\\n        for(int i=1;i<m;i++){if(dit[i]<a3){a3=dit[i];a4=i;}}\\n        vector<bool> comq(m, false);\\n        queue<int> qt;\\n        qt.push(a4);\\n        while(qt.empty()==false)\\n        {\\n            int b = qt.front();\\n            qt.pop();\\n            comq[b]=true;\\n            int b1 = INT_MAX;int b2 = -1;\\n            for(int i=0;i<m;i++)\\n            {\\n                if(comq[i]==false)\\n                {\\n                    int c = dit[b]+req[b][4]+abs(req[i][2]-req[b][0])+abs(req[i][3]-req[b][1]);\\n                    if(dit[i]>c)\\n                    {\\n                        dit[i]=c;\\n                    }\\n                    if(dit[i]<b1){b1=dis[i];b2=i;}\\n                }\\n            }\\n            if(b2!=-1){qt.push(b2);}\\n        }\\n        \\n        for(int i=0;i<m;i++){ans=min(ans, dis[i]+dit[i]+req[i][4]);}\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916045,
                "title": "priority-queue-map-graph-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using pii=pair<int, int>;\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        unordered_map<string,int>m;\\n        int count=1;\\n        string key_s=to_string(start[0])+\" \"+to_string(start[1]);\\n        m[key_s]=count;\\n        count++;\\n        string key_t=to_string(target[0])+\" \"+to_string(target[1]);\\n        m[key_t]=count;\\n        count++;\\n        vector<vector<int>>t=sr;\\n        sr.clear();\\n        for(int i=0;i<t.size();i++){\\n            string key=to_string(t[i][0])+\" \"+to_string(t[i][1]);\\n            if(!m.count(key)){\\n                m[key]=count;\\n                count++;\\n            }\\n            key=to_string(t[i][2])+\" \"+to_string(t[i][3]);\\n            if(!m.count(key)){\\n                m[key]=count;\\n                count++;\\n            }\\n        }\\n        vector<vector<pair<int,int>>>v(count+1);\\n        v[1].push_back({2,abs(target[0]-start[0])+abs(target[1]-start[1])});\\n        for(int i=0;i<t.size();i++){\\n            int n1=m[to_string(t[i][0])+\" \"+to_string(t[i][1])];\\n            int n2=m[to_string(t[i][2])+\" \"+to_string(t[i][3])];\\n            v[1].push_back({n1,abs(t[i][0]-start[0])+abs(t[i][1]-start[1])});\\n            v[n2].push_back({2,abs(t[i][2]-target[0])+abs(t[i][3]-target[1])});\\n            v[n1].push_back({n2,t[i][4]});\\n            for(int j=0;j<t.size();j++){\\n                if(j!=i){\\n                    int m1=m[to_string(t[j][0])+\" \"+to_string(t[j][1])];\\n                    v[n2].push_back({m1,abs(t[i][2]-t[j][0])+abs(t[i][3]-t[j][1])});\\n                }\\n            }\\n        }\\n        auto compare = [](const pii& a, const pii& b) {\\n            return a.first > b.first;\\n        };\\n        priority_queue<pii,vector<pii>,decltype(compare)>q(compare);\\n        vector<int>dp(count+1,INT_MAX);\\n        dp[1]=0;\\n        q.push({0,1});\\n        while(!q.empty()){\\n            int val=q.top().first;\\n            int node=q.top().second;\\n            q.pop();\\n            for(int i=0;i<v[node].size();i++){\\n                int fn=v[node][i].first;\\n                int fv=v[node][i].second;\\n                if(fv+val<dp[fn]){\\n                    dp[fn]=fv+val;\\n                    q.push({dp[fn],fn});\\n                }\\n            }\\n        }\\n        int w=dp[2];\\n        // if(w==INT_MAX) return -1;\\n        return w;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using pii=pair<int, int>;\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        unordered_map<string,int>m;\\n        int count=1;\\n        string key_s=to_string(start[0])+\" \"+to_string(start[1]);\\n        m[key_s]=count;\\n        count++;\\n        string key_t=to_string(target[0])+\" \"+to_string(target[1]);\\n        m[key_t]=count;\\n        count++;\\n        vector<vector<int>>t=sr;\\n        sr.clear();\\n        for(int i=0;i<t.size();i++){\\n            string key=to_string(t[i][0])+\" \"+to_string(t[i][1]);\\n            if(!m.count(key)){\\n                m[key]=count;\\n                count++;\\n            }\\n            key=to_string(t[i][2])+\" \"+to_string(t[i][3]);\\n            if(!m.count(key)){\\n                m[key]=count;\\n                count++;\\n            }\\n        }\\n        vector<vector<pair<int,int>>>v(count+1);\\n        v[1].push_back({2,abs(target[0]-start[0])+abs(target[1]-start[1])});\\n        for(int i=0;i<t.size();i++){\\n            int n1=m[to_string(t[i][0])+\" \"+to_string(t[i][1])];\\n            int n2=m[to_string(t[i][2])+\" \"+to_string(t[i][3])];\\n            v[1].push_back({n1,abs(t[i][0]-start[0])+abs(t[i][1]-start[1])});\\n            v[n2].push_back({2,abs(t[i][2]-target[0])+abs(t[i][3]-target[1])});\\n            v[n1].push_back({n2,t[i][4]});\\n            for(int j=0;j<t.size();j++){\\n                if(j!=i){\\n                    int m1=m[to_string(t[j][0])+\" \"+to_string(t[j][1])];\\n                    v[n2].push_back({m1,abs(t[i][2]-t[j][0])+abs(t[i][3]-t[j][1])});\\n                }\\n            }\\n        }\\n        auto compare = [](const pii& a, const pii& b) {\\n            return a.first > b.first;\\n        };\\n        priority_queue<pii,vector<pii>,decltype(compare)>q(compare);\\n        vector<int>dp(count+1,INT_MAX);\\n        dp[1]=0;\\n        q.push({0,1});\\n        while(!q.empty()){\\n            int val=q.top().first;\\n            int node=q.top().second;\\n            q.pop();\\n            for(int i=0;i<v[node].size();i++){\\n                int fn=v[node][i].first;\\n                int fv=v[node][i].second;\\n                if(fv+val<dp[fn]){\\n                    dp[fn]=fv+val;\\n                    q.push({dp[fn],fn});\\n                }\\n            }\\n        }\\n        int w=dp[2];\\n        // if(w==INT_MAX) return -1;\\n        return w;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869794,
                "title": "priorityqueue-easy-simple-and-fastest-way-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int sx = start[0];\\n        int sy = start[1];\\n        int ex = target[0];\\n        int ey = target[1];\\n        int len = specialRoads.size();\\n\\n        //pair<distance, special raod position>\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n\\n        for(int i=0; i<len; i++) {\\n            pq.push({abs(sx-specialRoads[i][0]) + abs(sy-specialRoads[i][1]), i});\\n        }\\n\\n        vector<int> dp(len, INT_MAX);\\n        while(!pq.empty()) {\\n            auto[cost, i] = pq.top();\\n            pq.pop();\\n            \\n            if(dp[i] != INT_MAX) continue;\\n\\n            dp[i] = cost+specialRoads[i][4];\\n\\n            for(int j=0; j<len; j++) {\\n                if(i==j) continue;\\n                pq.push({dp[i]+abs(specialRoads[i][2]-specialRoads[j][0])+abs(specialRoads[i][3]-specialRoads[j][1]), j}); \\n            }\\n        }\\n\\n        int minCost = abs(sx-ex) + abs(sy-ey);\\n        for(int i=0; i<len; i++) {\\n            minCost = min(minCost, dp[i]+abs(specialRoads[i][2]-ex)+abs(specialRoads[i][3]-ey));\\n        }\\n\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int sx = start[0];\\n        int sy = start[1];\\n        int ex = target[0];\\n        int ey = target[1];\\n        int len = specialRoads.size();\\n\\n        //pair<distance, special raod position>\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n\\n        for(int i=0; i<len; i++) {\\n            pq.push({abs(sx-specialRoads[i][0]) + abs(sy-specialRoads[i][1]), i});\\n        }\\n\\n        vector<int> dp(len, INT_MAX);\\n        while(!pq.empty()) {\\n            auto[cost, i] = pq.top();\\n            pq.pop();\\n            \\n            if(dp[i] != INT_MAX) continue;\\n\\n            dp[i] = cost+specialRoads[i][4];\\n\\n            for(int j=0; j<len; j++) {\\n                if(i==j) continue;\\n                pq.push({dp[i]+abs(specialRoads[i][2]-specialRoads[j][0])+abs(specialRoads[i][3]-specialRoads[j][1]), j}); \\n            }\\n        }\\n\\n        int minCost = abs(sx-ex) + abs(sy-ey);\\n        for(int i=0; i<len; i++) {\\n            minCost = min(minCost, dp[i]+abs(specialRoads[i][2]-ex)+abs(specialRoads[i][3]-ey));\\n        }\\n\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843030,
                "title": "rust-solution",
                "content": "\\n# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn minimum_cost(start: Vec<i32>, target: Vec<i32>, special_roads: Vec<Vec<i32>>) -> i32 {\\n    let mut set = HashSet::new();\\n    let mut map = HashMap::new();\\n    let default_val = 10_000_000;\\n    for arr in special_roads {\\n      let x1 = arr[0];\\n      let y1 = arr[1];\\n      let x2 = arr[2];\\n      let y2 = arr[3];\\n      let v = arr[4];\\n\\n      set.insert((x1,y1));\\n      set.insert((x2,y2));\\n      let entry = map.entry((x1,y1,x2,y2)).or_insert(default_val);\\n      if v < *entry {\\n        *entry = v;\\n      }\\n    }\\n    \\n    let mut dict = vec![(start[0], start[1])];\\n    for (x,y) in set {\\n      dict.push((x,y));\\n    }\\n    dict.push((target[0], target[1]));\\n\\n    let n = dict.len();\\n    let mut g = vec![vec![];n];\\n    for i in 0..n {\\n      let (x1,y1) = dict[i];\\n      for j in 0..n {\\n        if i == j { continue }\\n        let (x2,y2) = dict[j];\\n        let sv = if let Some(&v) = map.get(&(x1,y1,x2,y2)) {\\n          v\\n        } else {\\n          default_val\\n        };\\n        let av = (x1-x2).abs() + (y1-y2).abs();\\n        g[i].push((j, sv.min(av)));\\n      }\\n    }\\n\\n    let mut memo = vec![default_val;n];\\n    let mut stack = vec![(0,0)];\\n    while !stack.is_empty() {\\n      let mut new_stack = vec![];\\n      while let Some((ci,cv)) = stack.pop() {\\n        for &(ni, v) in &g[ci] {\\n          let nv = cv + v;\\n          if nv < memo[ni] {\\n            memo[ni] = nv;\\n            new_stack.push((ni,nv));\\n          }\\n        }\\n      }\\n      stack = new_stack;\\n    }\\n\\n    memo[n-1]\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn minimum_cost(start: Vec<i32>, target: Vec<i32>, special_roads: Vec<Vec<i32>>) -> i32 {\\n    let mut set = HashSet::new();\\n    let mut map = HashMap::new();\\n    let default_val = 10_000_000;\\n    for arr in special_roads {\\n      let x1 = arr[0];\\n      let y1 = arr[1];\\n      let x2 = arr[2];\\n      let y2 = arr[3];\\n      let v = arr[4];\\n\\n      set.insert((x1,y1));\\n      set.insert((x2,y2));\\n      let entry = map.entry((x1,y1,x2,y2)).or_insert(default_val);\\n      if v < *entry {\\n        *entry = v;\\n      }\\n    }\\n    \\n    let mut dict = vec![(start[0], start[1])];\\n    for (x,y) in set {\\n      dict.push((x,y));\\n    }\\n    dict.push((target[0], target[1]));\\n\\n    let n = dict.len();\\n    let mut g = vec![vec![];n];\\n    for i in 0..n {\\n      let (x1,y1) = dict[i];\\n      for j in 0..n {\\n        if i == j { continue }\\n        let (x2,y2) = dict[j];\\n        let sv = if let Some(&v) = map.get(&(x1,y1,x2,y2)) {\\n          v\\n        } else {\\n          default_val\\n        };\\n        let av = (x1-x2).abs() + (y1-y2).abs();\\n        g[i].push((j, sv.min(av)));\\n      }\\n    }\\n\\n    let mut memo = vec![default_val;n];\\n    let mut stack = vec![(0,0)];\\n    while !stack.is_empty() {\\n      let mut new_stack = vec![];\\n      while let Some((ci,cv)) = stack.pop() {\\n        for &(ni, v) in &g[ci] {\\n          let nv = cv + v;\\n          if nv < memo[ni] {\\n            memo[ni] = nv;\\n            new_stack.push((ni,nv));\\n          }\\n        }\\n      }\\n      stack = new_stack;\\n    }\\n\\n    memo[n-1]\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820990,
                "title": "java-dijkstra-fast-easy",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        // 0 -> x destination\\n        // 1 => y destination\\n        // 2 => cost\\n        // 3 => source indx\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] v1, int[] v2) -> Integer.compare(v1[2], v2[2]));\\n        boolean[] visited = new boolean[specialRoads.length+1];\\n\\n        int cost = Math.abs(target[0]-start[0])+Math.abs(target[1]-start[1]);\\n        pq.add(new int[]{start[0], start[1], 0, specialRoads.length });\\n        \\n        while ( ! pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n\\n            if (cur[0] == target[0] && cur[1] == target[1]) {\\n                return cur[2];\\n            }\\n\\n            if (visited[cur[3]]) {\\n                continue;\\n            }\\n            visited[cur[3]] = true;\\n\\n            cost = Math.abs(target[0]-cur[0])+Math.abs(target[1]-cur[1]) + cur[2];\\n            \\n            pq.add(new int[]{target[0], target[1], cost, cur[3]});\\n            \\n            int i = -1;\\n            for (int[] road : specialRoads) {\\n                i++;\\n                \\n            \\n                cost = Math.abs(road[0]-cur[0])+Math.abs(road[1]-cur[1])+road[4]+cur[2];\\n                pq.add(new int[]{road[2], road[3], cost, i});\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        // 0 -> x destination\\n        // 1 => y destination\\n        // 2 => cost\\n        // 3 => source indx\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] v1, int[] v2) -> Integer.compare(v1[2], v2[2]));\\n        boolean[] visited = new boolean[specialRoads.length+1];\\n\\n        int cost = Math.abs(target[0]-start[0])+Math.abs(target[1]-start[1]);\\n        pq.add(new int[]{start[0], start[1], 0, specialRoads.length });\\n        \\n        while ( ! pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n\\n            if (cur[0] == target[0] && cur[1] == target[1]) {\\n                return cur[2];\\n            }\\n\\n            if (visited[cur[3]]) {\\n                continue;\\n            }\\n            visited[cur[3]] = true;\\n\\n            cost = Math.abs(target[0]-cur[0])+Math.abs(target[1]-cur[1]) + cur[2];\\n            \\n            pq.add(new int[]{target[0], target[1], cost, cur[3]});\\n            \\n            int i = -1;\\n            for (int[] road : specialRoads) {\\n                i++;\\n                \\n            \\n                cost = Math.abs(road[0]-cur[0])+Math.abs(road[1]-cur[1])+road[4]+cur[2];\\n                pq.add(new int[]{road[2], road[3], cost, i});\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800284,
                "title": "dijkstra-note-the-special-roads-are-unidirectional",
                "content": "# Intuition\\nConnected Points with Manhattan dist and Special Road dist as applicable. Then used Dijkstra.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 logn )\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dist(vector<int> start,vector<int> end){\\n        return abs(start[0]-end[0])+abs(start[1]-end[1]);\\n    }\\n    void makeEdge(map<int,map<int,int>> &adj,int u,int v,int wt,bool uni){\\n        if(u==v){\\n            return;\\n        }        \\n        if(adj.count(u)==1){\\n            if(adj[u].count(v)==1){                \\n                adj[u][v]=min(adj[u][v],wt);\\n                if(!uni){                    \\n                    if(adj[v].count(u)==1){\\n                    adj[v][u]=min(wt,adj[v][u]);\\n                    }else{\\n                        adj[v][u]=wt;\\n                    }                                        \\n                }                  \\n                return;\\n            }\\n        }\\n        adj[u][v]=wt;\\n        if(!uni)\\n        {\\n            if(adj[v].count(u)==1){\\n                adj[v][u]=min(wt,adj[v][u]);\\n            }else{\\n                adj[v][u]=wt;\\n            } \\n        }                            \\n    }\\n    void CrdToNode(map<int,map<int,int>> &mp,int x,int y,int &k){\\n        if(mp.count(x)==1){\\n            if(mp[x].count(y)==1){\\n                return;\\n            }\\n        }\\n        mp[x][y]=k;\\n        k+=1;\\n        return;\\n    }\\n    class Comp{\\n        public:\\n        bool operator()(pair<int,int> &a,pair<int,int> &b){\\n            return a.second<b.second;\\n        }\\n    };\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int n=specialRoads.size();\\n        map<int,map<int,int>> Crds;\\n        int k=0;\\n        CrdToNode(Crds,start[0],start[1],k);\\n        CrdToNode(Crds,target[0],target[1],k);\\n        for(auto v:specialRoads){\\n            vector<int> st{v[0],v[1]};vector<int> end{v[2],v[3]};\\n            CrdToNode(Crds,st[0],st[1],k);\\n            CrdToNode(Crds,end[0],end[1],k);\\n        }        \\n        map<int,map<int,int>> adj;        \\n        int src=Crds[start[0]][start[1]];\\n        int dest=Crds[target[0]][target[1]];        \\n        makeEdge(adj,src,dest,dist(start,target),false);        \\n        for(int i=0;i<n;i++){\\n            vector<int> st{specialRoads[i][0],specialRoads[i][1]};vector<int> end{specialRoads[i][2],specialRoads[i][3]};\\n            int u1=Crds[st[0]][st[1]];int v1=Crds[end[0]][end[1]];            \\n            for(int j=i+1;j<n;j++){\\n                vector<int> s{specialRoads[j][0],specialRoads[j][1]};vector<int> e{specialRoads[j][2],specialRoads[j][3]};\\n                int u2=Crds[s[0]][s[1]];int v2=Crds[e[0]][e[1]]; \\n                makeEdge(adj,u1,u2,dist(st,s),false);\\n                makeEdge(adj,u1,v2,dist(st,e),false);\\n                makeEdge(adj,v1,u2,dist(end,s),false);\\n                makeEdge(adj,v1,v2,dist(end,e),false);\\n            }\\n        }                \\n        for(auto vec:specialRoads){\\n            vector<int> st{vec[0],vec[1]};vector<int> end{vec[2],vec[3]};\\n            int u=Crds[st[0]][st[1]];\\n            int v=Crds[end[0]][end[1]];            \\n            makeEdge(adj,u,v,vec[4],true);            \\n            makeEdge(adj,src,u,dist(start,st),false);\\n            makeEdge(adj,dest,u,dist(target,st),false);\\n            makeEdge(adj,src,v,dist(start,end),false);\\n            makeEdge(adj,dest,v,dist(target,end),false);\\n        }        \\n        vector<int> dist(k,INT_MAX);\\n        vector<int> par(k);\\n        map<int,map<int,int>> edgeDist;\\n        for(int i=0;i<k;i++)par[i]=i;\\n        dist[src]=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,Comp> pq;\\n        pq.push(make_pair(src,0));\\n        while(!pq.empty()){\\n            pair<int,int> top=pq.top();\\n            pq.pop();\\n            int u=top.first;\\n            for(auto it:adj[u]){\\n                int v=it.first;\\n                int wt=it.second;                \\n                if(dist[u]+wt<dist[v]){\\n                    par[v]=u;\\n                    edgeDist[u][v]=wt;\\n                    dist[v]=dist[u]+wt;\\n                    pq.push(make_pair(v,dist[v]));\\n                }\\n            }\\n        }\\n        int u=dest;        \\n        return dist[dest];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dist(vector<int> start,vector<int> end){\\n        return abs(start[0]-end[0])+abs(start[1]-end[1]);\\n    }\\n    void makeEdge(map<int,map<int,int>> &adj,int u,int v,int wt,bool uni){\\n        if(u==v){\\n            return;\\n        }        \\n        if(adj.count(u)==1){\\n            if(adj[u].count(v)==1){                \\n                adj[u][v]=min(adj[u][v],wt);\\n                if(!uni){                    \\n                    if(adj[v].count(u)==1){\\n                    adj[v][u]=min(wt,adj[v][u]);\\n                    }else{\\n                        adj[v][u]=wt;\\n                    }                                        \\n                }                  \\n                return;\\n            }\\n        }\\n        adj[u][v]=wt;\\n        if(!uni)\\n        {\\n            if(adj[v].count(u)==1){\\n                adj[v][u]=min(wt,adj[v][u]);\\n            }else{\\n                adj[v][u]=wt;\\n            } \\n        }                            \\n    }\\n    void CrdToNode(map<int,map<int,int>> &mp,int x,int y,int &k){\\n        if(mp.count(x)==1){\\n            if(mp[x].count(y)==1){\\n                return;\\n            }\\n        }\\n        mp[x][y]=k;\\n        k+=1;\\n        return;\\n    }\\n    class Comp{\\n        public:\\n        bool operator()(pair<int,int> &a,pair<int,int> &b){\\n            return a.second<b.second;\\n        }\\n    };\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int n=specialRoads.size();\\n        map<int,map<int,int>> Crds;\\n        int k=0;\\n        CrdToNode(Crds,start[0],start[1],k);\\n        CrdToNode(Crds,target[0],target[1],k);\\n        for(auto v:specialRoads){\\n            vector<int> st{v[0],v[1]};vector<int> end{v[2],v[3]};\\n            CrdToNode(Crds,st[0],st[1],k);\\n            CrdToNode(Crds,end[0],end[1],k);\\n        }        \\n        map<int,map<int,int>> adj;        \\n        int src=Crds[start[0]][start[1]];\\n        int dest=Crds[target[0]][target[1]];        \\n        makeEdge(adj,src,dest,dist(start,target),false);        \\n        for(int i=0;i<n;i++){\\n            vector<int> st{specialRoads[i][0],specialRoads[i][1]};vector<int> end{specialRoads[i][2],specialRoads[i][3]};\\n            int u1=Crds[st[0]][st[1]];int v1=Crds[end[0]][end[1]];            \\n            for(int j=i+1;j<n;j++){\\n                vector<int> s{specialRoads[j][0],specialRoads[j][1]};vector<int> e{specialRoads[j][2],specialRoads[j][3]};\\n                int u2=Crds[s[0]][s[1]];int v2=Crds[e[0]][e[1]]; \\n                makeEdge(adj,u1,u2,dist(st,s),false);\\n                makeEdge(adj,u1,v2,dist(st,e),false);\\n                makeEdge(adj,v1,u2,dist(end,s),false);\\n                makeEdge(adj,v1,v2,dist(end,e),false);\\n            }\\n        }                \\n        for(auto vec:specialRoads){\\n            vector<int> st{vec[0],vec[1]};vector<int> end{vec[2],vec[3]};\\n            int u=Crds[st[0]][st[1]];\\n            int v=Crds[end[0]][end[1]];            \\n            makeEdge(adj,u,v,vec[4],true);            \\n            makeEdge(adj,src,u,dist(start,st),false);\\n            makeEdge(adj,dest,u,dist(target,st),false);\\n            makeEdge(adj,src,v,dist(start,end),false);\\n            makeEdge(adj,dest,v,dist(target,end),false);\\n        }        \\n        vector<int> dist(k,INT_MAX);\\n        vector<int> par(k);\\n        map<int,map<int,int>> edgeDist;\\n        for(int i=0;i<k;i++)par[i]=i;\\n        dist[src]=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,Comp> pq;\\n        pq.push(make_pair(src,0));\\n        while(!pq.empty()){\\n            pair<int,int> top=pq.top();\\n            pq.pop();\\n            int u=top.first;\\n            for(auto it:adj[u]){\\n                int v=it.first;\\n                int wt=it.second;                \\n                if(dist[u]+wt<dist[v]){\\n                    par[v]=u;\\n                    edgeDist[u][v]=wt;\\n                    dist[v]=dist[u]+wt;\\n                    pq.push(make_pair(v,dist[v]));\\n                }\\n            }\\n        }\\n        int u=dest;        \\n        return dist[dest];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790033,
                "title": "c-dijkstra-s-easy-solution",
                "content": "Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int, int>, int> m1;  // for storing {co-ordinates} : node\\n        map<int, pair<int, int>> m2;  // for storing node : {co-ordinates}\\n        \\n        int n = 0;\\n\\n        m1[{start[0], start[1]}] = n;\\n        m2[n] = {start[0], start[1]};\\n        n++;\\n        \\n        \\n        for (auto road : specialRoads) {\\n            int s1 = road[0], e1 = road[1], s2 = road[2], e2 = road[3], w = road[4];\\n\\n            if (m1.find({s1, e1}) == m1.end()) { // avoiding duplicates\\n                m1[{s1, e1}] = n;\\n                m2[n] = {s1, e1};\\n                n++;\\n            }\\n\\n            if (m1.find({s2, e2}) == m1.end()) { // avoiding duplicates\\n                m1[{s2, e2}] = n;\\n                m2[n] = {s2, e2};\\n                n++;\\n            }\\n        }\\n\\n        if (m1.find({target[0], target[1]}) == m1.end()) { // avoiding duplicates\\n            m1[{target[0], target[1]}] = n;\\n            m2[n] = {target[0], target[1]};\\n            n++;\\n        }\\n\\n        // we have total n nodes (incluing start, end and all other special nodes)\\n        \\n        vector<pair<int, int>> adj[n]; // creating adj list\\n\\n        for (int idx1 = 0; idx1 < n; idx1++) {\\n            for (int idx2 = idx1 + 1; idx2 < n; idx2++){\\n                int a = m2[idx1].first, b = m2[idx1].second;  // get co-ordinates using m2\\n                int c = m2[idx2].first, d = m2[idx2].second;\\n\\n                adj[idx1].push_back({idx2, abs(c - a) + abs(d - b)}); // storing pairs with absolute diff\\n                adj[idx2].push_back({idx1, abs(c - a) + abs(d - b)}); \\n            }\\n        }\\n\\n        for (auto road : specialRoads) {\\n            int s1 = road[0], e1 = road[1], s2 = road[2], e2 = road[3], w = road[4];\\n\\n            int node1 = m1[{s1, e1}];\\n            int node2 = m1[{s2, e2}];\\n\\n            for (int idx = 0; idx < adj[node1].size(); idx++) {\\n                if (node2 == adj[node1][idx].first) {\\n                    // for special road storing min of abs distance and special road distance\\n                    adj[node1][idx] = {node2, min(w, adj[node1][idx].second)};  \\n                }\\n            }\\n        }\\n\\n        // apply dijkstra\\'s\\n\\n        vector<int> dist(n, 1e9);\\n        dist[0] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        pq.push({0, {0, 0}});\\n\\n        while (!pq.empty()) {\\n            int size = pq.size();\\n\\n            while (size--) {\\n                auto it = pq.top();\\n                pq.pop();\\n\\n                int w = it.first;\\n                int u = it.second.first;\\n                int v = it.second.second;\\n\\n                for (auto [adjNode, weight] : adj[v]) {\\n                    int distance = w + weight;\\n\\n                    if (distance < dist[adjNode]) {\\n                        dist[adjNode] = distance;\\n                        pq.push({distance, {v, adjNode}});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dist[m1[{target[0], target[1]}]];  // target node will not always present at last (if target duplicate present in special roads)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int, int>, int> m1;  // for storing {co-ordinates} : node\\n        map<int, pair<int, int>> m2;  // for storing node : {co-ordinates}\\n        \\n        int n = 0;\\n\\n        m1[{start[0], start[1]}] = n;\\n        m2[n] = {start[0], start[1]};\\n        n++;\\n        \\n        \\n        for (auto road : specialRoads) {\\n            int s1 = road[0], e1 = road[1], s2 = road[2], e2 = road[3], w = road[4];\\n\\n            if (m1.find({s1, e1}) == m1.end()) { // avoiding duplicates\\n                m1[{s1, e1}] = n;\\n                m2[n] = {s1, e1};\\n                n++;\\n            }\\n\\n            if (m1.find({s2, e2}) == m1.end()) { // avoiding duplicates\\n                m1[{s2, e2}] = n;\\n                m2[n] = {s2, e2};\\n                n++;\\n            }\\n        }\\n\\n        if (m1.find({target[0], target[1]}) == m1.end()) { // avoiding duplicates\\n            m1[{target[0], target[1]}] = n;\\n            m2[n] = {target[0], target[1]};\\n            n++;\\n        }\\n\\n        // we have total n nodes (incluing start, end and all other special nodes)\\n        \\n        vector<pair<int, int>> adj[n]; // creating adj list\\n\\n        for (int idx1 = 0; idx1 < n; idx1++) {\\n            for (int idx2 = idx1 + 1; idx2 < n; idx2++){\\n                int a = m2[idx1].first, b = m2[idx1].second;  // get co-ordinates using m2\\n                int c = m2[idx2].first, d = m2[idx2].second;\\n\\n                adj[idx1].push_back({idx2, abs(c - a) + abs(d - b)}); // storing pairs with absolute diff\\n                adj[idx2].push_back({idx1, abs(c - a) + abs(d - b)}); \\n            }\\n        }\\n\\n        for (auto road : specialRoads) {\\n            int s1 = road[0], e1 = road[1], s2 = road[2], e2 = road[3], w = road[4];\\n\\n            int node1 = m1[{s1, e1}];\\n            int node2 = m1[{s2, e2}];\\n\\n            for (int idx = 0; idx < adj[node1].size(); idx++) {\\n                if (node2 == adj[node1][idx].first) {\\n                    // for special road storing min of abs distance and special road distance\\n                    adj[node1][idx] = {node2, min(w, adj[node1][idx].second)};  \\n                }\\n            }\\n        }\\n\\n        // apply dijkstra\\'s\\n\\n        vector<int> dist(n, 1e9);\\n        dist[0] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        pq.push({0, {0, 0}});\\n\\n        while (!pq.empty()) {\\n            int size = pq.size();\\n\\n            while (size--) {\\n                auto it = pq.top();\\n                pq.pop();\\n\\n                int w = it.first;\\n                int u = it.second.first;\\n                int v = it.second.second;\\n\\n                for (auto [adjNode, weight] : adj[v]) {\\n                    int distance = w + weight;\\n\\n                    if (distance < dist[adjNode]) {\\n                        dist[adjNode] = distance;\\n                        pq.push({distance, {v, adjNode}});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dist[m1[{target[0], target[1]}]];  // target node will not always present at last (if target duplicate present in special roads)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754940,
                "title": "c-100-solution-bfs-adjacency-list-optimally-made",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define vi vector<int>\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n\\n        map<vector<int>,vector<vector<int>>> m;\\n        priority_queue<vi,vector<vi>,greater<vi>> pq;\\n        map<vector<int>,int> dist;\\n\\n        dist[{start[0],start[1]}]=0;\\n        dist[{target[0],target[1]}]=1e9;\\n\\n        m[{start[0],start[1]}].push_back({target[0],target[1],\\n                abs(target[0]-start[0])+abs(target[1]-start[1])}); //start to target\\n        for(auto road:sr){\\n            dist[{road[0],road[1]}]=1e9;\\n            dist[{road[2],road[3]}]=1e9;\\n\\n            m[{start[0],start[1]}].push_back({road[0],road[1],abs(road[0]-start[0])+abs(road[1]-start[1])});\\n            //start to road begin\\n\\n            m[{road[0],road[1]}].push_back({road[2],road[3],road[4]});\\n            //road start to end\\n            \\n            //road end to target\\n            m[{road[2],road[3]}].push_back({target[0],target[1],\\n                    abs(target[0]-road[2])+abs(target[1]-road[3])});\\n\\n            //road ends to other road start\\n            for(auto road1:sr){\\n                if(road!=road1){\\n                    m[{road[2],road[3]}].push_back({road1[0],road1[1], \\n                    abs(road1[0]-road[2])+abs(road1[1]-road[3])});\\n                }\\n            }\\n        }\\n\\n        pq.push({0,start[0],start[1]});\\n        while(pq.size()){\\n            auto f=pq.top(); pq.pop();\\n            int cost=f[0],x=f[1],y=f[2];\\n            for(auto neg:m[{x,y}]){\\n                int nx=neg[0],ny=neg[1],c=neg[2];\\n                if(dist[{nx,ny}]>cost+c){\\n                    dist[{nx,ny}]=cost+c;\\n                    pq.push({cost+c,nx,ny});\\n                }\\n            }\\n        }\\n        return dist[{target[0],target[1]}];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define vi vector<int>\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n\\n        map<vector<int>,vector<vector<int>>> m;\\n        priority_queue<vi,vector<vi>,greater<vi>> pq;\\n        map<vector<int>,int> dist;\\n\\n        dist[{start[0],start[1]}]=0;\\n        dist[{target[0],target[1]}]=1e9;\\n\\n        m[{start[0],start[1]}].push_back({target[0],target[1],\\n                abs(target[0]-start[0])+abs(target[1]-start[1])}); //start to target\\n        for(auto road:sr){\\n            dist[{road[0],road[1]}]=1e9;\\n            dist[{road[2],road[3]}]=1e9;\\n\\n            m[{start[0],start[1]}].push_back({road[0],road[1],abs(road[0]-start[0])+abs(road[1]-start[1])});\\n            //start to road begin\\n\\n            m[{road[0],road[1]}].push_back({road[2],road[3],road[4]});\\n            //road start to end\\n            \\n            //road end to target\\n            m[{road[2],road[3]}].push_back({target[0],target[1],\\n                    abs(target[0]-road[2])+abs(target[1]-road[3])});\\n\\n            //road ends to other road start\\n            for(auto road1:sr){\\n                if(road!=road1){\\n                    m[{road[2],road[3]}].push_back({road1[0],road1[1], \\n                    abs(road1[0]-road[2])+abs(road1[1]-road[3])});\\n                }\\n            }\\n        }\\n\\n        pq.push({0,start[0],start[1]});\\n        while(pq.size()){\\n            auto f=pq.top(); pq.pop();\\n            int cost=f[0],x=f[1],y=f[2];\\n            for(auto neg:m[{x,y}]){\\n                int nx=neg[0],ny=neg[1],c=neg[2];\\n                if(dist[{nx,ny}]>cost+c){\\n                    dist[{nx,ny}]=cost+c;\\n                    pq.push({cost+c,nx,ny});\\n                }\\n            }\\n        }\\n        return dist[{target[0],target[1]}];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712583,
                "title": "easy-java-solution-priorityqueue-dijkstra-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int x;\\n        int y;\\n        int cost;\\n        Pair(int x,int y,int cost){\\n            this.x=x;\\n            this.y=y;\\n            this.cost=cost;\\n        }\\n    }\\n\\n    public int minimumCost(int[] start, int[] target, int[][] sr) {\\n        int m = sr.length;\\n        int n = sr[0].length;\\n\\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.cost - b.cost);\\n\\n        int fx = target[0];\\n        int fy = target[1];\\n\\n        pq.add(new Pair(start[0], start[1], 0));\\n\\n        while(!pq.isEmpty()){\\n            Pair curr = pq.remove();\\n\\n            int x1 = curr.x;\\n            int y1 = curr.y;\\n\\n            if(map.containsKey(x1) && map.get(x1).contains(y1)){\\n                continue;\\n            }\\n\\n            if(map.containsKey(x1)==false){\\n                map.put(x1,new HashSet<Integer>());\\n            }\\n            map.get(x1).add(y1);\\n\\n            if(curr.x == fx && curr.y == fy){\\n                return curr.cost;\\n            }\\n\\n            int d = curr.cost + Math.abs(x1 - fx) + Math.abs(y1 - fy);\\n\\n            pq.add(new Pair(fx, fy, d));\\n\\n            for(int i = 0; i < sr.length; i++){\\n                int x=sr[i][0];\\n                int y=sr[i][1];\\n                int x2=sr[i][2];\\n                int y2=sr[i][3];\\n                int ct=sr[i][4];\\n                \\n               \\n                if(map.containsKey(x2)&&map.get(x2).contains(y2)){\\n                    continue;\\n                }\\n                pq.add(new Pair(x2,y2,curr.cost+ct+Math.abs(x1-x)+Math.abs(y1-y)));\\n            }\\n\\n\\n\\n        }\\n\\n\\n        return -1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int x;\\n        int y;\\n        int cost;\\n        Pair(int x,int y,int cost){\\n            this.x=x;\\n            this.y=y;\\n            this.cost=cost;\\n        }\\n    }\\n\\n    public int minimumCost(int[] start, int[] target, int[][] sr) {\\n        int m = sr.length;\\n        int n = sr[0].length;\\n\\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.cost - b.cost);\\n\\n        int fx = target[0];\\n        int fy = target[1];\\n\\n        pq.add(new Pair(start[0], start[1], 0));\\n\\n        while(!pq.isEmpty()){\\n            Pair curr = pq.remove();\\n\\n            int x1 = curr.x;\\n            int y1 = curr.y;\\n\\n            if(map.containsKey(x1) && map.get(x1).contains(y1)){\\n                continue;\\n            }\\n\\n            if(map.containsKey(x1)==false){\\n                map.put(x1,new HashSet<Integer>());\\n            }\\n            map.get(x1).add(y1);\\n\\n            if(curr.x == fx && curr.y == fy){\\n                return curr.cost;\\n            }\\n\\n            int d = curr.cost + Math.abs(x1 - fx) + Math.abs(y1 - fy);\\n\\n            pq.add(new Pair(fx, fy, d));\\n\\n            for(int i = 0; i < sr.length; i++){\\n                int x=sr[i][0];\\n                int y=sr[i][1];\\n                int x2=sr[i][2];\\n                int y2=sr[i][3];\\n                int ct=sr[i][4];\\n                \\n               \\n                if(map.containsKey(x2)&&map.get(x2).contains(y2)){\\n                    continue;\\n                }\\n                pq.add(new Pair(x2,y2,curr.cost+ct+Math.abs(x1-x)+Math.abs(y1-y)));\\n            }\\n\\n\\n\\n        }\\n\\n\\n        return -1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690568,
                "title": "easy-and-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& sp) {\\n\\n        map<pair<int,int>,int>cost;\\n        map<pair<int,int>,vector<vector<int>>>adj;\\n        for(auto it:sp)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            int nx=it[2];\\n            int ny=it[3];\\n            int c=it[4];\\n            adj[{s[0],s[1]}].push_back({x,y,abs(x-s[0])+abs(y-s[1])});\\n            adj[{s[0],s[1]}].push_back({nx,ny,abs(nx-s[0])+abs(ny-s[1])});\\n            adj[{x,y}].push_back({nx,ny,c});\\n            adj[{nx,ny}].push_back({t[0],t[1],abs(nx-t[0])+abs(ny-t[1])});\\n            adj[{x,y}].push_back({t[0],t[1],abs(x-t[0])+abs(y-t[1])});\\n        }\\n\\n        for (int i = 0; i < sp.size(); i++)\\n        {\\n            for (int j = 0; j < sp.size(); j++)\\n            {\\n\\n            int x1=sp[i][0];\\n            int y1=sp[i][1];\\n            int nx1=sp[i][2];\\n            int ny1=sp[i][3];   \\n            int x2=sp[j][0];\\n            int y2=sp[j][1];\\n            int nx2=sp[j][2];\\n            int ny2=sp[j][3];\\n            \\n            adj[{nx1,ny1}].push_back({x2,y2 ,abs (nx1-x2) + abs(ny1-y2) });\\n            adj[{nx2,ny2}].push_back({x1,y1 ,abs (nx2-x1) + abs(ny2-y1) });\\n                \\n            }\\n        }\\n// a -> b     c -> d\\n\\n\\n        set<pair<int,pair<int,int>>>st;\\n        st.insert({0,{s[0],s[1]}});\\n        cost[{s[0],s[1]}]=0;\\n        while(!st.empty())\\n        {\\n            auto top=*st.begin();\\n            int d=top.first;\\n            int ci=top.second.first;\\n            int cj=top.second.second;\\n            st.erase(top);\\n            for(auto it:adj[{ci,cj}])\\n            {\\n                int ni=it[0];\\n                int nj=it[1];\\n                int c=it[2];\\n                if(cost.find({ni,nj})==cost.end() || \\n                cost[{ni,nj}]>cost[{ci,cj}]+c)\\n                {\\n                    st.erase({cost[{ni,nj}],{ni,nj}});\\n                    cost[{ni,nj}]=cost[{ci,cj}]+c;\\n                    st.insert({cost[{ni,nj}],{ni,nj}});\\n                }\\n            }\\n        }\\n\\n    //     for (auto it : cost)\\n    //     {\\n    // cout<<it.first.first<<\\' \\'<<it.first.second<<\\' \\'<<it.second<<endl;\\n    //     }\\n        return cost[{t[0],t[1]}];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& sp) {\\n\\n        map<pair<int,int>,int>cost;\\n        map<pair<int,int>,vector<vector<int>>>adj;\\n        for(auto it:sp)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            int nx=it[2];\\n            int ny=it[3];\\n            int c=it[4];\\n            adj[{s[0],s[1]}].push_back({x,y,abs(x-s[0])+abs(y-s[1])});\\n            adj[{s[0],s[1]}].push_back({nx,ny,abs(nx-s[0])+abs(ny-s[1])});\\n            adj[{x,y}].push_back({nx,ny,c});\\n            adj[{nx,ny}].push_back({t[0],t[1],abs(nx-t[0])+abs(ny-t[1])});\\n            adj[{x,y}].push_back({t[0],t[1],abs(x-t[0])+abs(y-t[1])});\\n        }\\n\\n        for (int i = 0; i < sp.size(); i++)\\n        {\\n            for (int j = 0; j < sp.size(); j++)\\n            {\\n\\n            int x1=sp[i][0];\\n            int y1=sp[i][1];\\n            int nx1=sp[i][2];\\n            int ny1=sp[i][3];   \\n            int x2=sp[j][0];\\n            int y2=sp[j][1];\\n            int nx2=sp[j][2];\\n            int ny2=sp[j][3];\\n            \\n            adj[{nx1,ny1}].push_back({x2,y2 ,abs (nx1-x2) + abs(ny1-y2) });\\n            adj[{nx2,ny2}].push_back({x1,y1 ,abs (nx2-x1) + abs(ny2-y1) });\\n                \\n            }\\n        }\\n// a -> b     c -> d\\n\\n\\n        set<pair<int,pair<int,int>>>st;\\n        st.insert({0,{s[0],s[1]}});\\n        cost[{s[0],s[1]}]=0;\\n        while(!st.empty())\\n        {\\n            auto top=*st.begin();\\n            int d=top.first;\\n            int ci=top.second.first;\\n            int cj=top.second.second;\\n            st.erase(top);\\n            for(auto it:adj[{ci,cj}])\\n            {\\n                int ni=it[0];\\n                int nj=it[1];\\n                int c=it[2];\\n                if(cost.find({ni,nj})==cost.end() || \\n                cost[{ni,nj}]>cost[{ci,cj}]+c)\\n                {\\n                    st.erase({cost[{ni,nj}],{ni,nj}});\\n                    cost[{ni,nj}]=cost[{ci,cj}]+c;\\n                    st.insert({cost[{ni,nj}],{ni,nj}});\\n                }\\n            }\\n        }\\n\\n    //     for (auto it : cost)\\n    //     {\\n    // cout<<it.first.first<<\\' \\'<<it.first.second<<\\' \\'<<it.second<<endl;\\n    //     }\\n        return cost[{t[0],t[1]}];\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3656760,
                "title": "c-solution-using-dijkster-algo",
                "content": "class Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        //applying dijkster algorithm for shortest distance path.\\n        priority_queue <pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        map<pair<int,int>,int> minDis;\\n        int res=abs(start[0]-target[0])+abs(start[1]-target[1]);\\n        minDis[{start[0],start[1]}]=0;\\n        pq.push({0,{start[0],start[1]}});\\n        while(!pq.empty()){\\n           pair<int,pair<int,int>> tp=pq.top();\\n           pq.pop();\\n           int cost_upto=tp.first;\\n           pair<int,int> pt_upto=tp.second;\\n           res=min(res,cost_upto+abs(pt_upto.first-target[0])+abs(pt_upto.second-target[1]));\\n           for(int i=0;i<specialRoads.size();i++){\\n               pair<int,int> pt={specialRoads[i][2],specialRoads[i][3]};\\n               int cost=specialRoads[i][4];\\n               int total_cost=cost_upto + cost + abs(pt_upto.first-specialRoads[i][0])+abs(pt_upto.second-specialRoads[i][1]);\\n               if(minDis.find(pt)==minDis.end() || total_cost<minDis[pt]){\\n                   minDis[pt]=total_cost;\\n                   pq.push({total_cost,pt});\\n               }\\n           } \\n            \\n        }\\n        return res;\\n    }\\n    \\n        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        //applying dijkster algorithm for shortest distance path.\\n        priority_queue <pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        map<pair<int,int>,int> minDis;\\n        int res=abs(start[0]-target[0])+abs(start[1]-target[1]);\\n        minDis[{start[0],start[1]}",
                "codeTag": "Java"
            },
            {
                "id": 3640973,
                "title": "golang-dijkstra-s-algorithm",
                "content": "Treat potisions are nodes and roads as edges. We can also create an edge from any position to any other position with the cost of `|x2 - x1| + |y2 - y1|`. Then run Dijkstra\\'s algorithm on this graph.\\n\\n# Code\\n```\\ntype PriorityQueue [][3]int // pair<x, y, cost>\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i][2] < pq[j][2] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.([3]int)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc minimumCost(start []int, target []int, specialRoads [][]int) int {\\n  startXY := [2]int{start[0], start[1]}\\n  targetXY := [2]int{target[0], target[1]}\\n  adjacencyList := make(map[[2]int][][3]int)\\n  adjacencyList[startXY] = append(adjacencyList[startXY],\\n    [3]int{target[0], target[1], dist(start[0], start[1], target[0], target[1])})\\n  \\n  for i := 0; i < len(specialRoads); i++ {\\n    road := specialRoads[i]\\n    x1,  y1, x2, y2, cost := road[0], road[1], road[2], road[3], road[4]\\n    adjacencyList[[2]int{x1,y1}] = append(adjacencyList[[2]int{x1,y1}], [3]int{x2,y2,cost})\\n    // start -> x1, y1\\n    adjacencyList[startXY] = append(adjacencyList[startXY], [3]int{x1, y1, dist(start[0], start[1], x1, y1)})\\n    // x2, y2 -> target\\n    adjacencyList[[2]int{x2, y2}] = append(adjacencyList[[2]int{x2, y2}], [3]int{target[0], target[1], dist(x2, y2, target[0], target[1])})\\n    // End of a special Road to all other special road starts\\n    for j := 0; j < len(specialRoads); j++ {\\n      if i == j {\\n        continue\\n      }\\n      x3, y3 := specialRoads[j][0], specialRoads[j][1]\\n      adjacencyList[[2]int{x2, y2}] = append(adjacencyList[[2]int{x2, y2}], [3]int{x3, y3, dist(x2, y2, x3, y3)})\\n    }\\n  }\\n  poscost := make(map[[2]int]int)\\n  poscost[startXY] = 0\\n  var pq PriorityQueue\\n  heap.Push(&pq, [3]int{start[0], start[1], 0}) // starting from the start position\\n  for pq.Len() > 0 {\\n    top := heap.Pop(&pq).([3]int)\\n    // Let\\'s go through all positions that we can reach from\\n    for _, neighbor := range adjacencyList[[2]int{top[0], top[1]}] {\\n      travelCost := poscost[[2]int{top[0], top[1]}] + neighbor[2]\\n      nextCost, ok := poscost[[2]int{neighbor[0], neighbor[1]}]\\n      if !ok || travelCost < nextCost {\\n        poscost[[2]int{neighbor[0], neighbor[1]}] = travelCost\\n        heap.Push(&pq, neighbor)\\n      }\\n    }\\n  }\\n  return poscost[targetXY]\\n}\\n\\n\\nfunc dist(x1, y1, x2, y2 int) int {\\n  return abs(x2 - x1) + abs(y2 - y1)\\n}\\n\\nfunc abs(a int) int {\\n  if a < 0 {\\n    return -a\\n  }\\n  return a\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype PriorityQueue [][3]int // pair<x, y, cost>\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i][2] < pq[j][2] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.([3]int)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc minimumCost(start []int, target []int, specialRoads [][]int) int {\\n  startXY := [2]int{start[0], start[1]}\\n  targetXY := [2]int{target[0], target[1]}\\n  adjacencyList := make(map[[2]int][][3]int)\\n  adjacencyList[startXY] = append(adjacencyList[startXY],\\n    [3]int{target[0], target[1], dist(start[0], start[1], target[0], target[1])})\\n  \\n  for i := 0; i < len(specialRoads); i++ {\\n    road := specialRoads[i]\\n    x1,  y1, x2, y2, cost := road[0], road[1], road[2], road[3], road[4]\\n    adjacencyList[[2]int{x1,y1}] = append(adjacencyList[[2]int{x1,y1}], [3]int{x2,y2,cost})\\n    // start -> x1, y1\\n    adjacencyList[startXY] = append(adjacencyList[startXY], [3]int{x1, y1, dist(start[0], start[1], x1, y1)})\\n    // x2, y2 -> target\\n    adjacencyList[[2]int{x2, y2}] = append(adjacencyList[[2]int{x2, y2}], [3]int{target[0], target[1], dist(x2, y2, target[0], target[1])})\\n    // End of a special Road to all other special road starts\\n    for j := 0; j < len(specialRoads); j++ {\\n      if i == j {\\n        continue\\n      }\\n      x3, y3 := specialRoads[j][0], specialRoads[j][1]\\n      adjacencyList[[2]int{x2, y2}] = append(adjacencyList[[2]int{x2, y2}], [3]int{x3, y3, dist(x2, y2, x3, y3)})\\n    }\\n  }\\n  poscost := make(map[[2]int]int)\\n  poscost[startXY] = 0\\n  var pq PriorityQueue\\n  heap.Push(&pq, [3]int{start[0], start[1], 0}) // starting from the start position\\n  for pq.Len() > 0 {\\n    top := heap.Pop(&pq).([3]int)\\n    // Let\\'s go through all positions that we can reach from\\n    for _, neighbor := range adjacencyList[[2]int{top[0], top[1]}] {\\n      travelCost := poscost[[2]int{top[0], top[1]}] + neighbor[2]\\n      nextCost, ok := poscost[[2]int{neighbor[0], neighbor[1]}]\\n      if !ok || travelCost < nextCost {\\n        poscost[[2]int{neighbor[0], neighbor[1]}] = travelCost\\n        heap.Push(&pq, neighbor)\\n      }\\n    }\\n  }\\n  return poscost[targetXY]\\n}\\n\\n\\nfunc dist(x1, y1, x2, y2 int) int {\\n  return abs(x2 - x1) + abs(y2 - y1)\\n}\\n\\nfunc abs(a int) int {\\n  if a < 0 {\\n    return -a\\n  }\\n  return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3620011,
                "title": "a-few-solutions",
                "content": "Use Dijkstra\\'s algorithm to find the single-source-shortest-paths from source `S` to target `T`, ie. we use a min heap `q` to track the frontier as tuples `(cost, x, y)` which represent the min `cost` to reach point `(x, y)`, then we consider all possible edges `(i, j) \\uD83D\\uDC49 (u, v)` of weight `w` from the input array `A` to find the min distance `dist` to each edge\\'s endpoint `(u, v)`.  Finally, we perform a linear scan of all edge endpoints `(u, v)` as candidates `cand` for the `best` answer.\\n\\nEach candidate `cand` distance to `(u, v)` is constructed as `cand = cost + f(x, y, i, j) + w`, ie. the `cost` of the path from source `S` to `(x, y)` plus the distance from `(x, y)` to `(i, j)` as `f(x, y, i, j)` plus the distance from `(i, j)` to `(u, v)` as `w`.\\n\\n**Note:** we initialize the `best` answer via the function `f` which returns the manhattan distance from source `S` to target `T` directly\\n\\n---\\n\\n*Kotlin*\\n```\\n```\\n\\n*Javascript*\\n```\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumCost(self, S: List[int], T: List[int], A: List[List[int]], INF = int(1e9 + 7)) -> int:\\n        f = lambda i, j, u, v: abs(i - u) + abs(j - v)\\n        q, dist = [(0, S[0], S[1])], {(S[0], S[1]): 0}\\n        while q:\\n            cost, x, y = heappop(q)\\n            for i, j, u, v, w in A:\\n                cand = cost + f(x, y, i, j) + w\\n                if (u, v) not in dist or dist[(u, v)] > cand:\\n                    dist[(u, v)] = cand; heappush(q, (dist[(u, v)], u, v))\\n        best = f(S[0], S[1], T[0], T[1])\\n        for _, _, u, v, _ in A:\\n            cand = dist[(u, v)] + f(u, v, T[0], T[1])\\n            best = min(best, cand)\\n        return best\\n```\\n\\n*Rust*\\n```\\n```\\n\\n*C++*\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```\n```\\nclass Solution:\\n    def minimumCost(self, S: List[int], T: List[int], A: List[List[int]], INF = int(1e9 + 7)) -> int:\\n        f = lambda i, j, u, v: abs(i - u) + abs(j - v)\\n        q, dist = [(0, S[0], S[1])], {(S[0], S[1]): 0}\\n        while q:\\n            cost, x, y = heappop(q)\\n            for i, j, u, v, w in A:\\n                cand = cost + f(x, y, i, j) + w\\n                if (u, v) not in dist or dist[(u, v)] > cand:\\n                    dist[(u, v)] = cand; heappush(q, (dist[(u, v)], u, v))\\n        best = f(S[0], S[1], T[0], T[1])\\n        for _, _, u, v, _ in A:\\n            cand = dist[(u, v)] + f(u, v, T[0], T[1])\\n            best = min(best, cand)\\n        return best\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613597,
                "title": "cpp-solution-using-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nfristly i ceated a distance graph for each position to other position and than applied dijkstra algorithm to find minimum cost to reach target position.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sp) {\\n        int n = 0;\\n        for( int i = 0; i<sp.size(); i++ ) {\\n            if( sp[i][4] < abs(sp[i][0] - sp[i][2]) + abs(sp[i][1]-sp[i][3]) )\\n                sp[n++] = sp[i];\\n        }\\n\\n        map<pair<int, int>, vector<pair<int, pair<int, int> >> > mp;\\n\\n        int cost = abs(start[0]-target[0]) + abs(target[1]-start[1]);\\n        mp[{start[0], start[1]}].push_back( {cost, {target[0], target[1]} } );\\n        for( int i = 0; i<n; i++ ) {\\n            cost = abs(start[0]-sp[i][0]) + abs(start[1]-sp[i][1]);\\n            mp[{ start[0], start[1] }].push_back( { cost, { sp[i][0], sp[i][1]} } );\\n            // cost = abs(sp[i][0]-sp[i][2]) + abs(sp[i][1]-sp[i][3]);\\n            mp[{sp[i][0], sp[i][1]}].push_back( { sp[i][4], {sp[i][2], sp[i][3]} } );\\n        }\\n\\n        for( int i = 0; i<n; i++ ) {\\n            cost = abs(sp[i][2]-target[0]) + abs(sp[i][3]-target[1] );\\n            mp[{sp[i][2], sp[i][3]}].push_back( { cost, {target[0], target[1]} } );\\n\\n            for( int j = 0; j<n; j++ ) {\\n                if( i == j )\\n                    continue;\\n                cost = abs(sp[i][2]-sp[j][0]) + abs(sp[i][3]-sp[j][1] );\\n                mp[{sp[i][2], sp[i][3]}].push_back( { cost, { sp[j][0], sp[j][1] } });\\n            }\\n        }\\n\\n        // priority_queue< pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<int> > pq;\\n        priority_queue< pair<int, pair<int, int>> > pq;\\n        map< pair<int, int>, int> mp1;\\n\\n        pq.push( {0, {start[0], start[1]} } );\\n        mp1[{start[0], start[1]}] = 0;\\n        set<pair<int, int> > st;\\n        \\n        while( !pq.empty() ) {\\n            auto cur = pq.top().second;\\n            auto val = -pq.top().first;\\n            if( cur.first == target[0] and cur.second == target[1] )\\n                return val;\\n            pq.pop();\\n            if( st.find( cur ) != st.end() )\\n                continue;\\n            st.insert( cur );\\n            for( auto it : mp[cur] ) {\\n                if( !mp1[it.second] || mp1[it.second] > val + it.first ) {\\n                    mp1[it.second] = val + it.first;\\n                    pq.push( { -mp1[it.second], it.second } );\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sp) {\\n        int n = 0;\\n        for( int i = 0; i<sp.size(); i++ ) {\\n            if( sp[i][4] < abs(sp[i][0] - sp[i][2]) + abs(sp[i][1]-sp[i][3]) )\\n                sp[n++] = sp[i];\\n        }\\n\\n        map<pair<int, int>, vector<pair<int, pair<int, int> >> > mp;\\n\\n        int cost = abs(start[0]-target[0]) + abs(target[1]-start[1]);\\n        mp[{start[0], start[1]}].push_back( {cost, {target[0], target[1]} } );\\n        for( int i = 0; i<n; i++ ) {\\n            cost = abs(start[0]-sp[i][0]) + abs(start[1]-sp[i][1]);\\n            mp[{ start[0], start[1] }].push_back( { cost, { sp[i][0], sp[i][1]} } );\\n            // cost = abs(sp[i][0]-sp[i][2]) + abs(sp[i][1]-sp[i][3]);\\n            mp[{sp[i][0], sp[i][1]}].push_back( { sp[i][4], {sp[i][2], sp[i][3]} } );\\n        }\\n\\n        for( int i = 0; i<n; i++ ) {\\n            cost = abs(sp[i][2]-target[0]) + abs(sp[i][3]-target[1] );\\n            mp[{sp[i][2], sp[i][3]}].push_back( { cost, {target[0], target[1]} } );\\n\\n            for( int j = 0; j<n; j++ ) {\\n                if( i == j )\\n                    continue;\\n                cost = abs(sp[i][2]-sp[j][0]) + abs(sp[i][3]-sp[j][1] );\\n                mp[{sp[i][2], sp[i][3]}].push_back( { cost, { sp[j][0], sp[j][1] } });\\n            }\\n        }\\n\\n        // priority_queue< pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<int> > pq;\\n        priority_queue< pair<int, pair<int, int>> > pq;\\n        map< pair<int, int>, int> mp1;\\n\\n        pq.push( {0, {start[0], start[1]} } );\\n        mp1[{start[0], start[1]}] = 0;\\n        set<pair<int, int> > st;\\n        \\n        while( !pq.empty() ) {\\n            auto cur = pq.top().second;\\n            auto val = -pq.top().first;\\n            if( cur.first == target[0] and cur.second == target[1] )\\n                return val;\\n            pq.pop();\\n            if( st.find( cur ) != st.end() )\\n                continue;\\n            st.insert( cur );\\n            for( auto it : mp[cur] ) {\\n                if( !mp1[it.second] || mp1[it.second] > val + it.first ) {\\n                    mp1[it.second] = val + it.first;\\n                    pq.push( { -mp1[it.second], it.second } );\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598562,
                "title": "c-meet-in-the-middle",
                "content": "\\n# BFS\\n```\\nusing pi = pair<int, int>;\\nclass Solution {\\npublic:\\n    int distance(int x, int y, int x2, int y2) {\\n        return abs(x-x2) + abs(y-y2);\\n    }\\n\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        vector<vector<int>> roads;\\n        roads.push_back({ start[0], start[1], start[0], start[1], 0 });\\n        for (auto& r: specialRoads) {\\n            if (distance(r[0], r[1], r[2], r[3]) > r[4]) {\\n                roads.push_back(r);\\n            }\\n        }\\n\\n        vector<int> dist(roads.size(), INT_MAX);\\n        // priority_queue<pi, vector<pi>, greater<>> q;\\n        queue<pi> q;\\n        q.push({ 0, 0 });\\n        dist[0] = 0;\\n        while (!q.empty()) {\\n            // auto [i, w] = q.top();\\n            auto [i, w] = q.front();\\n            q.pop();\\n            int x = roads[i][2], y = roads[i][3];\\n            for (int j = 0; j < roads.size(); j++) {\\n                vector<int>& r = roads[j];\\n                int startX = r[0], startY = r[1], endX = r[2], endY = r[3], w2 = r[4];\\n                int distToJ = distance(x, y, startX, startY) + w + w2;\\n                if (distToJ < dist[j]) {\\n                    dist[j] = distToJ;\\n                    q.push({ j, distToJ });\\n                }\\n            }\\n        }\\n\\n        int ans = INT_MAX;\\n        for (int i = 0; i < roads.size(); i++) {\\n            vector<int> &r = roads[i];\\n            ans = min(ans, dist[i] + distance(r[2], r[3], target[0], target[1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n# Dijkstra\\n```\\nusing pi = pair<int, int>;\\nclass Solution {\\npublic:\\n    int distance(int x, int y, int x2, int y2) {\\n        return abs(x-x2) + abs(y-y2);\\n    }\\n\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        vector<vector<int>> roads;\\n        roads.push_back({ start[0], start[1], start[0], start[1], 0 });\\n        for (auto& r: specialRoads) {\\n            if (distance(r[0], r[1], r[2], r[3]) > r[4]) {\\n                roads.push_back(r);\\n            }\\n        }\\n\\n        vector<int> dist(roads.size(), INT_MAX);\\n        priority_queue<pi, vector<pi>, greater<>> q;\\n        q.push({ 0, 0 });\\n        dist[0] = 0;\\n        while (!q.empty()) {\\n            auto [i, w] = q.top();\\n            q.pop();\\n            int x = roads[i][2], y = roads[i][3];\\n            for (int j = 0; j < roads.size(); j++) {\\n                vector<int>& r = roads[j];\\n                int startX = r[0], startY = r[1], endX = r[2], endY = r[3], w2 = r[4];\\n                int distToJ = distance(x, y, startX, startY) + w + w2;\\n                if (distToJ < dist[j]) {\\n                    dist[j] = distToJ;\\n                    q.push({ j, distToJ });\\n                }\\n            }\\n        }\\n\\n        int ans = INT_MAX;\\n        for (int i = 0; i < roads.size(); i++) {\\n            vector<int> &r = roads[i];\\n            ans = min(ans, dist[i] + distance(r[2], r[3], target[0], target[1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing pi = pair<int, int>;\\nclass Solution {\\npublic:\\n    int distance(int x, int y, int x2, int y2) {\\n        return abs(x-x2) + abs(y-y2);\\n    }\\n\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        vector<vector<int>> roads;\\n        roads.push_back({ start[0], start[1], start[0], start[1], 0 });\\n        for (auto& r: specialRoads) {\\n            if (distance(r[0], r[1], r[2], r[3]) > r[4]) {\\n                roads.push_back(r);\\n            }\\n        }\\n\\n        vector<int> dist(roads.size(), INT_MAX);\\n        // priority_queue<pi, vector<pi>, greater<>> q;\\n        queue<pi> q;\\n        q.push({ 0, 0 });\\n        dist[0] = 0;\\n        while (!q.empty()) {\\n            // auto [i, w] = q.top();\\n            auto [i, w] = q.front();\\n            q.pop();\\n            int x = roads[i][2], y = roads[i][3];\\n            for (int j = 0; j < roads.size(); j++) {\\n                vector<int>& r = roads[j];\\n                int startX = r[0], startY = r[1], endX = r[2], endY = r[3], w2 = r[4];\\n                int distToJ = distance(x, y, startX, startY) + w + w2;\\n                if (distToJ < dist[j]) {\\n                    dist[j] = distToJ;\\n                    q.push({ j, distToJ });\\n                }\\n            }\\n        }\\n\\n        int ans = INT_MAX;\\n        for (int i = 0; i < roads.size(); i++) {\\n            vector<int> &r = roads[i];\\n            ans = min(ans, dist[i] + distance(r[2], r[3], target[0], target[1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\n```\\nusing pi = pair<int, int>;\\nclass Solution {\\npublic:\\n    int distance(int x, int y, int x2, int y2) {\\n        return abs(x-x2) + abs(y-y2);\\n    }\\n\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        vector<vector<int>> roads;\\n        roads.push_back({ start[0], start[1], start[0], start[1], 0 });\\n        for (auto& r: specialRoads) {\\n            if (distance(r[0], r[1], r[2], r[3]) > r[4]) {\\n                roads.push_back(r);\\n            }\\n        }\\n\\n        vector<int> dist(roads.size(), INT_MAX);\\n        priority_queue<pi, vector<pi>, greater<>> q;\\n        q.push({ 0, 0 });\\n        dist[0] = 0;\\n        while (!q.empty()) {\\n            auto [i, w] = q.top();\\n            q.pop();\\n            int x = roads[i][2], y = roads[i][3];\\n            for (int j = 0; j < roads.size(); j++) {\\n                vector<int>& r = roads[j];\\n                int startX = r[0], startY = r[1], endX = r[2], endY = r[3], w2 = r[4];\\n                int distToJ = distance(x, y, startX, startY) + w + w2;\\n                if (distToJ < dist[j]) {\\n                    dist[j] = distToJ;\\n                    q.push({ j, distToJ });\\n                }\\n            }\\n        }\\n\\n        int ans = INT_MAX;\\n        for (int i = 0; i < roads.size(); i++) {\\n            vector<int> &r = roads[i];\\n            ans = min(ans, dist[i] + distance(r[2], r[3], target[0], target[1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587518,
                "title": "they-don-t-want-you-to-know-it-trust-few",
                "content": "# Intuition\\nTrying to use the simplicity of distance formula failed miserably.\\nTrying to build a dynamic on cost wasn\\'t of good progress as well.\\n\\n# Approach\\nVector `specialRoads` consists of starting point (`[0]`, `[1]`), finish point (`[2]`, `[3]`) and cost (`[4]`). Let\\'s add `[5]` - the cheapest way to reach finish point of a road. Initially filled with the price to reach start plus price of a road usage.\\n\\nThis `[5]` will be relaxed (updated with a tightened approximation) `n-1` times. More is redundant. How? We take road `r` (to be relaxed) and for every road `R` we take price to reach finish point of `R`  plus price to move to the start of `r` plus price of road `r` usage. That\\'s it. \\n\\nLeaving a comment is welcomed. \\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$. Implementations with another $$log(n)$$ are not gonna pass\\n\\n- Space complexity: $$O(n)$$. The only liniar data we introduce is fifth coordinate of `specialRoads`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        for(auto& r : specialRoads)\\n            r.push_back(r[0]-start[0] + r[1]-start[1] + r[4]);\\n        for(int n{(int)specialRoads.size()}; --n;)\\n            for(auto& r : specialRoads)\\n                for(auto& R : specialRoads)\\n                    r[5] = min(r[5], R[5]+abs(R[2]-r[0])+abs(R[3]-r[1])+r[4]);\\n        int mn{target[0]-start[0] + target[1]-start[1]};\\n        for(auto& r: specialRoads)\\n            mn = min(mn, r[5] + target[0]-r[2] + target[1]-r[3]);\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        for(auto& r : specialRoads)\\n            r.push_back(r[0]-start[0] + r[1]-start[1] + r[4]);\\n        for(int n{(int)specialRoads.size()}; --n;)\\n            for(auto& r : specialRoads)\\n                for(auto& R : specialRoads)\\n                    r[5] = min(r[5], R[5]+abs(R[2]-r[0])+abs(R[3]-r[1])+r[4]);\\n        int mn{target[0]-start[0] + target[1]-start[1]};\\n        for(auto& r: specialRoads)\\n            mn = min(mn, r[5] + target[0]-r[2] + target[1]-r[3]);\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586429,
                "title": "floyd-warshall-method",
                "content": "# Complexity\\n- Time complexity: O(n3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n// taken prime number and converted int to long so that no collisions occur\\n    final long N = 102233l;\\n    public long getPoint(int[] p){\\n        return (long)p[0]*N + p[1];\\n    }\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        // making nodes by mapping the coordinates to one dimension\\n        HashSet<Long> h= new HashSet<>();\\n        h.add(getPoint(start));\\n        h.add(getPoint(target));\\n        for(int[] road : specialRoads){\\n            h.add(getPoint(new int[]{road[0],road[1]}));\\n            h.add(getPoint(new int[]{road[2],road[3]}));\\n        }\\n        // mapping the node to a number as they are large number to keep track\\n        // in a 2d array to find the distance between pair of nodes using floyd warshall\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        int index = 0;\\n        for(var val : h){\\n            map.put(val,index++);\\n        }\\n        //mapping cost from one node to another\\n        int[][] cost = new int[index][index];\\n        for(int i = 0; i < index; i++) \\n            Arrays.fill(cost[i],Integer.MAX_VALUE);\\n        for(var u : h){\\n            long x1 = u/N, y1 = u%N;\\n            for(var v : h){\\n                long x2 = v/N, y2 = v%N;\\n                cost[map.get(u)][map.get(v)] = (int)(Math.abs(x1 - x2) + Math.abs(y1 - y2));\\n            }\\n        }\\n        // also use specialRoads to map the cost\\n        for(int[] road : specialRoads){\\n            long num1 = getPoint(new int[]{road[0],road[1]});\\n            long num2 = getPoint(new int[]{road[2],road[3]});\\n            int u = map.get(num1), v = map.get(num2);\\n            cost[u][v] = Math.min(cost[u][v],road[4]);\\n        }\\n        for(int k = 0; k < index; k++){\\n            for(int i = 0; i < index; i++){\\n                for(int j = 0; j < index; j++){\\n                    cost[i][j] = Math.min(cost[i][j],cost[i][k] + cost[k][j]);\\n                }\\n            }\\n        }\\n        return cost[map.get(getPoint(start))][map.get(getPoint(target))];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n// taken prime number and converted int to long so that no collisions occur\\n    final long N = 102233l;\\n    public long getPoint(int[] p){\\n        return (long)p[0]*N + p[1];\\n    }\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        // making nodes by mapping the coordinates to one dimension\\n        HashSet<Long> h= new HashSet<>();\\n        h.add(getPoint(start));\\n        h.add(getPoint(target));\\n        for(int[] road : specialRoads){\\n            h.add(getPoint(new int[]{road[0],road[1]}));\\n            h.add(getPoint(new int[]{road[2],road[3]}));\\n        }\\n        // mapping the node to a number as they are large number to keep track\\n        // in a 2d array to find the distance between pair of nodes using floyd warshall\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        int index = 0;\\n        for(var val : h){\\n            map.put(val,index++);\\n        }\\n        //mapping cost from one node to another\\n        int[][] cost = new int[index][index];\\n        for(int i = 0; i < index; i++) \\n            Arrays.fill(cost[i],Integer.MAX_VALUE);\\n        for(var u : h){\\n            long x1 = u/N, y1 = u%N;\\n            for(var v : h){\\n                long x2 = v/N, y2 = v%N;\\n                cost[map.get(u)][map.get(v)] = (int)(Math.abs(x1 - x2) + Math.abs(y1 - y2));\\n            }\\n        }\\n        // also use specialRoads to map the cost\\n        for(int[] road : specialRoads){\\n            long num1 = getPoint(new int[]{road[0],road[1]});\\n            long num2 = getPoint(new int[]{road[2],road[3]});\\n            int u = map.get(num1), v = map.get(num2);\\n            cost[u][v] = Math.min(cost[u][v],road[4]);\\n        }\\n        for(int k = 0; k < index; k++){\\n            for(int i = 0; i < index; i++){\\n                for(int j = 0; j < index; j++){\\n                    cost[i][j] = Math.min(cost[i][j],cost[i][k] + cost[k][j]);\\n                }\\n            }\\n        }\\n        return cost[map.get(getPoint(start))][map.get(getPoint(target))];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551337,
                "title": "c-solution-based-on-djikstra-clean-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstruct a new graph with the special roads and new distances as edges.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEach special road can have atmost 2 unique endpoints. Therefore in total 200*2+2 = 402 total unique points.\\nNo of nodes in new graph = 402 = n;\\nNo of edges in new graph atmax = m = n*(n-1)/2;\\n\\nHence time complexity of djikstra = O(mlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n# Code\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int djikstra(int source, int target, VVI &graph, VVI &edges){\\n        int n = graph.size();\\n        VI dis(n, INT_MAX);\\n\\n        multiset<pair<int, int>> pq;\\n        pq.insert({source, 0});\\n        while(!pq.empty()){\\n            int node = pq.begin()->second, dist = pq.begin()->first;\\n            pq.erase(pq.begin());\\n\\n            if(node == target) return dist;\\n\\n            if(dis[node] > dist) dis[node] = dist;\\n            else continue;\\n\\n            for(auto x: graph[node]){\\n                if(dis[x] == INT_MAX){\\n                    pq.insert({dist + edges[node][x], x});\\n                }\\n            }\\n        }\\n        return dis[target];\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        if(start[0] == target[0] && start[1] == target[1]) return 0;\\n\\n        map<int, int> m;\\n        m[start[0]*10 + start[1]] = 0, m[target[0]*10 + target[1]] = 1;\\n        map<int, pair<int, int>> rm;\\n        rm[0] = {start[0], start[1]}, rm[1] = {target[0], target[1]};\\n\\n        int c = 2;\\n        for(auto x: specialRoads){\\n            int x1=x[0], y1=x[1], x2=x[2], y2=x[3], cost = x[4];\\n            int u = 10*x1 + y1, v = 10*x2 + y2;\\n            if(m.find(u) == m.end()) m[u] = c, rm[c++] = {x1, y1};\\n            if(m.find(v) == m.end()) m[v] = c, rm[c++] = {x2, y2};\\n        }\\n\\n        int n = m.size();\\n        VVI edges(n, VI(n, INT_MAX));\\n        for(auto x: specialRoads){\\n            int x1=x[0], y1=x[1], x2=x[2], y2=x[3], cost = x[4];\\n            int u = 10*x1 + y1, v = 10*x2 + y2;\\n            edges[m[u]][m[v]] = min(edges[m[u]][m[v]], cost);\\n        }\\n        VVI graph(n);\\n        //creat new edges for every pair of vertices\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int x1=rm[i].first, y1 = rm[i].second;\\n                int x2=rm[j].first, y2 = rm[j].second;\\n                edges[i][j] = min(edges[i][j], abs(x1-x2) + abs(y1-y2));\\n                if(edges[i][j] != INT_MAX && i != j){\\n                    graph[i].push_back(j);\\n                }\\n            }\\n        }\\n        return djikstra(0, 1, graph, edges);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int djikstra(int source, int target, VVI &graph, VVI &edges){\\n        int n = graph.size();\\n        VI dis(n, INT_MAX);\\n\\n        multiset<pair<int, int>> pq;\\n        pq.insert({source, 0});\\n        while(!pq.empty()){\\n            int node = pq.begin()->second, dist = pq.begin()->first;\\n            pq.erase(pq.begin());\\n\\n            if(node == target) return dist;\\n\\n            if(dis[node] > dist) dis[node] = dist;\\n            else continue;\\n\\n            for(auto x: graph[node]){\\n                if(dis[x] == INT_MAX){\\n                    pq.insert({dist + edges[node][x], x});\\n                }\\n            }\\n        }\\n        return dis[target];\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        if(start[0] == target[0] && start[1] == target[1]) return 0;\\n\\n        map<int, int> m;\\n        m[start[0]*10 + start[1]] = 0, m[target[0]*10 + target[1]] = 1;\\n        map<int, pair<int, int>> rm;\\n        rm[0] = {start[0], start[1]}, rm[1] = {target[0], target[1]};\\n\\n        int c = 2;\\n        for(auto x: specialRoads){\\n            int x1=x[0], y1=x[1], x2=x[2], y2=x[3], cost = x[4];\\n            int u = 10*x1 + y1, v = 10*x2 + y2;\\n            if(m.find(u) == m.end()) m[u] = c, rm[c++] = {x1, y1};\\n            if(m.find(v) == m.end()) m[v] = c, rm[c++] = {x2, y2};\\n        }\\n\\n        int n = m.size();\\n        VVI edges(n, VI(n, INT_MAX));\\n        for(auto x: specialRoads){\\n            int x1=x[0], y1=x[1], x2=x[2], y2=x[3], cost = x[4];\\n            int u = 10*x1 + y1, v = 10*x2 + y2;\\n            edges[m[u]][m[v]] = min(edges[m[u]][m[v]], cost);\\n        }\\n        VVI graph(n);\\n        //creat new edges for every pair of vertices\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int x1=rm[i].first, y1 = rm[i].second;\\n                int x2=rm[j].first, y2 = rm[j].second;\\n                edges[i][j] = min(edges[i][j], abs(x1-x2) + abs(y1-y2));\\n                if(edges[i][j] != INT_MAX && i != j){\\n                    graph[i].push_back(j);\\n                }\\n            }\\n        }\\n        return djikstra(0, 1, graph, edges);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529815,
                "title": "c-dijkstra-algo-set",
                "content": "```\\nclass Solution {\\n     int dijkstra(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads)\\n    {\\n        int n = specialRoads.size();\\n        vector<int> dist(n);\\n        set<pair<int,int>>st;\\n        for (int i = 0; i < n; i++) {\\n                int newdist = abs(start[0] - specialRoads[i][0]) +\\n                              abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];\\n            \\n          int olddist = abs(start[0] - specialRoads[i][2]) +\\n                        abs(start[1] - specialRoads[i][3]);\\n            \\n              dist[i]=min(newdist,olddist);\\n              st.insert({dist[i], i});\\n        }\\n        int minCost = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n        while (!st.empty()) {\\n            auto [currdist, Road_num] = *st.begin();\\n            st.erase({currdist, Road_num});\\n            if (currdist != dist[Road_num])\\n                continue;\\n            minCost = min(minCost, currdist + \\n                          abs(target[0] - specialRoads[Road_num][2]) +\\n                           abs(target[1]-specialRoads[Road_num][3]));\\n            \\n            \\n            for (int newRoad = 0; newRoad < n; newRoad++) {\\n                int wt = abs(specialRoads[Road_num][2] -   specialRoads[newRoad][0]) + abs(specialRoads[Road_num][3]  -  specialRoads[newRoad][1]) + specialRoads[newRoad][4];\\n                if (currdist + wt < dist[newRoad]) {\\n                    st.erase({dist[newRoad], newRoad});\\n                    dist[newRoad] = currdist + wt;\\n                    st.insert({dist[newRoad], newRoad});\\n                }\\n            }\\n        }\\n        return minCost;\\n    }\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        return  dijkstra(start,target,specialRoads);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n     int dijkstra(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads)\\n    {\\n        int n = specialRoads.size();\\n        vector<int> dist(n);\\n        set<pair<int,int>>st;\\n        for (int i = 0; i < n; i++) {\\n                int newdist = abs(start[0] - specialRoads[i][0]) +\\n                              abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];\\n            \\n          int olddist = abs(start[0] - specialRoads[i][2]) +\\n                        abs(start[1] - specialRoads[i][3]);\\n            \\n              dist[i]=min(newdist,olddist);\\n              st.insert({dist[i], i});\\n        }\\n        int minCost = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n        while (!st.empty()) {\\n            auto [currdist, Road_num] = *st.begin();\\n            st.erase({currdist, Road_num});\\n            if (currdist != dist[Road_num])\\n                continue;\\n            minCost = min(minCost, currdist + \\n                          abs(target[0] - specialRoads[Road_num][2]) +\\n                           abs(target[1]-specialRoads[Road_num][3]));\\n            \\n            \\n            for (int newRoad = 0; newRoad < n; newRoad++) {\\n                int wt = abs(specialRoads[Road_num][2] -   specialRoads[newRoad][0]) + abs(specialRoads[Road_num][3]  -  specialRoads[newRoad][1]) + specialRoads[newRoad][4];\\n                if (currdist + wt < dist[newRoad]) {\\n                    st.erase({dist[newRoad], newRoad});\\n                    dist[newRoad] = currdist + wt;\\n                    st.insert({dist[newRoad], newRoad});\\n                }\\n            }\\n        }\\n        return minCost;\\n    }\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        return  dijkstra(start,target,specialRoads);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518757,
                "title": "easy-solution-c",
                "content": "```\\n// Define a min-heap priority queue to store pairs of distance and index\\ntemplate<class T> using MinPriorityQueue = priority_queue<T, vector<T>, greater<T>>;\\n\\nclass Solution {\\npublic:\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        \\n        const int INF = 1e9+10;\\n        int numSpecialRoads = specialRoads.size();\\n\\n        // Initialize the distance of each special road to infinity\\n        vector<int> distance(numSpecialRoads, INF);\\n\\n        // Create a priority queue and push the distance from start to each special road\\n        MinPriorityQueue<pair<int, int>> pq;\\n        for (int i = 0; i < numSpecialRoads; i++) {\\n            distance[i] = abs(start[0] - specialRoads[i][0]) + abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];\\n            pq.push({distance[i], i});\\n        }\\n        \\n        // Initialize the answer with the Manhattan distance between start and target\\n        int minCost = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n\\n        // Continue to search for the shortest path until the priority queue is empty\\n        while (!pq.empty()) {\\n            // Pop the pair with the smallest distance\\n            auto [currentDistance, currentRoad] = pq.top();\\n            pq.pop();\\n\\n            // If the distance stored in \\'distance\\' is not equal to the current distance \\'currentDistance\\', skip this node\\n            if (currentDistance != distance[currentRoad])\\n                continue;\\n\\n            // Update the answer by finding the distance from the current special road to the target\\n            minCost = min(minCost, currentDistance + abs(target[0] - specialRoads[currentRoad][2]) + abs(target[1] - specialRoads[currentRoad][3]));\\n\\n            // For each special road that can be reached from the current special road, update its distance\\n            for (int nextRoad = 0; nextRoad < numSpecialRoads; nextRoad++) {\\n                int weight = abs(specialRoads[currentRoad][2] - specialRoads[nextRoad][0]) + abs(specialRoads[currentRoad][3] - specialRoads[nextRoad][1]) + specialRoads[nextRoad][4];\\n                if (currentDistance + weight < distance[nextRoad]) {\\n                    distance[nextRoad] = currentDistance + weight;\\n                    pq.push({distance[nextRoad], nextRoad});\\n                }\\n            }\\n        }\\n\\n        // Return the minimum cost of reaching the target\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Define a min-heap priority queue to store pairs of distance and index\\ntemplate<class T> using MinPriorityQueue = priority_queue<T, vector<T>, greater<T>>;\\n\\nclass Solution {\\npublic:\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        \\n        const int INF = 1e9+10;\\n        int numSpecialRoads = specialRoads.size();\\n\\n        // Initialize the distance of each special road to infinity\\n        vector<int> distance(numSpecialRoads, INF);\\n\\n        // Create a priority queue and push the distance from start to each special road\\n        MinPriorityQueue<pair<int, int>> pq;\\n        for (int i = 0; i < numSpecialRoads; i++) {\\n            distance[i] = abs(start[0] - specialRoads[i][0]) + abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];\\n            pq.push({distance[i], i});\\n        }\\n        \\n        // Initialize the answer with the Manhattan distance between start and target\\n        int minCost = abs(start[0] - target[0]) + abs(start[1] - target[1]);\\n\\n        // Continue to search for the shortest path until the priority queue is empty\\n        while (!pq.empty()) {\\n            // Pop the pair with the smallest distance\\n            auto [currentDistance, currentRoad] = pq.top();\\n            pq.pop();\\n\\n            // If the distance stored in \\'distance\\' is not equal to the current distance \\'currentDistance\\', skip this node\\n            if (currentDistance != distance[currentRoad])\\n                continue;\\n\\n            // Update the answer by finding the distance from the current special road to the target\\n            minCost = min(minCost, currentDistance + abs(target[0] - specialRoads[currentRoad][2]) + abs(target[1] - specialRoads[currentRoad][3]));\\n\\n            // For each special road that can be reached from the current special road, update its distance\\n            for (int nextRoad = 0; nextRoad < numSpecialRoads; nextRoad++) {\\n                int weight = abs(specialRoads[currentRoad][2] - specialRoads[nextRoad][0]) + abs(specialRoads[currentRoad][3] - specialRoads[nextRoad][1]) + specialRoads[nextRoad][4];\\n                if (currentDistance + weight < distance[nextRoad]) {\\n                    distance[nextRoad] = currentDistance + weight;\\n                    pq.push({distance[nextRoad], nextRoad});\\n                }\\n            }\\n        }\\n\\n        // Return the minimum cost of reaching the target\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512223,
                "title": "javascript-step-by-step-solution-using-dijkstra",
                "content": "1.) The minimumCost function takes three parameters: start, target, and specialRoads. These represent the starting position, the target position, and an array of \"special roads\" that can be used to travel between positions. The function returns the minimum cost to travel from the starting position to the target position using the given roads.\\n\\n2.) The getId function takes two arguments, x and y, and returns a string representation of their combination. This is used to uniquely identify positions in the graph.\\n\\n3.) The cost function takes four arguments, representing two positions, and returns the cost of traveling between them. This is calculated as the Manhattan distance between the two positions.\\n\\n4.) The getMinCost function takes two arguments, prev and cost, and returns the minimum between them. This is used to keep track of the minimum cost to travel to a given position.\\n\\n5.) The buildGraph function takes three arguments, representing the starting position, the target position, and the array of special roads. It creates a graph representing the connections between the positions in the problem.\\n\\n6.) The minimumCost function initializes some variables. It gets the starting and target position IDs using the getId function, builds the graph using the buildGraph function, and initializes a dp object to keep track of the minimum cost to travel to each position. It also initializes a priority queue using the MinPriorityQueue library, which will be used to prioritize the positions to be visited.\\n\\n7.) The while loop continues until the priority queue is empty. Inside the loop, the function dequeues the next position to be visited, which is the position with the minimum cost in the dp object. If this position is the target position, the loop continues.\\n\\n8.) The function loops through all the neighbors of the current position in the graph, calculates the distance to travel to them, and updates the dp object with the minimum cost to travel to the neighbor. If the minimum cost is updated, the neighbor is enqueued in the priority queue.\\n\\n9.) Once all the neighbors have been visited, the function returns the minimum cost to travel to the target position from the dp object.\\n\\n10.) The buildGraph function initializes a graph object to represent the connections between the positions in the problem. It loops through the special roads array and adds connections between the end of one road and the start of another. It then adds connections between the start and end points of each road, and connections between the start position and the ends of each road, and the start of each road and the target position.\\n\\n11.) The buildGraph function returns the graph object, which represents all the connections between positions in the problem.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nvar minimumCost = function(start, target, specialRoads) {\\n    const startArgId = getId(start[0], start[1]);\\n    const targetArgId = getId(target[0], target[1]);\\n    const graph = buildGraph(start, target, specialRoads);\\n    \\n    const dp = {\\n        [startArgId]: 0,\\n        [targetArgId]: targetArgId === startArgId ? 0 : Number.MAX_SAFE_INTEGER,\\n    }\\n    \\n    const queue = new MinPriorityQueue({ priority: (e) => e.min });\\n    queue.enqueue({ node: startArgId, min: 0 });\\n    \\n    while(!queue.isEmpty()) {\\n        const { node, min: currentDistance } = queue.dequeue().element;\\n        \\n        if (node === targetArgId) {\\n            continue;\\n        }\\n        \\n        for (const neibor of Object.keys(graph[node])) {\\n            const distance = (dp[node] !== undefined ? dp[node] : Number.MAX_SAFE_INTEGER) + graph[node][neibor];\\n            \\n            if (dp[neibor] === undefined || distance < dp[neibor]) {\\n                dp[neibor] = distance;\\n                queue.enqueue({ node: neibor, min: dp[neibor] });\\n            }\\n        }\\n    }\\n    \\n    return dp[targetArgId];\\n};\\n\\nconst cost = (x1, y1, x2, y2) => Math.abs(x2 - x1) + Math.abs(y2 - y1)\\nconst getId = (x, y) => `${x}-${y}`;\\nconst getMinCost = (prev, cost) => prev === undefined ? cost : Math.min(prev, cost);\\n\\nconst buildGraph = (start, target, specialRoads) => {\\n    const startArgId = getId(start[0], start[1]);\\n    const targetArgId = getId(target[0], target[1]);\\n    const graph = {\\n        [startArgId]: {\\n            [targetArgId]: cost(start[0], start[1], target[0], target[1]),\\n        }\\n    };\\n    \\n    // connections between roads\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        for (let j = 0; j < specialRoads.length; j++) {\\n            if (i === j) {\\n                continue;\\n            }\\n            \\n            const [,, x2, y2] = specialRoads[i]; // begin from end of i-th road\\n            const idStart = getId(x2, y2);\\n            const [x1, y1] = specialRoads[j]; // end in start for j-th road\\n            const idEnd = getId(x1, y1);\\n            \\n            if (idStart === idEnd) {\\n                continue;\\n            }\\n\\n            if(!graph[idStart]) {\\n                graph[idStart] = {};\\n            }\\n            \\n            graph[idStart][idEnd] = getMinCost(graph[idStart][idEnd], cost(x2, y2, x1, y1));\\n        }\\n    }\\n    \\n    //roads itself\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [x1, y1, x2, y2, cost] = specialRoads[i];\\n        const idStart = getId(x1, y1);\\n        const idEnd = getId(x2, y2);\\n\\n        if (idStart === idEnd) {\\n            continue;\\n        }\\n\\n        if(!graph[idStart]) {\\n            graph[idStart] = {};\\n        }\\n        \\n        graph[idStart][idEnd] = getMinCost(graph[idStart][idEnd], cost);\\n    }\\n    \\n    //connections with start\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [x1, y1] = specialRoads[i];\\n        const idEnd = getId(x1, y1);\\n\\n        if (startArgId === idEnd) {\\n            continue;\\n        }\\n\\n        graph[startArgId][idEnd] = getMinCost(graph[startArgId][idEnd], cost(start[0], start[1], x1, y1));\\n    }\\n    \\n    //connections with end\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [,, x2, y2] = specialRoads[i];\\n        const idStart = getId(x2, y2);\\n        \\n        if (idStart === targetArgId) {\\n            continue;\\n        }\\n\\n        if(!graph[idStart]) {\\n            graph[idStart] = {};\\n        }\\n\\n        graph[idStart][targetArgId] = getMinCost(graph[idStart][targetArgId], cost(x2, y2, target[0], target[1]));\\n    }\\n    \\n    return graph;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nvar minimumCost = function(start, target, specialRoads) {\\n    const startArgId = getId(start[0], start[1]);\\n    const targetArgId = getId(target[0], target[1]);\\n    const graph = buildGraph(start, target, specialRoads);\\n    \\n    const dp = {\\n        [startArgId]: 0,\\n        [targetArgId]: targetArgId === startArgId ? 0 : Number.MAX_SAFE_INTEGER,\\n    }\\n    \\n    const queue = new MinPriorityQueue({ priority: (e) => e.min });\\n    queue.enqueue({ node: startArgId, min: 0 });\\n    \\n    while(!queue.isEmpty()) {\\n        const { node, min: currentDistance } = queue.dequeue().element;\\n        \\n        if (node === targetArgId) {\\n            continue;\\n        }\\n        \\n        for (const neibor of Object.keys(graph[node])) {\\n            const distance = (dp[node] !== undefined ? dp[node] : Number.MAX_SAFE_INTEGER) + graph[node][neibor];\\n            \\n            if (dp[neibor] === undefined || distance < dp[neibor]) {\\n                dp[neibor] = distance;\\n                queue.enqueue({ node: neibor, min: dp[neibor] });\\n            }\\n        }\\n    }\\n    \\n    return dp[targetArgId];\\n};\\n\\nconst cost = (x1, y1, x2, y2) => Math.abs(x2 - x1) + Math.abs(y2 - y1)\\nconst getId = (x, y) => `${x}-${y}`;\\nconst getMinCost = (prev, cost) => prev === undefined ? cost : Math.min(prev, cost);\\n\\nconst buildGraph = (start, target, specialRoads) => {\\n    const startArgId = getId(start[0], start[1]);\\n    const targetArgId = getId(target[0], target[1]);\\n    const graph = {\\n        [startArgId]: {\\n            [targetArgId]: cost(start[0], start[1], target[0], target[1]),\\n        }\\n    };\\n    \\n    // connections between roads\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        for (let j = 0; j < specialRoads.length; j++) {\\n            if (i === j) {\\n                continue;\\n            }\\n            \\n            const [,, x2, y2] = specialRoads[i]; // begin from end of i-th road\\n            const idStart = getId(x2, y2);\\n            const [x1, y1] = specialRoads[j]; // end in start for j-th road\\n            const idEnd = getId(x1, y1);\\n            \\n            if (idStart === idEnd) {\\n                continue;\\n            }\\n\\n            if(!graph[idStart]) {\\n                graph[idStart] = {};\\n            }\\n            \\n            graph[idStart][idEnd] = getMinCost(graph[idStart][idEnd], cost(x2, y2, x1, y1));\\n        }\\n    }\\n    \\n    //roads itself\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [x1, y1, x2, y2, cost] = specialRoads[i];\\n        const idStart = getId(x1, y1);\\n        const idEnd = getId(x2, y2);\\n\\n        if (idStart === idEnd) {\\n            continue;\\n        }\\n\\n        if(!graph[idStart]) {\\n            graph[idStart] = {};\\n        }\\n        \\n        graph[idStart][idEnd] = getMinCost(graph[idStart][idEnd], cost);\\n    }\\n    \\n    //connections with start\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [x1, y1] = specialRoads[i];\\n        const idEnd = getId(x1, y1);\\n\\n        if (startArgId === idEnd) {\\n            continue;\\n        }\\n\\n        graph[startArgId][idEnd] = getMinCost(graph[startArgId][idEnd], cost(start[0], start[1], x1, y1));\\n    }\\n    \\n    //connections with end\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [,, x2, y2] = specialRoads[i];\\n        const idStart = getId(x2, y2);\\n        \\n        if (idStart === targetArgId) {\\n            continue;\\n        }\\n\\n        if(!graph[idStart]) {\\n            graph[idStart] = {};\\n        }\\n\\n        graph[idStart][targetArgId] = getMinCost(graph[idStart][targetArgId], cost(x2, y2, target[0], target[1]));\\n    }\\n    \\n    return graph;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502687,
                "title": "javascript-dijkstra",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nvar minimumCost = function (start, target, specialRoads) {\\n  const filteredRoads = [];\\n  for (const road of specialRoads) {\\n    const [x1, y1, x2, y2, cost] = road;\\n\\n    const normalCost = Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    if (cost < normalCost) {\\n      filteredRoads.push(road);\\n    }\\n  }\\n\\n  const minHeap = new MinHeap([]);\\n  minHeap.insert([start[0], 0, start[1]]);\\n  const map = {};\\n\\n  while (minHeap.getLength()) {\\n    const [x, costSoFar, y] = minHeap.remove();\\n\\n    for (const road of filteredRoads) {\\n      const [x1, y1, x2, y2, cost] = road;\\n\\n      const costToNextRoad = Math.abs(x - x1) + Math.abs(y - y1);\\n      const totalCost = costSoFar + costToNextRoad + cost;\\n      const key = [x2, y2].join(\\'-\\');\\n      if (!(key in map) || map[key] > totalCost) {\\n        map[key] = totalCost;\\n        minHeap.insert([x2, totalCost, y2]);\\n      }\\n    }\\n  }\\n\\n  let ans = Math.abs(start[0] - target[0]) + Math.abs(start[1] - target[1]);\\n  for (const [_, __, x2, y2, ___] of specialRoads) {\\n    const key = [x2, y2].join(\\'-\\');\\n    if (!(key in map)) continue;\\n\\n    const costToTarget = Math.abs(x2 - target[0]) + Math.abs(y2 - target[1]);\\n    ans = Math.min(ans, map[key] + costToTarget);\\n  }\\n\\n  return ans;\\n};\\n\\n```\\n[MinHeap](https://github.com/faustaleonardo/data-structure-in-js/blob/main/MinHeapWithArray.js)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nvar minimumCost = function (start, target, specialRoads) {\\n  const filteredRoads = [];\\n  for (const road of specialRoads) {\\n    const [x1, y1, x2, y2, cost] = road;\\n\\n    const normalCost = Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    if (cost < normalCost) {\\n      filteredRoads.push(road);\\n    }\\n  }\\n\\n  const minHeap = new MinHeap([]);\\n  minHeap.insert([start[0], 0, start[1]]);\\n  const map = {};\\n\\n  while (minHeap.getLength()) {\\n    const [x, costSoFar, y] = minHeap.remove();\\n\\n    for (const road of filteredRoads) {\\n      const [x1, y1, x2, y2, cost] = road;\\n\\n      const costToNextRoad = Math.abs(x - x1) + Math.abs(y - y1);\\n      const totalCost = costSoFar + costToNextRoad + cost;\\n      const key = [x2, y2].join(\\'-\\');\\n      if (!(key in map) || map[key] > totalCost) {\\n        map[key] = totalCost;\\n        minHeap.insert([x2, totalCost, y2]);\\n      }\\n    }\\n  }\\n\\n  let ans = Math.abs(start[0] - target[0]) + Math.abs(start[1] - target[1]);\\n  for (const [_, __, x2, y2, ___] of specialRoads) {\\n    const key = [x2, y2].join(\\'-\\');\\n    if (!(key in map)) continue;\\n\\n    const costToTarget = Math.abs(x2 - target[0]) + Math.abs(y2 - target[1]);\\n    ans = Math.min(ans, map[key] + costToTarget);\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496649,
                "title": "c-solution-dijkshtra",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic: \\n    int cost(int a,int b,int c,int d){\\n        return abs(a-c)+abs(b-d);\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n\\t\\tset<pair<int,int>> s;\\n        set<pair<int,int>> st;\\n        map<pair<int,int>,int> idx;\\n        \\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        \\n        for(auto x:specialRoads){\\n            st.insert({x[0],x[1]});\\n            st.insert({x[2],x[3]});\\n        }\\n        \\n        int in=0;\\n        for(auto x:st){\\n            idx[x]=in++;\\n        }\\n        \\n        list<pair<int, int> > *l2;\\n        l2 = new list<pair<int, int> >[in];\\n\\n        \\n        int src=idx[{start[0],start[1]}];\\n        int dest=idx[{target[0],target[1]}];\\n        \\n        l2[src].push_back({cost(start[0],start[1],target[0],target[1]),dest});\\n        \\n        for(auto x:specialRoads){\\n            l2[src].push_back({cost(x[0],x[1],start[0],start[1]),idx[{x[0],x[1]}]});\\n            l2[idx[{x[0],x[1]}]].push_back({x[4],idx[{x[2],x[3]}]});\\n            l2[idx[{x[2],x[3]}]].push_back({cost(x[2],x[3],target[0],target[1]),dest});\\n            \\n            for(auto y:specialRoads){\\n                if(y==x) continue;\\n                \\n                int spo=idx[{y[0],y[1]}];\\n                int spe=idx[{y[2],y[3]}];\\n                \\n                int cost1=cost(x[2],x[3],y[0],y[1]);\\n                int cost2=cost(x[0],x[1],y[2],y[3]);\\n                \\n                l2[idx[{x[2],x[3]}]].push_back({cost1,spo});\\n                l2[spe].push_back({cost2,idx[{x[0],x[1]}]});\\n            }\\n        }\\n        \\n        vector<int> dist(in, INT_MAX);\\n\\t\\tdist[src] = 0;\\n\\t\\ts.insert({0, src});\\n\\n\\t\\twhile (!s.empty()) {\\n\\t\\t\\tauto it = s.begin();\\n\\t\\t\\tint node = it->second;\\n\\t\\t\\tint disttillnow = it->first;\\n\\t\\t\\ts.erase(it);\\n\\n\\t\\t\\tfor (auto nbrPair : l2[node]) {\\n\\t\\t\\t\\tint nbr = nbrPair.second;\\n\\t\\t\\t\\tint currentEdge = nbrPair.first;\\n\\n\\t\\t\\t\\tif (disttillnow + currentEdge < dist[nbr]) {\\n\\t\\t\\t\\t\\tauto f = s.find({dist[nbr], nbr});\\n\\n\\t\\t\\t\\t\\tif (f != s.end()) {\\n\\t\\t\\t\\t\\t\\ts.erase(f);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdist[nbr] = disttillnow + currentEdge;\\n\\t\\t\\t\\t\\ts.insert({dist[nbr], nbr});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dist[dest];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int cost(int a,int b,int c,int d){\\n        return abs(a-c)+abs(b-d);\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n\\t\\tset<pair<int,int>> s;\\n        set<pair<int,int>> st;\\n        map<pair<int,int>,int> idx;\\n        \\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        \\n        for(auto x:specialRoads){\\n            st.insert({x[0],x[1]});\\n            st.insert({x[2],x[3]});\\n        }\\n        \\n        int in=0;\\n        for(auto x:st){\\n            idx[x]=in++;\\n        }\\n        \\n        list<pair<int, int> > *l2;\\n        l2 = new list<pair<int, int> >[in];\\n\\n        \\n        int src=idx[{start[0],start[1]}];\\n        int dest=idx[{target[0],target[1]}];\\n        \\n        l2[src].push_back({cost(start[0],start[1],target[0],target[1]),dest});\\n        \\n        for(auto x:specialRoads){\\n            l2[src].push_back({cost(x[0],x[1],start[0],start[1]),idx[{x[0],x[1]}]});\\n            l2[idx[{x[0],x[1]}]].push_back({x[4],idx[{x[2],x[3]}]});\\n            l2[idx[{x[2],x[3]}]].push_back({cost(x[2],x[3],target[0],target[1]),dest});\\n            \\n            for(auto y:specialRoads){\\n                if(y==x) continue;\\n                \\n                int spo=idx[{y[0],y[1]}];\\n                int spe=idx[{y[2],y[3]}];\\n                \\n                int cost1=cost(x[2],x[3],y[0],y[1]);\\n                int cost2=cost(x[0],x[1],y[2],y[3]);\\n                \\n                l2[idx[{x[2],x[3]}]].push_back({cost1,spo});\\n                l2[spe].push_back({cost2,idx[{x[0],x[1]}]});\\n            }\\n        }\\n        \\n        vector<int> dist(in, INT_MAX);\\n\\t\\tdist[src] = 0;\\n\\t\\ts.insert({0, src});\\n\\n\\t\\twhile (!s.empty()) {\\n\\t\\t\\tauto it = s.begin();\\n\\t\\t\\tint node = it->second;\\n\\t\\t\\tint disttillnow = it->first;\\n\\t\\t\\ts.erase(it);\\n\\n\\t\\t\\tfor (auto nbrPair : l2[node]) {\\n\\t\\t\\t\\tint nbr = nbrPair.second;\\n\\t\\t\\t\\tint currentEdge = nbrPair.first;\\n\\n\\t\\t\\t\\tif (disttillnow + currentEdge < dist[nbr]) {\\n\\t\\t\\t\\t\\tauto f = s.find({dist[nbr], nbr});\\n\\n\\t\\t\\t\\t\\tif (f != s.end()) {\\n\\t\\t\\t\\t\\t\\ts.erase(f);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdist[nbr] = disttillnow + currentEdge;\\n\\t\\t\\t\\t\\ts.insert({dist[nbr], nbr});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dist[dest];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496182,
                "title": "javascript-build-graph-dijkstra-245ms",
                "content": "```\\nconst minimumCost = (a, b, c) => {\\n    let m = new Map(), g = [];\\n    let A = build(m, g, a[0], a[1]), B = build(m, g, b[0], b[1]);\\n    g[A].push([B, cal(a[0], a[1], b[0], b[1])])\\n    for (const [x1, y1, x2, y2, cost] of c) {\\n        let u = build(m, g, x1, y1), v = build(m, g, x2, y2);\\n        g[A].push([u, cal(x1, y1, a[0], a[1])]);\\n        g[v].push([B, cal(x2, y2, b[0], b[1])]);\\n        g[u].push([v, cost]);\\n        for (const [xx, yy,] of c) {\\n            let xxyy = build(m, g, xx, yy);\\n            g[v].push([xxyy, cal(x2, y2, xx, yy)]);\\n        }\\n    }\\n    let d = dijkstra(g, A);\\n    return d[B];\\n}\\n\\nconst build = (m, g, x, y) => {\\n    let ke = x + \" \" + y;\\n    if (m.has(ke)) return m.get(ke);\\n    m.set(ke, g.length);\\n    g.push([]);\\n    return m.get(ke);\\n};\\n\\nconst cal = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n\\nconst dijkstra = (g, start) => {\\n    let n = g.length, dis = Array(n).fill(Number.MAX_SAFE_INTEGER);\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            return x[1] - y[1];\\n        }\\n    });\\n    dis[start] = 0;\\n    pq.enqueue([0, start]);\\n    while (pq.size()) {\\n        let [d, cur] = pq.dequeue();\\n        if (d > dis[cur]) continue;\\n        for (const [child, cost] of g[cur]) {\\n            let toChildCost = d + cost;\\n            if (toChildCost < dis[child]) {\\n                dis[child] = toChildCost;\\n                pq.enqueue([toChildCost, child]);\\n            }\\n        }\\n    }\\n    return dis;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nconst minimumCost = (a, b, c) => {\\n    let m = new Map(), g = [];\\n    let A = build(m, g, a[0], a[1]), B = build(m, g, b[0], b[1]);\\n    g[A].push([B, cal(a[0], a[1], b[0], b[1])])\\n    for (const [x1, y1, x2, y2, cost] of c) {\\n        let u = build(m, g, x1, y1), v = build(m, g, x2, y2);\\n        g[A].push([u, cal(x1, y1, a[0], a[1])]);\\n        g[v].push([B, cal(x2, y2, b[0], b[1])]);\\n        g[u].push([v, cost]);\\n        for (const [xx, yy,] of c) {\\n            let xxyy = build(m, g, xx, yy);\\n            g[v].push([xxyy, cal(x2, y2, xx, yy)]);\\n        }\\n    }\\n    let d = dijkstra(g, A);\\n    return d[B];\\n}\\n\\nconst build = (m, g, x, y) => {\\n    let ke = x + \" \" + y;\\n    if (m.has(ke)) return m.get(ke);\\n    m.set(ke, g.length);\\n    g.push([]);\\n    return m.get(ke);\\n};\\n\\nconst cal = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n\\nconst dijkstra = (g, start) => {\\n    let n = g.length, dis = Array(n).fill(Number.MAX_SAFE_INTEGER);\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            return x[1] - y[1];\\n        }\\n    });\\n    dis[start] = 0;\\n    pq.enqueue([0, start]);\\n    while (pq.size()) {\\n        let [d, cur] = pq.dequeue();\\n        if (d > dis[cur]) continue;\\n        for (const [child, cost] of g[cur]) {\\n            let toChildCost = d + cost;\\n            if (toChildCost < dis[child]) {\\n                dis[child] = toChildCost;\\n                pq.enqueue([toChildCost, child]);\\n            }\\n        }\\n    }\\n    return dis;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494403,
                "title": "clean-dijkstra-s-algorithm-with-brief-discussion",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Dijkstra\\'s algorithm\\n\\t\\n    Ingredients: 1. dict to retrieve src to node distance; 2. minHeap to do relaxation\\n    \\n    Here we could add target info to the specialRoads for convenience.\\n    \"\"\"\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        \\n        # 0. preparation\\n        specialRoads = [[a, b, c, d, x] for a, b, c, d, x in specialRoads if x < abs(a - c) + abs(b - d)]\\n        specialRoads.append([target[0], target[1], target[0], target[1], 0])\\n        \\n        # 1. Dijkstra\\'s algorithm\\n        dist = {tuple(start): 0}\\n        heap = [(0, *start)]\\n        while heap:\\n            currdist, x, y = heapq.heappop(heap)\\n            if (x, y) == tuple(target):\\n                return currdist\\n            \\n            # check if relaxation is available\\n            if currdist > dist.get((x, y), float(\"inf\")):\\n                continue\\n            for a, b, c, d, cost in specialRoads:\\n                tmp = currdist + abs(x - a) + abs(y - b) + cost\\n                if dist.get((c, d), float(\\'inf\\')) > tmp:\\n                    dist[(c, d)] = tmp\\n                    heapq.heappush(heap, (tmp, c, d))\\n        \\n                    \\n        # return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Dijkstra\\'s algorithm\\n\\t\\n    Ingredients: 1. dict to retrieve src to node distance; 2. minHeap to do relaxation\\n    \\n    Here we could add target info to the specialRoads for convenience.\\n    \"\"\"\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        \\n        # 0. preparation\\n        specialRoads = [[a, b, c, d, x] for a, b, c, d, x in specialRoads if x < abs(a - c) + abs(b - d)]\\n        specialRoads.append([target[0], target[1], target[0], target[1], 0])\\n        \\n        # 1. Dijkstra\\'s algorithm\\n        dist = {tuple(start): 0}\\n        heap = [(0, *start)]\\n        while heap:\\n            currdist, x, y = heapq.heappop(heap)\\n            if (x, y) == tuple(target):\\n                return currdist\\n            \\n            # check if relaxation is available\\n            if currdist > dist.get((x, y), float(\"inf\")):\\n                continue\\n            for a, b, c, d, cost in specialRoads:\\n                tmp = currdist + abs(x - a) + abs(y - b) + cost\\n                if dist.get((c, d), float(\\'inf\\')) > tmp:\\n                    dist[(c, d)] = tmp\\n                    heapq.heappush(heap, (tmp, c, d))\\n        \\n                    \\n        # return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494378,
                "title": "c-easy-to-understand-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can see the special roads constraints as 200 and the direction we can move is not up,down,left,right , but it also can choose special Roads and provide the minimum cost to reach destination. So we will be using dijkshtra algorithm here.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nMaintain the edge from start to end , start to specialRoadStart , start to specialRoadEnd, specialRoadEnd to end, and from every special road another special roads make edges.\\nthen we can simply use dijkstra to find shortest path.\\n\\n![Screenshot 2023-05-07 at 3.17.24 AM.png](https://assets.leetcode.com/users/images/c92bda53-75f3-4177-bcce-69105fd2f580_1683409665.824908.png)\\n\\nPlease UPVOTE Me ...................................\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& st, vector<int>& tr, vector<vector<int>>& sr) { \\n        map<pair<int,int>,vector<pair<int,pair<int,int>>>> gr;\\n        \\n        int si = st[0],sj = st[1], ti=tr[0],tj=tr[1];\\n        gr[{si,sj}].push_back({abs(ti-si)+abs(tj-sj),{ti,tj}});\\n        \\n        for(int i = 0 ; i < sr.size(); i++)\\n        {\\n            int u1i = sr[i][0],u1j = sr[i][1],v1i = sr[i][2],v1j = sr[i][3], c = sr[i][4];\\n            \\n            gr[{si,sj}].push_back({abs(u1i-si)+abs(u1j-sj),{u1i,u1j}});\\n            gr[{si,sj}].push_back({abs(v1i-si)+abs(v1j-sj),{v1i,v1j}});\\n            \\n            gr[{u1i,u1j}].push_back({c,{v1i,v1j}});\\n            \\n            gr[{u1i,u1j}].push_back({abs(ti-u1i)+abs(tj-u1j),{ti,tj}});\\n            gr[{v1i,v1j}].push_back({abs(ti-v1i)+abs(tj-v1j),{ti,tj}});\\n            \\n            for(int j = i+1; j < sr.size(); j++)\\n            {\\n                int u2i = sr[j][0],u2j = sr[j][1],v2i = sr[j][2],v2j = sr[j][3], c2 = sr[j][4];\\n                \\n                gr[{u1i,u1j}].push_back({abs(u1i-u2i)+abs(u1j-u2j),{u2i,u2j}});\\n                gr[{u2i,u2j}].push_back({abs(u1i-u2i)+abs(u1j-u2j),{u1i,u1j}});\\n                \\n                gr[{v1i,v1j}].push_back({abs(v1i-u2i)+abs(v1j-u2j),{u2i,u2j}});\\n                gr[{u2i,u2j}].push_back({abs(v1i-u2i)+abs(v1j-u2j),{v1i,v1j}});\\n                \\n                gr[{u1i,u1j}].push_back({abs(u1i-v2i)+abs(u1j-v2j),{v2i,v2j}});\\n                gr[{v2i,v2j}].push_back({abs(u1i-v2i)+abs(u1j-v2j),{u1i,u1j}});\\n                \\n                gr[{v1i,v1j}].push_back({abs(v1i-v2i)+abs(v1j-v2j),{v2i,v2j}});\\n                gr[{v2i,v2j}].push_back({abs(v1i-v2i)+abs(v1j-v2j),{v1i,v1j}});\\n\\n            }\\n        }\\n        \\n        \\n        map<pair<int,int>,int> vis;\\n        map<pair<int,int>,int> dis;\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        \\n        pq.push({0,{si,sj}});\\n        \\n        while(!pq.empty())\\n        {\\n            auto best = pq.top();\\n            pq.pop();\\n            \\n            int d = best.first;\\n            auto cord = best.second;\\n            \\n            if(vis[cord]==1) continue;\\n            \\n            dis[cord]=d;\\n            vis[cord]=1;\\n            \\n            for(auto ch : gr[cord])\\n            {\\n                if(vis[ch.second]==0)\\n                {\\n                    pq.push({d+ch.first,ch.second});\\n                }\\n            }\\n        }\\n        return dis[{ti,tj}];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& st, vector<int>& tr, vector<vector<int>>& sr) { \\n        map<pair<int,int>,vector<pair<int,pair<int,int>>>> gr;\\n        \\n        int si = st[0],sj = st[1], ti=tr[0],tj=tr[1];\\n        gr[{si,sj}].push_back({abs(ti-si)+abs(tj-sj),{ti,tj}});\\n        \\n        for(int i = 0 ; i < sr.size(); i++)\\n        {\\n            int u1i = sr[i][0],u1j = sr[i][1],v1i = sr[i][2],v1j = sr[i][3], c = sr[i][4];\\n            \\n            gr[{si,sj}].push_back({abs(u1i-si)+abs(u1j-sj),{u1i,u1j}});\\n            gr[{si,sj}].push_back({abs(v1i-si)+abs(v1j-sj),{v1i,v1j}});\\n            \\n            gr[{u1i,u1j}].push_back({c,{v1i,v1j}});\\n            \\n            gr[{u1i,u1j}].push_back({abs(ti-u1i)+abs(tj-u1j),{ti,tj}});\\n            gr[{v1i,v1j}].push_back({abs(ti-v1i)+abs(tj-v1j),{ti,tj}});\\n            \\n            for(int j = i+1; j < sr.size(); j++)\\n            {\\n                int u2i = sr[j][0],u2j = sr[j][1],v2i = sr[j][2],v2j = sr[j][3], c2 = sr[j][4];\\n                \\n                gr[{u1i,u1j}].push_back({abs(u1i-u2i)+abs(u1j-u2j),{u2i,u2j}});\\n                gr[{u2i,u2j}].push_back({abs(u1i-u2i)+abs(u1j-u2j),{u1i,u1j}});\\n                \\n                gr[{v1i,v1j}].push_back({abs(v1i-u2i)+abs(v1j-u2j),{u2i,u2j}});\\n                gr[{u2i,u2j}].push_back({abs(v1i-u2i)+abs(v1j-u2j),{v1i,v1j}});\\n                \\n                gr[{u1i,u1j}].push_back({abs(u1i-v2i)+abs(u1j-v2j),{v2i,v2j}});\\n                gr[{v2i,v2j}].push_back({abs(u1i-v2i)+abs(u1j-v2j),{u1i,u1j}});\\n                \\n                gr[{v1i,v1j}].push_back({abs(v1i-v2i)+abs(v1j-v2j),{v2i,v2j}});\\n                gr[{v2i,v2j}].push_back({abs(v1i-v2i)+abs(v1j-v2j),{v1i,v1j}});\\n\\n            }\\n        }\\n        \\n        \\n        map<pair<int,int>,int> vis;\\n        map<pair<int,int>,int> dis;\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        \\n        pq.push({0,{si,sj}});\\n        \\n        while(!pq.empty())\\n        {\\n            auto best = pq.top();\\n            pq.pop();\\n            \\n            int d = best.first;\\n            auto cord = best.second;\\n            \\n            if(vis[cord]==1) continue;\\n            \\n            dis[cord]=d;\\n            vis[cord]=1;\\n            \\n            for(auto ch : gr[cord])\\n            {\\n                if(vis[ch.second]==0)\\n                {\\n                    pq.push({d+ch.first,ch.second});\\n                }\\n            }\\n        }\\n        return dis[{ti,tj}];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491010,
                "title": "easy-to-read-bfs-solution-97ms",
                "content": "# Code\\n```\\nvar minimumCost = function(start, target, specialRoads) {\\n    let result = target[0] - start[0] + target[1] - start[1];\\n\\n    const stack = [];\\n    const dist = new Array(specialRoads.length);\\n    let index = 0;\\n\\n    for (const [x1, y1, x2, y2, c] of specialRoads) {\\n        dist[index] = x1 - start[0] + y1 - start[1];\\n        stack.push([x2, y2, c + dist[index++]]);\\n    }\\n\\n    let x, y, cost;\\n\\n    while (stack.length) {\\n        [x, y, cost] = stack.shift();\\n        result = Math.min(result, cost + target[0] - x + target[1] - y);\\n        index = 0;\\n        for (const [x1, y1, x2, y2, c] of specialRoads) {\\n            if (dist[index] > (cost + Math.abs(x1 - x) + Math.abs(y1 - y))) {\\n                dist[index] = cost + Math.abs(x1 - x) + Math.abs(y1 - y);\\n                stack.push([x2, y2, c + dist[index]]);\\n            }\\n            ++index;\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\nOr faster version of it (97ms):\\n```\\nvar minimumCost = function(start, target, specialRoads) {\\n    let result = target[0] - start[0] + target[1] - start[1];\\n\\n    const stack = [];\\n    const dist = new Array(specialRoads.length);\\n    for (let i = 0; i < specialRoads.length; ++i) {\\n        dist[i] = specialRoads[i][0] - start[0] + specialRoads[i][1] - start[1];\\n        stack.push([specialRoads[i][2], specialRoads[i][3], specialRoads[i][4] + dist[i]]);\\n    }\\n\\n    let x, y, cost;\\n\\n    while (stack.length) {\\n        [x, y, cost] = stack.shift();\\n        result = Math.min(result, cost + target[0] - x + target[1] - y);\\n        for (let j = 0; j < specialRoads.length; ++j) {\\n            if (dist[j] > (cost + Math.abs(specialRoads[j][0] - x) + Math.abs(specialRoads[j][1] - y))) {\\n                dist[j] = cost + Math.abs(specialRoads[j][0] - x) + Math.abs(specialRoads[j][1] - y);\\n                stack.push([specialRoads[j][2], specialRoads[j][3], specialRoads[j][4] + dist[j]]);\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumCost = function(start, target, specialRoads) {\\n    let result = target[0] - start[0] + target[1] - start[1];\\n\\n    const stack = [];\\n    const dist = new Array(specialRoads.length);\\n    let index = 0;\\n\\n    for (const [x1, y1, x2, y2, c] of specialRoads) {\\n        dist[index] = x1 - start[0] + y1 - start[1];\\n        stack.push([x2, y2, c + dist[index++]]);\\n    }\\n\\n    let x, y, cost;\\n\\n    while (stack.length) {\\n        [x, y, cost] = stack.shift();\\n        result = Math.min(result, cost + target[0] - x + target[1] - y);\\n        index = 0;\\n        for (const [x1, y1, x2, y2, c] of specialRoads) {\\n            if (dist[index] > (cost + Math.abs(x1 - x) + Math.abs(y1 - y))) {\\n                dist[index] = cost + Math.abs(x1 - x) + Math.abs(y1 - y);\\n                stack.push([x2, y2, c + dist[index]]);\\n            }\\n            ++index;\\n        }\\n    }\\n\\n    return result;\\n};\\n```\n```\\nvar minimumCost = function(start, target, specialRoads) {\\n    let result = target[0] - start[0] + target[1] - start[1];\\n\\n    const stack = [];\\n    const dist = new Array(specialRoads.length);\\n    for (let i = 0; i < specialRoads.length; ++i) {\\n        dist[i] = specialRoads[i][0] - start[0] + specialRoads[i][1] - start[1];\\n        stack.push([specialRoads[i][2], specialRoads[i][3], specialRoads[i][4] + dist[i]]);\\n    }\\n\\n    let x, y, cost;\\n\\n    while (stack.length) {\\n        [x, y, cost] = stack.shift();\\n        result = Math.min(result, cost + target[0] - x + target[1] - y);\\n        for (let j = 0; j < specialRoads.length; ++j) {\\n            if (dist[j] > (cost + Math.abs(specialRoads[j][0] - x) + Math.abs(specialRoads[j][1] - y))) {\\n                dist[j] = cost + Math.abs(specialRoads[j][0] - x) + Math.abs(specialRoads[j][1] - y);\\n                stack.push([specialRoads[j][2], specialRoads[j][3], specialRoads[j][4] + dist[j]]);\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3482539,
                "title": "dijkstra-s-algorithm",
                "content": "# Intuition\\nThis is a classic find the shortest path problem with some interesting constraints.\\n\\n# Approach\\nFirst, I tried a naive depth-first search solution, which I got working for simple cases, but of course timed out on larger datasets. Then I remembered Dijkstra\\'s algorithm and spent a long time implementing it. I used the specialRoads to make a full adjacency map between the start point, end point, and each road\\'s end point to each other road\\'s start point. Then I chiseled away at it and realized that I could do it more simply by processing each road as the sum of the distance from the current point to the road entrance and the cost of the road instead of considering each leg independently. Finally I removed a special case for considering the direct path to the target by adding and removing a road each step.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        struct Point {\\n            int x;\\n            int y;\\n            \\n            explicit Point(int x, int y) : x(x), y(y) {}\\n            explicit Point(const vector<int>& p, int o=0) : Point(p[o], p[o+1]) {}\\n            bool operator==(Point other) const { return x == other.x && y == other.y; }\\n            bool operator<(Point other) const { return x < other.x || x == other.x && y < other.y; }\\n        };\\n\\n        struct PointHasher {\\n            size_t operator()(Point k) const { return hash<long long>()(k.y*10001LL + k.x); }\\n        };\\n\\n        struct Road {\\n            Point p1, p2;\\n            int cost;\\n\\n            Road(Point p1, Point p2, int cost) : p1(p1), p2(p2), cost(cost) {}\\n        };\\n\\n        auto distance = [](Point p0, Point p1) {\\n            return abs(p0.x - p1.x) + abs(p0.y - p1.y);\\n        };\\n\\n        auto dist = unordered_map<Point, int, PointHasher>();\\n\\n        auto roads = vector<Road>();\\n        roads.reserve(specialRoads.size());\\n        transform(specialRoads.begin(), specialRoads.end(), back_inserter(roads), [](const vector<int>& specialRoad) {\\n            return Road(Point(specialRoad), Point(specialRoad, 2), specialRoad[4]);\\n        });\\n\\n        for (auto& road : roads) {\\n            dist[road.p2] = INT_MAX;\\n        }\\n        \\n        auto sp = Point(start), tp = Point(target);\\n        dist[tp] = INT_MAX;\\n        dist[sp] = 0;\\n        \\n        auto pq = priority_queue<pair<int,Point>, vector<pair<int,Point>>, greater<>>();\\n        pq.push({0, sp});\\n\\n        while (!pq.empty()) {\\n            auto item = pq.top();\\n            pq.pop();\\n\\n            int cost = item.first;\\n            Point u = item.second; \\n\\n            if (cost != dist[u]) continue;\\n\\n            roads.emplace_back(u, tp, distance(u, tp));\\n            for (auto road : roads) {\\n                auto alt = cost + distance(u, road.p1) + road.cost;\\n                if (alt < dist[road.p2]) {\\n                    dist[road.p2] = alt;\\n                    pq.emplace(alt, road.p2);\\n                }\\n            }\\n            roads.pop_back();\\n        }\\n\\n        return dist[tp];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        struct Point {\\n            int x;\\n            int y;\\n            \\n            explicit Point(int x, int y) : x(x), y(y) {}\\n            explicit Point(const vector<int>& p, int o=0) : Point(p[o], p[o+1]) {}\\n            bool operator==(Point other) const { return x == other.x && y == other.y; }\\n            bool operator<(Point other) const { return x < other.x || x == other.x && y < other.y; }\\n        };\\n\\n        struct PointHasher {\\n            size_t operator()(Point k) const { return hash<long long>()(k.y*10001LL + k.x); }\\n        };\\n\\n        struct Road {\\n            Point p1, p2;\\n            int cost;\\n\\n            Road(Point p1, Point p2, int cost) : p1(p1), p2(p2), cost(cost) {}\\n        };\\n\\n        auto distance = [](Point p0, Point p1) {\\n            return abs(p0.x - p1.x) + abs(p0.y - p1.y);\\n        };\\n\\n        auto dist = unordered_map<Point, int, PointHasher>();\\n\\n        auto roads = vector<Road>();\\n        roads.reserve(specialRoads.size());\\n        transform(specialRoads.begin(), specialRoads.end(), back_inserter(roads), [](const vector<int>& specialRoad) {\\n            return Road(Point(specialRoad), Point(specialRoad, 2), specialRoad[4]);\\n        });\\n\\n        for (auto& road : roads) {\\n            dist[road.p2] = INT_MAX;\\n        }\\n        \\n        auto sp = Point(start), tp = Point(target);\\n        dist[tp] = INT_MAX;\\n        dist[sp] = 0;\\n        \\n        auto pq = priority_queue<pair<int,Point>, vector<pair<int,Point>>, greater<>>();\\n        pq.push({0, sp});\\n\\n        while (!pq.empty()) {\\n            auto item = pq.top();\\n            pq.pop();\\n\\n            int cost = item.first;\\n            Point u = item.second; \\n\\n            if (cost != dist[u]) continue;\\n\\n            roads.emplace_back(u, tp, distance(u, tp));\\n            for (auto road : roads) {\\n                auto alt = cost + distance(u, road.p1) + road.cost;\\n                if (alt < dist[road.p2]) {\\n                    dist[road.p2] = alt;\\n                    pq.emplace(alt, road.p2);\\n                }\\n            }\\n            roads.pop_back();\\n        }\\n\\n        return dist[tp];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481110,
                "title": "commented-solution-dijkstra-s-algo-in-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:N2LOG(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n(N);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<vector<int>, int>dist;//to store the dist for particular point\\n        dist[start]=0;\\n\\n        //have to check in special road if the cost < thn mathn road \\n        // ..store in filter vector\\n        vector<vector<int>>filteredRoad;\\n        for(auto it:specialRoads){\\n            int x1 = it[0], y1= it[1], x2= it[2] , y2= it[3] , cost = it[4];\\n            if(cost< abs(x2-x1)+ abs(y2-y1)){\\n                filteredRoad.push_back({x1, y1, x2, y2,cost});//string thm separately\\n                dist[{x2, y2}]=1e9;\\n            }\\n        }\\n        //APPLYING DIJISTRA \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>pq;//min heap \\n        pq.push({0,start[0], start[1]});//dist , indxes\\n\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n\\n            int mindist = it[0], x= it[1] , y= it[2];\\n\\n            for(auto i: filteredRoad){\\n                int a = i[0], b=i[1], c = i[2], d= i[3], rcost= i[4];\\n                //x,y --- a b---- c,d\\n\\n                if(dist[{c,d}] > mindist+abs(x-a)+abs(y-b)+rcost){\\n                    dist[{c,d}]= mindist+abs(x-a)+abs(y-b)+rcost;\\n                    pq.push({dist[{c,d}], c,d});//herer we can use other special road \\n                    //x, y---> a,b ---> c, d-----> a1, b1---->till all spl road\\n\\n                }\\n            }\\n        }\\n\\n        //taking the last distance from special road to target one\\n        int res = abs(start[0]-target[0])+abs(start[1]-target[1]);//let it be ans \\n        //check if any smaller exits\\n\\n        for(auto i: filteredRoad){\\n            int tx= target[0], ty = target[1];\\n            int x1= i[0], y1= i[1], x2= i[2], y2= i[3];\\n            res = min(res, dist[{x2, y2}]+abs(x2-tx)+abs(y2-ty));\\n            cout<<dist[{x2,y2}];\\n        }return res;\\n        \\n    }\\n};\\n//will connect with special road with soeiacl rood in order to grt adj matrix--> O(spl)^2 loqm\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<vector<int>, int>dist;//to store the dist for particular point\\n        dist[start]=0;\\n\\n        //have to check in special road if the cost < thn mathn road \\n        // ..store in filter vector\\n        vector<vector<int>>filteredRoad;\\n        for(auto it:specialRoads){\\n            int x1 = it[0], y1= it[1], x2= it[2] , y2= it[3] , cost = it[4];\\n            if(cost< abs(x2-x1)+ abs(y2-y1)){\\n                filteredRoad.push_back({x1, y1, x2, y2,cost});//string thm separately\\n                dist[{x2, y2}]=1e9;\\n            }\\n        }\\n        //APPLYING DIJISTRA \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>pq;//min heap \\n        pq.push({0,start[0], start[1]});//dist , indxes\\n\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n\\n            int mindist = it[0], x= it[1] , y= it[2];\\n\\n            for(auto i: filteredRoad){\\n                int a = i[0], b=i[1], c = i[2], d= i[3], rcost= i[4];\\n                //x,y --- a b---- c,d\\n\\n                if(dist[{c,d}] > mindist+abs(x-a)+abs(y-b)+rcost){\\n                    dist[{c,d}]= mindist+abs(x-a)+abs(y-b)+rcost;\\n                    pq.push({dist[{c,d}], c,d});//herer we can use other special road \\n                    //x, y---> a,b ---> c, d-----> a1, b1---->till all spl road\\n\\n                }\\n            }\\n        }\\n\\n        //taking the last distance from special road to target one\\n        int res = abs(start[0]-target[0])+abs(start[1]-target[1]);//let it be ans \\n        //check if any smaller exits\\n\\n        for(auto i: filteredRoad){\\n            int tx= target[0], ty = target[1];\\n            int x1= i[0], y1= i[1], x2= i[2], y2= i[3];\\n            res = min(res, dist[{x2, y2}]+abs(x2-tx)+abs(y2-ty));\\n            cout<<dist[{x2,y2}];\\n        }return res;\\n        \\n    }\\n};\\n//will connect with special road with soeiacl rood in order to grt adj matrix--> O(spl)^2 loqm\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3480899,
                "title": "c-solution-complexity-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDijekstra algorithm: minimum distance between source and destination in weighted graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate an adjecency list of all special roads. Other ordinary roads dist can calculated without maintaining it in adjecency.\\n\\nin Dijekstra\\nafter checking special roads\\ncheck dist from current node to every other node in special node+target node\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nworst case 200 special roads -> 400+2(source and dest) nodes to check, \\n\\nV: 402-->O(100) \\nE:200+402*(402) --> O(100000) \\n\\nqueue operations log(V) maximum V nodes in queue ie log(100)\\n\\ncomplexity: O(E*log(V)) --> O(10^5)*log(100)\\n                          --> O(10^5)*6\\n                          --> O(10^5)\\n \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V)+O(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int, int>, vector<pair<pair<int,int>, int>>> adj;\\n        multiset<pair<int,pair<int,int>>> q;\\n        set<pair<int,int>> nodes;\\n        nodes.insert({target[0], target[1]});\\n      \\n        for(int i=0; i<specialRoads.size(); i++){\\n            nodes.insert({specialRoads[i][0], specialRoads[i][1]});\\n            nodes.insert({specialRoads[i][2], specialRoads[i][3]});\\n            adj[{specialRoads[i][0], specialRoads[i][1]}].push_back({{specialRoads[i][2], specialRoads[i][3]}, specialRoads[i][4]});\\n\\n          \\n        }\\n        \\n        q.insert({0,{start[0], start[1]}});\\n        map<pair<int,int>, int> dist;\\n        map <pair<int,int>, int> visited;\\n        dist[{start[0], start[1]}]=0;\\n        visited[{start[0], start[1]}]=1;\\n        \\n        \\n        while(!q.empty()){\\n            pair<int, pair<int,int>> temp = *q.begin();\\n            visited[temp.second]=1;    \\n            q.erase(q.begin());\\n            \\n            \\n            for(auto &i: adj[temp.second]){\\n          \\n                    if((dist.find(i.first)==dist.end() or ((dist.find(i.first)!=dist.end() and ((dist[temp.second]+i.second))<dist[i.first])))){\\n                        dist[i.first]=dist[temp.second]+i.second;\\n                        q.insert({dist[i.first], i.first});\\n                    }\\n            }\\n            \\n            for(auto &i: nodes){\\n                if((dist.find(i)==dist.end() or ((dist.find(i)!=dist.end() and ((dist[temp.second]+abs(temp.second.first-i.first)+abs(temp.second.second-i.second)))<dist[i])))){\\n                            \\n                            dist[i]=dist[temp.second]+abs(temp.second.first-i.first)+abs(temp.second.second-i.second);\\n                            q.insert({dist[i], i});\\n                 }\\n            }            \\n        }\\n      \\n      \\n        return dist[{target[0], target[1]}];   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int, int>, vector<pair<pair<int,int>, int>>> adj;\\n        multiset<pair<int,pair<int,int>>> q;\\n        set<pair<int,int>> nodes;\\n        nodes.insert({target[0], target[1]});\\n      \\n        for(int i=0; i<specialRoads.size(); i++){\\n            nodes.insert({specialRoads[i][0], specialRoads[i][1]});\\n            nodes.insert({specialRoads[i][2], specialRoads[i][3]});\\n            adj[{specialRoads[i][0], specialRoads[i][1]}].push_back({{specialRoads[i][2], specialRoads[i][3]}, specialRoads[i][4]});\\n\\n          \\n        }\\n        \\n        q.insert({0,{start[0], start[1]}});\\n        map<pair<int,int>, int> dist;\\n        map <pair<int,int>, int> visited;\\n        dist[{start[0], start[1]}]=0;\\n        visited[{start[0], start[1]}]=1;\\n        \\n        \\n        while(!q.empty()){\\n            pair<int, pair<int,int>> temp = *q.begin();\\n            visited[temp.second]=1;    \\n            q.erase(q.begin());\\n            \\n            \\n            for(auto &i: adj[temp.second]){\\n          \\n                    if((dist.find(i.first)==dist.end() or ((dist.find(i.first)!=dist.end() and ((dist[temp.second]+i.second))<dist[i.first])))){\\n                        dist[i.first]=dist[temp.second]+i.second;\\n                        q.insert({dist[i.first], i.first});\\n                    }\\n            }\\n            \\n            for(auto &i: nodes){\\n                if((dist.find(i)==dist.end() or ((dist.find(i)!=dist.end() and ((dist[temp.second]+abs(temp.second.first-i.first)+abs(temp.second.second-i.second)))<dist[i])))){\\n                            \\n                            dist[i]=dist[temp.second]+abs(temp.second.first-i.first)+abs(temp.second.second-i.second);\\n                            q.insert({dist[i], i});\\n                 }\\n            }            \\n        }\\n      \\n      \\n        return dist[{target[0], target[1]}];   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480864,
                "title": "easy-to-understand-dijkstra-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing dp here didn\\'t workout for me as order of choosing the special node mattered here.\\nOther option for solving this question is to assign all the given coordinates with unique ids (Nodes) and make a graph and then find the distance between source and destination using dijkstra.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssign unique ids or node values to all the given coordinates and then construct edges between all the edges using abs(x1-x2)+abs(y1-y2) and also make special edges as per the given special roads.\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    class Dijkstra_Algorithm\\n    {\\n        void bfs(vector<pair<int, int>> adj[], vector<int>& dist, int s, int n)\\n        {\\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            pq.push({ 0, s });\\n            while (!pq.empty())\\n            {\\n                int node = pq.top().second;\\n                int predist = pq.top().first; // distance to reach node from node root(0)...\\n                pq.pop();\\n                for (auto it : adj[node])\\n                {\\n                    if (predist + it.second < dist[it.first])\\n                    {\\n                        dist[it.first] = predist + it.second;\\n                        pq.push({ predist + it.second, it.first });\\n                    }\\n                }\\n            }\\n        }\\n\\n    public:\\n        // change this according to the constraints...\\n        int maxn = INT_MAX;\\n        vector<int> Find_path(vector<pair<int, int>> adj[], int s, int n)\\n        {\\n            vector<int> dist(n + 1, maxn);\\n            // setting the source distance s as 0...\\n            dist[s] = 0;\\n            bfs(adj, dist, s, n);\\n            return dist;\\n        }\\n    };\\n\\n\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int,int>,int> mp;\\n        vector<pair<int,int>> adj[10000];\\n        /// maximum number of nodes will be 200*2+Const = lets take 1e4;\\n\\n        mp[{start[0],start[1]}] = 0;\\n        /// source node is 0\\n        \\n        int id = 1; /// current node\\n        for(auto it:specialRoads){\\n            int x1,x2,y1,y2;\\n            x1 = it[0];\\n            y1 = it[1];\\n            x2 = it[2];\\n            y2 = it[3];\\n\\n            if(mp.find({x1,y1})==mp.end()){\\n                mp[{x1,y1}] = id;/// assigning node value to x,y\\n                id++;\\n            }\\n            if(mp.find({x2,y2})==mp.end()){\\n                mp[{x2,y2}] = id;/// assigning node value to x,y\\n                id++;\\n            }\\n\\n            adj[mp[{x1,y1}]].push_back({mp[{x2,y2}],it[4]});/// making edge from x1,y1 to x2,y2 \\n            //(their corresponding node value is used here)\\n        }\\n        if(mp.find({target[0],target[1]})==mp.end()){\\n            mp[{target[0],target[1]}] = id;\\n            id++;/// assigning node value to x,y\\n        }\\n\\n\\n        vector<pair<int,int>> arr;\\n        arr.push_back({start[0],start[1]});\\n        arr.push_back({target[0],target[1]});\\n\\n        for(auto it:specialRoads){\\n            int x1,x2,y1,y2;\\n            x1 = it[0];\\n            y1 = it[1];\\n            x2 = it[2];\\n            y2 = it[3];\\n            arr.push_back({x1,y1});\\n            arr.push_back({x2,y2});\\n        }\\n\\n        // arr contains all of the coordinates including start and target\\n\\n        /// here we are making edges between every other node\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                int dist =  abs(arr[i].first-arr[j].first)+\\n                            abs(arr[i].second-arr[j].second);\\n                if(dist==0){\\n                    continue;\\n                }\\n                adj[mp[arr[i]]].push_back({mp[arr[j]],dist});\\n                adj[mp[arr[j]]].push_back({mp[arr[i]],dist});\\n            }\\n        }\\n\\n        //// using dijkstra to find dist between source and edge\\n        Dijkstra_Algorithm dj;\\n        vector<int> dist = dj.Find_path(adj,0,10000);\\n        cout<<mp[{target[0],target[1]}]<<endl;\\n        return dist[mp[{target[0],target[1]}]];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Dijkstra_Algorithm\\n    {\\n        void bfs(vector<pair<int, int>> adj[], vector<int>& dist, int s, int n)\\n        {\\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            pq.push({ 0, s });\\n            while (!pq.empty())\\n            {\\n                int node = pq.top().second;\\n                int predist = pq.top().first; // distance to reach node from node root(0)...\\n                pq.pop();\\n                for (auto it : adj[node])\\n                {\\n                    if (predist + it.second < dist[it.first])\\n                    {\\n                        dist[it.first] = predist + it.second;\\n                        pq.push({ predist + it.second, it.first });\\n                    }\\n                }\\n            }\\n        }\\n\\n    public:\\n        // change this according to the constraints...\\n        int maxn = INT_MAX;\\n        vector<int> Find_path(vector<pair<int, int>> adj[], int s, int n)\\n        {\\n            vector<int> dist(n + 1, maxn);\\n            // setting the source distance s as 0...\\n            dist[s] = 0;\\n            bfs(adj, dist, s, n);\\n            return dist;\\n        }\\n    };\\n\\n\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int,int>,int> mp;\\n        vector<pair<int,int>> adj[10000];\\n        /// maximum number of nodes will be 200*2+Const = lets take 1e4;\\n\\n        mp[{start[0],start[1]}] = 0;\\n        /// source node is 0\\n        \\n        int id = 1; /// current node\\n        for(auto it:specialRoads){\\n            int x1,x2,y1,y2;\\n            x1 = it[0];\\n            y1 = it[1];\\n            x2 = it[2];\\n            y2 = it[3];\\n\\n            if(mp.find({x1,y1})==mp.end()){\\n                mp[{x1,y1}] = id;/// assigning node value to x,y\\n                id++;\\n            }\\n            if(mp.find({x2,y2})==mp.end()){\\n                mp[{x2,y2}] = id;/// assigning node value to x,y\\n                id++;\\n            }\\n\\n            adj[mp[{x1,y1}]].push_back({mp[{x2,y2}],it[4]});/// making edge from x1,y1 to x2,y2 \\n            //(their corresponding node value is used here)\\n        }\\n        if(mp.find({target[0],target[1]})==mp.end()){\\n            mp[{target[0],target[1]}] = id;\\n            id++;/// assigning node value to x,y\\n        }\\n\\n\\n        vector<pair<int,int>> arr;\\n        arr.push_back({start[0],start[1]});\\n        arr.push_back({target[0],target[1]});\\n\\n        for(auto it:specialRoads){\\n            int x1,x2,y1,y2;\\n            x1 = it[0];\\n            y1 = it[1];\\n            x2 = it[2];\\n            y2 = it[3];\\n            arr.push_back({x1,y1});\\n            arr.push_back({x2,y2});\\n        }\\n\\n        // arr contains all of the coordinates including start and target\\n\\n        /// here we are making edges between every other node\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                int dist =  abs(arr[i].first-arr[j].first)+\\n                            abs(arr[i].second-arr[j].second);\\n                if(dist==0){\\n                    continue;\\n                }\\n                adj[mp[arr[i]]].push_back({mp[arr[j]],dist});\\n                adj[mp[arr[j]]].push_back({mp[arr[i]],dist});\\n            }\\n        }\\n\\n        //// using dijkstra to find dist between source and edge\\n        Dijkstra_Algorithm dj;\\n        vector<int> dist = dj.Find_path(adj,0,10000);\\n        cout<<mp[{target[0],target[1]}]<<endl;\\n        return dist[mp[{target[0],target[1]}]];\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3479103,
                "title": "minimum-cost-of-a-path-with-special-roads-shortest-path-explanation-with-comments",
                "content": "```\\n\\n// startPos-------currPoint------[startOfRoad========RoadCost========endOfRoad]------targetPos\\n\\nclass Solution {\\nprivate:\\n    int manhattanDistance(pair<int,int> p1, pair<int,int> p2){\\n        return abs(p2.first-p1.first) + abs(p2.second-p1.second);\\n    }\\n    \\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        \\n        pair<int,int> startPos = {\\n            start[0], \\n            start[1]\\n        };\\n        \\n        pair<int,int> targetPos = {\\n            target[0], \\n            target[1]\\n        };\\n        \\n        //what is the min cost till my current point from startPos?\\n        map<pair<int,int>, int> minCost;\\n        \\n        minCost[startPos] = 0;\\n        \\n        //queue<Point,costTillThatPoint> - to explore all points and costs\\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({startPos,0});\\n        \\n        //shortestPath to reach from startPos to targetPos\\n        int shortestPath = INT_MAX;\\n        \\n        while(!q.empty()){\\n            \\n            //Get Current point and its cost till that point\\n            auto [point,costToThisPoint] = q.front();\\n            q.pop();\\n            \\n            //If this point has greater cost than previous minimum cost no need to update and process further\\n            if(costToThisPoint > (minCost.count(point)>0?minCost[point]:INT_MAX )) continue;\\n            \\n            //else update costToThisPoint as the minCost\\n            minCost[point] = costToThisPoint;\\n            \\n            //Then shortestPath to reach targetPos from this point is minCost till this point from previous all paths + manhattanDistance to targetPos\\n            shortestPath = min(shortestPath , minCost[point] + manhattanDistance(point, targetPos));\\n            \\n            //explore all specialRoads and updates minCost to reach endOfTheRoad\\n            for(auto v : specialRoads){\\n                pair<int,int> startOfRoad = {\\n                    v[0],\\n                    v[1]\\n                };\\n                \\n                pair<int,int> endOfRoad = {\\n                    v[2],\\n                    v[3]\\n                };\\n                \\n                int roadCost = v[4];\\n                \\n                //to reach roadEnd = cost till my current point + cost to reach start of Road + roadCost\\n                int costToEndOfRoad = costToThisPoint + manhattanDistance(point,startOfRoad) + roadCost;\\n                \\n                //If costToReach EndofTheRoad is greater than previous minimum cost, no need to update and process further\\n                if(costToEndOfRoad >= (minCost.count(endOfRoad)>0?minCost[endOfRoad]:INT_MAX )) continue;\\n                \\n                //else update cost to reach endOfRoad\\n                minCost[endOfRoad] = costToEndOfRoad;\\n                \\n                //push endOfRoad, to start exploring from endOfRoad\\n                q.push({endOfRoad, minCost[endOfRoad]});\\n            }\\n            \\n            \\n        }\\n        \\n        return shortestPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\n// startPos-------currPoint------[startOfRoad========RoadCost========endOfRoad]------targetPos\\n\\nclass Solution {\\nprivate:\\n    int manhattanDistance(pair<int,int> p1, pair<int,int> p2){\\n        return abs(p2.first-p1.first) + abs(p2.second-p1.second);\\n    }\\n    \\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        \\n        pair<int,int> startPos = {\\n            start[0], \\n            start[1]\\n        };\\n        \\n        pair<int,int> targetPos = {\\n            target[0], \\n            target[1]\\n        };\\n        \\n        //what is the min cost till my current point from startPos?\\n        map<pair<int,int>, int> minCost;\\n        \\n        minCost[startPos] = 0;\\n        \\n        //queue<Point,costTillThatPoint> - to explore all points and costs\\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({startPos,0});\\n        \\n        //shortestPath to reach from startPos to targetPos\\n        int shortestPath = INT_MAX;\\n        \\n        while(!q.empty()){\\n            \\n            //Get Current point and its cost till that point\\n            auto [point,costToThisPoint] = q.front();\\n            q.pop();\\n            \\n            //If this point has greater cost than previous minimum cost no need to update and process further\\n            if(costToThisPoint > (minCost.count(point)>0?minCost[point]:INT_MAX )) continue;\\n            \\n            //else update costToThisPoint as the minCost\\n            minCost[point] = costToThisPoint;\\n            \\n            //Then shortestPath to reach targetPos from this point is minCost till this point from previous all paths + manhattanDistance to targetPos\\n            shortestPath = min(shortestPath , minCost[point] + manhattanDistance(point, targetPos));\\n            \\n            //explore all specialRoads and updates minCost to reach endOfTheRoad\\n            for(auto v : specialRoads){\\n                pair<int,int> startOfRoad = {\\n                    v[0],\\n                    v[1]\\n                };\\n                \\n                pair<int,int> endOfRoad = {\\n                    v[2],\\n                    v[3]\\n                };\\n                \\n                int roadCost = v[4];\\n                \\n                //to reach roadEnd = cost till my current point + cost to reach start of Road + roadCost\\n                int costToEndOfRoad = costToThisPoint + manhattanDistance(point,startOfRoad) + roadCost;\\n                \\n                //If costToReach EndofTheRoad is greater than previous minimum cost, no need to update and process further\\n                if(costToEndOfRoad >= (minCost.count(endOfRoad)>0?minCost[endOfRoad]:INT_MAX )) continue;\\n                \\n                //else update cost to reach endOfRoad\\n                minCost[endOfRoad] = costToEndOfRoad;\\n                \\n                //push endOfRoad, to start exploring from endOfRoad\\n                q.push({endOfRoad, minCost[endOfRoad]});\\n            }\\n            \\n            \\n        }\\n        \\n        return shortestPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479078,
                "title": "c-kind-of-dijkstra",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) \\n    {\\n        if(start == target) return 0;\\n        multimap<int, pair<int,int>> dist2pos;\\n        map<pair<int,int>, vector<vector<int>>> pos2roads; // [vals: x, y, len]\\n        set<pair<int,int>> unvisited;\\n        for(vector<int> &v : specialRoads)\\n        {\\n            pos2roads[make_pair(v[0], v[1])].push_back({v[2], v[3], v[4]});\\n            dist2pos.insert({abs(v[0]-start[0]) + abs(v[1]-start[1]), {v[0], v[1]}}); // to road beginnings\\n            dist2pos.insert({abs(v[2]-start[0]) + abs(v[3]-start[1]), {v[2], v[3]}}); // to road ends\\n            unvisited.insert({v[0], v[1]});\\n            unvisited.insert({v[2], v[3]});\\n        }\\n        dist2pos.insert({abs(target[0]-start[0]) + abs(target[1]-start[1]), {target[0], target[1]}}); // to target\\n        unvisited.insert({target[0], target[1]});\\n        while(true)\\n        {\\n            // get the closest element:\\n            auto it = dist2pos.begin();\\n            if(unvisited.find(it->second) == unvisited.end()) // pos visited\\n            {\\n                dist2pos.erase(it);\\n                continue;\\n            }\\n            int curDist = it->first;\\n            pair<int, int> &curPos = it->second;\\n            unvisited.erase(curPos); // mark visited\\n            if(curPos.first == target[0] && curPos.second == target[1])\\n                return curDist;\\n            // process all unvisited elements:\\n            for(auto &u : unvisited)\\n            {\\n                dist2pos.insert({curDist+abs(curPos.first - u.first)+abs(curPos.second - u.second), u});\\n            }\\n            // process all roads from here:\\n            for(auto &road : pos2roads[curPos])\\n            {\\n                auto destinationIt = unvisited.find({road[0], road[1]});\\n                if(destinationIt != unvisited.end())  // destination is unvisited\\n                    dist2pos.insert({curDist+road[2], {road[0], road[1]}});\\n            }\\n            dist2pos.erase(it);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) \\n    {\\n        if(start == target) return 0;\\n        multimap<int, pair<int,int>> dist2pos;\\n        map<pair<int,int>, vector<vector<int>>> pos2roads; // [vals: x, y, len]\\n        set<pair<int,int>> unvisited;\\n        for(vector<int> &v : specialRoads)\\n        {\\n            pos2roads[make_pair(v[0], v[1])].push_back({v[2], v[3], v[4]});\\n            dist2pos.insert({abs(v[0]-start[0]) + abs(v[1]-start[1]), {v[0], v[1]}}); // to road beginnings\\n            dist2pos.insert({abs(v[2]-start[0]) + abs(v[3]-start[1]), {v[2], v[3]}}); // to road ends\\n            unvisited.insert({v[0], v[1]});\\n            unvisited.insert({v[2], v[3]});\\n        }\\n        dist2pos.insert({abs(target[0]-start[0]) + abs(target[1]-start[1]), {target[0], target[1]}}); // to target\\n        unvisited.insert({target[0], target[1]});\\n        while(true)\\n        {\\n            // get the closest element:\\n            auto it = dist2pos.begin();\\n            if(unvisited.find(it->second) == unvisited.end()) // pos visited\\n            {\\n                dist2pos.erase(it);\\n                continue;\\n            }\\n            int curDist = it->first;\\n            pair<int, int> &curPos = it->second;\\n            unvisited.erase(curPos); // mark visited\\n            if(curPos.first == target[0] && curPos.second == target[1])\\n                return curDist;\\n            // process all unvisited elements:\\n            for(auto &u : unvisited)\\n            {\\n                dist2pos.insert({curDist+abs(curPos.first - u.first)+abs(curPos.second - u.second), u});\\n            }\\n            // process all roads from here:\\n            for(auto &road : pos2roads[curPos])\\n            {\\n                auto destinationIt = unvisited.find({road[0], road[1]});\\n                if(destinationIt != unvisited.end())  // destination is unvisited\\n                    dist2pos.insert({curDist+road[2], {road[0], road[1]}});\\n            }\\n            dist2pos.erase(it);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478611,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_cost(start: Vec<i32>, target: Vec<i32>, special_roads: Vec<Vec<i32>>) -> i32 {\\n        let mut special_roads = special_roads;\\n        let mut res = target[0] - start[0] + target[1] - start[1];\\n        let sz = special_roads.len();\\n        special_roads.push(vec![start[0], start[1], start[0], start[1], 0]);\\n        let mut dp = vec![std::i32::MAX; sz + 1];\\n        let mut q = vec![vec![sz as i32, 0]];\\n        let mut q1 = vec![];\\n        while !q.is_empty() {\\n            q1.clear();\\n            for qq in q.iter() {\\n                let (i, cost_i) = (qq[0] as usize, qq[1]);\\n                if cost_i <= dp[i] {\\n                    let x2i = special_roads[i][2];\\n                    let y2i = special_roads[i][3];\\n                    for j in 0..sz {\\n                        let x1j = special_roads[j][0];\\n                        let y1j = special_roads[j][1];\\n                        let x2j = special_roads[j][2];\\n                        let y2j = special_roads[j][3];\\n                        let cost_j = special_roads[j][4];\\n                        dp[j] = std::cmp::min(dp[j], cost_i + (x2j - x2i).abs() + (y2j - y2i).abs());\\n                        let take = cost_i + cost_j + (x1j - x2i).abs() + (y1j - y2i).abs();\\n                        if take < dp[j] {\\n                            dp[j] = take;\\n                            q1.push(vec![j as i32, take]);\\n                            res = std::cmp::min(res, take + (x2j - target[0]).abs() + (y2j - target[1]).abs());\\n                        }\\n                    }\\n                }\\n            }\\n            std::mem::swap(&mut q, &mut q1);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_cost(start: Vec<i32>, target: Vec<i32>, special_roads: Vec<Vec<i32>>) -> i32 {\\n        let mut special_roads = special_roads;\\n        let mut res = target[0] - start[0] + target[1] - start[1];\\n        let sz = special_roads.len();\\n        special_roads.push(vec![start[0], start[1], start[0], start[1], 0]);\\n        let mut dp = vec![std::i32::MAX; sz + 1];\\n        let mut q = vec![vec![sz as i32, 0]];\\n        let mut q1 = vec![];\\n        while !q.is_empty() {\\n            q1.clear();\\n            for qq in q.iter() {\\n                let (i, cost_i) = (qq[0] as usize, qq[1]);\\n                if cost_i <= dp[i] {\\n                    let x2i = special_roads[i][2];\\n                    let y2i = special_roads[i][3];\\n                    for j in 0..sz {\\n                        let x1j = special_roads[j][0];\\n                        let y1j = special_roads[j][1];\\n                        let x2j = special_roads[j][2];\\n                        let y2j = special_roads[j][3];\\n                        let cost_j = special_roads[j][4];\\n                        dp[j] = std::cmp::min(dp[j], cost_i + (x2j - x2i).abs() + (y2j - y2i).abs());\\n                        let take = cost_i + cost_j + (x1j - x2i).abs() + (y1j - y2i).abs();\\n                        if take < dp[j] {\\n                            dp[j] = take;\\n                            q1.push(vec![j as i32, take]);\\n                            res = std::cmp::min(res, take + (x2j - target[0]).abs() + (y2j - target[1]).abs());\\n                        }\\n                    }\\n                }\\n            }\\n            std::mem::swap(&mut q, &mut q1);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477603,
                "title": "go-only-to-special-roads-from-a-node-or-go-to-target",
                "content": "# Intuition\\nGo only to special roads from a node or go to target\\n# Approach\\nGo only to special roads from a node or go to target\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int, vector<pair<pair<int, int>, long long>>  > >   g;\\n    \\n    unordered_map<int, unordered_map<int, long long> > dis;\\n    \\n   \\n    void createGraph(vector<vector<int>>& specialRoads) {\\n        for (auto specialRoad : specialRoads) {\\n            int src_x = specialRoad[0];\\n            int src_y = specialRoad[1];\\n            \\n            g[src_x][src_y].push_back({{specialRoad[2], specialRoad[3]}, specialRoad[4]});\\n        }\\n    }\\n    \\n    struct cmp {\\n        bool operator()(const pair<pair<int, int>, long long>& a, const pair<pair<int, int>, long long>& b) {\\n            return a.second > b.second;\\n        }\\n    };\\n    \\n    int getdis(const pair<int ,int>& start, const pair<int, int>& target) {\\n        long long d = 0;\\n        \\n        d += abs(start.first - target.first) + abs(start.second - target.second);\\n        \\n        return d;\\n    }\\n    \\n    bool isExistent(int r, int c) {\\n        return dis.find(r) != dis.end() && dis[r].find(c) != dis[r].end();\\n    }\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        createGraph(specialRoads);\\n        \\n        priority_queue<pair<pair<int, int>, long long>, vector<pair<pair<int, int>, long long>>, cmp> q;\\n        \\n        q.push({{start[0], start[1]}, 0});\\n        \\n        dis[start[0]][start[1]] = 0;\\n        \\n        while (!q.empty()) {\\n            pair<pair<int, int>, int> node = q.top();\\n            q.pop();\\n            int r = node.first.first;\\n            int c = node.first.second;\\n            \\n            long long wt = node.second;\\n            //cout<<r<<\" \"<<c<<\" \"<<wt<<endl;\\n            \\n            for (auto neigh : g[r][c]) {\\n                int n_r = neigh.first.first;\\n                int n_c = neigh.first.second;\\n                \\n                long long n_wt = neigh.second;\\n                \\n                if (!isExistent(n_r, n_c) || wt + n_wt < dis[n_r][n_c]) {\\n                    q.push({{n_r, n_c}, wt + n_wt});\\n                    dis[n_r][n_c] = wt + n_wt;\\n                }\\n            }\\n            \\n            for (auto specialRoad: specialRoads) {\\n                int n_r = specialRoad[0];\\n                int n_c = specialRoad[1];\\n                long long t_dis = getdis({r, c}, {specialRoad[0], specialRoad[1]});\\n                \\n                if (!isExistent(n_r, n_c) || t_dis + wt < dis[n_r][n_c]) {\\n                    q.push({{n_r, n_c}, t_dis + wt});\\n                    dis[n_r][n_c] = t_dis + wt;\\n                }\\n            }\\n            \\n            long long t_dis = getdis({r, c}, {target[0], target[1]});\\n            \\n            int n_r = target[0];\\n            int n_c = target[1];\\n            \\n            if (!isExistent(n_r, n_c) || t_dis + wt < dis[target[0]][target[1]]) {\\n                q.push({{n_r, n_c}, t_dis + wt});\\n                dis[n_r][n_c] = t_dis + wt;\\n            }\\n        }\\n        \\n        return dis[target[0]][target[1]];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int, vector<pair<pair<int, int>, long long>>  > >   g;\\n    \\n    unordered_map<int, unordered_map<int, long long> > dis;\\n    \\n   \\n    void createGraph(vector<vector<int>>& specialRoads) {\\n        for (auto specialRoad : specialRoads) {\\n            int src_x = specialRoad[0];\\n            int src_y = specialRoad[1];\\n            \\n            g[src_x][src_y].push_back({{specialRoad[2], specialRoad[3]}, specialRoad[4]});\\n        }\\n    }\\n    \\n    struct cmp {\\n        bool operator()(const pair<pair<int, int>, long long>& a, const pair<pair<int, int>, long long>& b) {\\n            return a.second > b.second;\\n        }\\n    };\\n    \\n    int getdis(const pair<int ,int>& start, const pair<int, int>& target) {\\n        long long d = 0;\\n        \\n        d += abs(start.first - target.first) + abs(start.second - target.second);\\n        \\n        return d;\\n    }\\n    \\n    bool isExistent(int r, int c) {\\n        return dis.find(r) != dis.end() && dis[r].find(c) != dis[r].end();\\n    }\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        createGraph(specialRoads);\\n        \\n        priority_queue<pair<pair<int, int>, long long>, vector<pair<pair<int, int>, long long>>, cmp> q;\\n        \\n        q.push({{start[0], start[1]}, 0});\\n        \\n        dis[start[0]][start[1]] = 0;\\n        \\n        while (!q.empty()) {\\n            pair<pair<int, int>, int> node = q.top();\\n            q.pop();\\n            int r = node.first.first;\\n            int c = node.first.second;\\n            \\n            long long wt = node.second;\\n            //cout<<r<<\" \"<<c<<\" \"<<wt<<endl;\\n            \\n            for (auto neigh : g[r][c]) {\\n                int n_r = neigh.first.first;\\n                int n_c = neigh.first.second;\\n                \\n                long long n_wt = neigh.second;\\n                \\n                if (!isExistent(n_r, n_c) || wt + n_wt < dis[n_r][n_c]) {\\n                    q.push({{n_r, n_c}, wt + n_wt});\\n                    dis[n_r][n_c] = wt + n_wt;\\n                }\\n            }\\n            \\n            for (auto specialRoad: specialRoads) {\\n                int n_r = specialRoad[0];\\n                int n_c = specialRoad[1];\\n                long long t_dis = getdis({r, c}, {specialRoad[0], specialRoad[1]});\\n                \\n                if (!isExistent(n_r, n_c) || t_dis + wt < dis[n_r][n_c]) {\\n                    q.push({{n_r, n_c}, t_dis + wt});\\n                    dis[n_r][n_c] = t_dis + wt;\\n                }\\n            }\\n            \\n            long long t_dis = getdis({r, c}, {target[0], target[1]});\\n            \\n            int n_r = target[0];\\n            int n_c = target[1];\\n            \\n            if (!isExistent(n_r, n_c) || t_dis + wt < dis[target[0]][target[1]]) {\\n                q.push({{n_r, n_c}, t_dis + wt});\\n                dis[n_r][n_c] = t_dis + wt;\\n            }\\n        }\\n        \\n        return dis[target[0]][target[1]];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3477123,
                "title": "kotlin-dijsktra-solution",
                "content": "\\n# Code\\n```\\ndata class Point(val x: Int, val y: Int)\\n\\ndata class PointWithCost(val p: Point, val cost: Int): Comparable<PointWithCost> {\\n    override fun compareTo(other: PointWithCost) = compareValuesBy(this, other, { it.cost })\\n}\\n\\nclass Solution {\\n    fun minimumCost(start: IntArray, target: IntArray, specialRoads: Array<IntArray>): Int {\\n        val pointList = mutableListOf<Point>()\\n        val costMap = HashMap<Pair<Point, Point>, Int>()\\n        val distMap = HashMap<Point, Int>()\\n\\n        val sp = Point(start[0], start[1])\\n        // pointList.add(sp)\\n        distMap[sp] = 0\\n\\n        for (road in specialRoads) {\\n            val p = Point(road[0], road[1])\\n            val q = Point(road[2], road[3])\\n            val cost = road[4]\\n\\n            if(costMap.getOrDefault(Pair(p, q), Int.MAX_VALUE) > cost) {\\n                costMap[Pair(p, q)] = cost\\n            }\\n\\n            pointList.add(p)\\n            pointList.add(q)\\n\\n            distMap[p] = Int.MAX_VALUE\\n            distMap[q] = Int.MAX_VALUE\\n        }\\n\\n        val tp = Point(target[0], target[1])\\n        pointList.add(tp)\\n        distMap[tp] = Int.MAX_VALUE\\n\\n\\n        val points = pointList.distinct()\\n        val pq = PriorityQueue<PointWithCost>()\\n        pq.offer(PointWithCost(sp, 0))\\n\\n        while(!pq.isEmpty()) {\\n            val curr = pq.poll()\\n            val cost = curr.cost\\n            val cp = curr.p\\n\\n            if(cp == tp) return cost\\n\\n            for(np in points) {\\n                if (cp == np) continue\\n                var nextCost = cost + dist(cp, np)\\n\\n                if (costMap.containsKey(Pair(cp, np))) {\\n                    nextCost = Math.min(nextCost, cost + costMap[Pair(cp, np)]!!)\\n                    // println(\"${cp.x}, ${cp.y} -> ${np.x}, ${np.y} : ${nextCost} ( ${costMap[Pair(cp, np)]!!} )\")\\n                }\\n\\n\\n                if (nextCost < distMap[np]!!) {\\n                    // println(\"${cp.x}, ${cp.y} -> ${np.x}, ${np.y} : ${nextCost}\")\\n                    distMap[np] = nextCost\\n                    pq.offer(PointWithCost(np, nextCost))\\n                }\\n            }\\n        }\\n\\n        return -1\\n    }\\n\\n    fun dist(sp: Point, tp: Point): Int{\\n        return Math.abs(sp.x - tp.x) + Math.abs(sp.y - tp.y)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\ndata class Point(val x: Int, val y: Int)\\n\\ndata class PointWithCost(val p: Point, val cost: Int): Comparable<PointWithCost> {\\n    override fun compareTo(other: PointWithCost) = compareValuesBy(this, other, { it.cost })\\n}\\n\\nclass Solution {\\n    fun minimumCost(start: IntArray, target: IntArray, specialRoads: Array<IntArray>): Int {\\n        val pointList = mutableListOf<Point>()\\n        val costMap = HashMap<Pair<Point, Point>, Int>()\\n        val distMap = HashMap<Point, Int>()\\n\\n        val sp = Point(start[0], start[1])\\n        // pointList.add(sp)\\n        distMap[sp] = 0\\n\\n        for (road in specialRoads) {\\n            val p = Point(road[0], road[1])\\n            val q = Point(road[2], road[3])\\n            val cost = road[4]\\n\\n            if(costMap.getOrDefault(Pair(p, q), Int.MAX_VALUE) > cost) {\\n                costMap[Pair(p, q)] = cost\\n            }\\n\\n            pointList.add(p)\\n            pointList.add(q)\\n\\n            distMap[p] = Int.MAX_VALUE\\n            distMap[q] = Int.MAX_VALUE\\n        }\\n\\n        val tp = Point(target[0], target[1])\\n        pointList.add(tp)\\n        distMap[tp] = Int.MAX_VALUE\\n\\n\\n        val points = pointList.distinct()\\n        val pq = PriorityQueue<PointWithCost>()\\n        pq.offer(PointWithCost(sp, 0))\\n\\n        while(!pq.isEmpty()) {\\n            val curr = pq.poll()\\n            val cost = curr.cost\\n            val cp = curr.p\\n\\n            if(cp == tp) return cost\\n\\n            for(np in points) {\\n                if (cp == np) continue\\n                var nextCost = cost + dist(cp, np)\\n\\n                if (costMap.containsKey(Pair(cp, np))) {\\n                    nextCost = Math.min(nextCost, cost + costMap[Pair(cp, np)]!!)\\n                    // println(\"${cp.x}, ${cp.y} -> ${np.x}, ${np.y} : ${nextCost} ( ${costMap[Pair(cp, np)]!!} )\")\\n                }\\n\\n\\n                if (nextCost < distMap[np]!!) {\\n                    // println(\"${cp.x}, ${cp.y} -> ${np.x}, ${np.y} : ${nextCost}\")\\n                    distMap[np] = nextCost\\n                    pq.offer(PointWithCost(np, nextCost))\\n                }\\n            }\\n        }\\n\\n        return -1\\n    }\\n\\n    fun dist(sp: Point, tp: Point): Int{\\n        return Math.abs(sp.x - tp.x) + Math.abs(sp.y - tp.y)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476601,
                "title": "c-dijkstra-s-algorithm-take-x-y-as-a-node",
                "content": "# Approach\\n- Here when we observe this question closely we can conclude this is an basically finding shortest distance from start to target if we consider each (x,y) as a node and distance between two nodes are abs(x1-x2)+abs(y1-y2) so we can easily able to find shortest path using Dijkstra algorithm \\n- So there is one more thing to observe for special paths we only can move in one way form (x1,y1) to (x2,y2) \\n- So here we are going to find out the min dist form starting point to the ending to all the special paths than we can easily conclude our answer from there\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<vector<int>,int> dist;\\n        dist[start]=0;\\n\\n        vector<vector<int>> validRoads;\\n\\n        for(auto x:specialRoads){\\n            int a=x[0], b=x[1], c=x[2], d=x[3], cost=x[4];\\n            if(abs(a-c)+abs(b-d)>cost){\\n                validRoads.push_back({a,b,c,d,cost});\\n                dist[{c,d}]=1e9;\\n            }\\n        }\\n\\n        set<vector<int>> se;\\n\\n        se.insert({0,start[0],start[1]});\\n\\n        while(se.size()){\\n            auto temp=*(se.begin());\\n            se.erase(temp);\\n            int tillCost=temp[0], x=temp[1], y=temp[2];\\n\\n            for(auto it:validRoads){\\n                int a=it[0], b=it[1], c=it[2], d=it[3], cost=it[4];\\n\\n                if(dist[{c,d}]>tillCost+abs(x-a)+abs(y-b)+cost){\\n                    se.erase({dist[{c,d}],c,d});\\n                    dist[{c,d}]=tillCost+abs(x-a)+abs(y-b)+cost;\\n                    se.insert({dist[{c,d}],c,d});\\n                }\\n            }\\n        }\\n\\n        int ans=abs(start[0]-target[0])+abs(start[1]-target[1]);\\n\\n        for(auto x:dist){\\n            int c=x.first[0], d=x.first[1], cost=x.second;\\n\\n            ans=min(ans,cost+abs(c-target[0])+abs(d-target[1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<vector<int>,int> dist;\\n        dist[start]=0;\\n\\n        vector<vector<int>> validRoads;\\n\\n        for(auto x:specialRoads){\\n            int a=x[0], b=x[1], c=x[2], d=x[3], cost=x[4];\\n            if(abs(a-c)+abs(b-d)>cost){\\n                validRoads.push_back({a,b,c,d,cost});\\n                dist[{c,d}]=1e9;\\n            }\\n        }\\n\\n        set<vector<int>> se;\\n\\n        se.insert({0,start[0],start[1]});\\n\\n        while(se.size()){\\n            auto temp=*(se.begin());\\n            se.erase(temp);\\n            int tillCost=temp[0], x=temp[1], y=temp[2];\\n\\n            for(auto it:validRoads){\\n                int a=it[0], b=it[1], c=it[2], d=it[3], cost=it[4];\\n\\n                if(dist[{c,d}]>tillCost+abs(x-a)+abs(y-b)+cost){\\n                    se.erase({dist[{c,d}],c,d});\\n                    dist[{c,d}]=tillCost+abs(x-a)+abs(y-b)+cost;\\n                    se.insert({dist[{c,d}],c,d});\\n                }\\n            }\\n        }\\n\\n        int ans=abs(start[0]-target[0])+abs(start[1]-target[1]);\\n\\n        for(auto x:dist){\\n            int c=x.first[0], d=x.first[1], cost=x.second;\\n\\n            ans=min(ans,cost+abs(c-target[0])+abs(d-target[1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475168,
                "title": "python3-dijkstra-variant-heavily-commented",
                "content": "# Explanation\\nIf we think of this problem as a graph, we have a starting node (given by its x and y coordinates) and would like to find the shortest path to the destination node. However, there are infinitely many neighbors of each node (since any coordinate can reach another coordinate via the Manhattan distance). We also have a list of special, directed edges that can connect some coordinate to another one, with a specified cost.\\n\\nThis problem seems extremely challenging at first since all nodes have inifinitely many neighbors. However, because the default distance between any two coordinates is the Manhattan Distance, we know that, without any special roads, the shortest path from a node to the destination node *is* the direct path from the current to the destination, and that no intermediate nodes should be considered. So, absent of any special roads, there\\'s really only one neighbor, instead of infinitely many, that has to be considered (which is the destination node).\\n\\nTo account for the fact that we have special roads, we also consider going to the source of each special road as well and factor that into our calculation.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        distances = dict()\\n        frontier = [(0, tuple(start))]\\n        distances[tuple(start)] = 0\\n        road_dict = defaultdict(lambda : [])\\n        global_dst = tuple(target)\\n        for road in specialRoads:\\n            src = (road[0], road[1])\\n            dst = (road[2], road[3])\\n            # does this road even help?\\n            if road[4] < self.distance(src, dst): \\n                road_dict[src].append((dst, road[4]))\\n\\n        while frontier:\\n            dist, src = heapq.heappop(frontier)\\n            if src == global_dst:\\n                return dist\\n            \\n            # Case where we have visited this location already in a more optimal manner\\n            if distances[src] < dist:\\n                continue\\n\\n            # check distance to destination (direct)\\n            to_dst = dist + self.distance(src, global_dst)\\n            if (global_dst not in distances or distances[global_dst] > to_dst):\\n                distances[global_dst] = to_dst\\n                # print(f\"From {src} can reach {global_dst} in {to_dst}\")\\n                heapq.heappush(frontier, (to_dst, global_dst))\\n\\n            # is this a special road? if so, try to use it.\\n            if src in road_dict:\\n                # Use the road; iterate over potential destinations\\n                for road_dst, road_cost in road_dict[src]:\\n                    to_road_dst = dist + road_cost\\n                    if road_dst not in distances or distances[road_dst] > to_road_dst:\\n                        distances[road_dst] = to_road_dst\\n                        heapq.heappush(frontier, (to_road_dst, road_dst))\\n\\n                # at this point since we\\'ve reached a point in our road_dict we can discard src\\n                road_dict.pop(src)\\n\\n            # attempt to go to the source of any special road that hasn\\'t been visited yet...\\n            for road_src in road_dict:\\n                to_road_src = dist + self.distance(src, road_src)\\n                if road_src not in distances or distances[road_src] > to_road_src:\\n                    distances[road_src] = to_road_src\\n                    heapq.heappush(frontier, (to_road_src, road_src))\\n\\n        # can\\'t reach here\\n        return -1\\n\\n    def distance(self, src, dst):\\n        # print(f\"Dist from {src} to {dst}\")\\n        return abs(src[1] - dst[1]) + abs(src[0] - dst[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        distances = dict()\\n        frontier = [(0, tuple(start))]\\n        distances[tuple(start)] = 0\\n        road_dict = defaultdict(lambda : [])\\n        global_dst = tuple(target)\\n        for road in specialRoads:\\n            src = (road[0], road[1])\\n            dst = (road[2], road[3])\\n            # does this road even help?\\n            if road[4] < self.distance(src, dst): \\n                road_dict[src].append((dst, road[4]))\\n\\n        while frontier:\\n            dist, src = heapq.heappop(frontier)\\n            if src == global_dst:\\n                return dist\\n            \\n            # Case where we have visited this location already in a more optimal manner\\n            if distances[src] < dist:\\n                continue\\n\\n            # check distance to destination (direct)\\n            to_dst = dist + self.distance(src, global_dst)\\n            if (global_dst not in distances or distances[global_dst] > to_dst):\\n                distances[global_dst] = to_dst\\n                # print(f\"From {src} can reach {global_dst} in {to_dst}\")\\n                heapq.heappush(frontier, (to_dst, global_dst))\\n\\n            # is this a special road? if so, try to use it.\\n            if src in road_dict:\\n                # Use the road; iterate over potential destinations\\n                for road_dst, road_cost in road_dict[src]:\\n                    to_road_dst = dist + road_cost\\n                    if road_dst not in distances or distances[road_dst] > to_road_dst:\\n                        distances[road_dst] = to_road_dst\\n                        heapq.heappush(frontier, (to_road_dst, road_dst))\\n\\n                # at this point since we\\'ve reached a point in our road_dict we can discard src\\n                road_dict.pop(src)\\n\\n            # attempt to go to the source of any special road that hasn\\'t been visited yet...\\n            for road_src in road_dict:\\n                to_road_src = dist + self.distance(src, road_src)\\n                if road_src not in distances or distances[road_src] > to_road_src:\\n                    distances[road_src] = to_road_src\\n                    heapq.heappush(frontier, (to_road_src, road_src))\\n\\n        # can\\'t reach here\\n        return -1\\n\\n    def distance(self, src, dst):\\n        # print(f\"Dist from {src} to {dst}\")\\n        return abs(src[1] - dst[1]) + abs(src[0] - dst[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474927,
                "title": "c-easy-solution-dijkstra-heap-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a min-heap, first push the start position into the min-heap with distance 0. For every steps in while loop, there are two circumstances, one is going straight to target, one is use the special road. For the first way, add the curr distance to manhattan distance from current to target and push into min-heap. \\n\\nFor the second way, traverse the speicial road. If the current position is same as the position of the starting point of special road, use the special road. On contrary, add the current position to the starting position of that special road. To optimize the time complexity, we could use a hashtable to record the smallest distance to the positions, if a position has been visited before, check if the current cost is smaller or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDijkstra\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        if(start==target){\\n            return 0;\\n        }\\n\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        unordered_map<int,unordered_map<int,int>> visited;\\n        pq.push({0,start[0],start[1]});\\n\\n        while(!pq.empty()){\\n            vector<int> curr = pq.top();\\n            pq.pop();\\n            int dis = curr[0];\\n            int r = curr[1];\\n            int c = curr[2];\\n            if(r==target[0] && c==target[1]){\\n                return dis;\\n            }\\n            if(visited.count(r) && visited[r].count(c)){\\n                if(visited[r][c]<=dis){\\n                    continue;\\n                }\\n            }\\n            visited[r][c] = dis;\\n            // straight to target\\n            int toTarget = abs(r-target[0]) + abs(c-target[1]);\\n            pq.push({dis+toTarget,target[0],target[1]});\\n            //if could to specialRoads\\n            for(auto sr:specialRoads){\\n                int x1=sr[0];\\n                int y1=sr[1];\\n                int x2=sr[2];\\n                int y2=sr[3];\\n                int cost=sr[4];\\n\\n                if(r==x1 && c==y1){ // could use specialRoads\\n                    int nextCost = cost + dis;\\n                    pq.push({nextCost,x2,y2});\\n                }else{\\n                    int nextCost = abs(r-x1) + abs(c-y1) + dis;\\n                    pq.push({nextCost,x1,y1});\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        if(start==target){\\n            return 0;\\n        }\\n\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        unordered_map<int,unordered_map<int,int>> visited;\\n        pq.push({0,start[0],start[1]});\\n\\n        while(!pq.empty()){\\n            vector<int> curr = pq.top();\\n            pq.pop();\\n            int dis = curr[0];\\n            int r = curr[1];\\n            int c = curr[2];\\n            if(r==target[0] && c==target[1]){\\n                return dis;\\n            }\\n            if(visited.count(r) && visited[r].count(c)){\\n                if(visited[r][c]<=dis){\\n                    continue;\\n                }\\n            }\\n            visited[r][c] = dis;\\n            // straight to target\\n            int toTarget = abs(r-target[0]) + abs(c-target[1]);\\n            pq.push({dis+toTarget,target[0],target[1]});\\n            //if could to specialRoads\\n            for(auto sr:specialRoads){\\n                int x1=sr[0];\\n                int y1=sr[1];\\n                int x2=sr[2];\\n                int y2=sr[3];\\n                int cost=sr[4];\\n\\n                if(r==x1 && c==y1){ // could use specialRoads\\n                    int nextCost = cost + dis;\\n                    pq.push({nextCost,x2,y2});\\n                }else{\\n                    int nextCost = abs(r-x1) + abs(c-y1) + dis;\\n                    pq.push({nextCost,x1,y1});\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474839,
                "title": "java-dijkstra",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        Map<List<Integer>, Integer> points = new HashMap<>();\\n        Map<Integer, Map<Integer, Integer>> edges = new HashMap<>();\\n        List<Integer> startPoint = new ArrayList<>(Arrays.asList(start[0], start[1]));\\n        List<Integer> targetPoint = new ArrayList<>(Arrays.asList(target[0], target[1]));\\n        int s = insertPoint(points, startPoint);\\n        int t = insertPoint(points, targetPoint);\\n        for (int[] road : specialRoads) {\\n            List<Integer> beginPoint = new ArrayList<>(Arrays.asList(road[0], road[1]));\\n            List<Integer> endPoint = new ArrayList<>(Arrays.asList(road[2], road[3]));\\n            int b = insertPoint(points, beginPoint);\\n            int e = insertPoint(points, endPoint);\\n            addEdge(b, e, road[4], edges);\\n        }\\n        for (List<Integer> ps : points.keySet()) {\\n            for (List<Integer> pe : points.keySet()) {\\n                addEdge(points.get(ps), points.get(pe), getDistance(ps, pe), edges);\\n            }\\n        }\\n        return getShortestDistance(s, t, edges);\\n    }\\n\\n    private int getShortestDistance(int s, int t, Map<Integer, Map<Integer, Integer>> edges) {\\n        Set<Integer> visited = new HashSet<>();\\n        Map<Integer, Integer> distances = new HashMap<>();\\n        for (var entry : edges.entrySet()) {\\n            distances.put(entry.getKey(), Integer.MAX_VALUE / 2);\\n            for (var key : entry.getValue().keySet()) {\\n                distances.put(key, Integer.MAX_VALUE / 2);\\n            }\\n        }\\n        distances.put(s, 0);\\n        while (!visited.contains(t)) {\\n            int next = getSmallestUnvistedKey(distances, visited);\\n            Map<Integer, Integer> nextNeighbors = edges.containsKey(next) ? \\n                edges.get(next) : new HashMap<>();\\n            for (int nbr : nextNeighbors.keySet()) {\\n                if (visited.contains(next)) {\\n                    continue;\\n                }\\n                int newDistance = distances.get(next) + nextNeighbors.get(nbr);\\n                int currentDistance = distances.get(nbr);\\n                if (newDistance < currentDistance) {\\n                    distances.put(nbr, newDistance);\\n                }\\n            }\\n            visited.add(next);\\n        }\\n        return distances.get(t);\\n    }\\n\\n    private int getSmallestUnvistedKey(Map<Integer, Integer> map, Set<Integer> visited) {\\n        int smallestValue = Integer.MAX_VALUE, smallestKey = -1;        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() < smallestValue && !visited.contains(entry.getKey())) {\\n                smallestValue = entry.getValue();\\n                smallestKey = entry.getKey();\\n            }\\n        }\\n        return smallestKey;\\n    }\\n\\n    private int insertPoint(Map<List<Integer>, Integer> points, List<Integer> point) {\\n        if (points.containsKey(point)) {\\n            return points.get(point);\\n        }\\n        points.put(point, points.size());\\n        return points.get(point);\\n    }\\n\\n    private void addEdge(int s, int t, int weight, Map<Integer, Map<Integer, Integer>> edges) {\\n        if (s == t) {\\n            return;\\n        }\\n        if (!edges.containsKey(s)) {\\n            edges.put(s, new HashMap<>());\\n        }\\n        Map<Integer, Integer> sourceMap = edges.get(s);\\n        if (sourceMap.containsKey(t) && sourceMap.get(t) <= weight) {\\n            return;\\n        }\\n        sourceMap.put(t, weight);\\n    }\\n\\n    private int getDistance(List<Integer> p1, List<Integer> p2) {\\n        return Math.abs(p1.get(0) - p2.get(0)) + Math.abs(p1.get(1) - p2.get(1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        Map<List<Integer>, Integer> points = new HashMap<>();\\n        Map<Integer, Map<Integer, Integer>> edges = new HashMap<>();\\n        List<Integer> startPoint = new ArrayList<>(Arrays.asList(start[0], start[1]));\\n        List<Integer> targetPoint = new ArrayList<>(Arrays.asList(target[0], target[1]));\\n        int s = insertPoint(points, startPoint);\\n        int t = insertPoint(points, targetPoint);\\n        for (int[] road : specialRoads) {\\n            List<Integer> beginPoint = new ArrayList<>(Arrays.asList(road[0], road[1]));\\n            List<Integer> endPoint = new ArrayList<>(Arrays.asList(road[2], road[3]));\\n            int b = insertPoint(points, beginPoint);\\n            int e = insertPoint(points, endPoint);\\n            addEdge(b, e, road[4], edges);\\n        }\\n        for (List<Integer> ps : points.keySet()) {\\n            for (List<Integer> pe : points.keySet()) {\\n                addEdge(points.get(ps), points.get(pe), getDistance(ps, pe), edges);\\n            }\\n        }\\n        return getShortestDistance(s, t, edges);\\n    }\\n\\n    private int getShortestDistance(int s, int t, Map<Integer, Map<Integer, Integer>> edges) {\\n        Set<Integer> visited = new HashSet<>();\\n        Map<Integer, Integer> distances = new HashMap<>();\\n        for (var entry : edges.entrySet()) {\\n            distances.put(entry.getKey(), Integer.MAX_VALUE / 2);\\n            for (var key : entry.getValue().keySet()) {\\n                distances.put(key, Integer.MAX_VALUE / 2);\\n            }\\n        }\\n        distances.put(s, 0);\\n        while (!visited.contains(t)) {\\n            int next = getSmallestUnvistedKey(distances, visited);\\n            Map<Integer, Integer> nextNeighbors = edges.containsKey(next) ? \\n                edges.get(next) : new HashMap<>();\\n            for (int nbr : nextNeighbors.keySet()) {\\n                if (visited.contains(next)) {\\n                    continue;\\n                }\\n                int newDistance = distances.get(next) + nextNeighbors.get(nbr);\\n                int currentDistance = distances.get(nbr);\\n                if (newDistance < currentDistance) {\\n                    distances.put(nbr, newDistance);\\n                }\\n            }\\n            visited.add(next);\\n        }\\n        return distances.get(t);\\n    }\\n\\n    private int getSmallestUnvistedKey(Map<Integer, Integer> map, Set<Integer> visited) {\\n        int smallestValue = Integer.MAX_VALUE, smallestKey = -1;        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() < smallestValue && !visited.contains(entry.getKey())) {\\n                smallestValue = entry.getValue();\\n                smallestKey = entry.getKey();\\n            }\\n        }\\n        return smallestKey;\\n    }\\n\\n    private int insertPoint(Map<List<Integer>, Integer> points, List<Integer> point) {\\n        if (points.containsKey(point)) {\\n            return points.get(point);\\n        }\\n        points.put(point, points.size());\\n        return points.get(point);\\n    }\\n\\n    private void addEdge(int s, int t, int weight, Map<Integer, Map<Integer, Integer>> edges) {\\n        if (s == t) {\\n            return;\\n        }\\n        if (!edges.containsKey(s)) {\\n            edges.put(s, new HashMap<>());\\n        }\\n        Map<Integer, Integer> sourceMap = edges.get(s);\\n        if (sourceMap.containsKey(t) && sourceMap.get(t) <= weight) {\\n            return;\\n        }\\n        sourceMap.put(t, weight);\\n    }\\n\\n    private int getDistance(List<Integer> p1, List<Integer> p2) {\\n        return Math.abs(p1.get(0) - p2.get(0)) + Math.abs(p1.get(1) - p2.get(1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474393,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    long T = 100000L;\\n    public int Dis(int x1, int y1, int x2, int y2)=>Math.Abs(x2-x1) + Math.Abs(y2-y1);\\n    public long Key(int x, int y) => x* T + y;\\n    \\n    public int MinimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        \\n        int M  = target.Sum()-start.Sum();\\n        Dictionary<long, int> Visited = new(); //keep visited position, postion=>cost\\n        PriorityQueue<(int x, int y, int cost),int> Q = new ();//D ar\\n        var specialRoadss = specialRoads.Where(sr=>Math.Abs(sr[2]-sr[0])+Math.Abs(sr[3]-sr[1])>sr[4]);\\n         \\n        \\n        if(specialRoadss.Count()==0)\\n            return M;\\n       \\n        Visited[Key(start[0] , start[1])]  =  0;\\n        Visited[Key(target[0], target[1])] =  M;\\n        \\n        foreach(int[] sr in specialRoadss)\\n        {\\n            long key =Key(sr[2],sr[3]);\\n            var distance = Math.Min(Dis(sr[0],sr[1],start[0],start[1]) + sr[4],Dis(start[0],start[1],sr[2],sr[3]));\\n            if( Visited.ContainsKey(key) )\\n                 Visited[key] = Math.Min(distance,Visited[key]) ; \\n            else\\n                 Visited[key] = distance;\\n          \\n            Q.Enqueue((sr[2],sr[3],Visited[key]), Visited[key] );\\n           \\n        }\\n        Q.Enqueue((target[0],target[1],M),M);\\n        \\n        while(Q.Count>0)\\n        {\\n            \\n            (int x, int y,int cost) = Q.Dequeue();\\n            long key = Key(x,y);\\n            if(Visited[key]<cost)\\n                continue;\\n            int distance = Visited[key] + Dis(x,y, target[0],target[1]);\\n            if(distance<M)\\n            {\\n                \\n               M = distance;\\n            }\\n                \\n            \\n           foreach(int[] sr in specialRoadss)\\n           {               \\n                distance = Dis(sr[0],sr[1],x,y) + sr[4] + Visited[key];\\n                var key1 = Key(sr[2],sr[3]);\\n                \\n                \\n                if(distance<M && distance<Visited[key1])\\n                {\\n                  \\n                    Visited[key1] = distance;\\n                    Q.Enqueue((sr[2],sr[3],distance), Visited[key1] );\\n                     \\n                }\\n           }\\n        }\\n            \\n       return M; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    long T = 100000L;\\n    public int Dis(int x1, int y1, int x2, int y2)=>Math.Abs(x2-x1) + Math.Abs(y2-y1);\\n    public long Key(int x, int y) => x* T + y;\\n    \\n    public int MinimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        \\n        int M  = target.Sum()-start.Sum();\\n        Dictionary<long, int> Visited = new(); //keep visited position, postion=>cost\\n        PriorityQueue<(int x, int y, int cost),int> Q = new ();//D ar\\n        var specialRoadss = specialRoads.Where(sr=>Math.Abs(sr[2]-sr[0])+Math.Abs(sr[3]-sr[1])>sr[4]);\\n         \\n        \\n        if(specialRoadss.Count()==0)\\n            return M;\\n       \\n        Visited[Key(start[0] , start[1])]  =  0;\\n        Visited[Key(target[0], target[1])] =  M;\\n        \\n        foreach(int[] sr in specialRoadss)\\n        {\\n            long key =Key(sr[2],sr[3]);\\n            var distance = Math.Min(Dis(sr[0],sr[1],start[0],start[1]) + sr[4],Dis(start[0],start[1],sr[2],sr[3]));\\n            if( Visited.ContainsKey(key) )\\n                 Visited[key] = Math.Min(distance,Visited[key]) ; \\n            else\\n                 Visited[key] = distance;\\n          \\n            Q.Enqueue((sr[2],sr[3],Visited[key]), Visited[key] );\\n           \\n        }\\n        Q.Enqueue((target[0],target[1],M),M);\\n        \\n        while(Q.Count>0)\\n        {\\n            \\n            (int x, int y,int cost) = Q.Dequeue();\\n            long key = Key(x,y);\\n            if(Visited[key]<cost)\\n                continue;\\n            int distance = Visited[key] + Dis(x,y, target[0],target[1]);\\n            if(distance<M)\\n            {\\n                \\n               M = distance;\\n            }\\n                \\n            \\n           foreach(int[] sr in specialRoadss)\\n           {               \\n                distance = Dis(sr[0],sr[1],x,y) + sr[4] + Visited[key];\\n                var key1 = Key(sr[2],sr[3]);\\n                \\n                \\n                if(distance<M && distance<Visited[key1])\\n                {\\n                  \\n                    Visited[key1] = distance;\\n                    Q.Enqueue((sr[2],sr[3],distance), Visited[key1] );\\n                     \\n                }\\n           }\\n        }\\n            \\n       return M; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474193,
                "title": "java-only-simple-bfs-faster-than-100-solution",
                "content": "\\n\\n# Code\\n```\\nclass Cord{\\n    int x,y,c;\\n    Cord(int x,int y,int c){\\n        this.x=x;\\n        this.y=y;\\n        this.c=c;\\n    }\\n}\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        List<Integer> l=new ArrayList<>();\\n        for(int i=0;i<specialRoads.length;i++){\\n            if(Math.abs(specialRoads[i][0]-specialRoads[i][2])+Math.abs(specialRoads[i][1]-specialRoads[i][3])>=specialRoads[i][4])   l.add(i);\\n        }\\n        int minCost=Math.abs(start[0]-target[0])+Math.abs(start[1]-target[1]),n=1;\\n        Queue<Cord> q=new PriorityQueue<>((e1,e2)->e1.c-e2.c);\\n        q.add(new Cord(start[0],start[1],0));\\n        Set<String> vis=new HashSet<>();\\n        while(!q.isEmpty() && minCost>q.peek().c){\\n            Cord c=q.poll();\\n            if(c.x==target[0] && c.y==target[1])    return c.c;\\n            String s=c.x+\" \"+c.y;\\n            if(vis.contains(s)) continue;\\n            vis.add(s);\\n            for(int i:l){\\n                if(c.x==specialRoads[i][0] && c.y==specialRoads[i][1]){\\n                    int cost=specialRoads[i][4]+c.c;\\n                    if(!vis.contains(specialRoads[i][2]+\" \"+specialRoads[i][3])){\\n                        Cord nc=new Cord(specialRoads[i][2],specialRoads[i][3],cost);\\n                        q.add(nc);\\n                    }\\n                }\\n                else{\\n                    int cost=Math.abs(c.x-specialRoads[i][0])+Math.abs(c.y-specialRoads[i][1])+c.c;\\n                    if(!vis.contains(specialRoads[i][0]+\" \"+specialRoads[i][1])){\\n                        Cord nc=new Cord(specialRoads[i][0],specialRoads[i][1],cost);\\n                        q.add(nc);\\n                    }\\n                }\\n            }\\n            q.add(new Cord(target[0],target[1],Math.abs(c.x-target[0])+Math.abs(c.y-target[1])+c.c));\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Cord{\\n    int x,y,c;\\n    Cord(int x,int y,int c){\\n        this.x=x;\\n        this.y=y;\\n        this.c=c;\\n    }\\n}\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        List<Integer> l=new ArrayList<>();\\n        for(int i=0;i<specialRoads.length;i++){\\n            if(Math.abs(specialRoads[i][0]-specialRoads[i][2])+Math.abs(specialRoads[i][1]-specialRoads[i][3])>=specialRoads[i][4])   l.add(i);\\n        }\\n        int minCost=Math.abs(start[0]-target[0])+Math.abs(start[1]-target[1]),n=1;\\n        Queue<Cord> q=new PriorityQueue<>((e1,e2)->e1.c-e2.c);\\n        q.add(new Cord(start[0],start[1],0));\\n        Set<String> vis=new HashSet<>();\\n        while(!q.isEmpty() && minCost>q.peek().c){\\n            Cord c=q.poll();\\n            if(c.x==target[0] && c.y==target[1])    return c.c;\\n            String s=c.x+\" \"+c.y;\\n            if(vis.contains(s)) continue;\\n            vis.add(s);\\n            for(int i:l){\\n                if(c.x==specialRoads[i][0] && c.y==specialRoads[i][1]){\\n                    int cost=specialRoads[i][4]+c.c;\\n                    if(!vis.contains(specialRoads[i][2]+\" \"+specialRoads[i][3])){\\n                        Cord nc=new Cord(specialRoads[i][2],specialRoads[i][3],cost);\\n                        q.add(nc);\\n                    }\\n                }\\n                else{\\n                    int cost=Math.abs(c.x-specialRoads[i][0])+Math.abs(c.y-specialRoads[i][1])+c.c;\\n                    if(!vis.contains(specialRoads[i][0]+\" \"+specialRoads[i][1])){\\n                        Cord nc=new Cord(specialRoads[i][0],specialRoads[i][1],cost);\\n                        q.add(nc);\\n                    }\\n                }\\n            }\\n            q.add(new Cord(target[0],target[1],Math.abs(c.x-target[0])+Math.abs(c.y-target[1])+c.c));\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473249,
                "title": "easy-djkstra-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dijkastra( map<pair<int,int>,vector<vector<int>>> graph,vector<int>& start,vector<int>& target,     map<pair<int,int>,long long > mp){\\n    set<vector<long>> st;\\n\\n    mp[{start[0],start[1]}]=0;\\n    st.insert({mp[{start[0],start[1]}],start[0],start[1]});\\n    while(!st.empty()){\\n        int nodex=(*st.begin())[1];\\n         int nodey=(*st.begin())[2];\\n         st.erase(st.begin());\\n         for(auto it : graph[{nodex,nodey}]){\\n             if(mp[{it[0],it[1]}]>mp[{nodex,nodey}]+it[2]){\\n                 mp[{it[0],it[1]}]=mp[{nodex,nodey}]+it[2];\\n                 st.insert({mp[{it[0],it[1]}],it[0],it[1]});\\n             }\\n         }\\n    }\\n\\n    return mp[{target[0],target[1]}];\\n\\n\\n}\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int,int>,vector<vector<int>>> mp;\\n            map<pair<int,int>,long long > mp1;\\n        for(int i=0;i<specialRoads.size();i++){\\n            mp[{specialRoads[i][0],specialRoads[i][1]}].push_back({specialRoads[i][2],specialRoads[i][3],specialRoads[i][4]});\\n\\n            // mp[{specialRoads[i][2],specialRoads[i][3]}].push_back({specialRoads[i][0],specialRoads[i][1],specialRoads[i][4]});\\n            mp[{start[0],start[1]}].push_back({specialRoads[i][0],specialRoads[i][1],abs(start[0]-specialRoads[i][0])+abs(start[1]-specialRoads[i][1])});\\n               mp[{specialRoads[i][2],specialRoads[i][3]}].push_back({target[0],target[1],abs(target[0]-specialRoads[i][2])+abs(target[1]-specialRoads[i][3])});\\n            mp1[{specialRoads[i][0],specialRoads[i][1]}] =INT_MAX;\\n            mp1[{specialRoads[i][2],specialRoads[i][3]}] =INT_MAX;\\n        }\\n          mp1[{target[0],target[1]}] =INT_MAX;\\n          mp[{start[0],start[1]}].push_back({target[0],target[1],abs(start[0]-target[0])+abs(start[1]-target[1])});\\n\\n          for(int i=0;i<specialRoads.size();i++){\\n              for(int j=0;j<specialRoads.size();j++){\\n                  if(i==j) continue;\\n                //    mp[{specialRoads[i][0],specialRoads[i][1]}].push_back({specialRoads[j][0],specialRoads[j][1],abs(specialRoads[i][0]-specialRoads[j][0])+abs(specialRoads[i][1]-specialRoads[j][1])});\\n                    //    mp[{specialRoads[j][0],specialRoads[j][1]}].push_back({specialRoads[i][0],specialRoads[i][1],abs(specialRoads[i][0]-specialRoads[j][0])+abs(specialRoads[i][1]-specialRoads[j][1])});\\n                        //    mp[{specialRoads[i][0],specialRoads[i][1]}].push_back({specialRoads[j][2],specialRoads[j][3],abs(specialRoads[i][0]-specialRoads[j][2])+abs(specialRoads[i][1]-specialRoads[j][3])});\\n                               mp[{specialRoads[j][2],specialRoads[j][3]}].push_back({specialRoads[i][0],specialRoads[i][1],abs(specialRoads[i][0]-specialRoads[j][2])+abs(specialRoads[i][1]-specialRoads[j][3])});\\n\\n\\n                                mp[{specialRoads[i][2],specialRoads[i][3]}].push_back({specialRoads[j][0],specialRoads[j][1],abs(specialRoads[i][2]-specialRoads[j][0])+abs(specialRoads[i][3]-specialRoads[j][1])});\\n                    //    mp[{specialRoads[j][0],specialRoads[j][1]}].push_back({specialRoads[i][2],specialRoads[i][1],abs(specialRoads[i][2]-specialRoads[j][0])+abs(specialRoads[i][3]-specialRoads[j][1])});\\n                        //    mp[{specialRoads[i][2],specialRoads[i][3]}].push_back({specialRoads[j][2],specialRoads[j][3],abs(specialRoads[i][2]-specialRoads[j][2])+abs(specialRoads[i][3]-specialRoads[j][3])});\\n                            //    mp[{specialRoads[j][2],specialRoads[j][3]}].push_back({specialRoads[i][2],specialRoads[i][3],abs(specialRoads[i][2]-specialRoads[j][2])+abs(specialRoads[i][3]-specialRoads[j][3])});\\n\\n              }\\n          }\\n    return dijkastra(mp,start,target,mp1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dijkastra( map<pair<int,int>,vector<vector<int>>> graph,vector<int>& start,vector<int>& target,     map<pair<int,int>,long long > mp){\\n    set<vector<long>> st;\\n\\n    mp[{start[0],start[1]}]=0;\\n    st.insert({mp[{start[0],start[1]}],start[0],start[1]});\\n    while(!st.empty()){\\n        int nodex=(*st.begin())[1];\\n         int nodey=(*st.begin())[2];\\n         st.erase(st.begin());\\n         for(auto it : graph[{nodex,nodey}]){\\n             if(mp[{it[0],it[1]}]>mp[{nodex,nodey}]+it[2]){\\n                 mp[{it[0],it[1]}]=mp[{nodex,nodey}]+it[2];\\n                 st.insert({mp[{it[0],it[1]}],it[0],it[1]});\\n             }\\n         }\\n    }\\n\\n    return mp[{target[0],target[1]}];\\n\\n\\n}\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        map<pair<int,int>,vector<vector<int>>> mp;\\n            map<pair<int,int>,long long > mp1;\\n        for(int i=0;i<specialRoads.size();i++){\\n            mp[{specialRoads[i][0],specialRoads[i][1]}].push_back({specialRoads[i][2],specialRoads[i][3],specialRoads[i][4]});\\n\\n            // mp[{specialRoads[i][2],specialRoads[i][3]}].push_back({specialRoads[i][0],specialRoads[i][1],specialRoads[i][4]});\\n            mp[{start[0],start[1]}].push_back({specialRoads[i][0],specialRoads[i][1],abs(start[0]-specialRoads[i][0])+abs(start[1]-specialRoads[i][1])});\\n               mp[{specialRoads[i][2],specialRoads[i][3]}].push_back({target[0],target[1],abs(target[0]-specialRoads[i][2])+abs(target[1]-specialRoads[i][3])});\\n            mp1[{specialRoads[i][0],specialRoads[i][1]}] =INT_MAX;\\n            mp1[{specialRoads[i][2],specialRoads[i][3]}] =INT_MAX;\\n        }\\n          mp1[{target[0],target[1]}] =INT_MAX;\\n          mp[{start[0],start[1]}].push_back({target[0],target[1],abs(start[0]-target[0])+abs(start[1]-target[1])});\\n\\n          for(int i=0;i<specialRoads.size();i++){\\n              for(int j=0;j<specialRoads.size();j++){\\n                  if(i==j) continue;\\n                //    mp[{specialRoads[i][0],specialRoads[i][1]}].push_back({specialRoads[j][0],specialRoads[j][1],abs(specialRoads[i][0]-specialRoads[j][0])+abs(specialRoads[i][1]-specialRoads[j][1])});\\n                    //    mp[{specialRoads[j][0],specialRoads[j][1]}].push_back({specialRoads[i][0],specialRoads[i][1],abs(specialRoads[i][0]-specialRoads[j][0])+abs(specialRoads[i][1]-specialRoads[j][1])});\\n                        //    mp[{specialRoads[i][0],specialRoads[i][1]}].push_back({specialRoads[j][2],specialRoads[j][3],abs(specialRoads[i][0]-specialRoads[j][2])+abs(specialRoads[i][1]-specialRoads[j][3])});\\n                               mp[{specialRoads[j][2],specialRoads[j][3]}].push_back({specialRoads[i][0],specialRoads[i][1],abs(specialRoads[i][0]-specialRoads[j][2])+abs(specialRoads[i][1]-specialRoads[j][3])});\\n\\n\\n                                mp[{specialRoads[i][2],specialRoads[i][3]}].push_back({specialRoads[j][0],specialRoads[j][1],abs(specialRoads[i][2]-specialRoads[j][0])+abs(specialRoads[i][3]-specialRoads[j][1])});\\n                    //    mp[{specialRoads[j][0],specialRoads[j][1]}].push_back({specialRoads[i][2],specialRoads[i][1],abs(specialRoads[i][2]-specialRoads[j][0])+abs(specialRoads[i][3]-specialRoads[j][1])});\\n                        //    mp[{specialRoads[i][2],specialRoads[i][3]}].push_back({specialRoads[j][2],specialRoads[j][3],abs(specialRoads[i][2]-specialRoads[j][2])+abs(specialRoads[i][3]-specialRoads[j][3])});\\n                            //    mp[{specialRoads[j][2],specialRoads[j][3]}].push_back({specialRoads[i][2],specialRoads[i][3],abs(specialRoads[i][2]-specialRoads[j][2])+abs(specialRoads[i][3]-specialRoads[j][3])});\\n\\n              }\\n          }\\n    return dijkastra(mp,start,target,mp1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472807,
                "title": "java-easy-bfs-not-dijecstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n \\n    LinkedList<int[]> points = new LinkedList<>();\\n    points.add(new int[]{start[0], start[1], 0});\\n    int ans = Integer.MAX_VALUE;\\n    int[] vis = new int[specialRoads.length];\\n    Arrays.fill(vis, Integer.MAX_VALUE);\\n\\n    while(!points.isEmpty()){\\n      int[] p = points.pollLast();\\n      if(p[2] + dis(p, target) < ans) ans = p[2] + dis(p, target);\\n\\n      for(int i = 0; i != specialRoads.length; ++i)\\n        if(p[2] + dis(p, specialRoads[i]) < vis[i]){\\n          vis[i] = p[2] + dis(p, specialRoads[i]);\\n          points.add(new int[]{specialRoads[i][2], specialRoads[i][3], vis[i] + specialRoads[i][4]});\\n        } \\n    } \\n\\n    return ans;\\n  }\\n\\n  private int dis(int[] a, int[] b){\\n    return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n \\n    LinkedList<int[]> points = new LinkedList<>();\\n    points.add(new int[]{start[0], start[1], 0});\\n    int ans = Integer.MAX_VALUE;\\n    int[] vis = new int[specialRoads.length];\\n    Arrays.fill(vis, Integer.MAX_VALUE);\\n\\n    while(!points.isEmpty()){\\n      int[] p = points.pollLast();\\n      if(p[2] + dis(p, target) < ans) ans = p[2] + dis(p, target);\\n\\n      for(int i = 0; i != specialRoads.length; ++i)\\n        if(p[2] + dis(p, specialRoads[i]) < vis[i]){\\n          vis[i] = p[2] + dis(p, specialRoads[i]);\\n          points.add(new int[]{specialRoads[i][2], specialRoads[i][3], vis[i] + specialRoads[i][4]});\\n        } \\n    } \\n\\n    return ans;\\n  }\\n\\n  private int dis(int[] a, int[] b){\\n    return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472646,
                "title": "c-o-n-3",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& roads) \\n    {\\n        int n=roads.size();\\n        vector<ll>cost(n,INT_MAX);\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                ll tmp=abs(start[0]-roads[j][0])+abs(start[1]-roads[j][1])+roads[j][4];\\n                for(int k=0;k<n;k++)\\n                {\\n                    ll cur=cost[k]+abs(roads[k][2]-roads[j][0])+abs(roads[k][3]-roads[j][1])+roads[j][4];\\n                    tmp=min(cur,tmp);\\n                }\\n                cost[j]=min(cost[j],1ll*tmp);\\n            }\\n        ll res=abs(target[0]-start[0])+abs(target[1]-start[1]);\\n        for(int i=0;i<n;i++)\\n        {\\n            ll cur=cost[i]+abs(target[0]-roads[i][2])+abs(target[1]-roads[i][3]);\\n            res=min(res,cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& roads) \\n    {\\n        int n=roads.size();\\n        vector<ll>cost(n,INT_MAX);\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                ll tmp=abs(start[0]-roads[j][0])+abs(start[1]-roads[j][1])+roads[j][4];\\n                for(int k=0;k<n;k++)\\n                {\\n                    ll cur=cost[k]+abs(roads[k][2]-roads[j][0])+abs(roads[k][3]-roads[j][1])+roads[j][4];\\n                    tmp=min(cur,tmp);\\n                }\\n                cost[j]=min(cost[j],1ll*tmp);\\n            }\\n        ll res=abs(target[0]-start[0])+abs(target[1]-start[1]);\\n        for(int i=0;i<n;i++)\\n        {\\n            ll cur=cost[i]+abs(target[0]-roads[i][2])+abs(target[1]-roads[i][3]);\\n            res=min(res,cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472485,
                "title": "python-dijkstra",
                "content": "# Code\\n```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        def dist(v1, v2):\\n            x1, y1 = v1\\n            x2, y2 = v2\\n            return abs(x1-x2) + abs(y1-y2)\\n\\n        h = [(0,start[0],start[1])]\\n        G = defaultdict(list)\\n        start, target = tuple(start), tuple(target)\\n        V = set()\\n        W = set()\\n        for x1, y1, x2, y2, d in specialRoads:\\n            G[(x1, y1)].append((x2, y2, d))\\n            V.add((x1,y1))\\n            W.add((x2,y2))\\n        G[start].append((target[0], target[1], dist(start, target)))\\n        for v in V:\\n            G[start].append((v[0], v[1], dist(start,v)))\\n        for w in W:\\n            G[w].append((target[0],target[1],dist(w,target)))\\n        for v in V|W:\\n            for w in V|W:\\n                G[v].append((w[0],w[1],dist(v,w)))\\n                G[w].append((v[0],v[1],dist(v,w)))\\n        visited = set()\\n        while h:\\n            d,i,j = heappop(h)\\n            if (i,j) in visited: continue\\n            if (i,j) == target: return d\\n            visited.add((i,j))\\n            for ni,nj,cost in G[(i,j)]:\\n                heappush(h, (d+cost,ni,nj))\\n        \\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        def dist(v1, v2):\\n            x1, y1 = v1\\n            x2, y2 = v2\\n            return abs(x1-x2) + abs(y1-y2)\\n\\n        h = [(0,start[0],start[1])]\\n        G = defaultdict(list)\\n        start, target = tuple(start), tuple(target)\\n        V = set()\\n        W = set()\\n        for x1, y1, x2, y2, d in specialRoads:\\n            G[(x1, y1)].append((x2, y2, d))\\n            V.add((x1,y1))\\n            W.add((x2,y2))\\n        G[start].append((target[0], target[1], dist(start, target)))\\n        for v in V:\\n            G[start].append((v[0], v[1], dist(start,v)))\\n        for w in W:\\n            G[w].append((target[0],target[1],dist(w,target)))\\n        for v in V|W:\\n            for w in V|W:\\n                G[v].append((w[0],w[1],dist(v,w)))\\n                G[w].append((v[0],v[1],dist(v,w)))\\n        visited = set()\\n        while h:\\n            d,i,j = heappop(h)\\n            if (i,j) in visited: continue\\n            if (i,j) == target: return d\\n            visited.add((i,j))\\n            for ni,nj,cost in G[(i,j)]:\\n                heappush(h, (d+cost,ni,nj))\\n        \\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472052,
                "title": "python3-dijkstra",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        xs, ys, xt, yt = start[0], start[1], target[0], target[1]\\n        \\n        min_cost = abs(xs-xt)+abs(ys-yt)\\n        seen = set()\\n        pq = [(0,xs,ys)] # (accumulated_cost,x,y)\\n        while pq:\\n            c1,x,y = heapq.heappop(pq)\\n            if (x,y) in seen or c1 > min_cost:\\n                continue\\n\\n            seen.add((x,y))\\n            min_cost = min(min_cost, c1+abs(x-xt)+abs(y-yt))\\n            for x1,y1,x2,y2,c2 in specialRoads:\\n                heapq.heappush(pq, (c1+abs(x1-x)+abs(y1-y)+c2,x2,y2))\\n                \\n        return min_cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        xs, ys, xt, yt = start[0], start[1], target[0], target[1]\\n        \\n        min_cost = abs(xs-xt)+abs(ys-yt)\\n        seen = set()\\n        pq = [(0,xs,ys)] # (accumulated_cost,x,y)\\n        while pq:\\n            c1,x,y = heapq.heappop(pq)\\n            if (x,y) in seen or c1 > min_cost:\\n                continue\\n\\n            seen.add((x,y))\\n            min_cost = min(min_cost, c1+abs(x-xt)+abs(y-yt))\\n            for x1,y1,x2,y2,c2 in specialRoads:\\n                heapq.heappush(pq, (c1+abs(x1-x)+abs(y1-y)+c2,x2,y2))\\n                \\n        return min_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471629,
                "title": "python-10-line-dijkstra-solution",
                "content": "```\\ndef minimumCost(self, s: List[int], t: List[int], roads: List[List[int]]) -> int:\\n\\tcost = {(e[2], e[3]):abs(e[2]-s[0])+abs(e[3]-s[1]) for e in roads}\\n\\tq, ans = [[0, s[0], s[1]]], abs(t[0]-s[0])+abs(t[1]-s[1])\\n\\twhile(q):\\n\\t\\tc, x, y = heappop(q)\\n\\t\\tans = min(ans, c+abs(t[0]-x)+abs(t[1]-y))\\n\\t\\tfor x1, y1, x2, y2, d in roads:\\n\\t\\t\\tif abs(x1-x2)+abs(y1-y2)>d and cost[(x2, y2)]>c+abs(x-x1)+abs(y-y1)+d:\\n\\t\\t\\t\\tcost[(x2, y2)] = c+abs(x-x1)+abs(y-y1)+d\\n\\t\\t\\t\\theappush(q, [cost[(x2, y2)], x2, y2])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumCost(self, s: List[int], t: List[int], roads: List[List[int]]) -> int:\\n\\tcost = {(e[2], e[3]):abs(e[2]-s[0])+abs(e[3]-s[1]) for e in roads}\\n\\tq, ans = [[0, s[0], s[1]]], abs(t[0]-s[0])+abs(t[1]-s[1])\\n\\twhile(q):\\n\\t\\tc, x, y = heappop(q)\\n\\t\\tans = min(ans, c+abs(t[0]-x)+abs(t[1]-y))\\n\\t\\tfor x1, y1, x2, y2, d in roads:\\n\\t\\t\\tif abs(x1-x2)+abs(y1-y2)>d and cost[(x2, y2)]>c+abs(x-x1)+abs(y-y1)+d:\\n\\t\\t\\t\\tcost[(x2, y2)] = c+abs(x-x1)+abs(y-y1)+d\\n\\t\\t\\t\\theappush(q, [cost[(x2, y2)], x2, y2])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3471358,
                "title": "bfs-shortest-path-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfrom the description this is a graph search problem which find\\na shortest path cost from start pos to target pos. so every waypoint will be a node for graph, and edge cost is the distance.\\nthe most difficult part is constructing the graph. it is a little tricky and need to pay attention to it when you construct it\\n# Approach\\nafter you construc the graph, just use bfs + priority_queue to find the shortest path(dijkstra shortest path)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass comp {\\npublic:\\n  bool operator()(pair<int, int>& lhs, pair<int, int>& rhs){\\n      if(lhs.second > rhs.second) {\\n          return true;\\n      }\\n      return false;\\n  }\\n};\\nclass Solution {\\npublic:\\n    string pos_to_key(int x, int y) {\\n        return to_string(x) + \":\" + to_string(y);\\n    }\\n\\n    void construct_order(\\n    vector<pair<int, int>>& order_map,\\n    vector<int>& start, vector<int>& target,\\n     vector<vector<int>>& specialRoads) {\\n       unordered_set<string> seen;\\n       \\n       order_map.push_back(pair<int, int>(start[0], start[1]));\\n       \\n       seen.insert(pos_to_key(start[0], start[1]));\\n       seen.insert(pos_to_key(target[0], target[1]));\\n       for(int idx = 0; idx < specialRoads.size(); idx++) {\\n           vector<int> road = specialRoads[idx];\\n           string s_key = pos_to_key(road[0], road[1]);\\n           string e_key = pos_to_key(road[2], road[3]);\\n           if(seen.find(s_key) == seen.end()) {\\n               order_map.push_back(pair<int, int>(road[0], road[1]));\\n               seen.insert(s_key);\\n           }\\n           if(seen.find(e_key) == seen.end()) {\\n               order_map.push_back(pair<int, int>(road[2], road[3]));\\n               seen.insert(e_key);\\n           }\\n       }\\n\\n       order_map.push_back(pair<int, int>(target[0], target[1]));\\n\\n\\n    }\\n    \\n    int dijkstra_find_shortest(vector<vector<int>>& graph, int node_count, int start, int end) {\\n        vector<int> distance(node_count, INT_MAX);\\n        distance[start] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, comp> node_queue;\\n        node_queue.push(pair<int, int>(start, 0));\\n        while(node_queue.empty() == false) {\\n            // every time you pop the smallest node \\n            pair<int ,int> front_node = node_queue.top();\\n            node_queue.pop();\\n            int node_idx = front_node.first;\\n            int cur_dis = front_node.second;\\n            vector<int> neighbors = graph[node_idx];\\n            for(int idx = 0; idx < node_count; idx++) {\\n                if(idx == node_idx) {\\n                    continue;\\n                }\\n                int direct_dis = graph[node_idx][idx];\\n                int candidate_dis = direct_dis + cur_dis;\\n                if(candidate_dis < distance[idx]) {\\n                    // update or call it relax the edge\\n                    distance[idx] = candidate_dis;\\n                    // push the new node\\n                    node_queue.push(pair<int, int>(idx, candidate_dis));\\n                }\\n            }\\n        }\\n        return distance[end];\\n    }\\n\\n    int minimumCost(vector<int>& start, vector<int>& target,\\n     vector<vector<int>>& specialRoads) {\\n        vector<pair<int, int>> order_map;\\n        construct_order(order_map, start, target, specialRoads);\\n        int count_nodes = order_map.size();\\n      //  cout << \"num of nodes:\" << count_nodes << endl;\\n        // construct the graph\\n        // first reverse order\\n        unordered_map<string, int> reverse_order_map;\\n        for(int idx = 0; idx < order_map.size(); idx++) {\\n            string key = pos_to_key(order_map[idx].first, order_map[idx].second);\\n            reverse_order_map[key] = idx;\\n        }\\n        \\n        vector<vector<int>> graph(count_nodes, vector<int>(count_nodes, INT_MAX));\\n        for(int i = 0; i < count_nodes; i++) {\\n            for(int j = i; j < count_nodes; j++) {\\n                if(i == j) {\\n                    graph[i][j] = 0;\\n                }\\n                else {\\n                    // you calculate the distance\\n                    pair<int, int> p1 = order_map[i];\\n                    pair<int, int> p2 = order_map[j];\\n                    int dis = abs(p1.first - p2.first) + abs(p1.second - p2.second);\\n                    graph[i][j] = dis;\\n                    graph[j][i] = dis;\\n                }\\n            }\\n        }\\n\\n        // use the special road\\n        for(int idx = 0; idx < specialRoads.size(); idx++) {\\n            vector<int> road = specialRoads[idx];\\n            string s_key = pos_to_key(road[0], road[1]);\\n            string e_key = pos_to_key(road[2], road[3]);\\n            int s_idx = reverse_order_map[s_key];\\n            int e_idx = reverse_order_map[e_key];\\n            int cost = road[4];\\n            if(graph[s_idx][e_idx] > cost) {\\n                graph[s_idx][e_idx] = cost;\\n            }\\n        }\\n       \\n       /* for(int i = 0; i < count_nodes; i++) {\\n            for(int j = 0; j < count_nodes; j++) {\\n                cout << graph[i][j] << \",\";\\n            }\\n            cout<<endl;\\n        } */\\n\\n        return dijkstra_find_shortest(graph, count_nodes, 0, count_nodes - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass comp {\\npublic:\\n  bool operator()(pair<int, int>& lhs, pair<int, int>& rhs){\\n      if(lhs.second > rhs.second) {\\n          return true;\\n      }\\n      return false;\\n  }\\n};\\nclass Solution {\\npublic:\\n    string pos_to_key(int x, int y) {\\n        return to_string(x) + \":\" + to_string(y);\\n    }\\n\\n    void construct_order(\\n    vector<pair<int, int>>& order_map,\\n    vector<int>& start, vector<int>& target,\\n     vector<vector<int>>& specialRoads) {\\n       unordered_set<string> seen;\\n       \\n       order_map.push_back(pair<int, int>(start[0], start[1]));\\n       \\n       seen.insert(pos_to_key(start[0], start[1]));\\n       seen.insert(pos_to_key(target[0], target[1]));\\n       for(int idx = 0; idx < specialRoads.size(); idx++) {\\n           vector<int> road = specialRoads[idx];\\n           string s_key = pos_to_key(road[0], road[1]);\\n           string e_key = pos_to_key(road[2], road[3]);\\n           if(seen.find(s_key) == seen.end()) {\\n               order_map.push_back(pair<int, int>(road[0], road[1]));\\n               seen.insert(s_key);\\n           }\\n           if(seen.find(e_key) == seen.end()) {\\n               order_map.push_back(pair<int, int>(road[2], road[3]));\\n               seen.insert(e_key);\\n           }\\n       }\\n\\n       order_map.push_back(pair<int, int>(target[0], target[1]));\\n\\n\\n    }\\n    \\n    int dijkstra_find_shortest(vector<vector<int>>& graph, int node_count, int start, int end) {\\n        vector<int> distance(node_count, INT_MAX);\\n        distance[start] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, comp> node_queue;\\n        node_queue.push(pair<int, int>(start, 0));\\n        while(node_queue.empty() == false) {\\n            // every time you pop the smallest node \\n            pair<int ,int> front_node = node_queue.top();\\n            node_queue.pop();\\n            int node_idx = front_node.first;\\n            int cur_dis = front_node.second;\\n            vector<int> neighbors = graph[node_idx];\\n            for(int idx = 0; idx < node_count; idx++) {\\n                if(idx == node_idx) {\\n                    continue;\\n                }\\n                int direct_dis = graph[node_idx][idx];\\n                int candidate_dis = direct_dis + cur_dis;\\n                if(candidate_dis < distance[idx]) {\\n                    // update or call it relax the edge\\n                    distance[idx] = candidate_dis;\\n                    // push the new node\\n                    node_queue.push(pair<int, int>(idx, candidate_dis));\\n                }\\n            }\\n        }\\n        return distance[end];\\n    }\\n\\n    int minimumCost(vector<int>& start, vector<int>& target,\\n     vector<vector<int>>& specialRoads) {\\n        vector<pair<int, int>> order_map;\\n        construct_order(order_map, start, target, specialRoads);\\n        int count_nodes = order_map.size();\\n      //  cout << \"num of nodes:\" << count_nodes << endl;\\n        // construct the graph\\n        // first reverse order\\n        unordered_map<string, int> reverse_order_map;\\n        for(int idx = 0; idx < order_map.size(); idx++) {\\n            string key = pos_to_key(order_map[idx].first, order_map[idx].second);\\n            reverse_order_map[key] = idx;\\n        }\\n        \\n        vector<vector<int>> graph(count_nodes, vector<int>(count_nodes, INT_MAX));\\n        for(int i = 0; i < count_nodes; i++) {\\n            for(int j = i; j < count_nodes; j++) {\\n                if(i == j) {\\n                    graph[i][j] = 0;\\n                }\\n                else {\\n                    // you calculate the distance\\n                    pair<int, int> p1 = order_map[i];\\n                    pair<int, int> p2 = order_map[j];\\n                    int dis = abs(p1.first - p2.first) + abs(p1.second - p2.second);\\n                    graph[i][j] = dis;\\n                    graph[j][i] = dis;\\n                }\\n            }\\n        }\\n\\n        // use the special road\\n        for(int idx = 0; idx < specialRoads.size(); idx++) {\\n            vector<int> road = specialRoads[idx];\\n            string s_key = pos_to_key(road[0], road[1]);\\n            string e_key = pos_to_key(road[2], road[3]);\\n            int s_idx = reverse_order_map[s_key];\\n            int e_idx = reverse_order_map[e_key];\\n            int cost = road[4];\\n            if(graph[s_idx][e_idx] > cost) {\\n                graph[s_idx][e_idx] = cost;\\n            }\\n        }\\n       \\n       /* for(int i = 0; i < count_nodes; i++) {\\n            for(int j = 0; j < count_nodes; j++) {\\n                cout << graph[i][j] << \",\";\\n            }\\n            cout<<endl;\\n        } */\\n\\n        return dijkstra_find_shortest(graph, count_nodes, 0, count_nodes - 1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3471306,
                "title": "javascript-dijkstra-s-algorithm-heap-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nconst Heap = function(n, empty, compare) {\\n    this.data = Array(n).fill(empty);\\n    this.end = 0;\\n    this.empty = empty;\\n    this.compare = compare;\\n}\\n\\nHeap.prototype.insert = function(val) {\\n    const end = this.end;\\n    const compare = this.compare;\\n    this.data[end] = val;\\n    if (end != 0) {\\n        let i = end;\\n        while(i > 0 && !compare(this.data[Math.floor((i-1)/2)], this.data[i])) {\\n            let j = Math.floor((i-1)/2);\\n            [this.data[j], this.data[i]] = [this.data[i], this.data[j]];\\n            i = j;\\n        }\\n    }\\n    this.end++;\\n}\\nHeap.prototype.poll = function() {\\n    const compare = this.compare;\\n    let end = this.end;\\n    if(end == 0) {\\n        return null;\\n    } else {\\n        end--;\\n        var output = this.data[0];\\n        if (end >= 0) {\\n            this.data[0] = this.data[end];\\n            let i = 0;\\n            let j = 2*i + 1;\\n            let k = 2*i + 2;\\n            while(!compare(this.data[i], this.data[j]) || !compare(this.data[i], this.data[k])) {\\n                let l = compare(this.data[j], this.data[k])? j : k;\\n                [this.data[i], this.data[l], i, j, k] = [this.data[l], this.data[i], l, 2*l + 1, 2*l + 2];\\n            }            \\n        }\\n    }\\n    this.end--;\\n    this.data[end] = this.empty;    \\n    return output;\\n}\\nvar minimumCost = function(start, target, specialRoads) {\\n    if(start.join(\" \") == target.join(\" \")) {\\n        return 0;\\n    }    \\n    const getCost = function(initial, terminal) {\\n        const [x1, y1] = initial;\\n        const [x2, y2] = terminal;\\n        return Math.abs(x1-x2) + Math.abs(y1-y2);\\n    }    \\n    const buildGraph = function(start, target, edges) {\\n        const nodeList = new Map();\\n        const nodeByType = [new Set(), new Set()];        \\n        nodeList.set(start.join(\" \"), 0);\\n        nodeList.set(target.join(\" \"), 1);\\n        let i = 2;\\n        let pairing = 0;\\n        const edgeList = [];\\n        for(let j = 0; j < edges.length; j++) {\\n            const [x1, y1, x2, y2, cost] = edges[j];\\n            const [init, term] = [[x1, y1] .join(\" \"), [x2, y2].join(\" \")];\\n            const nodes = Array(2).fill();\\n            for(let n = 0; n < 2; n++) {\\n                const pt = [init,term][n];\\n                let k = nodeList.get(pt);\\n                if (k == undefined) {\\n                    k = i;\\n                    i++;\\n                }\\n                nodeByType[n].add([pt, pairing]);\\n                nodeList.set(pt, k);\\n                nodes[n] = k;\\n            }\\n            edgeList.push([nodes[0], nodes[1], cost])\\n            pairing++;                        \\n        }\\n        \\n        edgeList.push([0,1, getCost(start, target)]);\\n\\n        nodeByType[0].forEach(pt => {\\n            const node = nodeList.get(pt[0]);\\n            const pt1 = pt[0].split(\" \");\\n            const coordinates = Array.from(pt1, s => Number(s));\\n            edgeList.push([0, node, getCost(start, coordinates)]);\\n        })\\n\\n        nodeByType[1].forEach(pt => {\\n            const node = nodeList.get(pt[0]);\\n            const pt1 = pt[0].split(\" \");\\n            const coordinates = Array.from(pt1, s => Number(s));\\n            edgeList.push([node,1, getCost(target, coordinates)]);\\n        })\\n\\n        nodeByType[1].forEach(init => {\\n            nodeByType[0].forEach(term => {\\n                if(init[1] != term[1]) {\\n                    const initNode = nodeList.get(init[0]);\\n                    const termNode = nodeList.get(term[0]);                    \\n                    const init1 = Array.from(init[0].split(\" \"), s => Number(s));\\n                    const term1 = Array.from(term[0].split(\" \"), s => Number(s));\\n                    edgeList.push([initNode,termNode, getCost(init1, term1)]);\\n                }\\n            })\\n        })\\n        const output = Array.from(Array(nodeList.size), () => []);\\n        edgeList.forEach(edge => {\\n            const [a,b,cost] = edge;\\n            output[a].push([b,cost]);\\n        })\\n        return output; \\n    }\\n    const graph = buildGraph(start, target, specialRoads);\\n    const dist = Array(graph.length).fill(Number.POSITIVE_INFINITY);\\n    dist[0] = 0;\\n    const visited = new Set();\\n    const heap = new Heap(400*400, [null, Number.POSITIVE_INFINITY], (a,b) => a[1] <= b[1]);\\n    heap.insert([0,0]);\\n    while(heap.end > 0) {\\n        const [a, currDist] = heap.poll();\\n        if(!visited.has(a)) {\\n            visited.add(a);\\n            graph[a].forEach(edge => {\\n                const [b, cost] = edge;\\n                dist[b] = Math.min(dist[b], cost + currDist);\\n                heap.insert([b,dist[b]]);\\n            });\\n        }\\n    }\\n    return dist[1];     \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nconst Heap = function(n, empty, compare) {\\n    this.data = Array(n).fill(empty);\\n    this.end = 0;\\n    this.empty = empty;\\n    this.compare = compare;\\n}\\n\\nHeap.prototype.insert = function(val) {\\n    const end = this.end;\\n    const compare = this.compare;\\n    this.data[end] = val;\\n    if (end != 0) {\\n        let i = end;\\n        while(i > 0 && !compare(this.data[Math.floor((i-1)/2)], this.data[i])) {\\n            let j = Math.floor((i-1)/2);\\n            [this.data[j], this.data[i]] = [this.data[i], this.data[j]];\\n            i = j;\\n        }\\n    }\\n    this.end++;\\n}\\nHeap.prototype.poll = function() {\\n    const compare = this.compare;\\n    let end = this.end;\\n    if(end == 0) {\\n        return null;\\n    } else {\\n        end--;\\n        var output = this.data[0];\\n        if (end >= 0) {\\n            this.data[0] = this.data[end];\\n            let i = 0;\\n            let j = 2*i + 1;\\n            let k = 2*i + 2;\\n            while(!compare(this.data[i], this.data[j]) || !compare(this.data[i], this.data[k])) {\\n                let l = compare(this.data[j], this.data[k])? j : k;\\n                [this.data[i], this.data[l], i, j, k] = [this.data[l], this.data[i], l, 2*l + 1, 2*l + 2];\\n            }            \\n        }\\n    }\\n    this.end--;\\n    this.data[end] = this.empty;    \\n    return output;\\n}\\nvar minimumCost = function(start, target, specialRoads) {\\n    if(start.join(\" \") == target.join(\" \")) {\\n        return 0;\\n    }    \\n    const getCost = function(initial, terminal) {\\n        const [x1, y1] = initial;\\n        const [x2, y2] = terminal;\\n        return Math.abs(x1-x2) + Math.abs(y1-y2);\\n    }    \\n    const buildGraph = function(start, target, edges) {\\n        const nodeList = new Map();\\n        const nodeByType = [new Set(), new Set()];        \\n        nodeList.set(start.join(\" \"), 0);\\n        nodeList.set(target.join(\" \"), 1);\\n        let i = 2;\\n        let pairing = 0;\\n        const edgeList = [];\\n        for(let j = 0; j < edges.length; j++) {\\n            const [x1, y1, x2, y2, cost] = edges[j];\\n            const [init, term] = [[x1, y1] .join(\" \"), [x2, y2].join(\" \")];\\n            const nodes = Array(2).fill();\\n            for(let n = 0; n < 2; n++) {\\n                const pt = [init,term][n];\\n                let k = nodeList.get(pt);\\n                if (k == undefined) {\\n                    k = i;\\n                    i++;\\n                }\\n                nodeByType[n].add([pt, pairing]);\\n                nodeList.set(pt, k);\\n                nodes[n] = k;\\n            }\\n            edgeList.push([nodes[0], nodes[1], cost])\\n            pairing++;                        \\n        }\\n        \\n        edgeList.push([0,1, getCost(start, target)]);\\n\\n        nodeByType[0].forEach(pt => {\\n            const node = nodeList.get(pt[0]);\\n            const pt1 = pt[0].split(\" \");\\n            const coordinates = Array.from(pt1, s => Number(s));\\n            edgeList.push([0, node, getCost(start, coordinates)]);\\n        })\\n\\n        nodeByType[1].forEach(pt => {\\n            const node = nodeList.get(pt[0]);\\n            const pt1 = pt[0].split(\" \");\\n            const coordinates = Array.from(pt1, s => Number(s));\\n            edgeList.push([node,1, getCost(target, coordinates)]);\\n        })\\n\\n        nodeByType[1].forEach(init => {\\n            nodeByType[0].forEach(term => {\\n                if(init[1] != term[1]) {\\n                    const initNode = nodeList.get(init[0]);\\n                    const termNode = nodeList.get(term[0]);                    \\n                    const init1 = Array.from(init[0].split(\" \"), s => Number(s));\\n                    const term1 = Array.from(term[0].split(\" \"), s => Number(s));\\n                    edgeList.push([initNode,termNode, getCost(init1, term1)]);\\n                }\\n            })\\n        })\\n        const output = Array.from(Array(nodeList.size), () => []);\\n        edgeList.forEach(edge => {\\n            const [a,b,cost] = edge;\\n            output[a].push([b,cost]);\\n        })\\n        return output; \\n    }\\n    const graph = buildGraph(start, target, specialRoads);\\n    const dist = Array(graph.length).fill(Number.POSITIVE_INFINITY);\\n    dist[0] = 0;\\n    const visited = new Set();\\n    const heap = new Heap(400*400, [null, Number.POSITIVE_INFINITY], (a,b) => a[1] <= b[1]);\\n    heap.insert([0,0]);\\n    while(heap.end > 0) {\\n        const [a, currDist] = heap.poll();\\n        if(!visited.has(a)) {\\n            visited.add(a);\\n            graph[a].forEach(edge => {\\n                const [b, cost] = edge;\\n                dist[b] = Math.min(dist[b], cost + currDist);\\n                heap.insert([b,dist[b]]);\\n            });\\n        }\\n    }\\n    return dist[1];     \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471223,
                "title": "c-beats-100-dijkstra-s",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef tuple<int,int,int> triple_int;\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        // So the solution seem to be a modified dijkstra\\'s.\\n        // BFS + priority queue. The visited data structure should remove redundant traversals.\\n        // Need to preprocess the special roads for bfs.\\n        unordered_map<int, unordered_map<int, vector<vector<int>>>> special_roads;\\n        for(int i = 0; i < sr.size(); i++){\\n            special_roads[sr[i][0]][sr[i][1]].push_back({sr[i][2], sr[i][3], sr[i][4]});\\n        }\\n\\n        unordered_map<int, unordered_set<int>> visited;\\n        priority_queue<triple_int, vector<triple_int>, std::greater<triple_int>> pq;\\n        pq.push(tuple{0, start[0], start[1]});\\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            int cost = get<0>(cur), x = get<1>(cur), y = get<2>(cur);\\n            if(visited[x].find(y) != visited[x].end()) continue;\\n            visited[x].insert(y);\\n            // cout << \"At x: \" << x << \" y: \" << y << \" cost: \" << cost << endl;\\n            // Found the destination.\\n            if(x == target[0] && y == target[1]){\\n                return cost;\\n            }\\n\\n            // Lets add non special edges from current point.\\n            // First add target.\\n            pq.push(tuple{cost + abs(x - target[0]) + abs(y - target[1]), target[0], target[1]});\\n\\n            // Next add start co-ordinate of special roads.\\n            for(int i = 0; i < sr.size(); i++){\\n                if(visited[sr[i][0]].find(sr[i][1]) == visited[sr[i][0]].end()){\\n                    pq.push(tuple{cost + abs(x - sr[i][0]) + abs(y - sr[i][1]), sr[i][0], sr[i][1]});\\n                }\\n            }\\n\\n            // If we are already at start of a special road. use special road cost.\\n            for(auto& road : special_roads[x][y]){\\n                if(visited[road[0]].find(road[1]) == visited[road[0]].end()){\\n                   pq.push(tuple{cost + road[2], road[0], road[1]}); \\n                }\\n            }\\n        }\\n\\n\\n        // Should never reach here.\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef tuple<int,int,int> triple_int;\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        // So the solution seem to be a modified dijkstra\\'s.\\n        // BFS + priority queue. The visited data structure should remove redundant traversals.\\n        // Need to preprocess the special roads for bfs.\\n        unordered_map<int, unordered_map<int, vector<vector<int>>>> special_roads;\\n        for(int i = 0; i < sr.size(); i++){\\n            special_roads[sr[i][0]][sr[i][1]].push_back({sr[i][2], sr[i][3], sr[i][4]});\\n        }\\n\\n        unordered_map<int, unordered_set<int>> visited;\\n        priority_queue<triple_int, vector<triple_int>, std::greater<triple_int>> pq;\\n        pq.push(tuple{0, start[0], start[1]});\\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            int cost = get<0>(cur), x = get<1>(cur), y = get<2>(cur);\\n            if(visited[x].find(y) != visited[x].end()) continue;\\n            visited[x].insert(y);\\n            // cout << \"At x: \" << x << \" y: \" << y << \" cost: \" << cost << endl;\\n            // Found the destination.\\n            if(x == target[0] && y == target[1]){\\n                return cost;\\n            }\\n\\n            // Lets add non special edges from current point.\\n            // First add target.\\n            pq.push(tuple{cost + abs(x - target[0]) + abs(y - target[1]), target[0], target[1]});\\n\\n            // Next add start co-ordinate of special roads.\\n            for(int i = 0; i < sr.size(); i++){\\n                if(visited[sr[i][0]].find(sr[i][1]) == visited[sr[i][0]].end()){\\n                    pq.push(tuple{cost + abs(x - sr[i][0]) + abs(y - sr[i][1]), sr[i][0], sr[i][1]});\\n                }\\n            }\\n\\n            // If we are already at start of a special road. use special road cost.\\n            for(auto& road : special_roads[x][y]){\\n                if(visited[road[0]].find(road[1]) == visited[road[0]].end()){\\n                   pq.push(tuple{cost + road[2], road[0], road[1]}); \\n                }\\n            }\\n        }\\n\\n\\n        // Should never reach here.\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3471115,
                "title": "golang-dijkstra",
                "content": "It might be straightforward to come up with the solution but the implementation can be quite tricky \\n\\nSteps I followed to make my life easier while implementaion \\n - Find all the veriticies that need to be included in the Dijkstra implementaion.\\n - Find all edges for each of these vertices note here we need to include edges from special road as well as edges which are adjacent to very node pair.\\n - Ones edges and vertices are ready apply Dijkstra\\n - Note: I tried to use Bellman\\u2013Ford algorithm but got TLE  \\n\\n```\\nfunc minimumCost(start []int, target []int, specialRoads [][]int) int {\\n\\tseen := make(map[string]bool)\\n\\tvertices := make([][]int, 0)\\n\\tvertices = append(vertices, start)\\n\\tvertices = append(vertices, target)\\n\\tseen[key(start)] = true\\n\\tseen[key(target)] = true\\n\\n\\tedges := make(map[string][][]int)\\n\\n\\tfor _, road := range specialRoads {\\n\\t\\tv1, v2, _ := separate(road)\\n\\t\\tif _, ok := seen[key(v1)]; !ok {\\n\\t\\t\\tseen[key(v1)] = true\\n\\t\\t\\tvertices = append(vertices, v1)\\n\\t\\t}\\n\\t\\tif _, ok := seen[key(v2)]; !ok {\\n\\t\\t\\tseen[key(v2)] = true\\n\\t\\t\\tvertices = append(vertices, v2)\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, v := range vertices {\\n\\t\\tedges[key(v)] = make([][]int, 0)\\n\\t}\\n\\n\\tfor _, road := range specialRoads {\\n\\t\\tv1, v2, edge := separate(road)\\n\\t\\tedges[key(v1)] = append(edges[key(v1)], []int{v2[0], v2[1], edge})\\n\\t}\\n\\n\\tfor _, s := range vertices {\\n\\t\\tfor _, t := range vertices {\\n\\t\\t\\tif key(s) == key(t) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tedges[key(s)] = append(edges[key(s)], []int{t[0], t[1], dist(s, t)})\\n\\t\\t}\\n\\t}\\n\\n\\tvar distances Arrays\\n\\tcost := make(map[string]int)\\n\\tfor _, s := range vertices {\\n\\t\\tif key(s) == key(start) {\\n\\t\\t\\tdistances = append(distances, IndexedVal{\\n\\t\\t\\t\\tindex: key(s),\\n\\t\\t\\t\\tval:   0,\\n\\t\\t\\t})\\n\\t\\t\\tcost[key(s)] = 0\\n\\t\\t} else {\\n\\t\\t\\tdistances = append(distances, IndexedVal{\\n\\t\\t\\t\\tindex: key(s),\\n\\t\\t\\t\\tval:   math.MaxInt,\\n\\t\\t\\t})\\n\\t\\t\\tcost[key(s)] = math.MaxInt\\n\\t\\t}\\n\\t}\\n\\theap.Init(&distances)\\n\\tfor distances.Len() != 0 {\\n\\t\\tcurrentMin := heap.Pop(&distances).(IndexedVal)\\n\\t\\tif currentMin.index == key(target) {\\n\\t\\t\\treturn currentMin.val\\n\\t\\t}\\n\\t\\tfor _, edge := range edges[currentMin.index] {\\n\\t\\t\\tto := []int{edge[0], edge[1]}\\n\\t\\t\\tweight := edge[2]\\n\\t\\t\\tif currentMin.val+weight < cost[key(to)] {\\n\\t\\t\\t\\tcost[key(to)] = currentMin.val + weight\\n\\t\\t\\t\\theap.Push(&distances, IndexedVal{index: key(to), val: cost[key(to)]})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc dist(start, target []int) int {\\n\\treturn Abs(start[0]-target[0]) + Abs(target[1]-start[1])\\n}\\n\\nfunc key(a []int) string {\\n\\treturn fmt.Sprintf(\"%d,%d\", a[0], a[1])\\n}\\n\\nfunc separate(start []int) ([]int, []int, int) {\\n\\treturn []int{start[0], start[1]}, []int{start[2], start[3]}, start[4]\\n}\\n\\n\\nfunc Abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n\\n\\n//heap stuff\\ntype IndexedVal struct {\\n\\tindex string\\n\\tval   int\\n}\\n\\nfunc (i IndexedVal) String() string {\\n\\treturn fmt.Sprintf(\"value: %d, index: %d\", i.val, i.index)\\n}\\n\\ntype Arrays []IndexedVal\\n\\nfunc (a *Arrays) Len() int {\\n\\treturn len(*a)\\n}\\n\\nfunc (a *Arrays) Less(i, j int) bool {\\n\\treturn (*a)[i].val <= (*a)[j].val\\n}\\n\\nfunc (a *Arrays) Swap(i, j int) {\\n\\t(*a)[i], (*a)[j] = (*a)[j], (*a)[i]\\n}\\n\\nfunc (a *Arrays) Push(x interface{}) {\\n\\t*a = append(*a, IndexedVal{\\n\\t\\tindex: x.(IndexedVal).index,\\n\\t\\tval:   x.(IndexedVal).val,\\n\\t})\\n}\\n\\nfunc (a *Arrays) Pop() interface{} {\\n\\tlastVal := (*a)[len(*a)-1]\\n\\t*a = (*a)[:len(*a)-1]\\n\\treturn lastVal\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumCost(start []int, target []int, specialRoads [][]int) int {\\n\\tseen := make(map[string]bool)\\n\\tvertices := make([][]int, 0)\\n\\tvertices = append(vertices, start)\\n\\tvertices = append(vertices, target)\\n\\tseen[key(start)] = true\\n\\tseen[key(target)] = true\\n\\n\\tedges := make(map[string][][]int)\\n\\n\\tfor _, road := range specialRoads {\\n\\t\\tv1, v2, _ := separate(road)\\n\\t\\tif _, ok := seen[key(v1)]; !ok {\\n\\t\\t\\tseen[key(v1)] = true\\n\\t\\t\\tvertices = append(vertices, v1)\\n\\t\\t}\\n\\t\\tif _, ok := seen[key(v2)]; !ok {\\n\\t\\t\\tseen[key(v2)] = true\\n\\t\\t\\tvertices = append(vertices, v2)\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, v := range vertices {\\n\\t\\tedges[key(v)] = make([][]int, 0)\\n\\t}\\n\\n\\tfor _, road := range specialRoads {\\n\\t\\tv1, v2, edge := separate(road)\\n\\t\\tedges[key(v1)] = append(edges[key(v1)], []int{v2[0], v2[1], edge})\\n\\t}\\n\\n\\tfor _, s := range vertices {\\n\\t\\tfor _, t := range vertices {\\n\\t\\t\\tif key(s) == key(t) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tedges[key(s)] = append(edges[key(s)], []int{t[0], t[1], dist(s, t)})\\n\\t\\t}\\n\\t}\\n\\n\\tvar distances Arrays\\n\\tcost := make(map[string]int)\\n\\tfor _, s := range vertices {\\n\\t\\tif key(s) == key(start) {\\n\\t\\t\\tdistances = append(distances, IndexedVal{\\n\\t\\t\\t\\tindex: key(s),\\n\\t\\t\\t\\tval:   0,\\n\\t\\t\\t})\\n\\t\\t\\tcost[key(s)] = 0\\n\\t\\t} else {\\n\\t\\t\\tdistances = append(distances, IndexedVal{\\n\\t\\t\\t\\tindex: key(s),\\n\\t\\t\\t\\tval:   math.MaxInt,\\n\\t\\t\\t})\\n\\t\\t\\tcost[key(s)] = math.MaxInt\\n\\t\\t}\\n\\t}\\n\\theap.Init(&distances)\\n\\tfor distances.Len() != 0 {\\n\\t\\tcurrentMin := heap.Pop(&distances).(IndexedVal)\\n\\t\\tif currentMin.index == key(target) {\\n\\t\\t\\treturn currentMin.val\\n\\t\\t}\\n\\t\\tfor _, edge := range edges[currentMin.index] {\\n\\t\\t\\tto := []int{edge[0], edge[1]}\\n\\t\\t\\tweight := edge[2]\\n\\t\\t\\tif currentMin.val+weight < cost[key(to)] {\\n\\t\\t\\t\\tcost[key(to)] = currentMin.val + weight\\n\\t\\t\\t\\theap.Push(&distances, IndexedVal{index: key(to), val: cost[key(to)]})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc dist(start, target []int) int {\\n\\treturn Abs(start[0]-target[0]) + Abs(target[1]-start[1])\\n}\\n\\nfunc key(a []int) string {\\n\\treturn fmt.Sprintf(\"%d,%d\", a[0], a[1])\\n}\\n\\nfunc separate(start []int) ([]int, []int, int) {\\n\\treturn []int{start[0], start[1]}, []int{start[2], start[3]}, start[4]\\n}\\n\\n\\nfunc Abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n\\n\\n//heap stuff\\ntype IndexedVal struct {\\n\\tindex string\\n\\tval   int\\n}\\n\\nfunc (i IndexedVal) String() string {\\n\\treturn fmt.Sprintf(\"value: %d, index: %d\", i.val, i.index)\\n}\\n\\ntype Arrays []IndexedVal\\n\\nfunc (a *Arrays) Len() int {\\n\\treturn len(*a)\\n}\\n\\nfunc (a *Arrays) Less(i, j int) bool {\\n\\treturn (*a)[i].val <= (*a)[j].val\\n}\\n\\nfunc (a *Arrays) Swap(i, j int) {\\n\\t(*a)[i], (*a)[j] = (*a)[j], (*a)[i]\\n}\\n\\nfunc (a *Arrays) Push(x interface{}) {\\n\\t*a = append(*a, IndexedVal{\\n\\t\\tindex: x.(IndexedVal).index,\\n\\t\\tval:   x.(IndexedVal).val,\\n\\t})\\n}\\n\\nfunc (a *Arrays) Pop() interface{} {\\n\\tlastVal := (*a)[len(*a)-1]\\n\\t*a = (*a)[:len(*a)-1]\\n\\treturn lastVal\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471113,
                "title": "c-struct-key-override-pq-dijkstra-280ms",
                "content": "# Intuition\\nWe reconstruct the whole graph as a traditional directed graph. Then Dijkstra. \\n\\n# Approach\\nTry some key override in map and unordered_map in c++. And use some template technique here, good for study !\\nV here is {source, target, both nodes on special roads}\\nE here is all the valid edge between the above nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(ElogV)\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T>>; //\\n\\npublic:\\n    struct node {\\n        int x;\\n        int y;\\n        node(int a,int b):x(a),y(b){};\\n\\n        // for map override\\n        bool operator==(const node & b) const {\\n            return x == b.x && y == b.y;\\n        }\\n        bool operator<(const node & b) const {\\n            return x < b.x || (x == b.x && y < b.y);\\n        }\\n    };\\n\\n    struct hash_node {\\n        size_t operator()(const node & a) const {\\n            size_t h1 = hash<int>()(a.x);\\n            size_t h2 = hash<int>()(a.y);\\n            return h1^h2;\\n        }\\n    };\\n\\n\\n\\n    int distance(node & a, node & b){\\n        return abs(a.x-b.x) + abs(a.y-b.y);\\n    }\\n\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        unordered_map<node,vector<pair<node,int>>,hash_node> g;\\n        \\n        unordered_map<node, int, hash_node> dist;\\n        \\n        node s{start[0],start[1]};\\n        node t{target[0],target[1]};\\n        \\n\\n    // construct graph\\n\\n        g[s].push_back(make_pair(t,distance(s,t)));\\n        \\n        for(auto & v: specialRoads){ \\n            node a{v[0],v[1]};\\n            node b{v[2],v[3]};\\n            g[s].push_back({a, distance(s,a)});\\n            g[b].push_back({t, distance(b,t)});\\n            g[a].push_back({b, min(distance(a,b), v[4])});\\n        }\\n        \\n        for(int i = 0; i<specialRoads.size(); ++i){\\n            for(int j = 0; j<specialRoads.size(); ++j){\\n                if(i != j){\\n                    node a{specialRoads[i][0],specialRoads[i][1]};\\n                    node b{specialRoads[i][2],specialRoads[i][3]};\\n                    node c{specialRoads[j][0],specialRoads[j][1]};\\n                    node d{specialRoads[j][2],specialRoads[j][3]};\\n                    g[b].push_back({c,distance(b,c)});\\n                    g[d].push_back({a,distance(a,d)});\\n                }\\n            }\\n        }\\n\\n    // Dijkstra\\n        min_pq<pair<int,node>> pq; // or rewrite as above with pair<int,node>\\n        \\n        for(auto & v: g[s]){\\n            pq.push({v.second, v.first}); //\\n        }\\n\\n        while(!pq.empty()){\\n            auto p = pq.top();\\n            pq.pop();\\n            node x = p.second;\\n            int d = p.first;\\n            \\n            if( x == t){\\n                dist[t] = d;\\n                return dist[t];\\n            }\\n            \\n            if(dist.count(x)){ // since dist always increase, the second time must be larger, no need to use\\n                // dist[{x,y}] = min(dist[{x,y}],d);\\n                continue;\\n            } \\n            \\n            dist[x] = d;\\n            \\n            for(auto & v: g[x]){\\n                pq.push({v.second + d, v.first});\\n            }\\n        }\\n        \\n        return dist[t];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\ntemplate<class T> using min_pq = priority_queue<T, vector<T>, greater<T>>; //\\n\\npublic:\\n    struct node {\\n        int x;\\n        int y;\\n        node(int a,int b):x(a),y(b){};\\n\\n        // for map override\\n        bool operator==(const node & b) const {\\n            return x == b.x && y == b.y;\\n        }\\n        bool operator<(const node & b) const {\\n            return x < b.x || (x == b.x && y < b.y);\\n        }\\n    };\\n\\n    struct hash_node {\\n        size_t operator()(const node & a) const {\\n            size_t h1 = hash<int>()(a.x);\\n            size_t h2 = hash<int>()(a.y);\\n            return h1^h2;\\n        }\\n    };\\n\\n\\n\\n    int distance(node & a, node & b){\\n        return abs(a.x-b.x) + abs(a.y-b.y);\\n    }\\n\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        unordered_map<node,vector<pair<node,int>>,hash_node> g;\\n        \\n        unordered_map<node, int, hash_node> dist;\\n        \\n        node s{start[0],start[1]};\\n        node t{target[0],target[1]};\\n        \\n\\n    // construct graph\\n\\n        g[s].push_back(make_pair(t,distance(s,t)));\\n        \\n        for(auto & v: specialRoads){ \\n            node a{v[0],v[1]};\\n            node b{v[2],v[3]};\\n            g[s].push_back({a, distance(s,a)});\\n            g[b].push_back({t, distance(b,t)});\\n            g[a].push_back({b, min(distance(a,b), v[4])});\\n        }\\n        \\n        for(int i = 0; i<specialRoads.size(); ++i){\\n            for(int j = 0; j<specialRoads.size(); ++j){\\n                if(i != j){\\n                    node a{specialRoads[i][0],specialRoads[i][1]};\\n                    node b{specialRoads[i][2],specialRoads[i][3]};\\n                    node c{specialRoads[j][0],specialRoads[j][1]};\\n                    node d{specialRoads[j][2],specialRoads[j][3]};\\n                    g[b].push_back({c,distance(b,c)});\\n                    g[d].push_back({a,distance(a,d)});\\n                }\\n            }\\n        }\\n\\n    // Dijkstra\\n        min_pq<pair<int,node>> pq; // or rewrite as above with pair<int,node>\\n        \\n        for(auto & v: g[s]){\\n            pq.push({v.second, v.first}); //\\n        }\\n\\n        while(!pq.empty()){\\n            auto p = pq.top();\\n            pq.pop();\\n            node x = p.second;\\n            int d = p.first;\\n            \\n            if( x == t){\\n                dist[t] = d;\\n                return dist[t];\\n            }\\n            \\n            if(dist.count(x)){ // since dist always increase, the second time must be larger, no need to use\\n                // dist[{x,y}] = min(dist[{x,y}],d);\\n                continue;\\n            } \\n            \\n            dist[x] = d;\\n            \\n            for(auto & v: g[x]){\\n                pq.push({v.second + d, v.first});\\n            }\\n        }\\n        \\n        return dist[t];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471072,
                "title": "javascript-dijkstra-full-graph-lookup",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nvar minimumCost = function(start, target, specialRoads) {\\n    const startArgId = getId(start[0], start[1]);\\n    const targetArgId = getId(target[0], target[1]);\\n    const graph = buildGraph(start, target, specialRoads);\\n    \\n    const dp = {\\n        [startArgId]: 0,\\n        [targetArgId]: targetArgId === startArgId ? 0 : Number.MAX_SAFE_INTEGER,\\n    }\\n    \\n    const queue = new MinPriorityQueue({ priority: (e) => e.min });\\n    queue.enqueue({ node: startArgId, min: 0 });\\n    \\n    while(!queue.isEmpty()) {\\n        const { node, min: currentDistance } = queue.dequeue().element;\\n        \\n        if (node === targetArgId) {\\n            continue;\\n        }\\n        \\n        for (const neibor of Object.keys(graph[node])) {\\n            const distance = (dp[node] !== undefined ? dp[node] : Number.MAX_SAFE_INTEGER) + graph[node][neibor];\\n            \\n            if (dp[neibor] === undefined || distance < dp[neibor]) {\\n                dp[neibor] = distance;\\n                queue.enqueue({ node: neibor, min: dp[neibor] });\\n            }\\n        }\\n    }\\n    \\n    return dp[targetArgId];\\n};\\n\\nconst cost = (x1, y1, x2, y2) => Math.abs(x2 - x1) + Math.abs(y2 - y1)\\nconst getId = (x, y) => `${x}-${y}`;\\nconst getMinCost = (prev, cost) => prev === undefined ? cost : Math.min(prev, cost);\\n\\nconst buildGraph = (start, target, specialRoads) => {\\n    const startArgId = getId(start[0], start[1]);\\n    const targetArgId = getId(target[0], target[1]);\\n    const graph = {\\n        [startArgId]: {\\n            [targetArgId]: cost(start[0], start[1], target[0], target[1]),\\n        }\\n    };\\n    \\n    // connections between roads\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        for (let j = 0; j < specialRoads.length; j++) {\\n            if (i === j) {\\n                continue;\\n            }\\n            \\n            const [,, x2, y2] = specialRoads[i]; // begin from end of i-th road\\n            const idStart = getId(x2, y2);\\n            const [x1, y1] = specialRoads[j]; // end in start for j-th road\\n            const idEnd = getId(x1, y1);\\n            \\n            if (idStart === idEnd) {\\n                continue;\\n            }\\n\\n            if(!graph[idStart]) {\\n                graph[idStart] = {};\\n            }\\n            \\n            graph[idStart][idEnd] = getMinCost(graph[idStart][idEnd], cost(x2, y2, x1, y1));\\n        }\\n    }\\n    \\n    //roads itself\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [x1, y1, x2, y2, cost] = specialRoads[i];\\n        const idStart = getId(x1, y1);\\n        const idEnd = getId(x2, y2);\\n\\n        if (idStart === idEnd) {\\n            continue;\\n        }\\n\\n        if(!graph[idStart]) {\\n            graph[idStart] = {};\\n        }\\n        \\n        graph[idStart][idEnd] = getMinCost(graph[idStart][idEnd], cost);\\n    }\\n    \\n    //connections with start\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [x1, y1] = specialRoads[i];\\n        const idEnd = getId(x1, y1);\\n\\n        if (startArgId === idEnd) {\\n            continue;\\n        }\\n\\n        graph[startArgId][idEnd] = getMinCost(graph[startArgId][idEnd], cost(start[0], start[1], x1, y1));\\n    }\\n    \\n    //connections with end\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [,, x2, y2] = specialRoads[i];\\n        const idStart = getId(x2, y2);\\n        \\n        if (idStart === targetArgId) {\\n            continue;\\n        }\\n\\n        if(!graph[idStart]) {\\n            graph[idStart] = {};\\n        }\\n\\n        graph[idStart][targetArgId] = getMinCost(graph[idStart][targetArgId], cost(x2, y2, target[0], target[1]));\\n    }\\n    \\n    return graph;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {number[]} start\\n * @param {number[]} target\\n * @param {number[][]} specialRoads\\n * @return {number}\\n */\\nvar minimumCost = function(start, target, specialRoads) {\\n    const startArgId = getId(start[0], start[1]);\\n    const targetArgId = getId(target[0], target[1]);\\n    const graph = buildGraph(start, target, specialRoads);\\n    \\n    const dp = {\\n        [startArgId]: 0,\\n        [targetArgId]: targetArgId === startArgId ? 0 : Number.MAX_SAFE_INTEGER,\\n    }\\n    \\n    const queue = new MinPriorityQueue({ priority: (e) => e.min });\\n    queue.enqueue({ node: startArgId, min: 0 });\\n    \\n    while(!queue.isEmpty()) {\\n        const { node, min: currentDistance } = queue.dequeue().element;\\n        \\n        if (node === targetArgId) {\\n            continue;\\n        }\\n        \\n        for (const neibor of Object.keys(graph[node])) {\\n            const distance = (dp[node] !== undefined ? dp[node] : Number.MAX_SAFE_INTEGER) + graph[node][neibor];\\n            \\n            if (dp[neibor] === undefined || distance < dp[neibor]) {\\n                dp[neibor] = distance;\\n                queue.enqueue({ node: neibor, min: dp[neibor] });\\n            }\\n        }\\n    }\\n    \\n    return dp[targetArgId];\\n};\\n\\nconst cost = (x1, y1, x2, y2) => Math.abs(x2 - x1) + Math.abs(y2 - y1)\\nconst getId = (x, y) => `${x}-${y}`;\\nconst getMinCost = (prev, cost) => prev === undefined ? cost : Math.min(prev, cost);\\n\\nconst buildGraph = (start, target, specialRoads) => {\\n    const startArgId = getId(start[0], start[1]);\\n    const targetArgId = getId(target[0], target[1]);\\n    const graph = {\\n        [startArgId]: {\\n            [targetArgId]: cost(start[0], start[1], target[0], target[1]),\\n        }\\n    };\\n    \\n    // connections between roads\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        for (let j = 0; j < specialRoads.length; j++) {\\n            if (i === j) {\\n                continue;\\n            }\\n            \\n            const [,, x2, y2] = specialRoads[i]; // begin from end of i-th road\\n            const idStart = getId(x2, y2);\\n            const [x1, y1] = specialRoads[j]; // end in start for j-th road\\n            const idEnd = getId(x1, y1);\\n            \\n            if (idStart === idEnd) {\\n                continue;\\n            }\\n\\n            if(!graph[idStart]) {\\n                graph[idStart] = {};\\n            }\\n            \\n            graph[idStart][idEnd] = getMinCost(graph[idStart][idEnd], cost(x2, y2, x1, y1));\\n        }\\n    }\\n    \\n    //roads itself\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [x1, y1, x2, y2, cost] = specialRoads[i];\\n        const idStart = getId(x1, y1);\\n        const idEnd = getId(x2, y2);\\n\\n        if (idStart === idEnd) {\\n            continue;\\n        }\\n\\n        if(!graph[idStart]) {\\n            graph[idStart] = {};\\n        }\\n        \\n        graph[idStart][idEnd] = getMinCost(graph[idStart][idEnd], cost);\\n    }\\n    \\n    //connections with start\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [x1, y1] = specialRoads[i];\\n        const idEnd = getId(x1, y1);\\n\\n        if (startArgId === idEnd) {\\n            continue;\\n        }\\n\\n        graph[startArgId][idEnd] = getMinCost(graph[startArgId][idEnd], cost(start[0], start[1], x1, y1));\\n    }\\n    \\n    //connections with end\\n    for (let i = 0; i < specialRoads.length; i++) {\\n        const [,, x2, y2] = specialRoads[i];\\n        const idStart = getId(x2, y2);\\n        \\n        if (idStart === targetArgId) {\\n            continue;\\n        }\\n\\n        if(!graph[idStart]) {\\n            graph[idStart] = {};\\n        }\\n\\n        graph[idStart][targetArgId] = getMinCost(graph[idStart][targetArgId], cost(x2, y2, target[0], target[1]));\\n    }\\n    \\n    return graph;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3470955,
                "title": "100-python-dijkstra",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        q, d = [(0, (start[0], start[1]))], defaultdict(list)\\n        for sp in specialRoads:\\n            if sp[4]<abs(sp[0]-sp[2])+abs(sp[1]-sp[3]):\\n                d[(sp[0], sp[1])].append(((sp[2], sp[3]), sp[4]))\\n        visited, res = set(), target[0]-start[0]+target[1]-start[1]\\n        while q:\\n            val, pos = heapq.heappop(q)\\n            if pos not in visited:\\n                visited.add(pos)\\n                res = min(res, abs(target[0]-pos[0])+abs(target[1]-pos[1])+val)\\n                for next_start in d:\\n                    for next_pos, next_val in d[next_start]:\\n                        if next_pos not in visited:\\n                            dis = abs(pos[0]-next_start[0])+abs(pos[1]-next_start[1])\\n                            heapq.heappush(q, ((val+next_val+dis, next_pos)))\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        q, d = [(0, (start[0], start[1]))], defaultdict(list)\\n        for sp in specialRoads:\\n            if sp[4]<abs(sp[0]-sp[2])+abs(sp[1]-sp[3]):\\n                d[(sp[0], sp[1])].append(((sp[2], sp[3]), sp[4]))\\n        visited, res = set(), target[0]-start[0]+target[1]-start[1]\\n        while q:\\n            val, pos = heapq.heappop(q)\\n            if pos not in visited:\\n                visited.add(pos)\\n                res = min(res, abs(target[0]-pos[0])+abs(target[1]-pos[1])+val)\\n                for next_start in d:\\n                    for next_pos, next_val in d[next_start]:\\n                        if next_pos not in visited:\\n                            dis = abs(pos[0]-next_start[0])+abs(pos[1]-next_start[1])\\n                            heapq.heappush(q, ((val+next_val+dis, next_pos)))\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 3470542,
                "title": "c-dijkstra-algorithm-map-to-store-each-nodes-i-j-shortest-distance-found",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        map<pair<int,int>,int>dis;\\n        \\n        pq.push({0,start[0],start[1]});\\n        dis[{start[0],start[1]}]=0;\\n\\n        int best=(abs(start[0]-target[1])+abs(target[0]-start[1]));\\n        \\n        while(!pq.empty()){\\n            int currNodei=pq.top()[1];\\n            int currNodej=pq.top()[2];\\n            int currDist=pq.top()[0];\\n\\n            pq.pop();\\n\\n            best=min(best,abs(currNodei-target[0])+abs(currNodej-target[1])+currDist);\\n\\n            for(auto &it:specialRoads){\\n                int cost=currDist+abs(it[0]-currNodei)+abs(it[1]-currNodej)+it[4];\\n                if(dis.find({it[2],it[3]})==dis.end()){\\n                    dis[{it[2],it[3]}]=cost;\\n                    pq.push({cost,it[2],it[3]});\\n                }\\n                else if(dis[{it[2],it[3]}]>cost){\\n                    dis[{it[2],it[3]}]=cost;\\n                    pq.push({cost,it[2],it[3]});\\n                }\\n            }\\n            \\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        map<pair<int,int>,int>dis;\\n        \\n        pq.push({0,start[0],start[1]});\\n        dis[{start[0],start[1]}]=0;\\n\\n        int best=(abs(start[0]-target[1])+abs(target[0]-start[1]));\\n        \\n        while(!pq.empty()){\\n            int currNodei=pq.top()[1];\\n            int currNodej=pq.top()[2];\\n            int currDist=pq.top()[0];\\n\\n            pq.pop();\\n\\n            best=min(best,abs(currNodei-target[0])+abs(currNodej-target[1])+currDist);\\n\\n            for(auto &it:specialRoads){\\n                int cost=currDist+abs(it[0]-currNodei)+abs(it[1]-currNodej)+it[4];\\n                if(dis.find({it[2],it[3]})==dis.end()){\\n                    dis[{it[2],it[3]}]=cost;\\n                    pq.push({cost,it[2],it[3]});\\n                }\\n                else if(dis[{it[2],it[3]}]>cost){\\n                    dis[{it[2],it[3]}]=cost;\\n                    pq.push({cost,it[2],it[3]});\\n                }\\n            }\\n            \\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470349,
                "title": "c-sam-lee-s-code-with-some-comments-changes-for-easy-reading",
                "content": "https://leetcode.com/qeetcode/\\n```\\n//Dijkstra\\'s algorithm\\n//Edges: special roads, and manhantan path to start position of special roads\\nclass Solution {\\n    //combine x/y coordinates as point id for hashing\\n    long w = 100001; // weight of x\\n    long pid(vector<int>const& p) { return p[0]*w+p[1]; }\\n    long pid(int x, int y) { return x*w+y; }\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int startX = start[0], startY = start[1], targetX = target[0], targetY = target[1]; \\n        unordered_map<long, vector<pair<long, int>>> rd = {{pid(target), {{0, 0}}}}; \\n        for (auto& x : specialRoads) {\\n            if(abs(x[0] - x[2]) + abs(x[1] - x[3]) > x[4])\\n                rd[pid(x)].emplace_back(pid(x[2],x[3]), x[4]); \\n        } \\n            \\n        unordered_map<long, int> dist; \\n        dist[pid(start)] = 0; \\n        priority_queue<pair<int, long>, vector<pair<int, long>>, greater<>> pq; \\n        pq.emplace(0, pid(start)); \\n        while (pq.size()) {\\n            auto [d, p] = pq.top(); pq.pop(); \\n            if (p == pid(target)) return d; \\n            for (auto const& [P, cost] : rd[p]) {\\n                if (!dist.count(P) || d+cost < dist[P]) {\\n                    dist[P] = d + cost;\\n                    pq.emplace(d+cost, P); \\n                }\\n            }\\n            for (auto const& [P, _] : rd) {\\n                int D = d + abs(P%w - p%w) + abs(P/w - p/w); \\n                if (!dist.count(P) || D < dist[P]) {\\n                    dist[P] = D; \\n                    pq.emplace(D, P); \\n                }\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Dijkstra\\'s algorithm\\n//Edges: special roads, and manhantan path to start position of special roads\\nclass Solution {\\n    //combine x/y coordinates as point id for hashing\\n    long w = 100001; // weight of x\\n    long pid(vector<int>const& p) { return p[0]*w+p[1]; }\\n    long pid(int x, int y) { return x*w+y; }\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        int startX = start[0], startY = start[1], targetX = target[0], targetY = target[1]; \\n        unordered_map<long, vector<pair<long, int>>> rd = {{pid(target), {{0, 0}}}}; \\n        for (auto& x : specialRoads) {\\n            if(abs(x[0] - x[2]) + abs(x[1] - x[3]) > x[4])\\n                rd[pid(x)].emplace_back(pid(x[2],x[3]), x[4]); \\n        } \\n            \\n        unordered_map<long, int> dist; \\n        dist[pid(start)] = 0; \\n        priority_queue<pair<int, long>, vector<pair<int, long>>, greater<>> pq; \\n        pq.emplace(0, pid(start)); \\n        while (pq.size()) {\\n            auto [d, p] = pq.top(); pq.pop(); \\n            if (p == pid(target)) return d; \\n            for (auto const& [P, cost] : rd[p]) {\\n                if (!dist.count(P) || d+cost < dist[P]) {\\n                    dist[P] = d + cost;\\n                    pq.emplace(d+cost, P); \\n                }\\n            }\\n            for (auto const& [P, _] : rd) {\\n                int D = d + abs(P%w - p%w) + abs(P/w - p/w); \\n                if (!dist.count(P) || D < dist[P]) {\\n                    dist[P] = D; \\n                    pq.emplace(D, P); \\n                }\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470015,
                "title": "c-61ms-bfs-dp-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDijkstra\\'s Algorithm using priority queue.\\n\\nWe seen the roads as node instead of {x, y} point.\\nWe can traverl through each roads to the destination.\\n\\nWe use visited[i] to store the minimum cost we need to travel to each roads.\\n\\nWe do not visit the ith road again once we find the current cost is >= visited[i].\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> pi;\\n    inline int dist(int x1, int y1, int x2, int y2){ return abs(x1 - x2) + abs(y1 - y2);}\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        vector<vector<int>> edges;\\n        for(auto &item: specialRoads){\\n            if(dist(item[0], item[1], item[2], item[3]) > item[4]){\\n                edges.emplace_back(item);\\n            }\\n        }\\n        int n = edges.size();\\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        pq.push({0, {start[0], start[1]}});\\n        \\n        vector<int> visited(n, INT_MAX);\\n        int res = dist(start[0], start[1], target[0], target[1]);\\n        while(!pq.empty()){\\n            auto item = pq.top(); pq.pop();\\n            int cost = item.first, x = item.second.first, y = item.second.second;\\n            if(cost >= res) return res;\\n            if(x == target[0] && y == target[1]) return cost;\\n            int direct_cost = cost + dist(x, y, target[0], target[1]);\\n            pq.push({direct_cost, {target[0], target[1]}});\\n            for(int i = 0; i < n; i++){\\n                auto &point = edges[i];\\n                int reach = cost + dist(x, y, point[0], point[1]);\\n                if(reach >= visited[i]) continue;\\n                visited[i] = reach;\\n                int tmp_cost = reach + point[4];\\n                pq.push({tmp_cost, {point[2], point[3]}});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> pi;\\n    inline int dist(int x1, int y1, int x2, int y2){ return abs(x1 - x2) + abs(y1 - y2);}\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        vector<vector<int>> edges;\\n        for(auto &item: specialRoads){\\n            if(dist(item[0], item[1], item[2], item[3]) > item[4]){\\n                edges.emplace_back(item);\\n            }\\n        }\\n        int n = edges.size();\\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        pq.push({0, {start[0], start[1]}});\\n        \\n        vector<int> visited(n, INT_MAX);\\n        int res = dist(start[0], start[1], target[0], target[1]);\\n        while(!pq.empty()){\\n            auto item = pq.top(); pq.pop();\\n            int cost = item.first, x = item.second.first, y = item.second.second;\\n            if(cost >= res) return res;\\n            if(x == target[0] && y == target[1]) return cost;\\n            int direct_cost = cost + dist(x, y, target[0], target[1]);\\n            pq.push({direct_cost, {target[0], target[1]}});\\n            for(int i = 0; i < n; i++){\\n                auto &point = edges[i];\\n                int reach = cost + dist(x, y, point[0], point[1]);\\n                if(reach >= visited[i]) continue;\\n                visited[i] = reach;\\n                int tmp_cost = reach + point[4];\\n                pq.push({tmp_cost, {point[2], point[3]}});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469743,
                "title": "c-dijkstra-dp-explanation-easy-to-understand",
                "content": "# Intuition\\nwe can think this question is to ask to find Shortest Paths from Source to target through middles vertices using Dijkstra\\u2019s Algorithm. The variant is that we pick two vertices ($x1_i$, $y1_i$), ($x2_i$, $y2_i$) once a time if we choose one special road `i` with cost $cost_i$, where. ($x1_i$, $y1_i$) is the start vertice of the spcecial road, and ($x2_i$, $y2_i$) is the end vertice.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nQ: how to find shortest path like \\n\\nStart -> ($x1_i$, $y1_i$) -> ($x2_i$, $y2_i$) ->  ($x1_{j}$, $y1_{j}$) -> ($x2_{j}$, $y2_{j}$) -> ...-> Target\\n\\n\\nThe key idea is \\n-  store costs from start vertice to all end point ($x2_i$, $y2_i$) in special roads into an array `d`; store index of that covered special road into a priority queue, and later to go through all items in that queue. Formular is as folllow: \\n  d[i] = abs($x1_i$ - start[0]) + abs($y1_i$ - start[1]) + $cost_i$\\n\\n- The cost from ($x2_i$, $y2_i$) to the final target vertice is\\n  abs(target[1] - $y2_i$) + abs(target[0] - $x2_i$)\\n\\n- The cost for S -> $x_i$ -> T is equal to \\n  cur_cost = d[i] +  abs(target[1] - $y2_i$) + abs(target[0] - $x2_i$); \\n  then compare the min cost from S to T through $road_i$ with the one from S to T without $road_i$\\n\\n- And then start from $x_i$, calculate its cost to other end vertice `j` in other special roads; if  `d[i]` + cost from  ($x1_i$, $y1_i$) to ($x2_j$, $y2_j$) smaller than the orginal `d[j]`, update d[j]. put `j` into the priority queue. \\n \\n\\n\\n# Complexity\\n- Time complexity: O(V^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n  int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {        \\n        int ans = abs(target[1] - start[1]) + abs(target[0] - start[0]);\\n        vector<int> d(specialRoads.size(), 0);\\n        priority_queue<int> pq;\\n        \\n        for(int i = 0; i < specialRoads.size(); i++) {\\n            d[i] = abs(specialRoads[i][1] - start[1]) + abs(specialRoads[i][0] - start[0]) + specialRoads[i][4];\\n            pq.push(i);\\n        }\\n        \\n        while(!pq.empty()) {\\n            int idx = pq.top(); pq.pop(); \\n            \\n            vector<int> sr = specialRoads[idx];\\n            ans = min(ans, d[idx] + abs(target[1] - sr[3]) + abs(target[0] - sr[2]));\\n            \\n            for(int j = 0; j < specialRoads.size(); j++) {\\n                if(j == idx) continue;\\n                int w = abs(specialRoads[j][1] - sr[3]) + abs(specialRoads[j][0] - sr[2]) + specialRoads[j][4];\\n                if(d[idx] + w < d[j]) {\\n                    d[j] = d[idx] + w; \\n                    pq.push(j);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {        \\n        int ans = abs(target[1] - start[1]) + abs(target[0] - start[0]);\\n        vector<int> d(specialRoads.size(), 0);\\n        priority_queue<int> pq;\\n        \\n        for(int i = 0; i < specialRoads.size(); i++) {\\n            d[i] = abs(specialRoads[i][1] - start[1]) + abs(specialRoads[i][0] - start[0]) + specialRoads[i][4];\\n            pq.push(i);\\n        }\\n        \\n        while(!pq.empty()) {\\n            int idx = pq.top(); pq.pop(); \\n            \\n            vector<int> sr = specialRoads[idx];\\n            ans = min(ans, d[idx] + abs(target[1] - sr[3]) + abs(target[0] - sr[2]));\\n            \\n            for(int j = 0; j < specialRoads.size(); j++) {\\n                if(j == idx) continue;\\n                int w = abs(specialRoads[j][1] - sr[3]) + abs(specialRoads[j][0] - sr[2]) + specialRoads[j][4];\\n                if(d[idx] + w < d[j]) {\\n                    d[j] = d[idx] + w; \\n                    pq.push(j);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469660,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialroads) {\\n        \\n        map<pair<int,int>,vector<vector<int>>> mp;\\n        map<pair<int,int>,int> cost;\\n        \\n        for(auto it : specialroads){\\n            \\n            int f = abs(it[2] - it[0]) + abs(it[3] - it[1]);\\n            \\n            // if the manhattan distance is greater than the cost, then we add it into our map\\n            if(it[4] < f) {\\n                mp[{it[0],it[1]}].push_back({it[2],it[3],it[4]});\\n                cost[{it[0],it[1]}] = INT_MAX;\\n                cost[{it[2],it[3]}] = INT_MAX;\\n            }\\n        }\\n        \\n        int min_dist = abs(target[1] - start[1]) + abs(target[0] - start[0]);   \\n        queue<vector<int>> q;\\n        \\n        cost[{start[0],start[1]}] = 0;\\n        cost[{target[0],target[1]}] = min_dist;\\n        \\n        q.push({start[0],start[1],0});\\n        \\n        while(!q.empty()){\\n            \\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            int c = q.front()[2];\\n            \\n            q.pop();\\n        \\n            // if there are special roads connected to this cell, use them if we can reach that cell at a lower cost\\n            \\n            for(auto it : mp[{x,y}]){\\n                \\n                int to_x = it[0];\\n                int to_y = it[1];\\n                int to_c = it[2];\\n                \\n                if((c + to_c) < cost[{to_x,to_y}]){\\n                    cost[{to_x,to_y}] = c + to_c;\\n                    q.push({to_x,to_y,c + to_c});\\n                }\\n            \\n            }\\n            \\n            // try to go to any of the special roads from here\\n            \\n            for(auto it : mp){                \\n\\n                int to_x = it.first.first;\\n                int to_y = it.first.second;\\n                int to_c = abs(to_x - x) + abs(to_y - y);\\n                \\n                if((c + to_c) < cost[{to_x,to_y}]){\\n                    cost[{to_x,to_y}] = c + to_c;\\n                    q.push({to_x,to_y,c + to_c});\\n                }\\n            }\\n            \\n            // try to reach the target cell directly from here\\n            \\n            int res = abs(target[0] - x) + abs(target[1] - y);\\n            \\n            if((res + c) < cost[{target[0],target[1]}]){\\n                cost[{target[0],target[1]}] = res + c;\\n                q.push({target[0],target[1],res + c});\\n            }\\n        }\\n        \\n\\n        return cost[{target[0],target[1]}];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialroads) {\\n        \\n        map<pair<int,int>,vector<vector<int>>> mp;\\n        map<pair<int,int>,int> cost;\\n        \\n        for(auto it : specialroads){\\n            \\n            int f = abs(it[2] - it[0]) + abs(it[3] - it[1]);\\n            \\n            // if the manhattan distance is greater than the cost, then we add it into our map\\n            if(it[4] < f) {\\n                mp[{it[0],it[1]}].push_back({it[2],it[3],it[4]});\\n                cost[{it[0],it[1]}] = INT_MAX;\\n                cost[{it[2],it[3]}] = INT_MAX;\\n            }\\n        }\\n        \\n        int min_dist = abs(target[1] - start[1]) + abs(target[0] - start[0]);   \\n        queue<vector<int>> q;\\n        \\n        cost[{start[0],start[1]}] = 0;\\n        cost[{target[0],target[1]}] = min_dist;\\n        \\n        q.push({start[0],start[1],0});\\n        \\n        while(!q.empty()){\\n            \\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            int c = q.front()[2];\\n            \\n            q.pop();\\n        \\n            // if there are special roads connected to this cell, use them if we can reach that cell at a lower cost\\n            \\n            for(auto it : mp[{x,y}]){\\n                \\n                int to_x = it[0];\\n                int to_y = it[1];\\n                int to_c = it[2];\\n                \\n                if((c + to_c) < cost[{to_x,to_y}]){\\n                    cost[{to_x,to_y}] = c + to_c;\\n                    q.push({to_x,to_y,c + to_c});\\n                }\\n            \\n            }\\n            \\n            // try to go to any of the special roads from here\\n            \\n            for(auto it : mp){                \\n\\n                int to_x = it.first.first;\\n                int to_y = it.first.second;\\n                int to_c = abs(to_x - x) + abs(to_y - y);\\n                \\n                if((c + to_c) < cost[{to_x,to_y}]){\\n                    cost[{to_x,to_y}] = c + to_c;\\n                    q.push({to_x,to_y,c + to_c});\\n                }\\n            }\\n            \\n            // try to reach the target cell directly from here\\n            \\n            int res = abs(target[0] - x) + abs(target[1] - y);\\n            \\n            if((res + c) < cost[{target[0],target[1]}]){\\n                cost[{target[0],target[1]}] = res + c;\\n                q.push({target[0],target[1],res + c});\\n            }\\n        }\\n        \\n\\n        return cost[{target[0],target[1]}];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469652,
                "title": "c-soln",
                "content": "# Intuition\\ndijkstra\\'s algo\\nmaking adjacency of graph\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469651,
                "title": "c-soln",
                "content": "# Intuition\\ndijkstra\\'s algo\\nmaking adjacency of graph\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469649,
                "title": "c-soln",
                "content": "# Intuition\\ndijkstra\\'s algo\\nmaking adjacency of graph\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469648,
                "title": "c-soln",
                "content": "# Intuition\\ndijkstra\\'s algo\\nmaking adjacency of graph\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469646,
                "title": "c-soln",
                "content": "# Intuition\\ndijkstra\\'s algo\\nmaking adjacency of graph\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2){\\n        return (abs(x2-x1)+abs(y2-y1));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specR){\\n        set<pair<int,int>>st;\\n        for(auto it:specR){\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        int i=0;\\n        map<pair<int,int>,int>mp;\\n        for(auto it:st){\\n            mp[it]=i++;\\n        }\\n        int s1=mp[{start[0],start[1]}];\\n        int e1=mp[{target[0],target[1]}];\\n        vector<pair<int,int>>adj[i];\\n        adj[s1].push_back({e1,cost(start[0],start[1],target[0],target[1])});\\n        for(auto it:specR){\\n            int sps=mp[{it[0],it[1]}];\\n            int spe=mp[{it[2],it[3]}];\\n            int wt=it[4];\\n            adj[s1].push_back({sps,cost(start[0],start[1],it[0],it[1])});\\n            adj[spe].push_back({e1,cost(it[2],it[3],target[0],target[1])});\\n            adj[sps].push_back({spe,wt});\\n\\n            for(auto x:specR){\\n                if(x==it)continue;\\n                int spss=mp[{x[0],x[1]}];\\n                int spee=mp[{x[2],x[3]}];\\n                adj[spe].push_back({spss,cost(it[2],it[3],x[0],x[1])});\\n                adj[spee].push_back({sps,cost(x[2],x[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        pq.push({0,s1});\\n        vector<int>dist(i,INT_MAX);\\n        dist[s1]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int dis=it.first;\\n            int node=it.second;\\n            if(node==e1){\\n                return dis;\\n            }\\n            for(auto x:adj[node]){\\n                int nnode=x.first;\\n                int ndis=x.second;\\n                if(dist[nnode]>dist[node]+ndis){\\n                    dist[nnode]=dist[node]+ndis;\\n                    pq.push({dist[nnode],nnode});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469626,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\ntypedef pair<int,int> pii;\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2)\\n    {\\n        return (abs(x1-x2)+abs(y1-y2));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        set<pii>st;\\n        for (auto it: sr)\\n        {\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        map<pii,int>mp;\\n        int cnt=0;\\n        for (auto it:st)\\n        {\\n            mp[it]=cnt++;\\n        }\\n        vector<pii>adj[cnt];\\n        int sInd=mp[{start[0],start[1]}];\\n        int eInd=mp[{target[0],target[1]}];\\n        adj[sInd].push_back({eInd,cost(start[0],start[1],target[0],target[1])});\\n        for ( auto it:sr)\\n        {\\n            int so=mp[{it[0],it[1]}];\\n            int se=mp[{it[2],it[3]}];\\n            int price=it[4];\\n\\n            adj[sInd].push_back({so,cost(start[0],start[1],it[0],it[1])});\\n            adj[so].push_back({se,price});\\n            adj[se].push_back({eInd,cost(it[2],it[3],target[0],target[1])});\\n\\n            for (auto it2: sr)\\n            {\\n                if (it==it2) continue;\\n                 int soo=mp[{it2[0],it2[1]}];\\n                 int see=mp[{it2[2],it2[3]}];\\n                 adj[se].push_back({soo,cost(it[2],it[3],it2[0],it2[1])});\\n                 adj[see].push_back({so,cost(it2[2],it2[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        vector<int>dist(cnt,INT_MAX);\\n        dist[sInd]=0;\\n        pq.push({0,sInd});\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            int d=temp.first;\\n            int node=temp.second;\\n            if (node==eInd) return d;\\n            for (auto it:adj[node])\\n            {\\n                if (dist[it.first]>dist[node]+it.second)\\n                {\\n                    dist[it.first]=dist[node]+it.second;\\n                    pq.push({dist[node]+it.second,it.first});\\n                }\\n            }\\n        }\\n        return 1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef pair<int,int> pii;\\nclass Solution {\\npublic:\\n    int cost(int x1,int y1,int x2,int y2)\\n    {\\n        return (abs(x1-x2)+abs(y1-y2));\\n    }\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        set<pii>st;\\n        for (auto it: sr)\\n        {\\n            st.insert({it[0],it[1]});\\n            st.insert({it[2],it[3]});\\n        }\\n        st.insert({start[0],start[1]});\\n        st.insert({target[0],target[1]});\\n        map<pii,int>mp;\\n        int cnt=0;\\n        for (auto it:st)\\n        {\\n            mp[it]=cnt++;\\n        }\\n        vector<pii>adj[cnt];\\n        int sInd=mp[{start[0],start[1]}];\\n        int eInd=mp[{target[0],target[1]}];\\n        adj[sInd].push_back({eInd,cost(start[0],start[1],target[0],target[1])});\\n        for ( auto it:sr)\\n        {\\n            int so=mp[{it[0],it[1]}];\\n            int se=mp[{it[2],it[3]}];\\n            int price=it[4];\\n\\n            adj[sInd].push_back({so,cost(start[0],start[1],it[0],it[1])});\\n            adj[so].push_back({se,price});\\n            adj[se].push_back({eInd,cost(it[2],it[3],target[0],target[1])});\\n\\n            for (auto it2: sr)\\n            {\\n                if (it==it2) continue;\\n                 int soo=mp[{it2[0],it2[1]}];\\n                 int see=mp[{it2[2],it2[3]}];\\n                 adj[se].push_back({soo,cost(it[2],it[3],it2[0],it2[1])});\\n                 adj[see].push_back({so,cost(it2[2],it2[3],it[0],it[1])});\\n            }\\n        }\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        vector<int>dist(cnt,INT_MAX);\\n        dist[sInd]=0;\\n        pq.push({0,sInd});\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            int d=temp.first;\\n            int node=temp.second;\\n            if (node==eInd) return d;\\n            for (auto it:adj[node])\\n            {\\n                if (dist[it.first]>dist[node]+it.second)\\n                {\\n                    dist[it.first]=dist[node]+it.second;\\n                    pq.push({dist[node]+it.second,it.first});\\n                }\\n            }\\n        }\\n        return 1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469440,
                "title": "c-beats-100-time-dijkstra",
                "content": "# Approach\\nSuppose we have `n` roads, then there are `m = 2*n+2` points in total, where each point with an id in the interval `[0 ... 2*n-1]` is either a start or an end of a road, point `(2*n)` is the start and point `2*n+1` is the target. Create a graph with these points as vertices, with edges corresponding to usual walks and roads (there can be multiple edges for a pair of vertices). Run the usual Dijkstra algorithm on the graph. \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ to build the graph, $$O(n \\\\log n)$$ to find the answer. \\n\\n- Space complexity: $$O(n^2)$$ to store the graph.\\n\\n# Code\\n```\\nint dist(int x1, int y1, int x2, int y2) {\\n    return abs(x1-x2)+abs(y1-y2);\\n}\\n\\nstruct Edge {\\n    int to;\\n    int cost;\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& roads) {\\n        int n = roads.size(); \\n        vector<vector<int>> pts(2*n+2);\\n        for (int i = 0; i < n; i++) {\\n            pts[2*i] = {roads[i][0], roads[i][1]};\\n            pts[2*i+1] = {roads[i][2], roads[i][3]};\\n        }\\n        pts[2*n] = s;\\n        pts[2*n+1] = t; \\n        int m = pts.size(); \\n        vector<vector<Edge>> g(m); \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i!=j) g[i].push_back({j, dist(pts[i][0], pts[i][1], pts[j][0], pts[j][1])}); \\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            g[2*i].push_back({2*i+1, roads[i][4]}); \\n        }\\n        priority_queue<vector<int>> q;\\n        q.push({0, 2*n});\\n        vector<int> d(m, 1e9);\\n        d[2*n] = 0; \\n        while(!q.empty()) {\\n            int v = q.top()[1];\\n            q.pop();\\n            for (Edge& ed : g[v]) {\\n                int upd = d[v] + ed.cost;\\n                if (upd < d[ed.to]) {\\n                    d[ed.to] = upd;\\n                    q.push({-upd, ed.to}); \\n                }\\n            }\\n        }\\n        return d[2*n+1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dist(int x1, int y1, int x2, int y2) {\\n    return abs(x1-x2)+abs(y1-y2);\\n}\\n\\nstruct Edge {\\n    int to;\\n    int cost;\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& roads) {\\n        int n = roads.size(); \\n        vector<vector<int>> pts(2*n+2);\\n        for (int i = 0; i < n; i++) {\\n            pts[2*i] = {roads[i][0], roads[i][1]};\\n            pts[2*i+1] = {roads[i][2], roads[i][3]};\\n        }\\n        pts[2*n] = s;\\n        pts[2*n+1] = t; \\n        int m = pts.size(); \\n        vector<vector<Edge>> g(m); \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i!=j) g[i].push_back({j, dist(pts[i][0], pts[i][1], pts[j][0], pts[j][1])}); \\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            g[2*i].push_back({2*i+1, roads[i][4]}); \\n        }\\n        priority_queue<vector<int>> q;\\n        q.push({0, 2*n});\\n        vector<int> d(m, 1e9);\\n        d[2*n] = 0; \\n        while(!q.empty()) {\\n            int v = q.top()[1];\\n            q.pop();\\n            for (Edge& ed : g[v]) {\\n                int upd = d[v] + ed.cost;\\n                if (upd < d[ed.to]) {\\n                    d[ed.to] = upd;\\n                    q.push({-upd, ed.to}); \\n                }\\n            }\\n        }\\n        return d[2*n+1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469391,
                "title": "dijkstra-algorithm-c",
                "content": "```\\nclass Solution {\\n\\n    \\npublic:\\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& v) {\\n    int n=2*v.size()+7;\\n    \\n    vector<pair<int,int>>adj[n];\\n        \\n    map<vector<int>,int>h;\\n        \\n    vector<vector<int>>p;\\n    int dis[n];\\n        \\n        for(int i=0;i<n;i++)dis[i]=1e9;\\n        dis[0]=0;\\n        p.push_back({s[0],s[1]});\\n        p.push_back({t[0],t[1]});\\n\\n    for(auto i:v){\\n          p.push_back({i[0],i[1]});\\n          p.push_back({i[2],i[3]});\\n// map given path nodes to minimum of all such paths\\n            if(h[{i[0],i[1],i[2],i[3]}]!=0)\\n        h[{i[0],i[1],i[2],i[3]}]=min(h[{i[0],i[1],i[2],i[3]}],i[4]);\\n        else h[{i[0],i[1],i[2],i[3]}]=i[4];\\n        }\\n        \\n       \\n        \\n        for(int i=0;i<p.size();i++){\\n          for(int j=i+1;j<p.size();j++){\\n              int  wt=abs(p[j][0]-p[i][0])+abs(p[j][1]-p[i][1]);\\n            \\n              \\n              if(h[{p[i][0],p[i][1],p[j][0],p[j][1]}]!=0)  // if front way is mapped then take minimum of absolute path vs speacial path\\n              {\\n                  adj[i].push_back({j,min(wt,h[{p[i][0],p[i][1],p[j][0],p[j][1]}])});\\n                  \\n              }\\n              else \\n              {\\n                  adj[i].push_back({j,wt});\\n                  \\n              }\\n              \\n              if(h[{p[j][0],p[j][1],p[i][0],p[i][1]}]!=0)  //if reverse way is mapped then take minimum of absolute path vs speacial path\\n              {\\n                  adj[j].push_back({i,min(wt,h[{p[j][0],p[j][1],p[i][0],p[i][1]}])});\\n                  \\n              }\\n              else \\n              {\\n                 adj[j].push_back({i,wt});\\n                  \\n              }              \\n          }\\n        }\\n\\n        //Normal Djikstra\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({0,0});\\n        while(q.size()){\\n            int pa_dis=q.top().first, pa=q.top().second;\\n            q.pop();\\n            \\n            for(auto i:adj[pa]){\\n                int ch=i.first,wt=i.second;\\n                if(dis[ch]>pa_dis+wt){\\n                    dis[ch]=pa_dis+wt;\\n                    q.push({dis[ch],ch});\\n                }\\n            }\\n        }\\n        \\n        return dis[1];\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    \\npublic:\\n    int minimumCost(vector<int>& s, vector<int>& t, vector<vector<int>>& v) {\\n    int n=2*v.size()+7;\\n    \\n    vector<pair<int,int>>adj[n];\\n        \\n    map<vector<int>,int>h;\\n        \\n    vector<vector<int>>p;\\n    int dis[n];\\n        \\n        for(int i=0;i<n;i++)dis[i]=1e9;\\n        dis[0]=0;\\n        p.push_back({s[0],s[1]});\\n        p.push_back({t[0],t[1]});\\n\\n    for(auto i:v){\\n          p.push_back({i[0],i[1]});\\n          p.push_back({i[2],i[3]});\\n// map given path nodes to minimum of all such paths\\n            if(h[{i[0],i[1],i[2],i[3]}]!=0)\\n        h[{i[0],i[1],i[2],i[3]}]=min(h[{i[0],i[1],i[2],i[3]}],i[4]);\\n        else h[{i[0],i[1],i[2],i[3]}]=i[4];\\n        }\\n        \\n       \\n        \\n        for(int i=0;i<p.size();i++){\\n          for(int j=i+1;j<p.size();j++){\\n              int  wt=abs(p[j][0]-p[i][0])+abs(p[j][1]-p[i][1]);\\n            \\n              \\n              if(h[{p[i][0],p[i][1],p[j][0],p[j][1]}]!=0)  // if front way is mapped then take minimum of absolute path vs speacial path\\n              {\\n                  adj[i].push_back({j,min(wt,h[{p[i][0],p[i][1],p[j][0],p[j][1]}])});\\n                  \\n              }\\n              else \\n              {\\n                  adj[i].push_back({j,wt});\\n                  \\n              }\\n              \\n              if(h[{p[j][0],p[j][1],p[i][0],p[i][1]}]!=0)  //if reverse way is mapped then take minimum of absolute path vs speacial path\\n              {\\n                  adj[j].push_back({i,min(wt,h[{p[j][0],p[j][1],p[i][0],p[i][1]}])});\\n                  \\n              }\\n              else \\n              {\\n                 adj[j].push_back({i,wt});\\n                  \\n              }              \\n          }\\n        }\\n\\n        //Normal Djikstra\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({0,0});\\n        while(q.size()){\\n            int pa_dis=q.top().first, pa=q.top().second;\\n            q.pop();\\n            \\n            for(auto i:adj[pa]){\\n                int ch=i.first,wt=i.second;\\n                if(dis[ch]>pa_dis+wt){\\n                    dis[ch]=pa_dis+wt;\\n                    q.push({dis[ch],ch});\\n                }\\n            }\\n        }\\n        \\n        return dis[1];\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469351,
                "title": "basic-dijkstra-algorithm-fully-expalined",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas this is a path minimizing problem with given start and end node our first intuition should always be dijkstra. hence i solved it using that only.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnow one ans is to go directly from start to target , and other to take help of special road but first we should filter special road array as those road whose cost is more than their manhattan distance would never be used hence we remove them, next we make a distance map for our dijkstra , now we push all special road in heap , and do simple dijkstra, finally after getting minimum distance of all points from start we would traverse our map and find the manhattan distance of point from target and add map distance then update our global answer.\\nThat was a brief approach on how i did it , for deep understanding you can look at code...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& end, vector<vector<int>>& vec) {\\n        vector<vector<int>> req;\\n        for(int i=0;i<vec.size();i++){\\n            int val=abs(vec[i][0]- vec[i][2])+abs(vec[i][1]-vec[i][3]);\\n            if(val>vec[i][4]){\\n                req.push_back(vec[i]);\\n            }\\n        }\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;\\n        map<pair<int,int>,int> mp;\\n        int x=start[0];\\n        int y=start[1];\\n        mp[make_pair(x,y)]=0;\\n        for(int i=0;i<req.size();i++){\\n            int val=abs(x-req[i][0])+abs(y-req[i][1]);\\n            int net_val=val+req[i][4];\\n            if(mp.count(make_pair(req[i][0],req[i][1])) && mp[make_pair(req[i][0],req[i][1])]>val){\\n            mp[make_pair(req[i][0],req[i][1])]=val;\\n            }\\n            else if(!mp.count(make_pair(req[i][0],req[i][1]))){\\n                   mp[make_pair(req[i][0],req[i][1])]=val;\\n            }\\n            if(mp.count(make_pair(req[i][2],req[i][3])) && mp[make_pair(req[i][2],req[i][3])]>net_val){\\n            mp[make_pair(req[i][2],req[i][3])]=net_val;\\n            }\\n            else if(!mp.count(make_pair(req[i][2],req[i][3]))){\\n                   mp[make_pair(req[i][2],req[i][3])]=net_val;\\n            }            \\n            pq.push({net_val,req[i][0],req[i][1],req[i][2],req[i][3]});\\n        }\\n        //cout<<mp[make_pair(6,9)]<<endl;\\n        while(!pq.empty()){\\n            vector<int> temp=pq.top();\\n            pq.pop();\\n            for(int i=0;i<req.size();i++){\\n                int val=temp[0]+abs(temp[3]-req[i][0])+abs(temp[4]-req[i][1]);\\n                if(mp[make_pair(req[i][0],req[i][1])]>val){\\n                    mp[make_pair(req[i][0],req[i][1])]=val;\\n                }\\n                int net_val=req[i][4]+val;\\n                if(mp[make_pair(req[i][2],req[i][3])]>net_val){\\n                    mp[make_pair(req[i][2],req[i][3])]=net_val;\\n                    pq.push({net_val,req[i][0],req[i][1],req[i][2],req[i][3]});\\n                }\\n            }\\n        }\\n        int ans=abs(start[0]-end[0])+abs(start[1]-end[1]);\\n        for(auto it: mp){\\n            cout<<it.first.first<<\" \"<<it.first.second<<\" \"<<it.second<<endl;\\n            int val=it.second+abs(it.first.first-end[0])+abs(it.first.second-end[1]);\\n            ans=min(ans,val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& end, vector<vector<int>>& vec) {\\n        vector<vector<int>> req;\\n        for(int i=0;i<vec.size();i++){\\n            int val=abs(vec[i][0]- vec[i][2])+abs(vec[i][1]-vec[i][3]);\\n            if(val>vec[i][4]){\\n                req.push_back(vec[i]);\\n            }\\n        }\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;\\n        map<pair<int,int>,int> mp;\\n        int x=start[0];\\n        int y=start[1];\\n        mp[make_pair(x,y)]=0;\\n        for(int i=0;i<req.size();i++){\\n            int val=abs(x-req[i][0])+abs(y-req[i][1]);\\n            int net_val=val+req[i][4];\\n            if(mp.count(make_pair(req[i][0],req[i][1])) && mp[make_pair(req[i][0],req[i][1])]>val){\\n            mp[make_pair(req[i][0],req[i][1])]=val;\\n            }\\n            else if(!mp.count(make_pair(req[i][0],req[i][1]))){\\n                   mp[make_pair(req[i][0],req[i][1])]=val;\\n            }\\n            if(mp.count(make_pair(req[i][2],req[i][3])) && mp[make_pair(req[i][2],req[i][3])]>net_val){\\n            mp[make_pair(req[i][2],req[i][3])]=net_val;\\n            }\\n            else if(!mp.count(make_pair(req[i][2],req[i][3]))){\\n                   mp[make_pair(req[i][2],req[i][3])]=net_val;\\n            }            \\n            pq.push({net_val,req[i][0],req[i][1],req[i][2],req[i][3]});\\n        }\\n        //cout<<mp[make_pair(6,9)]<<endl;\\n        while(!pq.empty()){\\n            vector<int> temp=pq.top();\\n            pq.pop();\\n            for(int i=0;i<req.size();i++){\\n                int val=temp[0]+abs(temp[3]-req[i][0])+abs(temp[4]-req[i][1]);\\n                if(mp[make_pair(req[i][0],req[i][1])]>val){\\n                    mp[make_pair(req[i][0],req[i][1])]=val;\\n                }\\n                int net_val=req[i][4]+val;\\n                if(mp[make_pair(req[i][2],req[i][3])]>net_val){\\n                    mp[make_pair(req[i][2],req[i][3])]=net_val;\\n                    pq.push({net_val,req[i][0],req[i][1],req[i][2],req[i][3]});\\n                }\\n            }\\n        }\\n        int ans=abs(start[0]-end[0])+abs(start[1]-end[1]);\\n        for(auto it: mp){\\n            cout<<it.first.first<<\" \"<<it.first.second<<\" \"<<it.second<<endl;\\n            int val=it.second+abs(it.first.first-end[0])+abs(it.first.second-end[1]);\\n            ans=min(ans,val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3469100,
                "title": "bfs-with-cache-invalidation",
                "content": "# Intuition\\nThis cannot be done with a simple BFS approach because, because the edges are weighted. So a modified BFS can be used, where, if a smaller cost path is found, that path is marked for exploration again.\\n\\n# Code\\n```\\nclass Solution {\\n    record Pt(int x, int y) {}\\n    Map<Pt, Long> costs = new HashMap<>();\\n\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        Pt targetPt = new Pt(target[0],target[1]);\\n        Pt startPt = new Pt(start[0],start[1]);\\n        \\n        Queue<Object[]> q = new ArrayDeque<>();\\n        \\n        costs.put(startPt,0L);\\n        q.add(new Object[]{startPt,0L});\\n        \\n        long min = Long.MAX_VALUE;\\n        \\n        while(!q.isEmpty()) {\\n            Object[] o = q.remove();\\n            Pt point = (Pt)o[0];\\n            long costToThisPoint = (long)o[1];\\n            \\n            if(costToThisPoint > costs.get(point)) continue;\\n            \\n            costs.put(point, costToThisPoint);\\n            min = Math.min(min, costToThisPoint + distance(point,targetPt));\\n \\n            for(int[] road:specialRoads) {\\n                int roadCost=road[4];\\n                Pt startOfRoad = new Pt(road[0],road[1]);\\n                Pt endOfRoad = new Pt(road[2],road[3]);\\n                long costToEndOfRoad = costToThisPoint + distance(point, startOfRoad) + roadCost;\\n                if(costToEndOfRoad >= costs.getOrDefault(endOfRoad, Long.MAX_VALUE)) continue;\\n                costs.put(endOfRoad, costToEndOfRoad);\\n                q.add(new Object[]{endOfRoad,costToEndOfRoad});\\n            }\\n        }\\n        \\n        return (int)min;\\n    }\\n    \\n    long distance(Pt from, Pt to) {\\n        return Math.abs(to.x()-from.x()) + Math.abs(to.y()-from.y());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    record Pt(int x, int y) {}\\n    Map<Pt, Long> costs = new HashMap<>();\\n\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        Pt targetPt = new Pt(target[0],target[1]);\\n        Pt startPt = new Pt(start[0],start[1]);\\n        \\n        Queue<Object[]> q = new ArrayDeque<>();\\n        \\n        costs.put(startPt,0L);\\n        q.add(new Object[]{startPt,0L});\\n        \\n        long min = Long.MAX_VALUE;\\n        \\n        while(!q.isEmpty()) {\\n            Object[] o = q.remove();\\n            Pt point = (Pt)o[0];\\n            long costToThisPoint = (long)o[1];\\n            \\n            if(costToThisPoint > costs.get(point)) continue;\\n            \\n            costs.put(point, costToThisPoint);\\n            min = Math.min(min, costToThisPoint + distance(point,targetPt));\\n \\n            for(int[] road:specialRoads) {\\n                int roadCost=road[4];\\n                Pt startOfRoad = new Pt(road[0],road[1]);\\n                Pt endOfRoad = new Pt(road[2],road[3]);\\n                long costToEndOfRoad = costToThisPoint + distance(point, startOfRoad) + roadCost;\\n                if(costToEndOfRoad >= costs.getOrDefault(endOfRoad, Long.MAX_VALUE)) continue;\\n                costs.put(endOfRoad, costToEndOfRoad);\\n                q.add(new Object[]{endOfRoad,costToEndOfRoad});\\n            }\\n        }\\n        \\n        return (int)min;\\n    }\\n    \\n    long distance(Pt from, Pt to) {\\n        return Math.abs(to.x()-from.x()) + Math.abs(to.y()-from.y());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469017,
                "title": "java-use-dijistras",
                "content": "# Intuition\\nUse Dijistra\\'s to solve the problem\\n\\n# Approach\\nWe have to travel from start to target using road, so add the special roads to edges. Also add the normal distances of each vertices to other to edges as that might be used to edges.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V + ElogE), here V = number of vertices equals to number of special roads and Edges equal to n + n*n. So, TC: $$O(n^2logn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$, due to edgeList being stored\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n   List<int[]> points = new ArrayList<>();\\n   points.add(new int[]{start[0], start[1]});\\n   Map<Integer, List<int[]>> edgeMap = new HashMap<>();\\n   \\n   int idx = 1;\\n   for(int[] specialRoad: specialRoads){\\n      points.add(new int[]{specialRoad[0], specialRoad[1]});\\n      points.add(new int[]{specialRoad[2], specialRoad[3]});\\n      if(!edgeMap.containsKey(idx)){\\n        edgeMap.put(idx, new ArrayList<>());\\n      }\\n      edgeMap.get(idx).add(new int[]{idx + 1, specialRoad[4]});\\n    \\n      idx += 2;\\n   }\\n\\n   points.add(new int[]{target[0], target[1]});\\n   for(int i = 0; i < points.size(); i++){\\n      for(int j = i + 1; j < points.size(); j++){\\n        if(!edgeMap.containsKey(i)){\\n            edgeMap.put(i, new ArrayList<>());\\n        }\\n        edgeMap.get(i).add(new int[]{j, Math.abs(points.get(i)[0] - points.get(j)[0]) + Math.abs(points.get(i)[1] - points.get(j)[1])});\\n        if(!edgeMap.containsKey(j)){\\n            edgeMap.put(j, new ArrayList<>());\\n        }\\n        edgeMap.get(j).add(new int[]{i, Math.abs(points.get(i)[0] - points.get(j)[0]) + Math.abs(points.get(i)[1] - points.get(j)[1])});\\n     }\\n   }\\n\\n  int[] minDist = new int[points.size()];\\n  Arrays.fill(minDist, -1);\\n\\n  PriorityQueue<int[]> pq = new PriorityQueue<>((p1, p2) ->{\\n    return p1[1] - p2[1];\\n  });\\n\\n  pq.add(new int[]{0, 0});\\n\\n  while(!pq.isEmpty()){\\n     int[] edge = pq.remove();\\n     int v = edge[0];\\n     int dist = edge[1];\\n\\n     if(minDist[v] == -1){\\n        minDist[v] = dist;\\n        for(int[] ed: edgeMap.get(v)){\\n            pq.add(new int[]{ed[0], dist + ed[1]});\\n        }\\n     } \\n  }\\n\\n  return minDist[points.size() - 1];\\n\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n   List<int[]> points = new ArrayList<>();\\n   points.add(new int[]{start[0], start[1]});\\n   Map<Integer, List<int[]>> edgeMap = new HashMap<>();\\n   \\n   int idx = 1;\\n   for(int[] specialRoad: specialRoads){\\n      points.add(new int[]{specialRoad[0], specialRoad[1]});\\n      points.add(new int[]{specialRoad[2], specialRoad[3]});\\n      if(!edgeMap.containsKey(idx)){\\n        edgeMap.put(idx, new ArrayList<>());\\n      }\\n      edgeMap.get(idx).add(new int[]{idx + 1, specialRoad[4]});\\n    \\n      idx += 2;\\n   }\\n\\n   points.add(new int[]{target[0], target[1]});\\n   for(int i = 0; i < points.size(); i++){\\n      for(int j = i + 1; j < points.size(); j++){\\n        if(!edgeMap.containsKey(i)){\\n            edgeMap.put(i, new ArrayList<>());\\n        }\\n        edgeMap.get(i).add(new int[]{j, Math.abs(points.get(i)[0] - points.get(j)[0]) + Math.abs(points.get(i)[1] - points.get(j)[1])});\\n        if(!edgeMap.containsKey(j)){\\n            edgeMap.put(j, new ArrayList<>());\\n        }\\n        edgeMap.get(j).add(new int[]{i, Math.abs(points.get(i)[0] - points.get(j)[0]) + Math.abs(points.get(i)[1] - points.get(j)[1])});\\n     }\\n   }\\n\\n  int[] minDist = new int[points.size()];\\n  Arrays.fill(minDist, -1);\\n\\n  PriorityQueue<int[]> pq = new PriorityQueue<>((p1, p2) ->{\\n    return p1[1] - p2[1];\\n  });\\n\\n  pq.add(new int[]{0, 0});\\n\\n  while(!pq.isEmpty()){\\n     int[] edge = pq.remove();\\n     int v = edge[0];\\n     int dist = edge[1];\\n\\n     if(minDist[v] == -1){\\n        minDist[v] = dist;\\n        for(int[] ed: edgeMap.get(v)){\\n            pq.add(new int[]{ed[0], dist + ed[1]});\\n        }\\n     } \\n  }\\n\\n  return minDist[points.size() - 1];\\n\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469009,
                "title": "c-vector-solution-24-ms-beats-100",
                "content": "# Intuition\\nShortest path from start to target via road entrances and exits\\n\\n# Approach\\n* Use std::vector to store the cost to reach each road entrance\\n* Always pick the one with the lowest cost to reach, and use it once only\\n* Update the minimum cost to reach the remaining roads\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ where $n$ = specialRoads.length\\n\\n- Space complexity:\\n$$O(n)$$\\n\\nhttps://leetcode.com/submissions/detail/941978770/\\nRuntime 24 ms Beats 100%\\nMemory 71.2 MB Beats 83.33%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        const pair<int,int> src = {start[0], start[1]};\\n        const pair<int,int> dst = {target[0], target[1]};\\n        \\n        auto get_cost = [](pair<int,int> src, pair<int,int> dst) {\\n            return abs(src.first - dst.first) + abs(src.second - dst.second);\\n        };\\n        \\n        vector<pair<int,int>> entrances; // cost, index\\n        for (int i = 0; i < specialRoads.size(); ++i) {\\n            auto &road = specialRoads[i];\\n            entrances.push_back({get_cost(src, {road[0], road[1]}), i});\\n        }\\n        \\n        vector<tuple<int,int,int>> exits; // cost, x, y\\n        while (int n = entrances.size()) {\\n            auto [cost, i] = *min_element(entrances.begin(), entrances.end());\\n            auto &road = specialRoads[i];\\n            int x = road[2];\\n            int y = road[3];\\n            cost += road[4];\\n            exits.push_back({cost, x, y});\\n            \\n            int k = 0; // write index\\n            for (int j = 0; j < n; ++j) {\\n                auto [cost2, i2] = entrances[j];\\n                if (i2 != i) {\\n                    auto &road2 = specialRoads[i2];\\n                    cost2 = min(cost2, cost + get_cost({x, y}, {road2[0], road2[1]}));\\n                    entrances[k++] = {cost2, i2};\\n                }\\n            }\\n            entrances.resize(k);\\n        }\\n        \\n        int result = get_cost(dst, src);\\n        for (auto [cost, x, y]: exits) {\\n            result = min(result, cost + get_cost({x, y}, dst));\\n        };\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        const pair<int,int> src = {start[0], start[1]};\\n        const pair<int,int> dst = {target[0], target[1]};\\n        \\n        auto get_cost = [](pair<int,int> src, pair<int,int> dst) {\\n            return abs(src.first - dst.first) + abs(src.second - dst.second);\\n        };\\n        \\n        vector<pair<int,int>> entrances; // cost, index\\n        for (int i = 0; i < specialRoads.size(); ++i) {\\n            auto &road = specialRoads[i];\\n            entrances.push_back({get_cost(src, {road[0], road[1]}), i});\\n        }\\n        \\n        vector<tuple<int,int,int>> exits; // cost, x, y\\n        while (int n = entrances.size()) {\\n            auto [cost, i] = *min_element(entrances.begin(), entrances.end());\\n            auto &road = specialRoads[i];\\n            int x = road[2];\\n            int y = road[3];\\n            cost += road[4];\\n            exits.push_back({cost, x, y});\\n            \\n            int k = 0; // write index\\n            for (int j = 0; j < n; ++j) {\\n                auto [cost2, i2] = entrances[j];\\n                if (i2 != i) {\\n                    auto &road2 = specialRoads[i2];\\n                    cost2 = min(cost2, cost + get_cost({x, y}, {road2[0], road2[1]}));\\n                    entrances[k++] = {cost2, i2};\\n                }\\n            }\\n            entrances.resize(k);\\n        }\\n        \\n        int result = get_cost(dst, src);\\n        for (auto [cost, x, y]: exits) {\\n            result = min(result, cost + get_cost({x, y}, dst));\\n        };\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468960,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start, target, specialRoads):\\n        dict2 = defaultdict(list)\\n\\n        dict2[(target[0],target[1])] = [0,0,0]\\n\\n        for x1,y1,x2,y2,c in specialRoads:\\n            if abs(x1-x2) + abs(y1-y2) >= c:\\n                dict2[(x1,y1)].append((x2,y2,c))\\n\\n        dict1 = defaultdict(lambda: float(\"inf\"))\\n\\n        dict1[(start[0],start[1])] = 0\\n\\n        stack = [(0,start[0],start[1])]\\n\\n        while stack:\\n            cost,x,y = heappop(stack)\\n\\n            if [x,y] == target:\\n                return cost\\n\\n            for nx,ny,c in dict2[(x,y)]:\\n                if dict1[(nx,ny)] > c + cost:\\n                    dict1[(nx,ny)] = c + cost\\n                    heappush(stack,(c+cost,nx,ny))\\n\\n            for xx,yy in dict2:\\n                if dict1[(xx,yy)] > cost + abs(xx-x) + abs(yy-y):\\n                    dict1[(xx,yy)] = cost + abs(xx-x) + abs(yy-y)\\n                    heappush(stack,(cost+abs(xx-x)+abs(yy-y),xx,yy))\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start, target, specialRoads):\\n        dict2 = defaultdict(list)\\n\\n        dict2[(target[0],target[1])] = [0,0,0]\\n\\n        for x1,y1,x2,y2,c in specialRoads:\\n            if abs(x1-x2) + abs(y1-y2) >= c:\\n                dict2[(x1,y1)].append((x2,y2,c))\\n\\n        dict1 = defaultdict(lambda: float(\"inf\"))\\n\\n        dict1[(start[0],start[1])] = 0\\n\\n        stack = [(0,start[0],start[1])]\\n\\n        while stack:\\n            cost,x,y = heappop(stack)\\n\\n            if [x,y] == target:\\n                return cost\\n\\n            for nx,ny,c in dict2[(x,y)]:\\n                if dict1[(nx,ny)] > c + cost:\\n                    dict1[(nx,ny)] = c + cost\\n                    heappush(stack,(c+cost,nx,ny))\\n\\n            for xx,yy in dict2:\\n                if dict1[(xx,yy)] > cost + abs(xx-x) + abs(yy-y):\\n                    dict1[(xx,yy)] = cost + abs(xx-x) + abs(yy-y)\\n                    heappush(stack,(cost+abs(xx-x)+abs(yy-y),xx,yy))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468828,
                "title": "c-100-solution-dp-with-floydd-warshall",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince coordinates can go to 1e5 this is better to take spl roads as our variable to work with which will go at most 200\\nnow using floydd warshall I have calculated the minimum dis to reach every end of a spl road from st and min dis to reach target from every spl roads st\\nnow there is no use to use a spl road twice so at most we are going to use n spl roads so taking our k->(1->n) spl roads we will get the min dis but this will give us TLE\\nnow to further improve it we can use our previously calculated values where we can say thet min dis to reach (say) from any spl road\\'s stx,sty to targetx , targety using ispl roads at most will be that of using i/2 spl roads and after that using any of other (0->n) spl roads(again taking i/2 roads to rach target) that \\'s why it will work even for 1->sqrt(n) as while calculating for 2 we know the min dis require to cover using at most 1 road similarly at 3 spl road we know the min dis with at most 2 spl roads so this will gactually give us answer for taking at most 4 spl roads similarly sqrt(n)+1 give us using at most n sp roads\\nkeep in mind that the min answer can be through any one of these (from st-> any spl road end point) or (start of any spl road -> target)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP -> floydd warshall algo\\nusing this algo I have found \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n x n x sqrt(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n![image.png](https://assets.leetcode.com/users/images/7ed75506-b5e4-4629-9bfd-73d6c729be1c_1682834921.9929557.png)\\n\\n\\n**PLS UPVOTE IT TAKES A LOT OF EFFORTS**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        int ans=abs(target[0]-start[0])+abs(target[1]-start[1]);\\n        int n=sr.size();\\n        int* e_dis=new int[n];\\n        int* dis_dp=new int[n];\\n\\n        int* st_dis=new int[n];\\n        int* dis_dp1=new int[n];\\n        vector<int> start_path(n);\\n\\n        vector<int> end_path(n);\\n        for(int i=0;i<n;i++){\\n            dis_dp[i]=sr[i][4];\\n            dis_dp[i]+=abs(target[0]-sr[i][2])+abs(target[1]-sr[i][3]);\\n            end_path[i]=i;\\n            e_dis[i]=dis_dp[i]-sr[i][4];\\n\\n            dis_dp1[i]=sr[i][4];\\n            dis_dp1[i]+=abs(start[0]-sr[i][0])+abs(start[1]-sr[i][1]);\\n            start_path[i]=i;\\n            st_dis[i]=dis_dp1[i]-sr[i][4];\\n        }\\n        for(int k=2;k<=sqrt(n)+1;k++){\\n            for(int i=0;i<n;i++){\\n                int res=e_dis[i];\\n                int n_ep=end_path[i];\\n                int res1=st_dis[i];\\n                int n_sp=start_path[i];\\n                for(int j=0;j<n;j++){\\n                    int x=abs(sr[end_path[i]][2]-sr[j][0])+abs(sr[end_path[i]][3]-sr[j][1]);\\n                    if(res>x+dis_dp[j]){\\n                        res=x+dis_dp[j];\\n                        n_ep=end_path[j];\\n                    }\\n                    x=abs(sr[start_path[i]][0]-sr[j][2])+abs(sr[start_path[i]][1]-sr[j][3]);\\n                    if(res1>x+dis_dp1[j]){\\n                        res1=x+dis_dp1[j];\\n                        n_sp=start_path[j];\\n                    }\\n                }\\n                dis_dp[i]+=-e_dis[i]+res;\\n                end_path[i]=n_ep;\\n                e_dis[i]=abs(target[0]-sr[n_ep][2])+abs(target[1]-sr[n_ep][3]);\\n                dis_dp1[i]+=-st_dis[i]+res1;\\n                start_path[i]=n_sp;\\n                st_dis[i]=abs(start[0]-sr[n_sp][0])+abs(start[1]-sr[n_sp][1]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int x=abs(start[0]-sr[i][0])+abs(start[1]-sr[i][1]);\\n            if(dis_dp[i]+x<ans){\\n                ans=dis_dp[i]+x;\\n            }\\n\\n            x=abs(target[0]-sr[i][2])+abs(target[1]-sr[i][3]);\\n            if(dis_dp1[i]+x<ans){\\n                ans=dis_dp1[i]+x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& sr) {\\n        int ans=abs(target[0]-start[0])+abs(target[1]-start[1]);\\n        int n=sr.size();\\n        int* e_dis=new int[n];\\n        int* dis_dp=new int[n];\\n\\n        int* st_dis=new int[n];\\n        int* dis_dp1=new int[n];\\n        vector<int> start_path(n);\\n\\n        vector<int> end_path(n);\\n        for(int i=0;i<n;i++){\\n            dis_dp[i]=sr[i][4];\\n            dis_dp[i]+=abs(target[0]-sr[i][2])+abs(target[1]-sr[i][3]);\\n            end_path[i]=i;\\n            e_dis[i]=dis_dp[i]-sr[i][4];\\n\\n            dis_dp1[i]=sr[i][4];\\n            dis_dp1[i]+=abs(start[0]-sr[i][0])+abs(start[1]-sr[i][1]);\\n            start_path[i]=i;\\n            st_dis[i]=dis_dp1[i]-sr[i][4];\\n        }\\n        for(int k=2;k<=sqrt(n)+1;k++){\\n            for(int i=0;i<n;i++){\\n                int res=e_dis[i];\\n                int n_ep=end_path[i];\\n                int res1=st_dis[i];\\n                int n_sp=start_path[i];\\n                for(int j=0;j<n;j++){\\n                    int x=abs(sr[end_path[i]][2]-sr[j][0])+abs(sr[end_path[i]][3]-sr[j][1]);\\n                    if(res>x+dis_dp[j]){\\n                        res=x+dis_dp[j];\\n                        n_ep=end_path[j];\\n                    }\\n                    x=abs(sr[start_path[i]][0]-sr[j][2])+abs(sr[start_path[i]][1]-sr[j][3]);\\n                    if(res1>x+dis_dp1[j]){\\n                        res1=x+dis_dp1[j];\\n                        n_sp=start_path[j];\\n                    }\\n                }\\n                dis_dp[i]+=-e_dis[i]+res;\\n                end_path[i]=n_ep;\\n                e_dis[i]=abs(target[0]-sr[n_ep][2])+abs(target[1]-sr[n_ep][3]);\\n                dis_dp1[i]+=-st_dis[i]+res1;\\n                start_path[i]=n_sp;\\n                st_dis[i]=abs(start[0]-sr[n_sp][0])+abs(start[1]-sr[n_sp][1]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int x=abs(start[0]-sr[i][0])+abs(start[1]-sr[i][1]);\\n            if(dis_dp[i]+x<ans){\\n                ans=dis_dp[i]+x;\\n            }\\n\\n            x=abs(target[0]-sr[i][2])+abs(target[1]-sr[i][3]);\\n            if(dis_dp1[i]+x<ans){\\n                ans=dis_dp1[i]+x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468792,
                "title": "a-star-cut",
                "content": "# Intuition\\nIntermediate points are\\n$x_2^{(i)}, y_2^{(i)}$ from $x_1^{(i)}, y_1^{(i)}, x_2^{(i)}, y_2^{(i)}, cost^{(i)}$ from `speicalRoads`.\\n\\n# Approach\\n* Sort candidate intermediate points by their expected distances from $x_2^{(i)}, y_2^{(i)}$ to $\\\\mathrm{target}_x, \\\\mathrm{target}_y$.\\n\\n* Early cut A: if current distance is longer than the current shortest distance\\n\\n* Early cut B: if current distance is longer than the existing shortest distance from the start point.\\n\\n# Complexity\\n- Time complexity:\\nThe complexity is $O(N^3)$, because there are $N + 1$ entries in `visited` (at most $N$ special roads plus the target), each entry can be updated at most $N - 1$ times (passing the other special roads, each at most once), thus heap will be inserted at most $O(N^2)$ times, and each heap pop will cause a traverse of specialRoads $O(N)$.\\n\\n- Space complexity:\\n$O(N^2)$ where $N$ is the length of `specialRoad`, the max length of the heap.\\n\\n\\n# Code\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        start_x, start_y = start\\n        target_x, target_y = target\\n        \\n        ret = abs(target_x - start_x) + abs(target_y - start_y)\\n        \\n        specials = sorted([ \\n            ( (abs(target_x - x2) + abs(target_y - y2) + cost), cost, x1, y1, x2, y2) \\n            for x1, y1, x2, y2, cost in specialRoads \\n        ])\\n        \\n        # a-star\\n        heap = [(0, start_x, start_y)] # used_dist, cur_x, cur_y\\n        visited = {(start_x, start_y): 0}\\n        \\n        while heap:\\n            cur_dist, cur_x, cur_y = heappop(heap)\\n            if cur_dist >= ret:\\n                continue            \\n            \\n            for delta, cost, x1, y1, x2, y2 in specials:\\n                pre_dist = abs(x1 - cur_x) + abs(y1 - cur_y) + cur_dist\\n                new_dist = pre_dist + cost\\n                all_dist = pre_dist + delta                \\n                if (x2, y2) not in visited or new_dist < visited[(x2, y2)]:\\n                    heappush(heap, (new_dist, x2, y2))\\n                    visited[(x2, y2)] = new_dist\\n                ret = min(ret, all_dist)\\n        \\n        return ret\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        start_x, start_y = start\\n        target_x, target_y = target\\n        \\n        ret = abs(target_x - start_x) + abs(target_y - start_y)\\n        \\n        specials = sorted([ \\n            ( (abs(target_x - x2) + abs(target_y - y2) + cost), cost, x1, y1, x2, y2) \\n            for x1, y1, x2, y2, cost in specialRoads \\n        ])\\n        \\n        # a-star\\n        heap = [(0, start_x, start_y)] # used_dist, cur_x, cur_y\\n        visited = {(start_x, start_y): 0}\\n        \\n        while heap:\\n            cur_dist, cur_x, cur_y = heappop(heap)\\n            if cur_dist >= ret:\\n                continue            \\n            \\n            for delta, cost, x1, y1, x2, y2 in specials:\\n                pre_dist = abs(x1 - cur_x) + abs(y1 - cur_y) + cur_dist\\n                new_dist = pre_dist + cost\\n                all_dist = pre_dist + delta                \\n                if (x2, y2) not in visited or new_dist < visited[(x2, y2)]:\\n                    heappush(heap, (new_dist, x2, y2))\\n                    visited[(x2, y2)] = new_dist\\n                ret = min(ret, all_dist)\\n        \\n        return ret\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468778,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n* n * log(n))\\n * Space Complexity: O(n * n)\\n * where `n` is the length of the vector `specialRoads`\\n */\\nclass Solution {\\n private:\\n  using node_t = pair<int, int>;\\n  \\n  class Hash {\\n   public:\\n    size_t operator()(const node_t &node) const noexcept {\\n      constexpr size_t magic = 0x9e3779b9;\\n      size_t ret = 0;\\n      ret ^= node.first + magic + (ret << 6) + (ret >> 2);\\n      ret ^= node.second + magic + (ret << 6) + (ret >> 2);\\n      return ret;\\n    }\\n  };\\n  \\n public:\\n  int minimumCost(const vector<int> &start,\\n                  const vector<int> &target,\\n                  const vector<vector<int>> &specialRoads) {\\n    using pq_node_t = tuple<int, int, int>;   // {cost, x, y}\\n    constexpr int x_i = 0;\\n    constexpr int y_i = 1;\\n    constexpr int x1_i = 0;\\n    constexpr int y1_i = 1;\\n    constexpr int x2_i = 2;\\n    constexpr int y2_i = 3;\\n    constexpr int cost_i = 4;\\n    const node_t start_node(start[x_i], start[y_i]);\\n    const node_t target_node(target[x_i], target[y_i]);\\n    unordered_map<node_t, vector<pair<node_t, int>>, Hash> graph;\\n    graph[start_node].emplace_back(target_node, distance(start_node, target_node));\\n    const int n_roads = static_cast<int>(specialRoads.size());\\n    for (int i = 0; i < n_roads; ++i) {\\n      const node_t from_i(specialRoads[i][x1_i], specialRoads[i][y1_i]);\\n      const node_t to_i(specialRoads[i][x2_i], specialRoads[i][y2_i]);\\n      const int cost = specialRoads[i][cost_i];\\n      graph[from_i].emplace_back(to_i, cost);\\n      if (start_node != from_i) {\\n        graph[start_node].emplace_back(from_i, distance(start_node, from_i));\\n      }\\n      if (to_i != target_node) {\\n        graph[to_i].emplace_back(target_node, distance(to_i, target_node));\\n      }\\n      for (int j = i + 1; j < n_roads; ++j) {\\n        const node_t from_j(specialRoads[j][x1_i], specialRoads[j][y1_i]);\\n        const node_t to_j(specialRoads[j][x2_i], specialRoads[j][y2_i]);\\n        graph[to_i].emplace_back(from_j, distance(to_i, from_j));\\n        graph[to_j].emplace_back(from_i, distance(to_j, from_i));\\n      }\\n    }\\n    \\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    unordered_set<node_t, Hash> visited;\\n    pq.emplace(0, start_node.first, start_node.second);\\n    while (!pq.empty()) {\\n      const auto [c, x, y] = pq.top();\\n      pq.pop();\\n      node_t node(x, y);\\n      if (node == target_node) {\\n        return c;\\n      }\\n      if (visited.find(node) != visited.end()) {\\n        continue;\\n      }\\n      visited.emplace(node);\\n      for (const auto &[next, delta_c] : graph[node]) {\\n        if (visited.find(next) != visited.end()) {\\n          continue;\\n        }\\n        pq.emplace(c + delta_c, next.first, next.second);\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n  \\n private:\\n  int distance(const node_t &from, const node_t &to) {\\n    return abs(from.first - to.first) + abs(from.second - to.second);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n* n * log(n))\\n * Space Complexity: O(n * n)\\n * where `n` is the length of the vector `specialRoads`\\n */\\nclass Solution {\\n private:\\n  using node_t = pair<int, int>;\\n  \\n  class Hash {\\n   public:\\n    size_t operator()(const node_t &node) const noexcept {\\n      constexpr size_t magic = 0x9e3779b9;\\n      size_t ret = 0;\\n      ret ^= node.first + magic + (ret << 6) + (ret >> 2);\\n      ret ^= node.second + magic + (ret << 6) + (ret >> 2);\\n      return ret;\\n    }\\n  };\\n  \\n public:\\n  int minimumCost(const vector<int> &start,\\n                  const vector<int> &target,\\n                  const vector<vector<int>> &specialRoads) {\\n    using pq_node_t = tuple<int, int, int>;   // {cost, x, y}\\n    constexpr int x_i = 0;\\n    constexpr int y_i = 1;\\n    constexpr int x1_i = 0;\\n    constexpr int y1_i = 1;\\n    constexpr int x2_i = 2;\\n    constexpr int y2_i = 3;\\n    constexpr int cost_i = 4;\\n    const node_t start_node(start[x_i], start[y_i]);\\n    const node_t target_node(target[x_i], target[y_i]);\\n    unordered_map<node_t, vector<pair<node_t, int>>, Hash> graph;\\n    graph[start_node].emplace_back(target_node, distance(start_node, target_node));\\n    const int n_roads = static_cast<int>(specialRoads.size());\\n    for (int i = 0; i < n_roads; ++i) {\\n      const node_t from_i(specialRoads[i][x1_i], specialRoads[i][y1_i]);\\n      const node_t to_i(specialRoads[i][x2_i], specialRoads[i][y2_i]);\\n      const int cost = specialRoads[i][cost_i];\\n      graph[from_i].emplace_back(to_i, cost);\\n      if (start_node != from_i) {\\n        graph[start_node].emplace_back(from_i, distance(start_node, from_i));\\n      }\\n      if (to_i != target_node) {\\n        graph[to_i].emplace_back(target_node, distance(to_i, target_node));\\n      }\\n      for (int j = i + 1; j < n_roads; ++j) {\\n        const node_t from_j(specialRoads[j][x1_i], specialRoads[j][y1_i]);\\n        const node_t to_j(specialRoads[j][x2_i], specialRoads[j][y2_i]);\\n        graph[to_i].emplace_back(from_j, distance(to_i, from_j));\\n        graph[to_j].emplace_back(from_i, distance(to_j, from_i));\\n      }\\n    }\\n    \\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    unordered_set<node_t, Hash> visited;\\n    pq.emplace(0, start_node.first, start_node.second);\\n    while (!pq.empty()) {\\n      const auto [c, x, y] = pq.top();\\n      pq.pop();\\n      node_t node(x, y);\\n      if (node == target_node) {\\n        return c;\\n      }\\n      if (visited.find(node) != visited.end()) {\\n        continue;\\n      }\\n      visited.emplace(node);\\n      for (const auto &[next, delta_c] : graph[node]) {\\n        if (visited.find(next) != visited.end()) {\\n          continue;\\n        }\\n        pq.emplace(c + delta_c, next.first, next.second);\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n  \\n private:\\n  int distance(const node_t &from, const node_t &to) {\\n    return abs(from.first - to.first) + abs(from.second - to.second);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468680,
                "title": "c-95ms-beats-100-runtime-priority-queue-unordered-map-of-pairs-dijkstra-s-algorithm",
                "content": "# Intuition\\nMake the special roads as just another node at specialRoad[2], specialRoad[3], then the cost from some node n to some special road s will be manhattanDistance(n, s[0][1]) + s[4]. Construct a graph with that info in mind and use dijkstra algorithm to get min cost from start node to end node\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // A hash function used to hash a pair of any kind\\n    struct hash_pair {\\n        template <class T1, class T2>\\n        size_t operator()(const pair<T1, T2>& p) const\\n        {\\n            auto hash1 = hash<T1>{}(p.first);\\n            auto hash2 = hash<T2>{}(p.second);\\n\\n            if (hash1 != hash2) {\\n                return hash1 ^ hash2;             \\n            }\\n\\n            // If hash1 == hash2, their XOR is zero.\\n              return hash1;\\n        }\\n    };\\n    \\n    int mhd(int x1, int y1, int x2, int y2){\\n        return abs(x1-x2) + abs(y1-y2);\\n    }\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        unordered_map<pair<int, int>, vector<int>, hash_pair> um; // map val = [currMinCost, visited{0(no), 1(yes)}]\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        \\n        pq.push({0, {start[0], start[1]}});\\n        um[{start[0], start[1]}] = {0, 1};\\n        while(!pq.empty()){\\n            auto node = pq.top();\\n            pq.pop();\\n            int nodeCost = um[node.second][0];\\n            int x = node.second.first;\\n            int y = node.second.second;\\n            \\n            for (vector<int>& specialRoad : specialRoads){\\n                int cost = nodeCost + mhd(x, y, specialRoad[0], specialRoad[1]) + specialRoad[4];\\n                pair<int, int> neighbor = {specialRoad[2], specialRoad[3]};\\n                \\n                if (um.find(neighbor) == um.end()){\\n                    um[neighbor] = {cost, 0};\\n                }\\n                \\n                if (um[neighbor][1] == 0){\\n                    pq.push({cost, neighbor});\\n                    um[neighbor][1] = 1;\\n                }\\n                \\n                um[neighbor][0] = min(um[neighbor][0], cost);\\n            }\\n            \\n            int cost = nodeCost + mhd(x, y, target[0], target[1]);\\n            pair<int, int> neighbor = {target[0], target[1]};\\n\\n            if (um.find(neighbor) == um.end()){\\n                um[neighbor] = {cost, 0};\\n            }\\n\\n            if (um[neighbor][1] == 0){\\n                pq.push({cost, neighbor});\\n                um[neighbor][1] = 1;\\n            }\\n\\n            um[neighbor][0] = min(um[neighbor][0], cost);\\n        }\\n        \\n        return um[{target[0], target[1]}][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // A hash function used to hash a pair of any kind\\n    struct hash_pair {\\n        template <class T1, class T2>\\n        size_t operator()(const pair<T1, T2>& p) const\\n        {\\n            auto hash1 = hash<T1>{}(p.first);\\n            auto hash2 = hash<T2>{}(p.second);\\n\\n            if (hash1 != hash2) {\\n                return hash1 ^ hash2;             \\n            }\\n\\n            // If hash1 == hash2, their XOR is zero.\\n              return hash1;\\n        }\\n    };\\n    \\n    int mhd(int x1, int y1, int x2, int y2){\\n        return abs(x1-x2) + abs(y1-y2);\\n    }\\n    \\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        unordered_map<pair<int, int>, vector<int>, hash_pair> um; // map val = [currMinCost, visited{0(no), 1(yes)}]\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        \\n        pq.push({0, {start[0], start[1]}});\\n        um[{start[0], start[1]}] = {0, 1};\\n        while(!pq.empty()){\\n            auto node = pq.top();\\n            pq.pop();\\n            int nodeCost = um[node.second][0];\\n            int x = node.second.first;\\n            int y = node.second.second;\\n            \\n            for (vector<int>& specialRoad : specialRoads){\\n                int cost = nodeCost + mhd(x, y, specialRoad[0], specialRoad[1]) + specialRoad[4];\\n                pair<int, int> neighbor = {specialRoad[2], specialRoad[3]};\\n                \\n                if (um.find(neighbor) == um.end()){\\n                    um[neighbor] = {cost, 0};\\n                }\\n                \\n                if (um[neighbor][1] == 0){\\n                    pq.push({cost, neighbor});\\n                    um[neighbor][1] = 1;\\n                }\\n                \\n                um[neighbor][0] = min(um[neighbor][0], cost);\\n            }\\n            \\n            int cost = nodeCost + mhd(x, y, target[0], target[1]);\\n            pair<int, int> neighbor = {target[0], target[1]};\\n\\n            if (um.find(neighbor) == um.end()){\\n                um[neighbor] = {cost, 0};\\n            }\\n\\n            if (um[neighbor][1] == 0){\\n                pq.push({cost, neighbor});\\n                um[neighbor][1] = 1;\\n            }\\n\\n            um[neighbor][0] = min(um[neighbor][0], cost);\\n        }\\n        \\n        return um[{target[0], target[1]}][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468616,
                "title": "any-body-who-can-tell-me-why-can-t-this-solution-pass-this-case",
                "content": "Here is my solution:\\nIt can\\'t pass the case:\\n[1,1]\\n[10,8]\\n[[6,4,9,7,1],[5,2,2,1,3],[3,2,5,5,2]]\\nGot 11 but supposed 10. I was confused, thanks!\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nimport heapq \\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        startX, startY = start\\n        targetX, targetY = target\\n        maxVal = float(\\'inf\\')\\n        dp = [[maxVal] * (targetY + 1) for _ in range(targetX + 1)]\\n        dp[startX][startY] = 0\\n        change = True\\n        while change:\\n            change = False\\n            for i in range(targetX + 1):\\n                for j in range(targetY + 1):\\n                    for road in specialRoads:\\n                        x1, y1, x2, y2, cost = road\\n                        if x2 == i and y2 == j:\\n                            if dp[x1][y1] + cost < dp[i][j]:\\n                                change = True\\n                                dp[i][j] = dp[x1][y1] + cost\\n                    if i > 0:\\n                        if dp[i - 1][j] + 1 < dp[i][j]:\\n                            dp[i][j] = dp[i - 1][j] + 1\\n                            change = True\\n                    if j > 0:\\n                        if dp[i][j - 1] + 1 < dp[i][j]:\\n                            change = True\\n                            dp[i][j] = dp[i][j - 1] + 1                \\n        return dp[targetX][targetY]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq \\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        startX, startY = start\\n        targetX, targetY = target\\n        maxVal = float(\\'inf\\')\\n        dp = [[maxVal] * (targetY + 1) for _ in range(targetX + 1)]\\n        dp[startX][startY] = 0\\n        change = True\\n        while change:\\n            change = False\\n            for i in range(targetX + 1):\\n                for j in range(targetY + 1):\\n                    for road in specialRoads:\\n                        x1, y1, x2, y2, cost = road\\n                        if x2 == i and y2 == j:\\n                            if dp[x1][y1] + cost < dp[i][j]:\\n                                change = True\\n                                dp[i][j] = dp[x1][y1] + cost\\n                    if i > 0:\\n                        if dp[i - 1][j] + 1 < dp[i][j]:\\n                            dp[i][j] = dp[i - 1][j] + 1\\n                            change = True\\n                    if j > 0:\\n                        if dp[i][j - 1] + 1 < dp[i][j]:\\n                            change = True\\n                            dp[i][j] = dp[i][j - 1] + 1                \\n        return dp[targetX][targetY]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468608,
                "title": "modified-dijkstra-algorithm",
                "content": "# Intuition\\nmodified djkistra algo\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& t, vector<vector<int>>& s) {\\n        vector<int>vis(201,0);\\n        vector<int>d(201,1e9);\\n        s.push_back({start[0],start[1],start[0],start[1],0});\\n        set<pair<int,int>>st;\\n        st.insert({0,s.size()-1});\\n        d[s.size()-1]=0;\\n        while(st.size()){\\n            auto n=*st.begin();\\n            int i=n.second;\\n            int dist=n.first;\\n            st.erase(st.begin());\\n            if(vis[i]) continue;\\n            vis[i]=1;\\n            for(int j=0;j<s.size();j++){\\n                if(d[i]+abs(s[i][2]-s[j][0])+abs(s[i][3]-s[j][1])+s[j][4]<d[j]){\\n                    d[j]=d[i]+abs(s[i][2]-s[j][0])+abs(s[i][3]-s[j][1])+s[j][4];\\n                    st.insert({d[j],j});\\n                }\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<s.size();i++){\\n            //cout<<d[i]<<\" \";\\n            ans=min(ans,d[i]+abs(t[0]-s[i][2])+abs(t[1]-s[i][3]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& t, vector<vector<int>>& s) {\\n        vector<int>vis(201,0);\\n        vector<int>d(201,1e9);\\n        s.push_back({start[0],start[1],start[0],start[1],0});\\n        set<pair<int,int>>st;\\n        st.insert({0,s.size()-1});\\n        d[s.size()-1]=0;\\n        while(st.size()){\\n            auto n=*st.begin();\\n            int i=n.second;\\n            int dist=n.first;\\n            st.erase(st.begin());\\n            if(vis[i]) continue;\\n            vis[i]=1;\\n            for(int j=0;j<s.size();j++){\\n                if(d[i]+abs(s[i][2]-s[j][0])+abs(s[i][3]-s[j][1])+s[j][4]<d[j]){\\n                    d[j]=d[i]+abs(s[i][2]-s[j][0])+abs(s[i][3]-s[j][1])+s[j][4];\\n                    st.insert({d[j],j});\\n                }\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<s.size();i++){\\n            //cout<<d[i]<<\" \";\\n            ans=min(ans,d[i]+abs(t[0]-s[i][2])+abs(t[1]-s[i][3]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468606,
                "title": "dijkstra-s-algorithm-easy-c",
                "content": "```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\\n#pragma GCC optimize(\"unroll-loops\")\\n#include <bits/stdc++.h>\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n#include <complex>\\n#include <queue>\\n#include <set>\\n#include <unordered_set>\\n#include <list>\\n#include <chrono>\\n#include <random>\\n#include <iostream>\\n#include <algorithm>\\n#include <cmath>\\n#include <string>\\n#include <vector>\\n#include <map>\\n#include <unordered_map>\\n#include <stack>\\n#include <iomanip>\\n#include <fstream>\\n\\nusing namespace std;\\nusing namespace __gnu_pbds;\\ntypedef long long ll;\\n// use less_equal to make it multiset\\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\ntypedef unsigned long long ull;\\ntypedef long double ld;\\ntypedef pair<int, int> p32;\\ntypedef pair<ll, ll> p64;\\ntypedef pair<double, double> pdd;\\ntypedef vector<ll> v64;\\ntypedef vector<int> v32;\\ntypedef vector<vector<int>> vv32;\\ntypedef vector<vector<ll>> vv64;\\ntypedef vector<vector<p64>> vvp64;\\ntypedef vector<p64> vp64;\\ntypedef vector<p32> vp32;\\ntypedef vector<pair<p64, ll>> vpp64;\\ntypedef set<ll> s64;\\ntypedef set<p64> sp64;\\ntypedef multiset<ll> ms64;\\ntypedef multiset<p64> msp64;\\ntypedef map<ll, ll> m64;\\ntypedef map<ll, v64> mv64;\\ntypedef unordered_map<ll, v64> uv64;\\ntypedef unordered_map<ll, ll> u64;\\ntypedef unordered_map<p64, ll> up64;\\ntypedef unordered_map<ll, vp64> uvp64;\\ntypedef priority_queue<ll> pq64;\\ntypedef priority_queue<ll, v64, greater<ll>> pqs64;\\nconst int MOD = 1000000007;\\ndouble eps = 1e-12;\\n#define forn(i, n) for (ll i = 0; i < n; i++)\\n#define forsn(i, s, e) for (ll i = s; i < e; i++)\\n#define rforn(i, s) for (ll i = s; i >= 0; i--)\\n#define rforsn(i, s, e) for (ll i = s; i >= e; i--)\\nstruct custom_hash\\n{\\n    static uint64_t splitmix64(uint64_t x)\\n    {\\n        x += 0x9e3779b97f4a7c15;\\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\\n        return x ^ (x >> 31);\\n    }\\n\\n    size_t operator()(p64 x) const\\n    {\\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\\n        return splitmix64(x.first + FIXED_RANDOM) ^ splitmix64(x.second + FIXED_RANDOM);\\n    }\\n    size_t operator()(ll x) const\\n    {\\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\\n        return splitmix64(x + FIXED_RANDOM);\\n    }\\n};\\ntypedef gp_hash_table<ll, ll, custom_hash> fm64;\\ntypedef gp_hash_table<p64, ll, custom_hash> fmp64;\\n\\n#define ln \"\\\\n\"\\n#define mp make_pair\\n#define ie insert\\n#define pb push_back\\n#define fi first\\n#define se second\\n#define INF 2e18\\n#define fast_cin()                    \\\\\\n    ios_base::sync_with_stdio(false); \\\\\\n    cin.tie(NULL);                    \\\\\\n    cout.tie(NULL)\\n#define all(x) (x).begin(), (x).end()\\n#define al(arr, n) arr, arr + n\\n#define sz(x) ((ll)(x).size())\\n#define dbg(a) cout << a << endl;\\n#define dbg2(a) cout << a << \\' \\';\\nusing ld = long double;\\nusing db = double;\\nusing str = string; // yay python!\\n// INPUT\\n#define tcT template <class T\\n#define tcTU tcT, class U\\n#define tcTUU tcT, class... U\\ntcT > void re(T &x)\\n{\\n    cin >> x;\\n}\\ntcTUU > void re(T &t, U &...u)\\n{\\n    re(t);\\n    re(u...);\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& edges) {\\n        map<p64,ll> hsh;\\n        hsh[{start[0],start[1]}]=1;\\n        hsh[{target[0],target[1]}]=2;\\n        vector<pair<ll,p64>> edge;\\n        edge.push_back({abs(start[0]-target[0])+abs(start[1]-target[1]),{1,2}});\\n        ll cc=2;\\n        for(auto t:edges)\\n        {\\n            int x1=t[0],y1=t[1];\\n            int x2=t[2],y2=t[3];\\n            int cost=t[4];\\n            if(hsh.count({x1,y1})==0)\\n            {\\n                cc++;\\n                hsh[{x1,y1}]=cc;\\n            }\\n            if(hsh.count({x2,y2})==0)\\n            {\\n                cc++;\\n                hsh[{x2,y2}]=cc;\\n            }\\n            // from 1 to x1,y1\\n            int dist1=abs(start[0]-x1)+abs(start[1]-y1);\\n            int dist2=abs(target[0]-x2)+abs(target[1]-y2);\\n            edge.push_back({dist1,{1,hsh[{x1,y1}]}});\\n            edge.push_back({dist2,{hsh[{x2,y2}],2}});\\n        }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int node1=hsh[{edges[i][0],edges[i][1]}];\\n            int node2=hsh[{edges[i][2],edges[i][3]}];\\n            int cost1=edges[i][4];            \\n            edge.push_back({cost1,{node1,node2}});\\n            for(int j=0;j<edges.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n\\n                    int node3=hsh[{edges[j][0],edges[j][1]}];\\n                    int node4=hsh[{edges[j][2],edges[j][3]}];\\n                    \\n                    int cost2=edges[j][4];\\n                    // node 2 se 3\\n                    int cost=abs(edges[i][2]-edges[j][0])+abs(edges[i][3]-edges[j][1]);\\n                    edge.push_back({cost,{node2,node3}});\\n                    // node 2 se 4\\n                    cost=abs(edges[i][2]-edges[j][2])+abs(edges[i][3]-edges[j][3]);\\n                    edge.push_back({cost,{node2,node4}});\\n                    // node 1 se 3\\n                    cost=abs(edges[i][0]-edges[j][0])+abs(edges[i][1]-edges[j][1]);\\n                    edge.push_back({cost,{node1,node3}});\\n                    // node 1 se 4\\n                    cost=abs(edges[i][0]-edges[j][2])+abs(edges[i][1]-edges[j][3]);\\n                    edge.push_back({cost,{node1,node4}});\\n                }\\n            }\\n        }\\n        uvp64 adj;\\n        u64 dist;\\n        for(auto t:edge)\\n        {\\n            int x=t.second.first;\\n            int y=t.second.second;\\n            int cost=t.first;\\n            adj[x].pb({y,cost});\\n            dist[x]=INF;\\n            dist[y]=INF;\\n        }\\n        set<pair<ll, ll>> st;\\n        dist[1] = 0;\\n        st.insert({0, 1});\\n        while (st.size())\\n        {\\n            pair<ll, ll> p = *st.begin();\\n            st.erase(st.begin());\\n            ll wt = p.first;\\n            ll u = p.second;\\n            for (auto t : adj[u])\\n            {\\n                pair<ll, ll> q = t;\\n                ll v = q.first;\\n                ll x = q.second;\\n                if (dist[v] > dist[u] + x)\\n                {\\n                    if (st.find({dist[v], v}) != st.end())\\n                        st.erase({dist[v], v});\\n                    dist[v] = dist[u] + x;\\n                    st.insert({dist[v], v});\\n                }\\n            }\\n        }\\n        return dist[2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\\n#pragma GCC optimize(\"unroll-loops\")\\n#include <bits/stdc++.h>\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n#include <complex>\\n#include <queue>\\n#include <set>\\n#include <unordered_set>\\n#include <list>\\n#include <chrono>\\n#include <random>\\n#include <iostream>\\n#include <algorithm>\\n#include <cmath>\\n#include <string>\\n#include <vector>\\n#include <map>\\n#include <unordered_map>\\n#include <stack>\\n#include <iomanip>\\n#include <fstream>\\n\\nusing namespace std;\\nusing namespace __gnu_pbds;\\ntypedef long long ll;\\n// use less_equal to make it multiset\\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\ntypedef unsigned long long ull;\\ntypedef long double ld;\\ntypedef pair<int, int> p32;\\ntypedef pair<ll, ll> p64;\\ntypedef pair<double, double> pdd;\\ntypedef vector<ll> v64;\\ntypedef vector<int> v32;\\ntypedef vector<vector<int>> vv32;\\ntypedef vector<vector<ll>> vv64;\\ntypedef vector<vector<p64>> vvp64;\\ntypedef vector<p64> vp64;\\ntypedef vector<p32> vp32;\\ntypedef vector<pair<p64, ll>> vpp64;\\ntypedef set<ll> s64;\\ntypedef set<p64> sp64;\\ntypedef multiset<ll> ms64;\\ntypedef multiset<p64> msp64;\\ntypedef map<ll, ll> m64;\\ntypedef map<ll, v64> mv64;\\ntypedef unordered_map<ll, v64> uv64;\\ntypedef unordered_map<ll, ll> u64;\\ntypedef unordered_map<p64, ll> up64;\\ntypedef unordered_map<ll, vp64> uvp64;\\ntypedef priority_queue<ll> pq64;\\ntypedef priority_queue<ll, v64, greater<ll>> pqs64;\\nconst int MOD = 1000000007;\\ndouble eps = 1e-12;\\n#define forn(i, n) for (ll i = 0; i < n; i++)\\n#define forsn(i, s, e) for (ll i = s; i < e; i++)\\n#define rforn(i, s) for (ll i = s; i >= 0; i--)\\n#define rforsn(i, s, e) for (ll i = s; i >= e; i--)\\nstruct custom_hash\\n{\\n    static uint64_t splitmix64(uint64_t x)\\n    {\\n        x += 0x9e3779b97f4a7c15;\\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\\n        return x ^ (x >> 31);\\n    }\\n\\n    size_t operator()(p64 x) const\\n    {\\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\\n        return splitmix64(x.first + FIXED_RANDOM) ^ splitmix64(x.second + FIXED_RANDOM);\\n    }\\n    size_t operator()(ll x) const\\n    {\\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\\n        return splitmix64(x + FIXED_RANDOM);\\n    }\\n};\\ntypedef gp_hash_table<ll, ll, custom_hash> fm64;\\ntypedef gp_hash_table<p64, ll, custom_hash> fmp64;\\n\\n#define ln \"\\\\n\"\\n#define mp make_pair\\n#define ie insert\\n#define pb push_back\\n#define fi first\\n#define se second\\n#define INF 2e18\\n#define fast_cin()                    \\\\\\n    ios_base::sync_with_stdio(false); \\\\\\n    cin.tie(NULL);                    \\\\\\n    cout.tie(NULL)\\n#define all(x) (x).begin(), (x).end()\\n#define al(arr, n) arr, arr + n\\n#define sz(x) ((ll)(x).size())\\n#define dbg(a) cout << a << endl;\\n#define dbg2(a) cout << a << \\' \\';\\nusing ld = long double;\\nusing db = double;\\nusing str = string; // yay python!\\n// INPUT\\n#define tcT template <class T\\n#define tcTU tcT, class U\\n#define tcTUU tcT, class... U\\ntcT > void re(T &x)\\n{\\n    cin >> x;\\n}\\ntcTUU > void re(T &t, U &...u)\\n{\\n    re(t);\\n    re(u...);\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& edges) {\\n        map<p64,ll> hsh;\\n        hsh[{start[0],start[1]}]=1;\\n        hsh[{target[0],target[1]}]=2;\\n        vector<pair<ll,p64>> edge;\\n        edge.push_back({abs(start[0]-target[0])+abs(start[1]-target[1]),{1,2}});\\n        ll cc=2;\\n        for(auto t:edges)\\n        {\\n            int x1=t[0],y1=t[1];\\n            int x2=t[2],y2=t[3];\\n            int cost=t[4];\\n            if(hsh.count({x1,y1})==0)\\n            {\\n                cc++;\\n                hsh[{x1,y1}]=cc;\\n            }\\n            if(hsh.count({x2,y2})==0)\\n            {\\n                cc++;\\n                hsh[{x2,y2}]=cc;\\n            }\\n            // from 1 to x1,y1\\n            int dist1=abs(start[0]-x1)+abs(start[1]-y1);\\n            int dist2=abs(target[0]-x2)+abs(target[1]-y2);\\n            edge.push_back({dist1,{1,hsh[{x1,y1}]}});\\n            edge.push_back({dist2,{hsh[{x2,y2}],2}});\\n        }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int node1=hsh[{edges[i][0],edges[i][1]}];\\n            int node2=hsh[{edges[i][2],edges[i][3]}];\\n            int cost1=edges[i][4];            \\n            edge.push_back({cost1,{node1,node2}});\\n            for(int j=0;j<edges.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n\\n                    int node3=hsh[{edges[j][0],edges[j][1]}];\\n                    int node4=hsh[{edges[j][2],edges[j][3]}];\\n                    \\n                    int cost2=edges[j][4];\\n                    // node 2 se 3\\n                    int cost=abs(edges[i][2]-edges[j][0])+abs(edges[i][3]-edges[j][1]);\\n                    edge.push_back({cost,{node2,node3}});\\n                    // node 2 se 4\\n                    cost=abs(edges[i][2]-edges[j][2])+abs(edges[i][3]-edges[j][3]);\\n                    edge.push_back({cost,{node2,node4}});\\n                    // node 1 se 3\\n                    cost=abs(edges[i][0]-edges[j][0])+abs(edges[i][1]-edges[j][1]);\\n                    edge.push_back({cost,{node1,node3}});\\n                    // node 1 se 4\\n                    cost=abs(edges[i][0]-edges[j][2])+abs(edges[i][1]-edges[j][3]);\\n                    edge.push_back({cost,{node1,node4}});\\n                }\\n            }\\n        }\\n        uvp64 adj;\\n        u64 dist;\\n        for(auto t:edge)\\n        {\\n            int x=t.second.first;\\n            int y=t.second.second;\\n            int cost=t.first;\\n            adj[x].pb({y,cost});\\n            dist[x]=INF;\\n            dist[y]=INF;\\n        }\\n        set<pair<ll, ll>> st;\\n        dist[1] = 0;\\n        st.insert({0, 1});\\n        while (st.size())\\n        {\\n            pair<ll, ll> p = *st.begin();\\n            st.erase(st.begin());\\n            ll wt = p.first;\\n            ll u = p.second;\\n            for (auto t : adj[u])\\n            {\\n                pair<ll, ll> q = t;\\n                ll v = q.first;\\n                ll x = q.second;\\n                if (dist[v] > dist[u] + x)\\n                {\\n                    if (st.find({dist[v], v}) != st.end())\\n                        st.erase({dist[v], v});\\n                    dist[v] = dist[u] + x;\\n                    st.insert({dist[v], v});\\n                }\\n            }\\n        }\\n        return dist[2];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468565,
                "title": "clean-java",
                "content": "Instead of bfs go layer by layer, we convert road to edge and only go with edges.\\nso\\n1. start -> edge[0]\\n2. edge[0] -> edge[1]\\n3. self edge[1] -> other edge[0];\\n4. edge[1] -> target\\n```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int maxRow = Math.max(start[0], target[0]);\\n        int maxCol = Math.max(start[1], target[1]);\\n        int res = getDistance(start[0], start[1], target[0], target[1]);\\n        int N = maxCol + 1;\\n        \\n        Map<Integer, Integer> distance = new HashMap<>();\\n        Map<Integer, List<int[]>> edges = new HashMap<>();\\n        for (int[] bridge : specialRoads) {\\n            int key = bridge[0] * N + bridge[1];  //selfEdge[0] -> selfEdge[1] \\n            edges.putIfAbsent(key, new ArrayList<>());\\n            edges.get(key).add(new int[]{bridge[2], bridge[3], bridge[4]});\\n        }\\n        for (int[] road: specialRoads) {\\n            int key = start[0] * N + start[1]; //start -> edge\\n            edges.putIfAbsent(key, new ArrayList<>());\\n            edges.get(key).add(new int[]{road[0], road[1], getDistance(start[0], start[1], road[0], road[1])}); //<end0, end1, cost>\\n        }\\n        for (int[] from: specialRoads) {\\n            int key = from[2] * N + from[3];   //edge -> target\\n            edges.putIfAbsent(key, new ArrayList<>());\\n            edges.get(key).add(new int[]{target[0], target[1], getDistance(from[2], from[3], target[0], target[1])});\\n            for (int[] to : specialRoads) {\\n                edges.get(key).add(new int[]{to[0], to[1], getDistance(from[2], from[3], to[0], to[1])}); //edge -> otherEdge\\n            }\\n        }\\n        \\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        q.offer(new int[]{start[0], start[1], 0});\\n        distance.put(start[0] * N + start[1], 0);\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            if (cur[0] == target[0] && cur[1] == target[1]) {\\n                return Math.min(res, cur[2]);\\n            }\\n            int key = cur[0] * N + cur[1];\\n            if (edges.containsKey(key)) {\\n                for (int[] data : edges.get(key)) {\\n                    int x = data[0];\\n                    int y = data[1];\\n                    int cost = cur[2] + data[2];\\n                    int nk = x * N + y;\\n                    if (!distance.containsKey(nk) || cost < distance.get(nk)) {\\n                        q.offer(new int[]{x, y, cost});\\n                        distance.put(nk, cost);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int getDistance(int x1, int y1, int x2, int y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        int maxRow = Math.max(start[0], target[0]);\\n        int maxCol = Math.max(start[1], target[1]);\\n        int res = getDistance(start[0], start[1], target[0], target[1]);\\n        int N = maxCol + 1;\\n        \\n        Map<Integer, Integer> distance = new HashMap<>();\\n        Map<Integer, List<int[]>> edges = new HashMap<>();\\n        for (int[] bridge : specialRoads) {\\n            int key = bridge[0] * N + bridge[1];  //selfEdge[0] -> selfEdge[1] \\n            edges.putIfAbsent(key, new ArrayList<>());\\n            edges.get(key).add(new int[]{bridge[2], bridge[3], bridge[4]});\\n        }\\n        for (int[] road: specialRoads) {\\n            int key = start[0] * N + start[1]; //start -> edge\\n            edges.putIfAbsent(key, new ArrayList<>());\\n            edges.get(key).add(new int[]{road[0], road[1], getDistance(start[0], start[1], road[0], road[1])}); //<end0, end1, cost>\\n        }\\n        for (int[] from: specialRoads) {\\n            int key = from[2] * N + from[3];   //edge -> target\\n            edges.putIfAbsent(key, new ArrayList<>());\\n            edges.get(key).add(new int[]{target[0], target[1], getDistance(from[2], from[3], target[0], target[1])});\\n            for (int[] to : specialRoads) {\\n                edges.get(key).add(new int[]{to[0], to[1], getDistance(from[2], from[3], to[0], to[1])}); //edge -> otherEdge\\n            }\\n        }\\n        \\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        q.offer(new int[]{start[0], start[1], 0});\\n        distance.put(start[0] * N + start[1], 0);\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            if (cur[0] == target[0] && cur[1] == target[1]) {\\n                return Math.min(res, cur[2]);\\n            }\\n            int key = cur[0] * N + cur[1];\\n            if (edges.containsKey(key)) {\\n                for (int[] data : edges.get(key)) {\\n                    int x = data[0];\\n                    int y = data[1];\\n                    int cost = cur[2] + data[2];\\n                    int nk = x * N + y;\\n                    if (!distance.containsKey(nk) || cost < distance.get(nk)) {\\n                        q.offer(new int[]{x, y, cost});\\n                        distance.put(nk, cost);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int getDistance(int x1, int y1, int x2, int y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468539,
                "title": "beats-100-java-shortest-path",
                "content": "# Intuition\\nPath to special Roads and Path to Target. These will be the entry in the Priority Queue. We can also start with looking adjacent cordinates with a dist as 1. But reaching via special roads will be less if we move by 1 dist at a time. SO this gives me an idea to elimiate them and directly use special path.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nO(m) to build the Map for look up of special path // lets say m special paths\\nO(m + mlog(m)) \\n\\n\\n- Space complexity:\\nO(m * k) k is the length of the shortest path\\n# Code\\n```\\nclass Solution {\\n     int r []= {0,-1,1,0};\\n    int c []= {1,0,0,-1};\\n    class P {\\n        int x;\\n        int y;\\n        int cost;\\n\\n        @Override\\n        public String toString() {\\n            return x + \" &&& \" + y +  \" &&& \" +cost;\\n        }\\n    }\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        \\n\\n        int res = Integer.MAX_VALUE;\\n        PriorityQueue<P> pq = new PriorityQueue<>(new Comparator<P>() {\\n\\n            @Override\\n            public int compare(P a, P b) {\\n                return a.cost - b.cost; // min heap and 0 element is the cost and 1 and 2  is the index.\\n            }\\n        });\\n\\n        Map<String,  List<int[]>> special = new HashMap<>();\\n        for(int [] s : specialRoads) {\\n            String hj = s[0] + \"##\" + s[1];\\n          \\n            if(special.containsKey(hj)) {\\n                special.get(hj).add( new int[] {s[2],s[3], s[4]});\\n            } else {\\n                List<int[]> l = new ArrayList<>();\\n                l.add( new int[] {s[2],s[3], s[4]});\\n                special.put(hj, l);\\n            }\\n\\n            \\n        }\\n        P st = new P();\\n        st.x = start[0];\\n        st.y = start[1];\\n        st.cost = 0;\\n        pq.add(st);\\n        Set<String> visisted = new HashSet<>();\\n        \\n\\n        while(pq.size() > 0) {\\n\\n            P p1 = pq.poll();\\n           \\n            if(p1.x == target[0] && p1.y == target[1]) {\\n                return p1.cost;\\n            }\\n\\n             String gh = p1.x + \"##\" + p1.y;\\n             if(visisted.contains(gh)) continue;\\n             visisted.add(gh);\\n\\n\\n            for(Map.Entry<String,  List<int[]>> entry : special.entrySet()) {\\n                int d = Math.abs(p1.x - Integer.valueOf(entry.getKey().split(\"##\")[0])) + \\n                Math.abs(p1.y - Integer.valueOf(entry.getKey().split(\"##\")[1]));\\n                 for(int[] cos :  entry.getValue()) {\\n                     P p = new P();\\n                     p.x = cos[0];\\n                     p.y = cos[1];\\n                     p.cost = d + cos[2] + p1.cost;\\n                    pq.add(p);\\n                   \\n                 }\\n               \\n               \\n            }\\n\\n                 P p2 = new P();\\n                p2.x = target[0];\\n                p2.y = target[1];\\n                p2.cost = Math.abs(target[0] - p1.x) + Math.abs(target[1] -p1.y) + p1.cost;\\n                pq.add(p2);\\n\\n          \\n\\n            \\n\\n\\n\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     int r []= {0,-1,1,0};\\n    int c []= {1,0,0,-1};\\n    class P {\\n        int x;\\n        int y;\\n        int cost;\\n\\n        @Override\\n        public String toString() {\\n            return x + \" &&& \" + y +  \" &&& \" +cost;\\n        }\\n    }\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        \\n\\n        int res = Integer.MAX_VALUE;\\n        PriorityQueue<P> pq = new PriorityQueue<>(new Comparator<P>() {\\n\\n            @Override\\n            public int compare(P a, P b) {\\n                return a.cost - b.cost; // min heap and 0 element is the cost and 1 and 2  is the index.\\n            }\\n        });\\n\\n        Map<String,  List<int[]>> special = new HashMap<>();\\n        for(int [] s : specialRoads) {\\n            String hj = s[0] + \"##\" + s[1];\\n          \\n            if(special.containsKey(hj)) {\\n                special.get(hj).add( new int[] {s[2],s[3], s[4]});\\n            } else {\\n                List<int[]> l = new ArrayList<>();\\n                l.add( new int[] {s[2],s[3], s[4]});\\n                special.put(hj, l);\\n            }\\n\\n            \\n        }\\n        P st = new P();\\n        st.x = start[0];\\n        st.y = start[1];\\n        st.cost = 0;\\n        pq.add(st);\\n        Set<String> visisted = new HashSet<>();\\n        \\n\\n        while(pq.size() > 0) {\\n\\n            P p1 = pq.poll();\\n           \\n            if(p1.x == target[0] && p1.y == target[1]) {\\n                return p1.cost;\\n            }\\n\\n             String gh = p1.x + \"##\" + p1.y;\\n             if(visisted.contains(gh)) continue;\\n             visisted.add(gh);\\n\\n\\n            for(Map.Entry<String,  List<int[]>> entry : special.entrySet()) {\\n                int d = Math.abs(p1.x - Integer.valueOf(entry.getKey().split(\"##\")[0])) + \\n                Math.abs(p1.y - Integer.valueOf(entry.getKey().split(\"##\")[1]));\\n                 for(int[] cos :  entry.getValue()) {\\n                     P p = new P();\\n                     p.x = cos[0];\\n                     p.y = cos[1];\\n                     p.cost = d + cos[2] + p1.cost;\\n                    pq.add(p);\\n                   \\n                 }\\n               \\n               \\n            }\\n\\n                 P p2 = new P();\\n                p2.x = target[0];\\n                p2.y = target[1];\\n                p2.cost = Math.abs(target[0] - p1.x) + Math.abs(target[1] -p1.y) + p1.cost;\\n                pq.add(p2);\\n\\n          \\n\\n            \\n\\n\\n\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468520,
                "title": "python3-djikstra-easy-to-read-solution-with-comments-explanation",
                "content": "# Intuition\\nThere are a few key points to note:\\n\\n- Special roads may not be the optimal path between two coordinates. We should filter out these bad special roads before consuming them in our algorithm.\\n- The cost from (1, 1) => (2, 2) => (3, 3) is the same as the cost from (1, 1) => (3, 3). We should consider routes between coordinates directly when possible.\\n\\nTo solve this problem, we can create a graph where each vertex is a coordinate, and edges are cost between coordinates. We will run Djikstra\\'s on this graph from start => end and return minimum cost.\\n\\nThe vertex we will add are:\\n- Start, end coordinates given as input\\n- Start / end coordinates of filtered special roads\\n\\nWe don\\'t need to add any intermediate points because like we discussed in point #2 above, we can directly go to another coordinate using the distance metric with the same cost as using another intermediate coordinate.\\n\\n# Complexity\\n- Time complexity: O(V^2)\\n\\nDjikstra\\'s is VlogV, but we compute compute costs for each pair of coordinates which is V^2\\n\\n- Space complexity: O(V^2)\\nMaintain costs for each pair of coordinates\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom typing import Tuple\\nimport heapq\\nimport math\\n\\ndef compute_dist(start: Tuple[int], end: Tuple[int]) -> int:\\n    \"\"\"Computes distance given two coordinates.\"\"\"\\n    return abs(end[0] - start[0]) + abs(end[1] - start[1])\\n\\ndef build_graph(start_coord: Tuple[int], target_coord: Tuple[int], filtered_roads):\\n    # { start_coord : { end_coord : dist } }\\n    # Only add edges where coord is bottom left relative to next.\\n    graph = defaultdict(lambda: defaultdict(int))\\n    all_coords = set([start_coord, target_coord])\\n    for road in filtered_roads:\\n        all_coords.add(road[0])\\n        all_coords.add(road[1])\\n        graph[road[0]][road[1]] = road[2]\\n\\n    # Build edge from each pairs of coordinates.\\n    all_coords = list(all_coords)\\n    for idx in range(len(all_coords)):\\n        for jdx in range(len(all_coords)):\\n            if idx == jdx:\\n                continue\\n            start_coord = all_coords[idx]\\n            end_coord = all_coords[jdx]\\n            # Ignore if special road exists, which we know is less than normal distance.\\n            if end_coord not in graph[start_coord]:\\n                graph[start_coord][end_coord] = compute_dist(start_coord, end_coord)\\n    return graph\\n\\n    \\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        # Remove all roads where distance is not less than normal distance.\\n        filtered_roads = []\\n        for road in specialRoads:\\n            road_start = (road[0], road[1])\\n            road_end = (road[2], road[3])\\n            curr_dist = compute_dist(road_start, road_end)\\n            if road[4] < curr_dist:\\n                filtered_roads.append((road_start, road_end, road[4]))\\n        \\n        # Build graph of all relevant nodes.\\n        start_coord = (start[0], start[1])\\n        target_coord = (target[0], target[1])\\n        if start_coord == target_coord:\\n            return 0\\n        graph = build_graph(start_coord, target_coord, filtered_roads)\\n        \\n        # Run Djikstra\\'s given graph.\\n        pq = [(0, start_coord)]\\n        visited = set()\\n        heapq.heapify(pq)\\n        while len(pq) > 0:\\n            dist, coord = heapq.heappop(pq)\\n            if coord in visited:\\n                continue\\n            if target_coord == coord:\\n                return dist\\n            visited.add(coord)\\n            for next_coord in graph[coord]:\\n                next_dist = graph[coord][next_coord] + dist\\n                heapq.heappush(pq, (next_dist, next_coord))\\n        return -1\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import Tuple\\nimport heapq\\nimport math\\n\\ndef compute_dist(start: Tuple[int], end: Tuple[int]) -> int:\\n    \"\"\"Computes distance given two coordinates.\"\"\"\\n    return abs(end[0] - start[0]) + abs(end[1] - start[1])\\n\\ndef build_graph(start_coord: Tuple[int], target_coord: Tuple[int], filtered_roads):\\n    # { start_coord : { end_coord : dist } }\\n    # Only add edges where coord is bottom left relative to next.\\n    graph = defaultdict(lambda: defaultdict(int))\\n    all_coords = set([start_coord, target_coord])\\n    for road in filtered_roads:\\n        all_coords.add(road[0])\\n        all_coords.add(road[1])\\n        graph[road[0]][road[1]] = road[2]\\n\\n    # Build edge from each pairs of coordinates.\\n    all_coords = list(all_coords)\\n    for idx in range(len(all_coords)):\\n        for jdx in range(len(all_coords)):\\n            if idx == jdx:\\n                continue\\n            start_coord = all_coords[idx]\\n            end_coord = all_coords[jdx]\\n            # Ignore if special road exists, which we know is less than normal distance.\\n            if end_coord not in graph[start_coord]:\\n                graph[start_coord][end_coord] = compute_dist(start_coord, end_coord)\\n    return graph\\n\\n    \\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        # Remove all roads where distance is not less than normal distance.\\n        filtered_roads = []\\n        for road in specialRoads:\\n            road_start = (road[0], road[1])\\n            road_end = (road[2], road[3])\\n            curr_dist = compute_dist(road_start, road_end)\\n            if road[4] < curr_dist:\\n                filtered_roads.append((road_start, road_end, road[4]))\\n        \\n        # Build graph of all relevant nodes.\\n        start_coord = (start[0], start[1])\\n        target_coord = (target[0], target[1])\\n        if start_coord == target_coord:\\n            return 0\\n        graph = build_graph(start_coord, target_coord, filtered_roads)\\n        \\n        # Run Djikstra\\'s given graph.\\n        pq = [(0, start_coord)]\\n        visited = set()\\n        heapq.heapify(pq)\\n        while len(pq) > 0:\\n            dist, coord = heapq.heappop(pq)\\n            if coord in visited:\\n                continue\\n            if target_coord == coord:\\n                return dist\\n            visited.add(coord)\\n            for next_coord in graph[coord]:\\n                next_dist = graph[coord][next_coord] + dist\\n                heapq.heappush(pq, (next_dist, next_coord))\\n        return -1\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468515,
                "title": "java-floyd-solution",
                "content": "# Intuition\\nThere are only 200 spefic roads, so the maimum number of point is 402. Build a graph (402 x 402) which indicates that from i to j. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minimumCost(int[] start, int[] target, int[][] roads) {\\n        int roadLen = pickTheBest(roads);\\n        Arrays.sort(roads, 0, roadLen, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        List<String> list = new ArrayList<>();\\n        HashMap<String, Integer> map = new HashMap<>();\\n\\n        int cnt = buildMap(list, map, start, target, roads, roadLen);\\n        int[][] graph = new int[cnt][cnt];\\n        String fromIndex;\\n        String toIndex;\\n        for(int i = 0; i < cnt; i ++){\\n            for(int j = 0; j < cnt; j ++){\\n                String[] from = list.get(i).split(\"_\");\\n                int x1 = Integer.valueOf(from[0]);\\n                int y1 = Integer.valueOf(from[1]);\\n                String[] to = list.get(j).split(\"_\");\\n                int x2 = Integer.valueOf(to[0]);\\n                int y2 = Integer.valueOf(to[1]);\\n                graph[i][j] = distance(x1, y1, x2, y2);\\n            }\\n        }\\n        for(int i = 0; i < roadLen; i ++){\\n            fromIndex = roads[i][0] + \"_\" + roads[i][1];\\n            toIndex = roads[i][2] + \"_\" + roads[i][3];\\n            int fromi = map.get(fromIndex);\\n            int toi = map.get(toIndex);\\n            graph[fromi][toi] = Math.min(graph[fromi][toi], roads[i][4]);\\n        }\\n        \\n        for(int i = 0; i < cnt; i ++){\\n            for(int from = 0; from < cnt; from ++){\\n                for(int to = 0; to < cnt; to ++){\\n                    graph[from][to] = Math.min(graph[from][to], graph[from][i] + graph[i][to]);\\n                }\\n            }\\n        }\\n        String startIndex = start[0] + \"_\" + start[1];\\n        int starti = map.get(startIndex);\\n        String targetIndex = target[0] + \"_\" + target[1];\\n        int targeti = map.get(targetIndex);\\n        return graph[starti][targeti];\\n        \\n    }\\n\\n    public static int buildMap(List<String> list, HashMap<String, Integer> stringMap, int[] start, int[] target, int[][] road, int len) {\\n        int cnt = 0;\\n        String index;\\n        for (int i = 0; i < len; i++) {\\n            int[] cur = road[i];\\n            //add first node\\n            index = String.valueOf(cur[0]) + \"_\" + String.valueOf(cur[1]);\\n            if (!stringMap.containsKey(index)) {\\n                stringMap.put(index, cnt++);\\n                list.add(index);\\n            }\\n            // add second node\\n            index = String.valueOf(cur[2]) + \"_\" + String.valueOf(cur[3]);\\n            if (!stringMap.containsKey(index)) {\\n                list.add(index);\\n                stringMap.put(index, cnt++);\\n            }\\n        }\\n        index = String.valueOf(start[0]) + \"_\" + String.valueOf(start[1]);\\n        if (!stringMap.containsKey(index)) {\\n            stringMap.put(index, cnt++);\\n            list.add(index);\\n        }\\n        index = String.valueOf(target[0]) + \"_\" + String.valueOf(target[1]);\\n        if (!stringMap.containsKey(index)) {\\n            stringMap.put(index, cnt++);\\n            list.add(index);\\n        }\\n        return cnt;\\n    }\\n    public static int pickTheBest(int[][] roads) {\\n        int r = roads.length;\\n        for (int i = 0; i < r; i++) {\\n            int[] road = roads[i];\\n            int distance = distance(road[0], road[1], road[2], road[3]);\\n            if (distance > road[4]) {\\n                continue;\\n            } else {\\n                swap(roads, i, --r);\\n                i--;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public static void swap(int[][] roads, int l, int r) {\\n        int[] temp = roads[l];\\n        roads[l] = roads[r];\\n        roads[r] = temp;\\n    }\\n\\n    public static int distance(int x1, int y1, int x2, int y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minimumCost(int[] start, int[] target, int[][] roads) {\\n        int roadLen = pickTheBest(roads);\\n        Arrays.sort(roads, 0, roadLen, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        List<String> list = new ArrayList<>();\\n        HashMap<String, Integer> map = new HashMap<>();\\n\\n        int cnt = buildMap(list, map, start, target, roads, roadLen);\\n        int[][] graph = new int[cnt][cnt];\\n        String fromIndex;\\n        String toIndex;\\n        for(int i = 0; i < cnt; i ++){\\n            for(int j = 0; j < cnt; j ++){\\n                String[] from = list.get(i).split(\"_\");\\n                int x1 = Integer.valueOf(from[0]);\\n                int y1 = Integer.valueOf(from[1]);\\n                String[] to = list.get(j).split(\"_\");\\n                int x2 = Integer.valueOf(to[0]);\\n                int y2 = Integer.valueOf(to[1]);\\n                graph[i][j] = distance(x1, y1, x2, y2);\\n            }\\n        }\\n        for(int i = 0; i < roadLen; i ++){\\n            fromIndex = roads[i][0] + \"_\" + roads[i][1];\\n            toIndex = roads[i][2] + \"_\" + roads[i][3];\\n            int fromi = map.get(fromIndex);\\n            int toi = map.get(toIndex);\\n            graph[fromi][toi] = Math.min(graph[fromi][toi], roads[i][4]);\\n        }\\n        \\n        for(int i = 0; i < cnt; i ++){\\n            for(int from = 0; from < cnt; from ++){\\n                for(int to = 0; to < cnt; to ++){\\n                    graph[from][to] = Math.min(graph[from][to], graph[from][i] + graph[i][to]);\\n                }\\n            }\\n        }\\n        String startIndex = start[0] + \"_\" + start[1];\\n        int starti = map.get(startIndex);\\n        String targetIndex = target[0] + \"_\" + target[1];\\n        int targeti = map.get(targetIndex);\\n        return graph[starti][targeti];\\n        \\n    }\\n\\n    public static int buildMap(List<String> list, HashMap<String, Integer> stringMap, int[] start, int[] target, int[][] road, int len) {\\n        int cnt = 0;\\n        String index;\\n        for (int i = 0; i < len; i++) {\\n            int[] cur = road[i];\\n            //add first node\\n            index = String.valueOf(cur[0]) + \"_\" + String.valueOf(cur[1]);\\n            if (!stringMap.containsKey(index)) {\\n                stringMap.put(index, cnt++);\\n                list.add(index);\\n            }\\n            // add second node\\n            index = String.valueOf(cur[2]) + \"_\" + String.valueOf(cur[3]);\\n            if (!stringMap.containsKey(index)) {\\n                list.add(index);\\n                stringMap.put(index, cnt++);\\n            }\\n        }\\n        index = String.valueOf(start[0]) + \"_\" + String.valueOf(start[1]);\\n        if (!stringMap.containsKey(index)) {\\n            stringMap.put(index, cnt++);\\n            list.add(index);\\n        }\\n        index = String.valueOf(target[0]) + \"_\" + String.valueOf(target[1]);\\n        if (!stringMap.containsKey(index)) {\\n            stringMap.put(index, cnt++);\\n            list.add(index);\\n        }\\n        return cnt;\\n    }\\n    public static int pickTheBest(int[][] roads) {\\n        int r = roads.length;\\n        for (int i = 0; i < r; i++) {\\n            int[] road = roads[i];\\n            int distance = distance(road[0], road[1], road[2], road[3]);\\n            if (distance > road[4]) {\\n                continue;\\n            } else {\\n                swap(roads, i, --r);\\n                i--;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public static void swap(int[][] roads, int l, int r) {\\n        int[] temp = roads[l];\\n        roads[l] = roads[r];\\n        roads[r] = temp;\\n    }\\n\\n    public static int distance(int x1, int y1, int x2, int y2) {\\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468468,
                "title": "why-are-there-duplicate-special-roads-with-different-costs-in-test-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDijkstra.\\n\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        special = {}\\n        points = {tuple(start): 0, tuple(target): inf}\\n        for road in specialRoads:\\n            x1, y1, x2, y2, cost = road\\n            points[(x1, y1)] = inf\\n            points[(x2, y2)] = inf\\n            special[(x1, y1, x2, y2)] = min(special.get((x1,y1,x2,y2), inf), cost)\\n        all_points = points.keys()\\n        for point in all_points:\\n            for top in all_points:\\n                if top == point:\\n                    continue\\n                distance = abs(point[0] - top[0]) + abs(point[1] - top[1])\\n                combo1 = (point[0], point[1], top[0], top[1]) \\n                distance = min(distance, special.get(combo1, inf))\\n                adj[point].append((distance, top))\\n        queue = [(0, tuple(start))]\\n        points[tuple(start)] = 0\\n        while queue:\\n            dis, p = heapq.heappop(queue)\\n            for ed in adj[p]:\\n                cost, to = ed\\n                if dis + cost < points[to]:\\n                    points[to] = dis + cost\\n                    heapq.heappush(queue, (dis+cost, to))\\n        return points[tuple(target)]\\n      \\n        \\n                    \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        special = {}\\n        points = {tuple(start): 0, tuple(target): inf}\\n        for road in specialRoads:\\n            x1, y1, x2, y2, cost = road\\n            points[(x1, y1)] = inf\\n            points[(x2, y2)] = inf\\n            special[(x1, y1, x2, y2)] = min(special.get((x1,y1,x2,y2), inf), cost)\\n        all_points = points.keys()\\n        for point in all_points:\\n            for top in all_points:\\n                if top == point:\\n                    continue\\n                distance = abs(point[0] - top[0]) + abs(point[1] - top[1])\\n                combo1 = (point[0], point[1], top[0], top[1]) \\n                distance = min(distance, special.get(combo1, inf))\\n                adj[point].append((distance, top))\\n        queue = [(0, tuple(start))]\\n        points[tuple(start)] = 0\\n        while queue:\\n            dis, p = heapq.heappop(queue)\\n            for ed in adj[p]:\\n                cost, to = ed\\n                if dis + cost < points[to]:\\n                    points[to] = dis + cost\\n                    heapq.heappush(queue, (dis+cost, to))\\n        return points[tuple(target)]\\n      \\n        \\n                    \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468465,
                "title": "dijkstra-s-algorithm-with-a-subset-of-nodes",
                "content": "# Intuition\\nThis is a shortest path problem, so I instantly think Dijkstra.\\n\\nBut in this case, it\\'s a $$10^5$$ by $$10^5$$ grid.\\nThere are `10^(10)` possible nodes!\\n\\nBut we don\\'t have to think about all of the nodes, because we can quickly calculate the default distance between any two nodes. Think of this default path as an L-Shaped line.\\n\\nThe optimum solution will either travel from start to target via an L-shaped line, or it will take an L-shaped line to the start of a road, and then from the end of this road it will travel via an L-shaped line to either the target, or to the start of a different road.\\n\\nSo now we only need to focus on a subset of nodes: \\n\\n- The start\\n- The target node\\n- The beginning of each road\\n- The end of each road\\n\\nThere is a maximum of 200 roads, so this will mean a maximum of 402 nodes. That\\'s an easily managable size.\\n\\n# Approach\\nThis code identifies the relevant nodes and puts them into a table.\\n\\nIt then calculates the default distance between each node.\\n\\nIt then updates the table with each special road distance. (Taking into account that the road distance might be longer than not taking it, as question designers would introduce a useless road just to thwart us)\\n\\nNow that we have a populated table, we can implement Dijkstra\\'s shortest path algorithm.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(r^2)$$ where r is the number of roads\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(r^2)$$ where r is the number of roads\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: list[int], target: list[int], specialRoads: list[list[int]]) -> int:\\n\\n        # Identify the unique set of relevant nodes\\n        # and create a lookup table for them\\n        all_points = set()\\n        all_points.add((start[0], start[1]))\\n        all_points.add((target[0], target[1]))\\n        for s1,s2,t1,t2,dist in specialRoads:\\n            all_points.add((s1, s2))\\n            all_points.add((t1, t2))\\n        point_to_index = dict()\\n        all_points = list(all_points)\\n        for i,p in enumerate(all_points):\\n            point_to_index[p] = i\\n        \\n        # Now generate a table of distances between each node\\n        # using the default distance formula\\n        from_to = [[None] * len(all_points) for _ in all_points]\\n        for i in range(len(all_points)):\\n            pi = all_points[i]\\n            for j in range(len(all_points)):\\n                pj = all_points[j]\\n                dist = abs(pi[0] - pj[0]) + abs(pi[1] - pj[1])\\n                from_to[i][j] = dist\\n\\n        # Apply the special roads to this table\\n        for s1,s2,t1,t2,dist in specialRoads:\\n            iFrom = point_to_index[s1,s2]\\n            iTo = point_to_index[t1,t2]\\n            from_to[iFrom][iTo] = min(from_to[iFrom][iTo], dist)\\n\\n        # Implement dijkstra\\'s algorithm\\n        start_index = point_to_index[tuple(start)]\\n        target_index = point_to_index[tuple(target)]\\n        distances = from_to[start_index][:]\\n        visited = set()\\n        while(True):\\n            closest_unvisited_distance, closest_unvisited_index = min([\\n              (distance, i)\\n                    for i,distance in enumerate(distances) \\n                    if i not in visited\\n            ])\\n            if closest_unvisited_index == target_index:\\n                return closest_unvisited_distance\\n            for i,d in enumerate(from_to[closest_unvisited_index]):\\n                distance_from_start = closest_unvisited_distance + d\\n                distances[i] = min(distances[i], distance_from_start)\\n            visited.add(closest_unvisited_index)\\n\\n        return  # Should never get here\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: list[int], target: list[int], specialRoads: list[list[int]]) -> int:\\n\\n        # Identify the unique set of relevant nodes\\n        # and create a lookup table for them\\n        all_points = set()\\n        all_points.add((start[0], start[1]))\\n        all_points.add((target[0], target[1]))\\n        for s1,s2,t1,t2,dist in specialRoads:\\n            all_points.add((s1, s2))\\n            all_points.add((t1, t2))\\n        point_to_index = dict()\\n        all_points = list(all_points)\\n        for i,p in enumerate(all_points):\\n            point_to_index[p] = i\\n        \\n        # Now generate a table of distances between each node\\n        # using the default distance formula\\n        from_to = [[None] * len(all_points) for _ in all_points]\\n        for i in range(len(all_points)):\\n            pi = all_points[i]\\n            for j in range(len(all_points)):\\n                pj = all_points[j]\\n                dist = abs(pi[0] - pj[0]) + abs(pi[1] - pj[1])\\n                from_to[i][j] = dist\\n\\n        # Apply the special roads to this table\\n        for s1,s2,t1,t2,dist in specialRoads:\\n            iFrom = point_to_index[s1,s2]\\n            iTo = point_to_index[t1,t2]\\n            from_to[iFrom][iTo] = min(from_to[iFrom][iTo], dist)\\n\\n        # Implement dijkstra\\'s algorithm\\n        start_index = point_to_index[tuple(start)]\\n        target_index = point_to_index[tuple(target)]\\n        distances = from_to[start_index][:]\\n        visited = set()\\n        while(True):\\n            closest_unvisited_distance, closest_unvisited_index = min([\\n              (distance, i)\\n                    for i,distance in enumerate(distances) \\n                    if i not in visited\\n            ])\\n            if closest_unvisited_index == target_index:\\n                return closest_unvisited_distance\\n            for i,d in enumerate(from_to[closest_unvisited_index]):\\n                distance_from_start = closest_unvisited_distance + d\\n                distances[i] = min(distances[i], distance_from_start)\\n            visited.add(closest_unvisited_index)\\n\\n        return  # Should never get here\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468437,
                "title": "python-3-bfs-solution",
                "content": "\\n# Intuition\\nI interpreted this as a BFS approach. I think I might of dervied dijiskra while working on this. \\n\\nYou have your starting location. \\n\\nYou can calculate to the end location or the possible roads. If you have been to a road previously at a cheaper cost there is no point in visiting the road.\\n\\n\\nTime: O(n^2)\\nSpace: O(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        seen = dict()\\n        paths = [(start[0],start[1],0)]\\n        end = tuple(target)\\n        seen[end] = abs(target[0]-start[0]) + abs(target[1]-start[1])\\n\\n        while paths:\\n            next_paths = []\\n            for x0,y0,cur_cost in paths:\\n                for x1,y1,x2,y2,road_cost in specialRoads:\\n                    cost_to_end_of_road = abs(y1-y0) + abs(x1-x0) + road_cost + cur_cost\\n                    if (x2,y2) not in seen:\\n                        seen[(x2,y2)] = cost_to_end_of_road\\n                        next_paths.append([x2,y2,cost_to_end_of_road])\\n\\n                    if seen[(x2,y2)] > cost_to_end_of_road:\\n                        seen[(x2,y2)] = cost_to_end_of_road\\n                        next_paths.append([x2,y2,cost_to_end_of_road])\\n                    cost_to_end = abs(target[0]-x2) + abs(target[1]-y2) + cost_to_end_of_road\\n                    if cost_to_end < seen[end]:\\n                        seen[end] = cost_to_end\\n            paths=next_paths\\n        return seen[end]\\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        seen = dict()\\n        paths = [(start[0],start[1],0)]\\n        end = tuple(target)\\n        seen[end] = abs(target[0]-start[0]) + abs(target[1]-start[1])\\n\\n        while paths:\\n            next_paths = []\\n            for x0,y0,cur_cost in paths:\\n                for x1,y1,x2,y2,road_cost in specialRoads:\\n                    cost_to_end_of_road = abs(y1-y0) + abs(x1-x0) + road_cost + cur_cost\\n                    if (x2,y2) not in seen:\\n                        seen[(x2,y2)] = cost_to_end_of_road\\n                        next_paths.append([x2,y2,cost_to_end_of_road])\\n\\n                    if seen[(x2,y2)] > cost_to_end_of_road:\\n                        seen[(x2,y2)] = cost_to_end_of_road\\n                        next_paths.append([x2,y2,cost_to_end_of_road])\\n                    cost_to_end = abs(target[0]-x2) + abs(target[1]-y2) + cost_to_end_of_road\\n                    if cost_to_end < seen[end]:\\n                        seen[end] = cost_to_end\\n            paths=next_paths\\n        return seen[end]\\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468432,
                "title": "python-dijkstra",
                "content": "# Intuition\\n\\nwithout using any special roads:\\n`res = calCost(start[0], start[1], target[0], target[1])` at least\\n\\nfor each special roads, we can use it or skip it.\\n\\nI don\\'t know which strategy is better, so I use BFS to traverse them all, and seems that **Dijkstra** is a nice way to use. (no negative cost)\\n\\nonce we use it, we store destination in `visited` hashset because if we reach same position again, its cost must be higher.\\n\\nand we check cost from every position after using special roads to target, choose minimum cost amoung them.\\n\\nactually, I just think every position as a node in graph and they all have special roads as their directed edges\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        def calCost(x1, y1, x2, y2):\\n            return abs(x1-x2) + abs(y1-y2)\\n\\n        res = calCost(start[0], start[1], target[0], target[1])\\n        pq = [(0, start)]\\n        visited = set()\\n        while pq:\\n            cost, (x,y) = heapq.heappop(pq)\\n            if (x,y) in visited: continue\\n            visited.add((x,y))\\n            res = min(res, cost + calCost(x, y, target[0], target[1]))\\n\\n            for x1, y1, x2, y2, c in specialRoads:\\n                heapq.heappush(pq, (cost+calCost(x1, y1, x, y)+c, (x2,y2)))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        def calCost(x1, y1, x2, y2):\\n            return abs(x1-x2) + abs(y1-y2)\\n\\n        res = calCost(start[0], start[1], target[0], target[1])\\n        pq = [(0, start)]\\n        visited = set()\\n        while pq:\\n            cost, (x,y) = heapq.heappop(pq)\\n            if (x,y) in visited: continue\\n            visited.add((x,y))\\n            res = min(res, cost + calCost(x, y, target[0], target[1]))\\n\\n            for x1, y1, x2, y2, c in specialRoads:\\n                heapq.heappush(pq, (cost+calCost(x1, y1, x, y)+c, (x2,y2)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468361,
                "title": "full-explanation-build-a-graph-from-roads-use-dijkstra-to-find-shortest-path",
                "content": "# Intuition\\n\\nI didn\\'t like the problem as the intuition was reasonablly straight forward, but it was hard to implement it (at least for me)\\n\\n------\\n\\nThere is no need to look at all possible ways to go from start to finish. You need to construct a graph which consists of the following types of edges:\\n\\n - from Start to End\\n - from Start to beginning of the road\\n - from end of the road to End\\n - road itself\\n\\nThen additional roads which connects each pair of roads:\\n - road_i end to road_j start\\n - road_j end to road_i start\\n\\nThis graph construction was the hardest to do correctly.\\n\\nAfter you have the graph, just do the Dijkstra.\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n- Space complexity: $O(n^2)$\\n\\n# Code\\n```\\nclass Solution:\\n\\n  def build_graph(self, s, e, roads):\\n    G = defaultdict(list)\\n    G[\\'S\\'] = [(\\'E\\', abs(s[0] - e[0]) + abs(s[1] - e[1]))]\\n    for i, (x1, y1, x2, y2, c) in enumerate(roads):\\n      r_s, r_e = f\\'Rs_{i}\\', f\\'Re_{i}\\'\\n      G[\\'S\\'].append((r_s, abs(s[0] - x1) + abs(s[1] - y1)))\\n      G[r_e].append((\\'E\\', abs(e[0] - x2) + abs(e[1] - y2)))\\n      G[r_s].append((r_e, c))\\n\\n    for i in range(len(roads)):\\n      xi1, yi1, xi2, yi2, _ = roads[i]\\n      for j in range(len(roads)):\\n        if i == j: continue\\n        xj1, yj1, xj2, yj2, _ = roads[j]\\n\\n        G[f\\'Re_{i}\\'].append((f\\'Rs_{j}\\', abs(xi2 - xj1) + abs(yi2 - yj1)))\\n        G[f\\'Re_{j}\\'].append((f\\'Rs_{i}\\', abs(xi1 - xj2) + abs(yi1 - yj2)))\\n\\n    return G\\n\\n  def min_path(self, G):\\n    all_distances = {}\\n    for k, v in G.items():\\n      all_distances[k] = float(\\'inf\\')\\n      for el, _ in v:\\n        all_distances[el] = float(\\'inf\\')\\n    all_distances[\\'S\\'] = 0\\n\\n    frontier = [(0, \\'S\\')]\\n\\n    while frontier:\\n      cost, node = heappop(frontier)\\n      for node_nxt, dist in G[node]:\\n        cost_to_move = cost + dist\\n        if all_distances[node_nxt] > cost_to_move:\\n          all_distances[node_nxt] = cost_to_move\\n          heappush(frontier, (cost_to_move, node_nxt))\\n    \\n    return all_distances[\\'E\\']\\n\\n\\n\\n\\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n    g = self.build_graph(start, target, specialRoads)\\n    return self.min_path(g)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n  def build_graph(self, s, e, roads):\\n    G = defaultdict(list)\\n    G[\\'S\\'] = [(\\'E\\', abs(s[0] - e[0]) + abs(s[1] - e[1]))]\\n    for i, (x1, y1, x2, y2, c) in enumerate(roads):\\n      r_s, r_e = f\\'Rs_{i}\\', f\\'Re_{i}\\'\\n      G[\\'S\\'].append((r_s, abs(s[0] - x1) + abs(s[1] - y1)))\\n      G[r_e].append((\\'E\\', abs(e[0] - x2) + abs(e[1] - y2)))\\n      G[r_s].append((r_e, c))\\n\\n    for i in range(len(roads)):\\n      xi1, yi1, xi2, yi2, _ = roads[i]\\n      for j in range(len(roads)):\\n        if i == j: continue\\n        xj1, yj1, xj2, yj2, _ = roads[j]\\n\\n        G[f\\'Re_{i}\\'].append((f\\'Rs_{j}\\', abs(xi2 - xj1) + abs(yi2 - yj1)))\\n        G[f\\'Re_{j}\\'].append((f\\'Rs_{i}\\', abs(xi1 - xj2) + abs(yi1 - yj2)))\\n\\n    return G\\n\\n  def min_path(self, G):\\n    all_distances = {}\\n    for k, v in G.items():\\n      all_distances[k] = float(\\'inf\\')\\n      for el, _ in v:\\n        all_distances[el] = float(\\'inf\\')\\n    all_distances[\\'S\\'] = 0\\n\\n    frontier = [(0, \\'S\\')]\\n\\n    while frontier:\\n      cost, node = heappop(frontier)\\n      for node_nxt, dist in G[node]:\\n        cost_to_move = cost + dist\\n        if all_distances[node_nxt] > cost_to_move:\\n          all_distances[node_nxt] = cost_to_move\\n          heappush(frontier, (cost_to_move, node_nxt))\\n    \\n    return all_distances[\\'E\\']\\n\\n\\n\\n\\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n    g = self.build_graph(start, target, specialRoads)\\n    return self.min_path(g)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468337,
                "title": "java-yet-another-dijkstra-problem",
                "content": "# Intuition\\nYet another Dijkstra problem. It seems Leetcode really likes Dijkstra.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        // ind 0 is start, ind 1 is target, others are specialRoads\\n        int[] distTo = new int[specialRoads.length + 2];\\n        Arrays.fill(distTo, Integer.MAX_VALUE);\\n        distTo[0] = 0;\\n\\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(i -> i[1]));\\n        queue.add(new int[] {0, 0});\\n\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            \\n            if (curr[0] == 1) {\\n                break;\\n            }\\n            \\n            int[] s = curr[0] == 0 ? start : (curr[0] == 1 ? target : specialRoads[curr[0] - 2]);\\n\\n            for (int next = 0; next < specialRoads.length + 2; next++) {\\n                if (curr[0] == next) {\\n                    continue;\\n                }\\n\\n                int[] t = next == 0 ? start : (next == 1 ? target : specialRoads[next - 2]);\\n\\n                int dist = Math.abs(s[0] - t[0]) + Math.abs(s[1] - t[1]);\\n                if (curr[0] >= 2) {\\n                    int[] road = specialRoads[curr[0] - 2];\\n                    dist = Math.min(dist, Math.abs(road[2] - t[0]) + Math.abs(road[3] - t[1]) + road[4]);\\n                }\\n\\n                if (distTo[next] > distTo[curr[0]] + dist && distTo[1] > distTo[curr[0]] + dist) {\\n                    distTo[next] = distTo[curr[0]] + dist;\\n                    queue.add(new int[] {next, distTo[next]});\\n                }\\n            }\\n        }\\n\\n        return distTo[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\\n        // ind 0 is start, ind 1 is target, others are specialRoads\\n        int[] distTo = new int[specialRoads.length + 2];\\n        Arrays.fill(distTo, Integer.MAX_VALUE);\\n        distTo[0] = 0;\\n\\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(i -> i[1]));\\n        queue.add(new int[] {0, 0});\\n\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            \\n            if (curr[0] == 1) {\\n                break;\\n            }\\n            \\n            int[] s = curr[0] == 0 ? start : (curr[0] == 1 ? target : specialRoads[curr[0] - 2]);\\n\\n            for (int next = 0; next < specialRoads.length + 2; next++) {\\n                if (curr[0] == next) {\\n                    continue;\\n                }\\n\\n                int[] t = next == 0 ? start : (next == 1 ? target : specialRoads[next - 2]);\\n\\n                int dist = Math.abs(s[0] - t[0]) + Math.abs(s[1] - t[1]);\\n                if (curr[0] >= 2) {\\n                    int[] road = specialRoads[curr[0] - 2];\\n                    dist = Math.min(dist, Math.abs(road[2] - t[0]) + Math.abs(road[3] - t[1]) + road[4]);\\n                }\\n\\n                if (distTo[next] > distTo[curr[0]] + dist && distTo[1] > distTo[curr[0]] + dist) {\\n                    distTo[next] = distTo[curr[0]] + dist;\\n                    queue.add(new int[] {next, distTo[next]});\\n                }\\n            }\\n        }\\n\\n        return distTo[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468317,
                "title": "dijakstra",
                "content": "# Intuition\\nIdea is to treat all the points described in the edges plus the starting and ending points as nodes. Then we\\'ll just run dijakstra on this graph to get the cheapest cost. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        set<pair<int, int>> nodes;\\n        nodes.insert({start[0], start[1]});\\n        nodes.insert({target[0], target[1]});\\n        for (auto el: specialRoads) {\\n            nodes.insert({el[0], el[1]});\\n            nodes.insert({el[2], el[3]});\\n        }\\n        \\n        //reverse-index to go from coordinates of a node to its index\\n        map<pair<int, int>, int> rev;\\n        \\n        vector<pair<int, int>> vnodes;\\n        int ind = 0;\\n        for (auto el: nodes) {\\n            vnodes.push_back(el);\\n            rev[el] = ind;\\n            ind++;\\n        }\\n        \\n        int n = vnodes.size();\\n        int adj[n][n]; //cost to go from node i to node j\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                adj[i][j] = abs(vnodes[i].first - vnodes[j].first) + abs(vnodes[i].second - vnodes[j].second);\\n            }\\n        }\\n        \\n        //Use the edges to update the cheapest costs\\n        for (auto k: specialRoads) {\\n            int i = rev[{k[0], k[1]}];\\n            int j = rev[{k[2], k[3]}];\\n            \\n            adj[i][j] = min(adj[i][j], k[4]);\\n        }\\n        \\n        priority_queue<pair<int, pair<int, int>>> pq;\\n        pq.push({0, {start[0], start[1]}});\\n        \\n        \\n        bool used[n];\\n        for (int i = 0; i < n; i++) {\\n            used[i] = false;\\n        }\\n        \\n        //Run Dijakstra\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n            \\n            cur.first *= -1;\\n            \\n            if (cur.second.first == target[0] && cur.second.second == target[1]) {\\n                return cur.first;\\n            }\\n            \\n            int cind = rev[cur.second];\\n            if (used[cind]) {\\n                continue;\\n            }\\n            \\n            used[cind] = true;\\n            \\n            for (int i = 0; i < n; i++) {\\n                if (used[i]) {\\n                    continue;\\n                }\\n                \\n                int nc = -1*(cur.first + adj[cind][i]);\\n                pq.push({nc, {vnodes[i].first, vnodes[i].second}});\\n            }\\n        }\\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        set<pair<int, int>> nodes;\\n        nodes.insert({start[0], start[1]});\\n        nodes.insert({target[0], target[1]});\\n        for (auto el: specialRoads) {\\n            nodes.insert({el[0], el[1]});\\n            nodes.insert({el[2], el[3]});\\n        }\\n        \\n        //reverse-index to go from coordinates of a node to its index\\n        map<pair<int, int>, int> rev;\\n        \\n        vector<pair<int, int>> vnodes;\\n        int ind = 0;\\n        for (auto el: nodes) {\\n            vnodes.push_back(el);\\n            rev[el] = ind;\\n            ind++;\\n        }\\n        \\n        int n = vnodes.size();\\n        int adj[n][n]; //cost to go from node i to node j\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                adj[i][j] = abs(vnodes[i].first - vnodes[j].first) + abs(vnodes[i].second - vnodes[j].second);\\n            }\\n        }\\n        \\n        //Use the edges to update the cheapest costs\\n        for (auto k: specialRoads) {\\n            int i = rev[{k[0], k[1]}];\\n            int j = rev[{k[2], k[3]}];\\n            \\n            adj[i][j] = min(adj[i][j], k[4]);\\n        }\\n        \\n        priority_queue<pair<int, pair<int, int>>> pq;\\n        pq.push({0, {start[0], start[1]}});\\n        \\n        \\n        bool used[n];\\n        for (int i = 0; i < n; i++) {\\n            used[i] = false;\\n        }\\n        \\n        //Run Dijakstra\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n            \\n            cur.first *= -1;\\n            \\n            if (cur.second.first == target[0] && cur.second.second == target[1]) {\\n                return cur.first;\\n            }\\n            \\n            int cind = rev[cur.second];\\n            if (used[cind]) {\\n                continue;\\n            }\\n            \\n            used[cind] = true;\\n            \\n            for (int i = 0; i < n; i++) {\\n                if (used[i]) {\\n                    continue;\\n                }\\n                \\n                int nc = -1*(cur.first + adj[cind][i]);\\n                pq.push({nc, {vnodes[i].first, vnodes[i].second}});\\n            }\\n        }\\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468304,
                "title": "using-queue",
                "content": "\\nUpvote if you like \\uD83D\\uDE42;\\n# Python\\n```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        graph=collections.defaultdict(list)\\n        for i,j,u,v,k in specialRoads:\\n            graph[(i,j)].append((k,u,v))\\n        visited=set()\\n        q=[(0,start[0],start[1])]\\n        if start==target:return 0\\n        total=0\\n        while q:\\n            val,i,j=heapq.heappop(q)\\n            # print(val,i,j)\\n            if (i,j) in visited:continue\\n            visited.add((i,j))\\n            if [i,j]==target:return val\\n            if (i,j) in graph:\\n                for k,u,v in graph[(i,j)]:\\n                    if (u,v) in visited:continue\\n                    heapq.heappush(q,(k+val,u,v))\\n            for (u,v) in graph:\\n                if (u,v) in visited:continue\\n                heapq.heappush(q,(abs(i-u)+abs(v-j)+val,u,v))\\n            heapq.heappush(q,(abs(target[0]-i)+abs(target[1]-j)+val,target[0],target[1]))\\n        return -1\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\\n        graph=collections.defaultdict(list)\\n        for i,j,u,v,k in specialRoads:\\n            graph[(i,j)].append((k,u,v))\\n        visited=set()\\n        q=[(0,start[0],start[1])]\\n        if start==target:return 0\\n        total=0\\n        while q:\\n            val,i,j=heapq.heappop(q)\\n            # print(val,i,j)\\n            if (i,j) in visited:continue\\n            visited.add((i,j))\\n            if [i,j]==target:return val\\n            if (i,j) in graph:\\n                for k,u,v in graph[(i,j)]:\\n                    if (u,v) in visited:continue\\n                    heapq.heappush(q,(k+val,u,v))\\n            for (u,v) in graph:\\n                if (u,v) in visited:continue\\n                heapq.heappush(q,(abs(i-u)+abs(v-j)+val,u,v))\\n            heapq.heappush(q,(abs(target[0]-i)+abs(target[1]-j)+val,target[0],target[1]))\\n        return -1\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468302,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinimumCost(int[] start, int[] target, int[][] specialRoads)\\n    {\\n        var n = specialRoads.Length;\\n        var graph = new List<(int, int)>[2 * n + 2];\\n\\n        for (var i = 0; i < 2 * n + 2; i++)\\n            graph[i] = new List<(int, int)>();\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            graph[0].Add((i + 1, Math.Abs(specialRoads[i][0] - start[0]) + Math.Abs(specialRoads[i][1] - start[1])));\\n            graph[i + 1].Add((n + i + 1, specialRoads[i][4]));\\n            graph[n + i + 1].Add((2 * n + 1, Math.Abs(specialRoads[i][2] - target[0]) + Math.Abs(specialRoads[i][3] - target[1])));\\n\\n            for (var j = 0; j < n; j++)\\n                if (i != j)\\n                    graph[n + i + 1].Add((j + 1,\\n                        Math.Abs(specialRoads[i][2] - specialRoads[j][0]) +\\n                        Math.Abs(specialRoads[i][3] - specialRoads[j][1])));\\n        }\\n\\n        var dist = new int[2 * n + 2];\\n        Array.Fill(dist, int.MaxValue);\\n        dist[0] = 0;\\n        var visited = new bool[2 * n + 2];\\n\\n        for (var i = 0; i < 2 * n + 2; i++)\\n        {\\n            var u = -1;\\n\\n            for (var j = 0; j < 2 * n + 2; j++)\\n                if (!visited[j] && (u == -1 || dist[j] < dist[u]))\\n                    u = j;\\n\\n            visited[u] = true;\\n\\n            foreach (var (v, w) in graph[u])\\n                if (dist[u] + w < dist[v])\\n                    dist[v] = dist[u] + w;\\n        }\\n\\n        return Math.Min(dist[2 * n + 1], Math.Abs(target[0] - start[0]) + Math.Abs(target[1] - start[1]));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumCost(int[] start, int[] target, int[][] specialRoads)\\n    {\\n        var n = specialRoads.Length;\\n        var graph = new List<(int, int)>[2 * n + 2];\\n\\n        for (var i = 0; i < 2 * n + 2; i++)\\n            graph[i] = new List<(int, int)>();\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            graph[0].Add((i + 1, Math.Abs(specialRoads[i][0] - start[0]) + Math.Abs(specialRoads[i][1] - start[1])));\\n            graph[i + 1].Add((n + i + 1, specialRoads[i][4]));\\n            graph[n + i + 1].Add((2 * n + 1, Math.Abs(specialRoads[i][2] - target[0]) + Math.Abs(specialRoads[i][3] - target[1])));\\n\\n            for (var j = 0; j < n; j++)\\n                if (i != j)\\n                    graph[n + i + 1].Add((j + 1,\\n                        Math.Abs(specialRoads[i][2] - specialRoads[j][0]) +\\n                        Math.Abs(specialRoads[i][3] - specialRoads[j][1])));\\n        }\\n\\n        var dist = new int[2 * n + 2];\\n        Array.Fill(dist, int.MaxValue);\\n        dist[0] = 0;\\n        var visited = new bool[2 * n + 2];\\n\\n        for (var i = 0; i < 2 * n + 2; i++)\\n        {\\n            var u = -1;\\n\\n            for (var j = 0; j < 2 * n + 2; j++)\\n                if (!visited[j] && (u == -1 || dist[j] < dist[u]))\\n                    u = j;\\n\\n            visited[u] = true;\\n\\n            foreach (var (v, w) in graph[u])\\n                if (dist[u] + w < dist[v])\\n                    dist[v] = dist[u] + w;\\n        }\\n\\n        return Math.Min(dist[2 * n + 1], Math.Abs(target[0] - start[0]) + Math.Abs(target[1] - start[1]));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468301,
                "title": "dijkstras-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        // use dijkstras algorithm\\n        int sx = start[0], sy = start[1];\\n        int tx = target[0], ty = target[1];\\n        \\n        using ll = long long;\\n        using pipii = pair<ll,pair<int,int>>;\\n        priority_queue<pipii,vector<pipii>,greater<pipii>> pq;\\n        \\n        ll INF = 1e12;\\n        \\n        map<pair<int,int>,ll> distance;\\n        \\n        auto dist = [&](int x, int y) {\\n            if(not distance.count({x, y})) distance[{x,y}] = INF;\\n            return distance[{x,y}];\\n        };\\n        \\n        pq.push({0, {sx, sy}});\\n        distance[{sx, sy}] = 0;\\n        \\n        while(not pq.empty()) {\\n            ll d = pq.top().first;\\n            \\n            auto [cx, cy] = pq.top().second;\\n            \\n            pq.pop();\\n            \\n            if(cx == tx and cy == ty) return d;\\n            \\n            // directly go to target\\n            ll direct = d + abs(cx-tx) + abs(cy-ty);\\n            \\n            pq.push({direct, {tx, ty}});\\n            \\n            \\n            // take some road\\n            for(vector<int>& road : specialRoads) {\\n                int fromx = road[0], fromy = road[1];\\n                int tox  = road[2], toy = road[3];\\n                ll cost = road[4];\\n                \\n                ll val = d + cost + abs(cx-fromx) + abs(cy-fromy);\\n                    \\n                if(dist(tox, toy) > val) {\\n                    distance[{tox, toy}] = val;\\n                    pq.push({val, {tox, toy}});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {\\n        // use dijkstras algorithm\\n        int sx = start[0], sy = start[1];\\n        int tx = target[0], ty = target[1];\\n        \\n        using ll = long long;\\n        using pipii = pair<ll,pair<int,int>>;\\n        priority_queue<pipii,vector<pipii>,greater<pipii>> pq;\\n        \\n        ll INF = 1e12;\\n        \\n        map<pair<int,int>,ll> distance;\\n        \\n        auto dist = [&](int x, int y) {\\n            if(not distance.count({x, y})) distance[{x,y}] = INF;\\n            return distance[{x,y}];\\n        };\\n        \\n        pq.push({0, {sx, sy}});\\n        distance[{sx, sy}] = 0;\\n        \\n        while(not pq.empty()) {\\n            ll d = pq.top().first;\\n            \\n            auto [cx, cy] = pq.top().second;\\n            \\n            pq.pop();\\n            \\n            if(cx == tx and cy == ty) return d;\\n            \\n            // directly go to target\\n            ll direct = d + abs(cx-tx) + abs(cy-ty);\\n            \\n            pq.push({direct, {tx, ty}});\\n            \\n            \\n            // take some road\\n            for(vector<int>& road : specialRoads) {\\n                int fromx = road[0], fromy = road[1];\\n                int tox  = road[2], toy = road[3];\\n                ll cost = road[4];\\n                \\n                ll val = d + cost + abs(cx-fromx) + abs(cy-fromy);\\n                    \\n                if(dist(tox, toy) > val) {\\n                    distance[{tox, toy}] = val;\\n                    pq.push({val, {tox, toy}});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1879346,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1877853,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1880179,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1912345,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1878288,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1877959,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1877833,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1877733,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1980911,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1911890,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1879346,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1877853,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1880179,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1912345,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1878288,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1877959,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1877833,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1877733,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1980911,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            },
            {
                "id": 1911890,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "> ...the `ith` special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal to `costi`.\\n\\nNote that this statement does not say that the road can also take you from `(x2i, y2i)` to `(x1i, y1i)`, indicating that it is a one-way road. Tricky wording considering I\\'ve seen plenty of one-way streets but never a one-way road. I\\'m sure one exists somewhere though and it\\'s good practice to look out for such subtleties."
                    },
                    {
                        "username": "twinshu",
                        "content": "One of the best grid question have ever seen!"
                    },
                    {
                        "username": "sylvex",
                        "content": "how this is a grid question??"
                    },
                    {
                        "username": "Balwierz",
                        "content": "It doesn\\'t explicitly say if the roads are bidirectional or unidirectional."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "noob noob go away .. come again another day (me singing for myself :-)"
                    },
                    {
                        "username": "Mycotina",
                        "content": "While the solution arguably straightforward, but the implementation is tricky. Spend lots of time fixing minor bugs :("
                    },
                    {
                        "username": "sylvex",
                        "content": "One of the most painful moment in my life.\\nsimple BFS with pruning in my implementation, cannot pass the last testcase.\\n![pain](https://cdn.discordapp.com/attachments/958846513268793394/1102132280257945641/image.png)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "just use min heap \\n"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Because it is not a BFS problem. It is a Dijkstra problem"
                    },
                    {
                        "username": "vikas58616",
                        "content": "can we solve this problem using knapsack dp ? if not then why ?\\nbecause an optical path consist of [0.....n] roads and for each road we have option to to either pick this road  or leave this road. \\nI strongly feel that this could be a possible solution but failed to pass test cases \\ncould anyone know how to solve this using knapsack"
                    },
                    {
                        "username": "bparanj",
                        "content": "This falls into the category of pathfinding in a weighted graph, where the objective is to find the shortest path from a start point to a target point. The special roads essentially add weighted edges between points in the 2D space.\\n\\nThe Knapsack problem, on the other hand, is a combinatorial optimization problem where the objective is to maximize the total value of items chosen subject to a total weight limit. In a Knapsack problem, the choice of one item doesn\\'t affect the availability or cost of choosing another item, other than reducing the total weight limit available.\\n\\nWhile there might be some similarity in the sense that in both problems we\\'re making a series of decisions (whether to use a special road or pick an item in the Knapsack problem), the nature of these decisions is quite different.\\n\\nOne key difference is that the Knapsack problem assumes that choosing an item (or road, in your analogy) doesn\\'t affect the cost or benefit of choosing any other item, whereas in the pathfinding problem, the cost of reaching a point very much depends on which other points (or roads) we\\'ve passed through to get there.\\n\\nAlso, the pathfinding problem assumes that we need to reach a specific destination, and going through a longer route might actually increase the total cost, unlike the Knapsack problem where more items (up to the weight limit) are always better.\\n\\nInstead of trying to solve this problem as a knapsack problem, you might want to look at pathfinding algorithms such as Dijkstra\\'s or A*. These algorithms are designed to handle this kind of problem and can accommodate the use of special roads with different costs. In the graph that these algorithms would traverse, each position in the 2D space is a node, each move from one position to another is an edge, and the cost of moving along an edge is given by the problem (with special roads providing alternative, possibly cheaper edges)."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "For each knapsack, you need to determine the order of roads, so not a o(n) or o(1) evaluation per knapsack "
                    },
                    {
                        "username": "arijit__12",
                        "content": "I tried this but faild can u please provide ur solution?"
                    },
                    {
                        "username": "Mek_san",
                        "content": "It is giving TLE :) \\njust sort special road in increasing order by starting points before applying knapsack."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "there is nothing more frustrating than to pass 1038/1040 testcases and getting a wrong answer on the last few huge testcases.\\nI still have no idea why my algo doesn\\'t work cause those cases are impossible to analyze"
                    },
                    {
                        "username": "shunhsu",
                        "content": "Maybe path cost of start point to end point have multiple value, i.e. where specialRoads[i] = [x1i, y1i, x2i, y2i, costi], only \"costi\" are different."
                    },
                    {
                        "username": "f20190909",
                        "content": "For TestCase:\\nStart: [1,1] Target: [10,4] \\nspecialRoads=[[4,2,1,1,3],[1,2,7,4,4],[10,3,6,1,2],[6,1,1,2,3]]\\n(1,1) -> (1,2)  (1) (man)\\n(1,2) -> (6,1)  (3) (spl)\\n(6,1) -> (10,3) (2) (spl)\\n(10,3) -> (10,4) (1) (man)\\nAnswer should be 7 Right, but the system is expecting 8"
                    },
                    {
                        "username": "toyash",
                        "content": "[@toyash](/toyash) I think the reason was that I was treating the graph to be undirected graph, we need to treat it as directed graph."
                    },
                    {
                        "username": "toyash",
                        "content": "Exactly, I got stuck on the same testcase and the current status is 634 / 1045 test cases passed. Am I missing something in this testcase?"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "this is a really good question"
                    }
                ]
            }
        ]
    }
]