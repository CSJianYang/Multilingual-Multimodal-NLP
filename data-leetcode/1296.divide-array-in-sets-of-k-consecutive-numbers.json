[
    {
        "title": "Construct Binary Tree from Preorder and Postorder Traversal",
        "question_content": "Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and postorder is the postorder traversal of the same tree, reconstruct and return the binary tree.\nIf there exist multiple answers, you can return any of them.\n&nbsp;\nExample 1:\n\nInput: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\nOutput: [1,2,3,4,5,6,7]\n\nExample 2:\n\nInput: preorder = [1], postorder = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\t1 <= preorder.length <= 30\n\t1 <= preorder[i] <= preorder.length\n\tAll the values of preorder are unique.\n\tpostorder.length == preorder.length\n\t1 <= postorder[i] <= postorder.length\n\tAll the values of postorder are unique.\n\tIt is guaranteed that preorder and postorder are the preorder traversal and postorder traversal of the same binary tree.",
        "solutions": [
            {
                "id": 161268,
                "title": "c-java-python-one-pass-real-o-n",
                "content": "## **Foreword**\\nI saw some solutions saying `O(N)` time, but actually they are not.\\nIf it takes already `O(N)` time to find left part and right part, it could not be `O(N)`.\\n<br>\\n\\n## **Complexity**:\\nTime `O(N)`, as we iterate both pre index and post index only once.\\nSpace `O(height)`, depending on the height of constructed tree.\\n<br>\\n\\n## **Recursive Solution**\\nCreate a node `TreeNode(pre[preIndex])` as the root.\\n\\nBecasue root node will be lastly iterated in post order,\\n`if root.val == post[posIndex]`,\\nit means we have constructed the whole tree,\\n\\nIf we haven\\'t completed constructed the whole tree,\\nSo we recursively `constructFromPrePost` for left sub tree and right sub tree.\\n\\nAnd finally, we\\'ll reach the `posIndex` that `root.val == post[posIndex]`.\\nWe increment `posIndex` and return our `root` node.\\n\\n**C++:**\\n```cpp\\n    int preIndex = 0, posIndex = 0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if (root->val != post[posIndex])\\n            root->left = constructFromPrePost(pre, post);\\n        if (root->val != post[posIndex])\\n            root->right = constructFromPrePost(pre, post);\\n        posIndex++;\\n        return root;\\n    }\\n```\\n\\n**Java:**\\ninspired by @duhber\\n```java\\n    int preIndex = 0, posIndex = 0;\\n    public TreeNode constructFromPrePost(int[]pre, int[]post) {\\n        TreeNode root = new TreeNode(pre[preIndex++]);\\n        if (root.val != post[posIndex])\\n            root.left = constructFromPrePost(pre, post);\\n        if (root.val != post[posIndex])\\n            root.right = constructFromPrePost(pre, post);\\n        posIndex++;\\n        return root;\\n    }\\n```\\n**Python:**\\n```py\\n    preIndex, posIndex = 0, 0\\n    def constructFromPrePost(self, pre, post):\\n        root = TreeNode(pre[self.preIndex])\\n        self.preIndex += 1\\n        if (root.val != post[self.posIndex]):\\n            root.left = self.constructFromPrePost(pre, post)\\n        if (root.val != post[self.posIndex]):\\n            root.right = self.constructFromPrePost(pre, post)\\n        self.posIndex += 1\\n        return root\\n```\\n<br>\\n\\n## **Iterative Solution**\\nWe will **preorder** generate TreeNodes, push them to `stack` and **postorder** pop them out.\\n1. Iterate on `pre` array and construct node one by one.\\n2. `stack` save the current path of tree.\\n3. `node = new TreeNode(pre[i])`, if not left child, add node to the left. otherwise add it to the right.\\n4. If we meet a same value in the pre and post, it means we complete the construction for current subtree. We pop it from `stack`.\\n\\n**C++:**\\n```cpp\\n    TreeNode* constructFromPrePost(vector<int> pre, vector<int> post) {\\n        vector<TreeNode*> s;\\n        s.push_back(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.size(); ++i) {\\n            TreeNode* node = new TreeNode(pre[i]);\\n            while (s.back()->val == post[j])\\n                s.pop_back(), j++;\\n            if (s.back()->left == NULL) s.back()->left = node;\\n            else s.back()->right = node;\\n            s.push_back(node);\\n        }\\n        return s[0];\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.offer(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.length; ++i) {\\n            TreeNode node = new TreeNode(pre[i]);\\n            while (s.getLast().val == post[j]) {\\n                s.pollLast(); j++;\\n            }\\n            if (s.getLast().left == null) s.getLast().left = node;\\n            else s.getLast().right = node;\\n            s.offer(node);\\n        }\\n        return s.getFirst();\\n    }\\n```\\n**Python:**\\n```py\\n    def constructFromPrePost(self, pre, post):\\n        stack = [TreeNode(pre[0])]\\n        j = 0\\n        for v in pre[1:]:\\n            node = TreeNode(v)\\n            while stack[-1].val == post[j]:\\n                stack.pop()\\n                j += 1\\n            if not stack[-1].left:\\n                stack[-1].left = node\\n            else:\\n                stack[-1].right = node\\n            stack.append(node)\\n        return stack[0]\\n```\\n<br>\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int preIndex = 0, posIndex = 0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if (root->val != post[posIndex])\\n            root->left = constructFromPrePost(pre, post);\\n        if (root->val != post[posIndex])\\n            root->right = constructFromPrePost(pre, post);\\n        posIndex++;\\n        return root;\\n    }\\n```\n```java\\n    int preIndex = 0, posIndex = 0;\\n    public TreeNode constructFromPrePost(int[]pre, int[]post) {\\n        TreeNode root = new TreeNode(pre[preIndex++]);\\n        if (root.val != post[posIndex])\\n            root.left = constructFromPrePost(pre, post);\\n        if (root.val != post[posIndex])\\n            root.right = constructFromPrePost(pre, post);\\n        posIndex++;\\n        return root;\\n    }\\n```\n```py\\n    preIndex, posIndex = 0, 0\\n    def constructFromPrePost(self, pre, post):\\n        root = TreeNode(pre[self.preIndex])\\n        self.preIndex += 1\\n        if (root.val != post[self.posIndex]):\\n            root.left = self.constructFromPrePost(pre, post)\\n        if (root.val != post[self.posIndex]):\\n            root.right = self.constructFromPrePost(pre, post)\\n        self.posIndex += 1\\n        return root\\n```\n```cpp\\n    TreeNode* constructFromPrePost(vector<int> pre, vector<int> post) {\\n        vector<TreeNode*> s;\\n        s.push_back(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.size(); ++i) {\\n            TreeNode* node = new TreeNode(pre[i]);\\n            while (s.back()->val == post[j])\\n                s.pop_back(), j++;\\n            if (s.back()->left == NULL) s.back()->left = node;\\n            else s.back()->right = node;\\n            s.push_back(node);\\n        }\\n        return s[0];\\n    }\\n```\n```java\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.offer(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.length; ++i) {\\n            TreeNode node = new TreeNode(pre[i]);\\n            while (s.getLast().val == post[j]) {\\n                s.pollLast(); j++;\\n            }\\n            if (s.getLast().left == null) s.getLast().left = node;\\n            else s.getLast().right = node;\\n            s.offer(node);\\n        }\\n        return s.getFirst();\\n    }\\n```\n```py\\n    def constructFromPrePost(self, pre, post):\\n        stack = [TreeNode(pre[0])]\\n        j = 0\\n        for v in pre[1:]:\\n            node = TreeNode(v)\\n            while stack[-1].val == post[j]:\\n                stack.pop()\\n                j += 1\\n            if not stack[-1].left:\\n                stack[-1].left = node\\n            else:\\n                stack[-1].right = node\\n            stack.append(node)\\n        return stack[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161372,
                "title": "java-python-divide-and-conquer-with-explanation",
                "content": "The problem is easier to solve if we decrease it into subproblems using **Divide and Conquer**.\\n```\\ne.g.   Given preorder : 1 2 4 5 3 6;     postorder: 4 5 2 6 3 1.\\nWe see it as preorder : 1 (2 4 5) (3 6); postorder: (4 5 2) (6 3) 1 [to be explained afterwards]\\nThat can be decreased to subproblems A, B, C: \\nA. preorder : 1; postorder: 1 =>\\n 1\\nB. preorder : (2 4 5); postorder: (4 5 2) => \\n   2\\n  / \\\\\\n 4   5\\nC. preorder : (3 6); postorder: (6 3) => \\n   3\\n  / \\n 6     or\\n   3\\n    \\\\\\n     6\\n* Then we conquer the subproblems => A.left = B; A.right = C;\\n   1\\n  / \\\\\\n 2   3\\n/ \\\\  /\\n4  5 6\\n```\\nIf we observe parameters in each recursion above:\\n```\\npreStart: 0, preEnd: 5, postStart: 0, postEnd: 5\\npreStart: 1, preEnd: 3, postStart: 0, postEnd: 2\\npreStart: 4, preEnd: 5, postStart: 3, postEnd: 4\\n```\\nFor the commented, `[to be explained afterwards]`, how do we decrease a problem?\\nThat is, 1 is root and 2 is its left child. Since 2 is the root of the left subtree, all elements in front of 2 in `post[]` must be in the left subtree also. \\nWe recursively follow the above approach.\\nPlease note that `pre[preStart + 1] may also be the root of the right subtree` if there is no left subtree at all in the orginal tree. Since we are asked to generate one possible original tree, I assume `pre[preStart + 1]` to be the left subtree root always.\\n\\n****\\n**Java**\\n```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return constructFromPrePost(pre, 0, pre.length - 1, post, 0, pre.length - 1);\\n    }\\n    \\n    private TreeNode constructFromPrePost(int[] pre, int preStart, int preEnd, int[] post, int postStart, int postEnd) {\\n        // Base cases.\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        if (preStart == preEnd) {\\n            return new TreeNode(pre[preStart]);\\n        }\\n        \\n        // Build root.\\n        TreeNode root = new TreeNode(pre[preStart]);\\n        \\n        // Locate left subtree.\\n        int leftSubRootInPre = preStart + 1; \\n        int leftSubRootInPost = findLeftSubRootInPost(pre[leftSubRootInPre], post, postStart, postEnd);\\n        int leftSubEndInPre = leftSubRootInPre + (leftSubRootInPost - postStart);\\n        \\n        // Divide.\\n        TreeNode leftSubRoot = constructFromPrePost(pre, leftSubRootInPre, leftSubEndInPre, \\n                                                    post, postStart, leftSubRootInPost);  \\n        TreeNode rightSubRoot = constructFromPrePost(pre, leftSubEndInPre + 1, preEnd, \\n                                                     post, leftSubRootInPost + 1, postEnd - 1);\\n        \\n        // Conquer.      \\n        root.left = leftSubRoot;\\n        root.right = rightSubRoot;\\n        \\n        return root;\\n    }\\n    \\n    private int findLeftSubRootInPost(int leftSubRootVal, int[] post, int postStart, int postEnd) {\\n        for (int i = postStart; i <= postEnd; i++) {\\n            if (post[i] == leftSubRootVal) {\\n                return i;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException();\\n    }\\n\\n```\\n**Python**\\n```\\n    def constructFromPrePost(self, pre, post):\\n        return self.constructFromPrePostRecurUtil(\\n            pre, 0, len(pre) - 1, post, 0, len(post) - 1)\\n        \\n    def constructFromPrePostRecurUtil(\\n            self, \\n            pre, \\n            preStart, \\n            preEnd, \\n            post, \\n            postStart, \\n            postEnd):\\n        # Base case.\\n        if (preStart > preEnd):\\n            return None\\n        if (preStart == preEnd):\\n            return TreeNode(pre[preStart])\\n        # Recursive case.\\n        root = TreeNode(pre[preStart])\\n        leftRootIndexInPre = preStart + 1\\n        leftRootIndexInPost = self.getIndexInPost(\\n            post, pre[leftRootIndexInPre])\\n        leftEndIndexInPre = leftRootIndexInPre + \\\\\\n            (leftRootIndexInPost - postStart)\\n        root.left = self.constructFromPrePostRecurUtil(\\n            pre, \\n            leftRootIndexInPre, \\n            leftEndIndexInPre, \\n            post, \\n            postStart, \\n            leftRootIndexInPost)\\n        root.right = self.constructFromPrePostRecurUtil(\\n            pre, \\n            leftEndIndexInPre + 1, \\n            preEnd, \\n            post, \\n            leftRootIndexInPost + 1, \\n            postEnd - 1)\\n        return root\\n        \\n    def getIndexInPost(self, post, target):\\n        for i, v in enumerate(post):\\n            if v == target:\\n                return i\\n        return -1   # to optimize\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\ne.g.   Given preorder : 1 2 4 5 3 6;     postorder: 4 5 2 6 3 1.\\nWe see it as preorder : 1 (2 4 5) (3 6); postorder: (4 5 2) (6 3) 1 [to be explained afterwards]\\nThat can be decreased to subproblems A, B, C: \\nA. preorder : 1; postorder: 1 =>\\n 1\\nB. preorder : (2 4 5); postorder: (4 5 2) => \\n   2\\n  / \\\\\\n 4   5\\nC. preorder : (3 6); postorder: (6 3) => \\n   3\\n  / \\n 6     or\\n   3\\n    \\\\\\n     6\\n* Then we conquer the subproblems => A.left = B; A.right = C;\\n   1\\n  / \\\\\\n 2   3\\n/ \\\\  /\\n4  5 6\\n```\n```\\npreStart: 0, preEnd: 5, postStart: 0, postEnd: 5\\npreStart: 1, preEnd: 3, postStart: 0, postEnd: 2\\npreStart: 4, preEnd: 5, postStart: 3, postEnd: 4\\n```\n```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return constructFromPrePost(pre, 0, pre.length - 1, post, 0, pre.length - 1);\\n    }\\n    \\n    private TreeNode constructFromPrePost(int[] pre, int preStart, int preEnd, int[] post, int postStart, int postEnd) {\\n        // Base cases.\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        if (preStart == preEnd) {\\n            return new TreeNode(pre[preStart]);\\n        }\\n        \\n        // Build root.\\n        TreeNode root = new TreeNode(pre[preStart]);\\n        \\n        // Locate left subtree.\\n        int leftSubRootInPre = preStart + 1; \\n        int leftSubRootInPost = findLeftSubRootInPost(pre[leftSubRootInPre], post, postStart, postEnd);\\n        int leftSubEndInPre = leftSubRootInPre + (leftSubRootInPost - postStart);\\n        \\n        // Divide.\\n        TreeNode leftSubRoot = constructFromPrePost(pre, leftSubRootInPre, leftSubEndInPre, \\n                                                    post, postStart, leftSubRootInPost);  \\n        TreeNode rightSubRoot = constructFromPrePost(pre, leftSubEndInPre + 1, preEnd, \\n                                                     post, leftSubRootInPost + 1, postEnd - 1);\\n        \\n        // Conquer.      \\n        root.left = leftSubRoot;\\n        root.right = rightSubRoot;\\n        \\n        return root;\\n    }\\n    \\n    private int findLeftSubRootInPost(int leftSubRootVal, int[] post, int postStart, int postEnd) {\\n        for (int i = postStart; i <= postEnd; i++) {\\n            if (post[i] == leftSubRootVal) {\\n                return i;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException();\\n    }\\n\\n```\n```\\n    def constructFromPrePost(self, pre, post):\\n        return self.constructFromPrePostRecurUtil(\\n            pre, 0, len(pre) - 1, post, 0, len(post) - 1)\\n        \\n    def constructFromPrePostRecurUtil(\\n            self, \\n            pre, \\n            preStart, \\n            preEnd, \\n            post, \\n            postStart, \\n            postEnd):\\n        # Base case.\\n        if (preStart > preEnd):\\n            return None\\n        if (preStart == preEnd):\\n            return TreeNode(pre[preStart])\\n        # Recursive case.\\n        root = TreeNode(pre[preStart])\\n        leftRootIndexInPre = preStart + 1\\n        leftRootIndexInPost = self.getIndexInPost(\\n            post, pre[leftRootIndexInPre])\\n        leftEndIndexInPre = leftRootIndexInPre + \\\\\\n            (leftRootIndexInPost - postStart)\\n        root.left = self.constructFromPrePostRecurUtil(\\n            pre, \\n            leftRootIndexInPre, \\n            leftEndIndexInPre, \\n            post, \\n            postStart, \\n            leftRootIndexInPost)\\n        root.right = self.constructFromPrePostRecurUtil(\\n            pre, \\n            leftEndIndexInPre + 1, \\n            preEnd, \\n            post, \\n            leftRootIndexInPost + 1, \\n            postEnd - 1)\\n        return root\\n        \\n    def getIndexInPost(self, post, target):\\n        for i, v in enumerate(post):\\n            if v == target:\\n                return i\\n        return -1   # to optimize\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161286,
                "title": "c-o-n-recursive-solution",
                "content": "For two subarrays `pre[a,b]` and `post[c,d]`, if we want to reconstruct a tree from them, we know that pre[a]==post[d] is the root node.\\n\\n```\\n[root][......left......][...right..]  ---pre\\n[......left......][...right..][root]  ---post\\n```\\n\\n`pre[a+1]` is the root node of the left subtree.\\nFind the index of `pre[a+1]` in `post`, then we know the left subtree should be constructed from `pre[a+1, a+idx-c+1]` and `post[c, idx]`.\\n\\nHere is my code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; // value->index\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        int len = post.size();\\n        for (int i = 0; i < len; i++) m[post[i]] = i;\\n        return construct(pre, post, 0, len - 1, 0, len - 1);\\n    }\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int a, int b, int c, int d) {\\n        TreeNode* n = new TreeNode(pre[a]);\\n        if (a == b) return n;\\n        int t = pre[a + 1];\\n        int idx = m[t];\\n        int len = idx - c + 1;\\n        n->left = construct(pre, post, a + 1, a + len, c, c + len - 1);\\n        if (idx + 1 == d) return n;\\n        n->right = construct(pre, post, a + len + 1, b, idx + 1, d - 1);\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[root][......left......][...right..]  ---pre\\n[......left......][...right..][root]  ---post\\n```\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; // value->index\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        int len = post.size();\\n        for (int i = 0; i < len; i++) m[post[i]] = i;\\n        return construct(pre, post, 0, len - 1, 0, len - 1);\\n    }\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int a, int b, int c, int d) {\\n        TreeNode* n = new TreeNode(pre[a]);\\n        if (a == b) return n;\\n        int t = pre[a + 1];\\n        int idx = m[t];\\n        int len = idx - c + 1;\\n        n->left = construct(pre, post, a + 1, a + len, c, c + len - 1);\\n        if (idx + 1 == d) return n;\\n        n->right = construct(pre, post, a + len + 1, b, idx + 1, d - 1);\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748216,
                "title": "python3-solution-with-a-detailed-explanation-construct-binary-tree-from",
                "content": "Make sure you understand the preorder and postorder traversal and how the nodes are arranged in each, with respect to the other one. [This](https://www.***.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/) might help. I also find [this](https://www.***.org/full-and-complete-binary-tree-from-given-preorder-and-postorder-traversals/) explanation helpful. The solution that I\\'ll show below comes from reading different posts on leetcode and elsewhere. \\n\\nSome relations between the two orders include: 1) the first node of `pre` is root, same as the last node of `post`. 2) The second node of `pre` is left subtree root, while the second to the last node of `post` is the right subtree root. Now think for a moment about `post`. The last number is `root` value, if we do `post.pop()`, what is the last element now? The root of right subtree, right? What if we do that again? The last node now is the root of a deeper subtree on the right side again (`7`). \\n\\nCheck out this example! `pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]`. This can correspond to a tree like this (note that we can construct many trees given `pre` and `post`): \\n\\n\\t\\t\\t\\t\\t   1\\n\\t\\t\\t\\t2             3\\n\\t\\t\\t  4\\t 5           6  7\\n\\nThe node of right subtrees are `3`, and then `7`. If you check the `post`, you\\'ll see that they appear from right after `root`. We\\'ll use this in the solution. We do some prechecking to see whether tree is empty of not. If there has zero nodes, we return `None`. If there is one node, it\\'s root, we `return TreeNode(post.pop())`. Line `#3` adds the last element of `post` to the tree as the `root` of that level. Then, in line `#4`, it finds the  index in `pre` corresponding to the last element of `post` after popping (the `root` of right subtree in that level) because that element is the start of right subtree in `pre` (check the example). After we `pop` the root (`1`) from `post`, the root of right subtree is `3`. Now, in `pre`, anything before `3` corresponds to the left subtree with `2` being the root of it. \\n\\nNow comes the recursive part of solution. We split the `pre` into two parts, one for right subtree (line `#1`) and one for left subtree (line `#2`). We add them to `node.right` and `node.left`, respectively. Imaging you\\'re at the `root` level, in line `#3`, you add the root to `node`. Then, line `#1` after recursion produces the whole right subtree, and line `#2` produces the whole left subtree. Finally, `node` is returned which includes all the elements. Keep reading! \\n\\n\\t\\t\\t\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        # read this: https://www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\\n        def helper(pre,post):\\n            print(\\'pre is: \\', pre, \\'post is: \\', post)\\n            if not pre:\\n                return None\\n        \\n            if len(pre)==1:\\n                return TreeNode(post.pop())\\n        \\n        \\n            node=TreeNode(post.pop()) #3\\n            ind=pre.index(post[-1]) #4\\n        \\n            node.right=helper(pre[ind:],post) #1\\n            node.left=helper(pre[1:ind],post) #2\\n            return node\\n    \\n        return helper(pre,post)\\n```\\n\\nIf you print `pre` and `post` everytime the `helper` function is called, you get something like this: \\n\\t\\t\\t\\n```\\npre is:  [1, 2, 4, 5, 3, 6, 7] post is:  [4, 5, 2, 6, 7, 3, 1] # initial\\npre is:  [3, 6, 7] post is:  [4, 5, 2, 6, 7, 3] # right subtree depth 1 (right side of root) \\npre is:  [7] post is:  [4, 5, 2, 6, 7] #  right subtree depth 2 (right side of root)\\npre is:  [6] post is:  [4, 5, 2, 6] # line 2 is called for left subtree of level 2 (right side of root)\\npre is:  [2, 4, 5] post is:  [4, 5, 2] # line 2 is called for level one left subtree (left side of root)\\npre is:  [5] post is:  [4, 5] # line 1 is called for right subtree of level 2 (left side of root)\\npre is:  [4] post is:  [4] # line 2 is called for left subtree of level 2 (left side of root)\\n```\\n\\nThe `pre` and `post` here show each of the traversals once `helper` is called. For example, at first row, initial `pre` and `post` are shown. Next row, is when `helper` is called in line `#1`. Now, we have a new `pre` and `post`. The `pre` is the one that gets splited in each calling of `helper` while `post` pops its last element every time `helper` is called. As you can see, `post` looses one element at a time. \\n\\nI hope it\\'s clear. Let me know if there is any ambiquity anywhere. \\n\\n========================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix them. \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        # read this: https://www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\\n        def helper(pre,post):\\n            print(\\'pre is: \\', pre, \\'post is: \\', post)\\n            if not pre:\\n                return None\\n        \\n            if len(pre)==1:\\n                return TreeNode(post.pop())\\n        \\n        \\n            node=TreeNode(post.pop()) #3\\n            ind=pre.index(post[-1]) #4\\n        \\n            node.right=helper(pre[ind:],post) #1\\n            node.left=helper(pre[1:ind],post) #2\\n            return node\\n    \\n        return helper(pre,post)\\n```\n```\\npre is:  [1, 2, 4, 5, 3, 6, 7] post is:  [4, 5, 2, 6, 7, 3, 1] # initial\\npre is:  [3, 6, 7] post is:  [4, 5, 2, 6, 7, 3] # right subtree depth 1 (right side of root) \\npre is:  [7] post is:  [4, 5, 2, 6, 7] #  right subtree depth 2 (right side of root)\\npre is:  [6] post is:  [4, 5, 2, 6] # line 2 is called for left subtree of level 2 (right side of root)\\npre is:  [2, 4, 5] post is:  [4, 5, 2] # line 2 is called for level one left subtree (left side of root)\\npre is:  [5] post is:  [4, 5] # line 1 is called for right subtree of level 2 (left side of root)\\npre is:  [4] post is:  [4] # line 2 is called for left subtree of level 2 (left side of root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161651,
                "title": "easy-python-recursive-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre, post):\\n        if not pre or not post: return None\\n        root = TreeNode(pre[0])\\n        if len(post) == 1: return root\\n        idx = pre.index(post[-2])\\n        root.left = self.constructFromPrePost(pre[1: idx], post[:(idx - 1)])\\n        root.right = self.constructFromPrePost(pre[idx: ], post[(idx - 1):-1])\\n        return root\\n```\\n\\nThe first element in \"pre\" and the last element in \"post\" should both be the value of the root. The second to last of \"post\" should be the value of right child of the root. So we can find the index to split \"left\" and \"right\" children in \"pre\". Don\\'t forget to evaluate if the length of \"post\" is larger than 1, since we used post[-2]. ",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre, post):\\n        if not pre or not post: return None\\n        root = TreeNode(pre[0])\\n        if len(post) == 1: return root\\n        idx = pre.index(post[-2])\\n        root.left = self.constructFromPrePost(pre[1: idx], post[:(idx - 1)])\\n        root.right = self.constructFromPrePost(pre[idx: ], post[(idx - 1):-1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161281,
                "title": "clean-java-o-n",
                "content": "The key point is 1: preprocessing. 2: Find the correct index\\n\\n\\tclass Solution {\\n    Map<Integer, Integer> postMap = new HashMap<>();\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int length = pre.length;\\n        for(int i = 0; i < post.length; i++) {\\n            postMap.put(post[i], i);\\n        }\\n        \\n        return build(0, length - 1, 0, length - 1, pre, post);\\n    }\\n    \\n    private TreeNode build(int preLeft, int preRight, int postLeft, int postRight, int[] pre, int[] post) {\\n        if(preLeft > preRight || postLeft > postRight) {\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(pre[preLeft]);\\n        \\n        if(preLeft + 1 <= preRight) {\\n            int index = postMap.get(pre[preLeft + 1]);\\n            int sum = index - postLeft;\\n            root.left = build(preLeft + 1, preLeft + sum + 1, postLeft, postLeft + sum, pre, post);\\n            root.right = build(preLeft + sum + 2, preRight, postLeft + sum + 1, postRight - 1, pre, post);\\n        }\\n\\n        return root;\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, Integer> postMap = new HashMap<>();\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int length = pre.length;\\n        for(int i = 0; i < post.length; i++) {\\n            postMap.put(post[i], i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 821268,
                "title": "c-construct-tree-using-preorder-traversal-first",
                "content": "August 30, 2020\\n889. Construct Binary Tree from Preorder and Postorder Traversal\\n**Introduction**\\nI like to learn all ideas to solve this tree algorithm. I came cross this idea from the discussion post [here](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/161268/C%2B%2BJavaPython-One-Pass-Real-O(N)).\\n\\nThe idea is to construct binary tree using preorder traversal list, so it is easy to figure out the order of nodes in preorder list is from root node to left child until last one without left child. And then it is time to set up a node as a right child. \\n\\n**Case study**\\nI like to draw the diagram to explain how to solve this question using given example in the problem statement. \\nInput: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\\nOutput: [1,2,3,4,5,6,7]\\n\\nI debugged the code and then figured out the idea. It is to construct binary tree using preorder list first, starting from root node, and then go left continuously until it is the node without left child. Actually it is the first node in postorder traveral. \\n\\nUsing the example, root node 1 -> left child - node 2 -> left child - node 4, argue that it is the node without left child, since value is the first node in postorder traversal, marking using a in the following diagram. Preorder traversal list is iterated from a to b to c, the third node is with value 4. Now need to increment postorder traversal list\\'s index. \\n\\n![image](https://assets.leetcode.com/users/images/31024d89-5b18-4b4b-9f96-a21c4c0e22c6_1598857372.1623378.png)\\n\\nOne important task is to argue that when pre[preIndex] == post[postIndex], for example, preIndex = 2, node with value 4 is leaf node, in other words, skip steps to add left and right child. \\n\\nI think that the idea is hard to figure out and I will come back later to see if I can learn better next time. \\nFollow up on August 31, 2020\\nThe first time the condition is true: pre[preIndex] == post[postIndex], \\nNo. 1, preIndex = 2, postIndex = 0, value is 4, so depth first search break out:\\n root.left  = runPreorder(pre, post);   \\n No. 2, preIndex = 3, postIndex = 1, value is 5, so depth first search break out:\\n root.right = runPreorder(pre, post).\\n \\n**Design concern**\\nI do think that it is easy to figure out that each time a node is visited in preorder list, the node is added to the binary tree, preIndex variable is incremented by one. And if pre[preIndex] == post[postIndex], then skip to add left or right child, increment postIndex by one. \\nAs long as preIndex and postIndex both have places to increment one, the design is completed. Do not overthink. \\n\\n**Follow up**\\n**Another case study**\\nBased on the previous test case binary tree, if node with value 5 and node with value 6 are removed, then there are two solutions.\\nInput: pre = [1,2,4,3,7], post = [4,2,7,3,1]\\nOutput: [1,2,3,4,7]\\nThere are two solutions I can come out so far. \\nFour solutions:\\noutput 1: [1, 2, 3, 4, null, null, 7]\\noutput 2: [1, 2, 3, 4, null, 7, null]\\n\\n![image](https://assets.leetcode.com/users/images/4fd7cbb8-b0cf-490a-b878-ab1d783f14ec_1599026142.568195.png)\\n\\nIn my approach, the solution given in my code is solution 2. Node with value 7 is the left child of node 3. \\n\\nSolution 2 is to assume that node with value 7 is the first node in left subtree; actually  there is another case, missing left subtree, value 7 is the first node in right subtree instead. \\n\\n\\n\\n**Time complexity**\\nIt should be O(N). \\n\\n**Advice**\\nTake some time to read this paper about the algorithm. [Here](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8845&rep=rep1&type=pdf) is the link. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace preorder_post_order\\n{\\n    public class TreeNode {\\n        public int val;\\n        public TreeNode left;\\n        public TreeNode right;\\n        public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n          this.val = val;\\n          this.left = left;\\n          this.right = right;\\n      }\\n    }\\n\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var node1 = new TreeNode(1);\\n            var node2 = new TreeNode(2);\\n            var node3 = new TreeNode(3);\\n            var node4 = new TreeNode(4);\\n            var node5 = new TreeNode(5);\\n            var node6 = new TreeNode(6);\\n            var node7 = new TreeNode(7);\\n\\n            node1.left = node2;\\n            node1.right = node3;\\n            node2.left = node4;\\n            node2.right = node5;\\n            node3.left = node6;\\n            node3.right = node7;\\n\\n            var root = ConstructFromPrePost(\\n                new int[]{1,2,4,5,3,6,7}, \\n                new int[]{4,5,2,6,7,3,1});\\n        }\\n\\n        public static int preIndex = 0;\\n        public static int postIndex = 0;\\n        public static TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {            \\n\\t\\t    preIndex = 0;\\n\\t\\t\\tpostIndex = 0;\\n            return runPreorder(pre, post);\\n        }\\n\\n        /// <summary>\\n        /// August 30, 2020\\n        /// Recursive function desgin: \\n        /// </summary>\\n        /// <param name=\"pre\"></param>\\n        /// <param name=\"post\"></param>\\n        /// <returns></returns>\\n        private static TreeNode runPreorder(int[] pre, int[] post)\\n        {\\n            var preLength = pre.Length;\\n            var postLength = post.Length;\\n\\n            if (pre == null || post == null || preIndex >= preLength || postIndex >= postLength)\\n                return null;\\n\\n            var rootVal = pre[preIndex];\\n\\n            var root = new TreeNode(pre[preIndex]);\\n            preIndex++;\\n\\n            if (rootVal != post[postIndex])\\n            {\\n                root.left    = runPreorder(pre, post);           \\n                root.right = runPreorder(pre, post);\\n            }\\n\\n            postIndex++;\\n\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace preorder_post_order\\n{\\n    public class TreeNode {\\n        public int val;\\n        public TreeNode left;\\n        public TreeNode right;\\n        public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n          this.val = val;\\n          this.left = left;\\n          this.right = right;\\n      }\\n    }\\n\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var node1 = new TreeNode(1);\\n            var node2 = new TreeNode(2);\\n            var node3 = new TreeNode(3);\\n            var node4 = new TreeNode(4);\\n            var node5 = new TreeNode(5);\\n            var node6 = new TreeNode(6);\\n            var node7 = new TreeNode(7);\\n\\n            node1.left = node2;\\n            node1.right = node3;\\n            node2.left = node4;\\n            node2.right = node5;\\n            node3.left = node6;\\n            node3.right = node7;\\n\\n            var root = ConstructFromPrePost(\\n                new int[]{1,2,4,5,3,6,7}, \\n                new int[]{4,5,2,6,7,3,1});\\n        }\\n\\n        public static int preIndex = 0;\\n        public static int postIndex = 0;\\n        public static TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {            \\n\\t\\t    preIndex = 0;\\n\\t\\t\\tpostIndex = 0;\\n            return runPreorder(pre, post);\\n        }\\n\\n        /// <summary>\\n        /// August 30, 2020\\n        /// Recursive function desgin: \\n        /// </summary>\\n        /// <param name=\"pre\"></param>\\n        /// <param name=\"post\"></param>\\n        /// <returns></returns>\\n        private static TreeNode runPreorder(int[] pre, int[] post)\\n        {\\n            var preLength = pre.Length;\\n            var postLength = post.Length;\\n\\n            if (pre == null || post == null || preIndex >= preLength || postIndex >= postLength)\\n                return null;\\n\\n            var rootVal = pre[preIndex];\\n\\n            var root = new TreeNode(pre[preIndex]);\\n            preIndex++;\\n\\n            if (rootVal != post[postIndex])\\n            {\\n                root.left    = runPreorder(pre, post);           \\n                root.right = runPreorder(pre, post);\\n            }\\n\\n            postIndex++;\\n\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249734,
                "title": "simple-java-recursion-with-explanation-o-n",
                "content": "Simple Algo steps we have to follow:-\\n1.preorder first element is the root, add that in TreeNode.\\n2.now find the next element from preorder, then its index from postorder map.\\n3.for left tree , elements will be from start upto the index of next element from postorder array\\n4.for right tree, elements will be from next index of the above element found upto end-1, because we already added root element into the tree, which is last in postorder array.\\n\\n```\\n int postpreindex=0;\\n public  TreeNode constructFromPrePost(int[] pre, int[] post) {\\n\\t\\t\\t \\n\\t\\t\\t HashMap<Integer,Integer> map=new HashMap<>();\\n\\t\\t        for(int i=0;i<post.length;i++) {\\n\\t\\t        \\tmap.put(post[i], i);\\n\\t\\t        }\\n\\t\\t       return helper(pre,post,map,0,post.length-1);\\n\\t\\t    }\\n\\n\\n\\tprivate  TreeNode helper(int[] preorder, int[] postorder,HashMap<Integer, Integer> map, int start, int end) {\\n\\t\\t\\tif(start>end) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode root=new TreeNode(preorder[postpreindex++]);\\n\\t\\t\\t\\n\\t\\t\\tif(start==end) {\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint index=map.get(preorder[postpreindex]);\\n\\t\\t\\t\\n\\t\\t\\troot.left=helper(preorder,postorder,map,start,index);\\n\\t\\t\\troot.right=helper(preorder,postorder,map,index+1,end-1);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n int postpreindex=0;\\n public  TreeNode constructFromPrePost(int[] pre, int[] post) {\\n\\t\\t\\t \\n\\t\\t\\t HashMap<Integer,Integer> map=new HashMap<>();\\n\\t\\t        for(int i=0;i<post.length;i++) {\\n\\t\\t        \\tmap.put(post[i], i);\\n\\t\\t        }\\n\\t\\t       return helper(pre,post,map,0,post.length-1);\\n\\t\\t    }\\n\\n\\n\\tprivate  TreeNode helper(int[] preorder, int[] postorder,HashMap<Integer, Integer> map, int start, int end) {\\n\\t\\t\\tif(start>end) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode root=new TreeNode(preorder[postpreindex++]);\\n\\t\\t\\t\\n\\t\\t\\tif(start==end) {\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint index=map.get(preorder[postpreindex]);\\n\\t\\t\\t\\n\\t\\t\\troot.left=helper(preorder,postorder,map,start,index);\\n\\t\\t\\troot.right=helper(preorder,postorder,map,index+1,end-1);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 177793,
                "title": "python-easy-to-understand-recursion",
                "content": "The first value of \\'pre\\' and last value of \\'post\\' is \\'root\\'. Find the second value of \\'pre\\' in \\'post\\' as it is the left child of \\'root\\'. From here, we divide pre and post into left branch and right branch.\\n\\n```\\ndef constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre: return\\n        root = TreeNode(pre[0])\\n        pre, post = pre[1:], post[:-1]\\n        if not pre: return root\\n        i = post.index(pre[0])\\n        root.left = self.constructFromPrePost(pre[:i+1], post[:i+1])\\n        root.right = self.constructFromPrePost(pre[i+1:], post[i+1:])\\n        return root\\n",
                "solutionTags": [],
                "code": "The first value of \\'pre\\' and last value of \\'post\\' is \\'root\\'. Find the second value of \\'pre\\' in \\'post\\' as it is the left child of \\'root\\'. From here, we divide pre and post into left branch and right branch.\\n\\n```\\ndef constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre: return\\n        root = TreeNode(pre[0])\\n        pre, post = pre[1:], post[:-1]\\n        if not pre: return root\\n        i = post.index(pre[0])\\n        root.left = self.constructFromPrePost(pre[:i+1], post[:i+1])\\n        root.right = self.constructFromPrePost(pre[i+1:], post[i+1:])\\n        return root\\n",
                "codeTag": "Python3"
            },
            {
                "id": 163540,
                "title": "java-recursive-solution-beat-99-9",
                "content": "```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return constructFromPrePost(pre, 0, pre.length-1, post, 0, post.length-1);\\n    }\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int preL, int preR, int[] post, int postL, int postR) {\\n        if (preL > preR || postL > postR) return null;\\n        TreeNode root = new TreeNode(pre[preL]);\\n        if (preL == preR) return root;\\n        \\n        int index = -1;\\n        for (int i = postL ; i < postR ; i++) {\\n            if (pre[preL+1] == post[i]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if (index == -1) return root;\\n        \\n        root.left = constructFromPrePost(pre, preL+1, preL+1+(index-postL), post, postL, index);\\n        root.right = constructFromPrePost(pre, preL+1+(index-postL)+1, preR, post, index+1, postR);\\n        return root;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return constructFromPrePost(pre, 0, pre.length-1, post, 0, post.length-1);\\n    }\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int preL, int preR, int[] post, int postL, int postR) {\\n        if (preL > preR || postL > postR) return null;\\n        TreeNode root = new TreeNode(pre[preL]);\\n        if (preL == preR) return root;\\n        \\n        int index = -1;\\n        for (int i = postL ; i < postR ; i++) {\\n            if (pre[preL+1] == post[i]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if (index == -1) return root;\\n        \\n        root.left = constructFromPrePost(pre, preL+1, preL+1+(index-postL), post, postL, index);\\n        root.right = constructFromPrePost(pre, preL+1+(index-postL)+1, preR, post, index+1, postR);\\n        return root;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688342,
                "title": "c-o-n-2-recursive",
                "content": "**\\nI saw many solutions here but none of them was as easily understandable as this one. \\nSee, we know its impossible to create a unique binary tree with just preorder and postorder. We can only construct full binary tree. Below are the simple steps to solve this problem: \\n1. First node in preorder is always the root node. We will create a node root with data = pre[preindex].\\n2. Now, how to find the left subtree nodes? See, the second element in preorder is the immediate left node of root.  And in postorder, this (second element of preorder) node is lying after all the elements of left subtree (as its POSTorder.). \\n3. So we will find the index of that node( say its index) in postorder and recursively build the tree. All the nodes  ( postorder[0] to postorder[index]{ including } ) will form the left subtree and the nodes { postorder[index+1] to postorder[end-1]) will contribute to the right subtree. We are not taking the last node of POSTorder as it is the root node and has already used.\\n4. Take care of the base conditions and you are good to go.\\n\\n**\\nclass Solution {\\npublic:\\n\\n    TreeNode* buildTree(vector<int>&pre,vector<int>&post,int &preindex,int start,int end)\\n    {\\n        if(start>end or preindex>=pre.size())\\n            return NULL;\\n        TreeNode* new_head = new TreeNode(pre[preindex++]);\\n        if(preindex==pre.size() or start==end)\\n            return new_head;\\n        int i;\\n        for(i=start;i<=end;i++)\\n        {\\n            if(pre[preindex]==post[i])\\n                break;\\n        }\\n        if(i<=end)\\n        {\\n            new_head->left = buildTree(pre,post,preindex,start,i);\\n            new_head->right = buildTree(pre,post,preindex,i+1,end-1);\\n        }\\n        return new_head;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        int preindex = 0 ;\\n        return buildTree(pre,post,preindex,0,pre.size()-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    TreeNode* buildTree(vector<int>&pre,vector<int>&post,int &preindex,int start,int end)\\n    {\\n        if(start>end or preindex>=pre.size())\\n            return NULL;\\n        TreeNode* new_head = new TreeNode(pre[preindex++]);\\n        if(preindex==pre.size() or start==end)\\n            return new_head;\\n        int i;\\n        for(i=start;i<=end;i++)\\n        {\\n            if(pre[preindex]==post[i])\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1308753,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n     \\n        //map all the elements of postorder with their index\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<post.size();i++)\\n            mp[post[i]]=i;\\n        \\n        int preorderIndex=0;\\n        return buildTree(pre,mp,preorderIndex);\\n        \\n    }\\n    TreeNode* buildTree(vector<int>& pre,unordered_map<int,int>& mp,int& preorderIndex)\\n    {\\n        int curr=pre[preorderIndex];\\n        TreeNode* n=new TreeNode(curr);\\n        preorderIndex++;\\n        if(preorderIndex<pre.size()  && mp[pre[preorderIndex]] < mp[curr])\\n        {\\n            //the next elemenet is present to the left of tree\\n            n->left=buildTree(pre,mp,preorderIndex);\\n        }\\n        else \\n            return n;\\n        if(preorderIndex < pre.size() && mp[pre[preorderIndex]] < mp[curr])\\n        {\\n            n->right=buildTree(pre,mp,preorderIndex);\\n        }\\n        return n;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you ;)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n     \\n        //map all the elements of postorder with their index\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<post.size();i++)\\n            mp[post[i]]=i;\\n        \\n        int preorderIndex=0;\\n        return buildTree(pre,mp,preorderIndex);\\n        \\n    }\\n    TreeNode* buildTree(vector<int>& pre,unordered_map<int,int>& mp,int& preorderIndex)\\n    {\\n        int curr=pre[preorderIndex];\\n        TreeNode* n=new TreeNode(curr);\\n        preorderIndex++;\\n        if(preorderIndex<pre.size()  && mp[pre[preorderIndex]] < mp[curr])\\n        {\\n            //the next elemenet is present to the left of tree\\n            n->left=buildTree(pre,mp,preorderIndex);\\n        }\\n        else \\n            return n;\\n        if(preorderIndex < pre.size() && mp[pre[preorderIndex]] < mp[curr])\\n        {\\n            n->right=buildTree(pre,mp,preorderIndex);\\n        }\\n        return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259055,
                "title": "python-combo-pack-3-questions",
                "content": "I think it\\'s instructive to consider three travelsal questions together.\\n**105. Construct Binary Tree from Preorder and Inorder Traversal**\\n**106. Construct Binary Tree from Inorder and Postorder Traversal**\\n**889. Construct Binary Tree from Preorder and Postorder Traversal**\\n\\nWe need 2 out of 3 travesal arrays (preorder, inorder, postorder) in order to uniquely reconstruct the binary tree. For all 3 cases consider a function `recur(preorder, inorder)` that reconstructs one node at a time. The structure is the same for all three problems: (i) Find the current node to split, (ii) Find left and right traversals, (iii) Create the node and find left and right subtrees via recursion.\\n\\n* **Preorder and Inorder Traversal:** The node we consider is `x = preorder[0]`. How do we split `preorder` and `inorder` when we go left and right? For both arrays, they can be splitted into two based on a single index as in both arrays all left elements appear before right elements. For `inorder` find `i` such that `inorder[i] = x` and split as `inorder[:i]` and `inorder[i+1:]`. On the other hand, for `preorder` the lengths should match `inorder` which means the only choice we have is the pair `preorder[1:i+1]` and `preorder[i+1:]`. This is so, because we have already used `preorder[0]`.\\n\\n* **Inorder and Postorder Traversal:** The node we consider is `x = postorder[-1]`. How do we split `postorder` and `inorder` when we go left and right? Once again, for both arrays, they can be splitted into two based on a single index as in both arrays all left elements appear before right elements. For `inorder` find `i` such that `inorder[i] = x` and split as `inorder[:i]` and `inorder[i+1:]`. On the other hand, for `postorder` the lengths should match `inorder` which means the only choice we have is the pair `postorder[:i]` and `preorder[i:]`.\\n\\n* **Preorder and Postorder Traversal:** This is the trickiest one! (The length should be at least two in both arrays to proceed.) Reverse `postorder` before you begin. The node we consider is `x = preorder[0]`. To find how many elements are to the left, find `i` such that `preorder[i] == postorder[1]`. Then the preorder is splitted as `preorder[1:i]` and `preorder[i:]`. Since postorder is flipped the left and right elements appear in reverse order, but they are given by `postorder[n-i+1:]` and `postorder[1:n-i+1]`.\\n\\n\\n**105. Construct Binary Tree from Preorder and Inorder Traversal**\\n```python\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        def recur(preorder, inorder):\\n            if not preorder: return None\\n            #current value\\n            x = preorder[0]\\n            #split\\n            i = inorder.index(x)\\n            inorder_left, inorder_right = inorder[:i], inorder[i+1:]\\n            preorder_left, preorder_right = preorder[1:i+1], preorder[i+1:]\\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(preorder_left, inorder_left)\\n            this.right = recur(preorder_right, inorder_right)\\n            return this\\n        \\n        return recur(preorder, inorder)\\n```\\n\\n**106. Construct Binary Tree from Inorder and Postorder Traversal**\\n```python\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        def recur(inorder, postorder):\\n            if not postorder: return None\\n            #current value\\n            x = postorder.pop()\\n\\t\\t\\t#split\\n            i = inorder.index(x)\\n            inorder_left, inorder_right = inorder[:i], inorder[i+1:]\\n            postorder_left, postorder_right = postorder[:i], postorder[i:]\\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(inorder_left, postorder_left)\\n            this.right = recur(inorder_right, postorder_right)\\n            return this\\n        \\n        return recur(inorder, postorder)\\n```\\n\\n**889. Construct Binary Tree from Preorder and Postorder Traversal**\\n```python\\nclass Solution:\\n    def constructFromPrePost(self, preorder, postorder):\\n        def recur(preorder, postorder):\\n            if not preorder: return None\\n            #current value\\n            x = preorder[0]\\n            #split\\n            preorder_left, preorder_right = [], []\\n            postorder_left, postorder_right = [], []\\n            if len(preorder) > 1:\\n                i, n = preorder.index(postorder[1]), len(preorder)\\n                preorder_left, preorder_right = preorder[1:i], preorder[i:]\\n                postorder_left, postorder_right = postorder[n-i+1:], postorder[1:n-i+1] \\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(preorder_left, postorder_left)\\n            this.right = recur(preorder_right, postorder_right)\\n            return this\\n        \\n        return recur(preorder, postorder[::-1])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        def recur(preorder, inorder):\\n            if not preorder: return None\\n            #current value\\n            x = preorder[0]\\n            #split\\n            i = inorder.index(x)\\n            inorder_left, inorder_right = inorder[:i], inorder[i+1:]\\n            preorder_left, preorder_right = preorder[1:i+1], preorder[i+1:]\\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(preorder_left, inorder_left)\\n            this.right = recur(preorder_right, inorder_right)\\n            return this\\n        \\n        return recur(preorder, inorder)\\n```\n```python\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        def recur(inorder, postorder):\\n            if not postorder: return None\\n            #current value\\n            x = postorder.pop()\\n\\t\\t\\t#split\\n            i = inorder.index(x)\\n            inorder_left, inorder_right = inorder[:i], inorder[i+1:]\\n            postorder_left, postorder_right = postorder[:i], postorder[i:]\\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(inorder_left, postorder_left)\\n            this.right = recur(inorder_right, postorder_right)\\n            return this\\n        \\n        return recur(inorder, postorder)\\n```\n```python\\nclass Solution:\\n    def constructFromPrePost(self, preorder, postorder):\\n        def recur(preorder, postorder):\\n            if not preorder: return None\\n            #current value\\n            x = preorder[0]\\n            #split\\n            preorder_left, preorder_right = [], []\\n            postorder_left, postorder_right = [], []\\n            if len(preorder) > 1:\\n                i, n = preorder.index(postorder[1]), len(preorder)\\n                preorder_left, preorder_right = preorder[1:i], preorder[i:]\\n                postorder_left, postorder_right = postorder[n-i+1:], postorder[1:n-i+1] \\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(preorder_left, postorder_left)\\n            this.right = recur(preorder_right, postorder_right)\\n            return this\\n        \\n        return recur(preorder, postorder[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763804,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if not pre:\\n            return None\\n        root = TreeNode(post.pop())\\n        if len(pre) == 1:\\n            return root\\n        rightIndex = pre.index(post[-1])\\n        root.right = self.constructFromPrePost(pre[rightIndex:], post)\\n        root.left = self.constructFromPrePost(pre[1:rightIndex], post)\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if not pre:\\n            return None\\n        root = TreeNode(post.pop())\\n        if len(pre) == 1:\\n            return root\\n        rightIndex = pre.index(post[-1])\\n        root.right = self.constructFromPrePost(pre[rightIndex:], post)\\n        root.left = self.constructFromPrePost(pre[1:rightIndex], post)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161312,
                "title": "simple-java-using-stack-with-explanation",
                "content": "Lets see what we know;\\n1- We know that root always comes first in PreOrder but Last in Post Order. So, if we read PreOrder list from start, and check the position of the node in Post Order list, whatever nodes come before its index in PostOrder list is sub Node of this node (this node is the parent node for sure).\\n2- PreOrder always start from ROOT, then LEFT, and then RIGHT. So if the current node in PreOrder list has no left node, the next node in the list is its left node for sure (please refer to the *NOTE*), unless the next node index in PostOrder list is higher than the current node, since we know that in PostOrder we have LEFT,RIGHT, ROOT. So what ever node comes after the current node in our PreOrder list is a sub node of the current node as long as it\\'s index is smaller than the current node index in our PostOrder list. \\n*Note: We assume it is the left node, as it may have a right node which comes later. Since PreOrder is Root,Left,Right, and we start reading the list from 0 index, so we do not know whether the right node exists or not. What if it has a right node and we set the first sub node as its right node.* \\n```\\n public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n    \\tif(post==null || post.length==0 || pre==null || pre.length==0) return null;\\n    \\tint len = post.length;\\t\\n    \\tHashMap<Integer,Integer> index = new HashMap<>();\\n    \\tfor(int i=0; i<len; i++) index.put(post[i], i); //record the indexs\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tint i=0;\\n    \\tTreeNode root = new TreeNode(pre[i++]); //the first node in our PreOrder list is always the ROOT Node\\n    \\tstack.push(root);\\n    \\twhile(i<len){  //start reading the PreOrder list and check the indexs with PostOrder list\\n    \\t\\tTreeNode next = new TreeNode(pre[i]);    \\t\\t\\n    \\t\\twhile(index.get(stack.peek().val)<index.get(next.val)) stack.pop(); //we remove nodes with smaller index from stack as they cannot be the next nodes\\' parent\\n    \\t\\tTreeNode existing = stack.pop();    \\t\\t\\t\\n    \\t\\tif(existing.left==null) { //left always come first\\n    \\t\\t\\texisting.left=next;\\n    \\t\\t\\tstack.push(existing); stack.push(next); // we push the existing node again into the stack as it may have a right node\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\texisting.right=next;\\n    \\t\\t\\tstack.push(next); // we do not push the existing node anymore, as it\\'s left and right nodes already found\\n    \\t\\t}    \\t\\t    \\t\\t\\n    \\t\\ti++;\\n    \\t}\\n    \\treturn root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n    \\tif(post==null || post.length==0 || pre==null || pre.length==0) return null;\\n    \\tint len = post.length;\\t\\n    \\tHashMap<Integer,Integer> index = new HashMap<>();\\n    \\tfor(int i=0; i<len; i++) index.put(post[i], i); //record the indexs\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tint i=0;\\n    \\tTreeNode root = new TreeNode(pre[i++]); //the first node in our PreOrder list is always the ROOT Node\\n    \\tstack.push(root);\\n    \\twhile(i<len){  //start reading the PreOrder list and check the indexs with PostOrder list\\n    \\t\\tTreeNode next = new TreeNode(pre[i]);    \\t\\t\\n    \\t\\twhile(index.get(stack.peek().val)<index.get(next.val)) stack.pop(); //we remove nodes with smaller index from stack as they cannot be the next nodes\\' parent\\n    \\t\\tTreeNode existing = stack.pop();    \\t\\t\\t\\n    \\t\\tif(existing.left==null) { //left always come first\\n    \\t\\t\\texisting.left=next;\\n    \\t\\t\\tstack.push(existing); stack.push(next); // we push the existing node again into the stack as it may have a right node\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\texisting.right=next;\\n    \\t\\t\\tstack.push(next); // we do not push the existing node anymore, as it\\'s left and right nodes already found\\n    \\t\\t}    \\t\\t    \\t\\t\\n    \\t\\ti++;\\n    \\t}\\n    \\treturn root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369848,
                "title": "java-easy-approach-with-explanation-hashmap-postorder",
                "content": "```\\nclass Solution\\n{\\n    private HashMap<Integer, Integer> postorderMap= new HashMap<>();//data -- index\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) \\n    {\\n        for(int i= 0; i< postorder.length; i++)//putting the postorder value and index into the hash map to reduce the  access time of O(1)\\n            postorderMap.put(postorder[i], i);\\n        \\n        return constructBT(preorder, 0, preorder.length - 1, 0, postorder.length - 1);//creates the BST, and returns the new root\\n    }\\n    public TreeNode constructBT(int[] preorder, int preorderStart, int preorderEnd, int postorderStart, int postorderEnd) \\n    {//postorder travrersal is used because we want to first know about children first and then the parent  \\n        if(preorderStart > preorderEnd)//base case when we rech to wrong index, retuning null to tell the parent there is no node \\n            return null;\\n        \\n        int rootData= preorder[preorderStart];//new root, root is always present at the starting index of the preorder (Root Left Right)\\n \\n        if(preorderStart == preorderEnd)//when we reach to array size of 1, we return that node since no child is present after that node \\n            return new TreeNode(rootData, null, null);\\n        \\n        int  LeftrootIndex= postorderMap.get(preorder[preorderStart + 1]);//as we know that the postorder traverse first Left then Right and then root, so we are taking advantage of that we are getting the index of root next element in postorder(as it will be the upperbound for left subtree )\\n        \\n        int leftSubtreeSize= LeftrootIndex - postorderStart + 1;//w.r.t to root //including both the index //calculating the left subtree length to partion the array and contruct the tree recursively \\n            \\n        TreeNode left= constructBT(preorder, preorderStart+ 1, preorderStart + leftSubtreeSize, postorderStart, LeftrootIndex);//recursing down the left subtree and knowing about the child \\n        TreeNode right= constructBT(preorder, preorderStart + leftSubtreeSize + 1, preorderEnd, LeftrootIndex + 1, preorderEnd - 1);        TreeNode left= constructBT(preorder, preorderStart+ 1, preorderStart + leftSubtreeSize, postorderStart, LeftrootIndex);//recursing down the right subtree and knowing about the child \\n\\n        \\n        TreeNode node= new TreeNode(rootData, left, right);//after the full fledged information of left and right child constructing the node \\n        \\n        return node;//returning the node to maintain the backward limnk between newly created nodes \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    private HashMap<Integer, Integer> postorderMap= new HashMap<>();//data -- index\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) \\n    {\\n        for(int i= 0; i< postorder.length; i++)//putting the postorder value and index into the hash map to reduce the  access time of O(1)\\n            postorderMap.put(postorder[i], i);\\n        \\n        return constructBT(preorder, 0, preorder.length - 1, 0, postorder.length - 1);//creates the BST, and returns the new root\\n    }\\n    public TreeNode constructBT(int[] preorder, int preorderStart, int preorderEnd, int postorderStart, int postorderEnd) \\n    {//postorder travrersal is used because we want to first know about children first and then the parent  \\n        if(preorderStart > preorderEnd)//base case when we rech to wrong index, retuning null to tell the parent there is no node \\n            return null;\\n        \\n        int rootData= preorder[preorderStart];//new root, root is always present at the starting index of the preorder (Root Left Right)\\n \\n        if(preorderStart == preorderEnd)//when we reach to array size of 1, we return that node since no child is present after that node \\n            return new TreeNode(rootData, null, null);\\n        \\n        int  LeftrootIndex= postorderMap.get(preorder[preorderStart + 1]);//as we know that the postorder traverse first Left then Right and then root, so we are taking advantage of that we are getting the index of root next element in postorder(as it will be the upperbound for left subtree )\\n        \\n        int leftSubtreeSize= LeftrootIndex - postorderStart + 1;//w.r.t to root //including both the index //calculating the left subtree length to partion the array and contruct the tree recursively \\n            \\n        TreeNode left= constructBT(preorder, preorderStart+ 1, preorderStart + leftSubtreeSize, postorderStart, LeftrootIndex);//recursing down the left subtree and knowing about the child \\n        TreeNode right= constructBT(preorder, preorderStart + leftSubtreeSize + 1, preorderEnd, LeftrootIndex + 1, preorderEnd - 1);        TreeNode left= constructBT(preorder, preorderStart+ 1, preorderStart + leftSubtreeSize, postorderStart, LeftrootIndex);//recursing down the right subtree and knowing about the child \\n\\n        \\n        TreeNode node= new TreeNode(rootData, left, right);//after the full fledged information of left and right child constructing the node \\n        \\n        return node;//returning the node to maintain the backward limnk between newly created nodes \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161287,
                "title": "recursive-c-o-n-log-n",
                "content": "The basic idea is to find the left subtree and the right subtree. \\n* The root node must be the first element of the pre sequence.\\n* The root node must be the last element of the post sequence.\\n* The left subtree and the right subtree must be consecutive in both of the sequences.\\n```\\npre: 1 | 2 4 5 | 3 6 7\\npost:  | 4 5 2 | 6 7 3 | 1\\n```\\n\\nStart scanning from pre[1] and post[0]. Once they contains the same set of numbers, we can truncate it to be two parts. One is the left subtree, another is the right subtree.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* constuctFromRange(vector<int>& pre, vector<int>& post, int s1, int e1, int s2, int e2) {\\n        if (s1 > e1 || s2 > e2) return NULL;\\n        TreeNode *root = new TreeNode(pre[s1]);\\n        if (s1 == e1) return root;\\n        int m1 = s1 + 1, m2 = s2;\\n        int set1 = 0, set2 = 0;\\n        while (set1 == 0 || set1 != set2) {\\n            set1 = set1 | (1 << pre[m1++]);\\n            set2 = set2 | (1 << post[m2++]);\\n        }\\n        root->left = constuctFromRange(pre, post, s1 + 1, m1 - 1, s2, m2 - 1);\\n        root->right = constuctFromRange(pre, post, m1, e1, m2, e2);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return constuctFromRange(pre, post, 0, pre.size() - 1, 0, post.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npre: 1 | 2 4 5 | 3 6 7\\npost:  | 4 5 2 | 6 7 3 | 1\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* constuctFromRange(vector<int>& pre, vector<int>& post, int s1, int e1, int s2, int e2) {\\n        if (s1 > e1 || s2 > e2) return NULL;\\n        TreeNode *root = new TreeNode(pre[s1]);\\n        if (s1 == e1) return root;\\n        int m1 = s1 + 1, m2 = s2;\\n        int set1 = 0, set2 = 0;\\n        while (set1 == 0 || set1 != set2) {\\n            set1 = set1 | (1 << pre[m1++]);\\n            set2 = set2 | (1 << post[m2++]);\\n        }\\n        root->left = constuctFromRange(pre, post, s1 + 1, m1 - 1, s2, m2 - 1);\\n        root->right = constuctFromRange(pre, post, m1, e1, m2, e2);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return constuctFromRange(pre, post, 0, pre.size() - 1, 0, post.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491853,
                "title": "c-clean-solution-for-beginners-recurse-on-left-and-right-subtree",
                "content": "The idea is:\\n- keep a `pre_start` index for the preorder array\\n- use the preorder array as root nodes\\n- everytime, find the left child, which is at `pre_start + 1` in preorder\\n- find the left child\\'s index in postorder\\n- split the nodes in the postorder into left and right subtree\\n- time is O( n )\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> val_to_idx;\\n    \\n    TreeNode* build(vector<int>& preorder, vector<int>& postorder, int pre_start, int post_start, int post_end){\\n        if(post_start > post_end) return NULL;\\n        if(post_start == post_end) return new TreeNode(preorder[pre_start]);\\n        \\n        int val = preorder[pre_start];\\n        int left_child = preorder[pre_start + 1];\\n        int left_child_idx = val_to_idx[left_child];\\n        int left_size = left_child_idx - post_start + 1;\\n        \\n        TreeNode* root = new TreeNode(val);\\n        root->left = build(preorder, postorder, pre_start+1, post_start, left_child_idx);\\n        root->right = build(preorder, postorder, pre_start+left_size+1, left_child_idx+1, post_end-1);\\n        \\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i = 0; i < postorder.size(); i++){\\n            val_to_idx[postorder[i]] = i;\\n        }\\n        return build(preorder, postorder, 0, 0, preorder.size()-1);\\n    }\\n};\\n```\\n\\nHope it can help!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> val_to_idx;\\n    \\n    TreeNode* build(vector<int>& preorder, vector<int>& postorder, int pre_start, int post_start, int post_end){\\n        if(post_start > post_end) return NULL;\\n        if(post_start == post_end) return new TreeNode(preorder[pre_start]);\\n        \\n        int val = preorder[pre_start];\\n        int left_child = preorder[pre_start + 1];\\n        int left_child_idx = val_to_idx[left_child];\\n        int left_size = left_child_idx - post_start + 1;\\n        \\n        TreeNode* root = new TreeNode(val);\\n        root->left = build(preorder, postorder, pre_start+1, post_start, left_child_idx);\\n        root->right = build(preorder, postorder, pre_start+left_size+1, left_child_idx+1, post_end-1);\\n        \\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i = 0; i < postorder.size(); i++){\\n            val_to_idx[postorder[i]] = i;\\n        }\\n        return build(preorder, postorder, 0, 0, preorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431380,
                "title": "c-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int preidx=0,postidx=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post)\\n    {\\n        TreeNode* root=new TreeNode(pre[preidx++]);\\n        if(root->val!=post[postidx])\\n            root->left=constructFromPrePost(pre,post);\\n        if(root->val!=post[postidx])\\n            root->right=constructFromPrePost(pre,post);\\n        postidx++;\\n        return root;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int preidx=0,postidx=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post)\\n    {\\n        TreeNode* root=new TreeNode(pre[preidx++]);\\n        if(root->val!=post[postidx])\\n            root->left=constructFromPrePost(pre,post);\\n        if(root->val!=post[postidx])\\n            root->right=constructFromPrePost(pre,post);\\n        postidx++;\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2268607,
                "title": "c-easy-recursive-solution",
                "content": "\\uD83D\\uDD25 **Kindly Upvote, It is FREE From your side**\\n\\n\\uD83D\\uDE07 Observation:-\\nPreorder Traversal is:- Root Left and Right\\nPostOrder Traversal is:- Left Right Root.\\n\\nNow, we know the exact location of the Root that is the First element of the Preorder. But we donot know about the Left and Right Subtree after the root selection. For that We can select the first element of the left in preorder and can search in Postorder. So we\\'ll find the left and right subtree after that in the Postorder.\\n\\nMake sure you keep four pointers to tract start and end of pre and post order.\\n\\nRest, follow the code and dry run a case to know more about it.\\n\\n\\n\\n```\\n#define Tn TreeNode*\\n#define um unordered_map<int, int>\\n#define vc vector<int>\\n#define dvc vector<vector<int>>\\n#define ll long long int\\nclass Solution {\\nprivate:\\n    int findElement(vc post, int element){\\n        return find(post.begin(), post.end(), element) - post.begin();\\n    }\\n    \\n    TreeNode* helper(vc &pre, vc &post, int preStart, int preEnd, int postStart, int postEnd){\\n        if(preStart > preEnd){\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(pre[preStart]);\\n        \\n        if(preStart==preEnd){\\n            return root;\\n        }\\n        \\n        int index = findElement(post, pre[preStart+1]);\\n        int length = index-postStart+1;\\n        \\n        root->left = helper(pre, post, preStart+1, preStart+length, postStart, index);\\n        root->right = helper(pre, post, preStart+length+1, preEnd, index+1, postEnd-1);\\n        \\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return helper(pre, post, 0, pre.size()-1, 0, post.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define Tn TreeNode*\\n#define um unordered_map<int, int>\\n#define vc vector<int>\\n#define dvc vector<vector<int>>\\n#define ll long long int\\nclass Solution {\\nprivate:\\n    int findElement(vc post, int element){\\n        return find(post.begin(), post.end(), element) - post.begin();\\n    }\\n    \\n    TreeNode* helper(vc &pre, vc &post, int preStart, int preEnd, int postStart, int postEnd){\\n        if(preStart > preEnd){\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(pre[preStart]);\\n        \\n        if(preStart==preEnd){\\n            return root;\\n        }\\n        \\n        int index = findElement(post, pre[preStart+1]);\\n        int length = index-postStart+1;\\n        \\n        root->left = helper(pre, post, preStart+1, preStart+length, postStart, index);\\n        root->right = helper(pre, post, preStart+length+1, preEnd, index+1, postEnd-1);\\n        \\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return helper(pre, post, 0, pre.size()-1, 0, post.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635468,
                "title": "c-beats-92-5-29-line-code-unordered-map-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> um;\\n    int idx = 0;\\n\\n    TreeNode * dfs(vector<int>& preorder, int s, int e, vector<int>& postorder){\\n        if(s > e)\\n            return NULL;\\n        if(s == e)\\n            return new TreeNode(preorder[idx++]);\\n\\n        int pos = um[preorder[idx+1]];\\n\\n        TreeNode * root = new TreeNode(preorder[idx++]);\\n        root->left      = dfs(preorder, s, pos, postorder);\\n        root->right     = dfs(preorder, pos+1, e-1, postorder);\\n\\n        return root;\\n    }\\n\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n\\n        int pos = postorder.size();\\n        for(int i = 0; i<pos; i++)\\n            um[postorder[i]] = i;\\n\\n        return dfs(preorder, 0, pos-1, postorder);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> um;\\n    int idx = 0;\\n\\n    TreeNode * dfs(vector<int>& preorder, int s, int e, vector<int>& postorder){\\n        if(s > e)\\n            return NULL;\\n        if(s == e)\\n            return new TreeNode(preorder[idx++]);\\n\\n        int pos = um[preorder[idx+1]];\\n\\n        TreeNode * root = new TreeNode(preorder[idx++]);\\n        root->left      = dfs(preorder, s, pos, postorder);\\n        root->right     = dfs(preorder, pos+1, e-1, postorder);\\n\\n        return root;\\n    }\\n\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n\\n        int pos = postorder.size();\\n        for(int i = 0; i<pos; i++)\\n            um[postorder[i]] = i;\\n\\n        return dfs(preorder, 0, pos-1, postorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446650,
                "title": "python-easy-to-understand-solution",
                "content": "Solution has an extra step to make it easier to understand and implement - this can be optimized away.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        \\n        # Slice preorder and postorder to make math easier\\n        preorder = preorder[1:]\\n        posted = postorder[:-1]\\n        if preorder and postorder:\\n            left_start = preorder[0]\\n            left_end = postorder.index(preorder[0])\\n\\t\\t\\t# Left is everything up to and including left end\\n            root.left = self.constructFromPrePost(preorder[:left_end + 1], postorder[:left_end + 1])\\n\\t\\t\\t# Right is everything after left ends\\n            root.right = self.constructFromPrePost(preorder[left_end + 1:], postorder[left_end + 1:])\\n        return root\\n```\\n\\nOptimized:\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        \\n        if len(preorder) > 1:\\n            left_start = preorder[1]\\n            left_end = postorder.index(preorder[1])\\n\\t\\t\\t# Note that the (extra) array slicing is gone in favor of more logical slicing\\n\\t\\t\\t# This could be optimized further to not slice at all if you\\'re particularly brave in an interview\\n            root.left = self.constructFromPrePost(preorder[1:left_end + 2], postorder[:left_end + 1])\\n            root.right = self.constructFromPrePost(preorder[left_end + 2:], postorder[left_end + 1:-1])\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        \\n        # Slice preorder and postorder to make math easier\\n        preorder = preorder[1:]\\n        posted = postorder[:-1]\\n        if preorder and postorder:\\n            left_start = preorder[0]\\n            left_end = postorder.index(preorder[0])\\n\\t\\t\\t# Left is everything up to and including left end\\n            root.left = self.constructFromPrePost(preorder[:left_end + 1], postorder[:left_end + 1])\\n\\t\\t\\t# Right is everything after left ends\\n            root.right = self.constructFromPrePost(preorder[left_end + 1:], postorder[left_end + 1:])\\n        return root\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        \\n        if len(preorder) > 1:\\n            left_start = preorder[1]\\n            left_end = postorder.index(preorder[1])\\n\\t\\t\\t# Note that the (extra) array slicing is gone in favor of more logical slicing\\n\\t\\t\\t# This could be optimized further to not slice at all if you\\'re particularly brave in an interview\\n            root.left = self.constructFromPrePost(preorder[1:left_end + 2], postorder[:left_end + 1])\\n            root.right = self.constructFromPrePost(preorder[left_end + 2:], postorder[left_end + 1:-1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733971,
                "title": "c-solution-4-lines-code-only",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if(root->val != post[posIndex]) root->left = constructFromPrePost(pre,post);\\n        if(root->val != post[posIndex]) root->right = constructFromPrePost(pre,post);\\n        posIndex++;\\n        return root;\\n    }\\nprivate:\\n    int preIndex = 0, posIndex = 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if(root->val != post[posIndex]) root->left = constructFromPrePost(pre,post);\\n        if(root->val != post[posIndex]) root->right = constructFromPrePost(pre,post);\\n        posIndex++;\\n        return root;\\n    }\\nprivate:\\n    int preIndex = 0, posIndex = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161300,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre, post):\\n        if pre:\\n            root = TreeNode(pre.pop(0))\\n            post.pop()\\n            if pre:\\n                if pre[0] == post[-1]:\\n                    root.left = self.constructFromPrePost(pre, post)\\n                else:\\n                    l, r = post.index(pre[0]), pre.index(post[-1])\\n                    root.left = self.constructFromPrePost(pre[:r], post[:l + 1])\\n                    root.right = self.constructFromPrePost(pre[r:], post[l + 1:]) \\n            return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre, post):\\n        if pre:\\n            root = TreeNode(pre.pop(0))\\n            post.pop()\\n            if pre:\\n                if pre[0] == post[-1]:\\n                    root.left = self.constructFromPrePost(pre, post)\\n                else:\\n                    l, r = post.index(pre[0]), pre.index(post[-1])\\n                    root.left = self.constructFromPrePost(pre[:r], post[:l + 1])\\n                    root.right = self.constructFromPrePost(pre[r:], post[l + 1:]) \\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760443,
                "title": "javascript-clean-dfs",
                "content": "## Solution-1\\n```javascript\\nvar constructFromPrePost = function(pre, post) {\\n    let i = 0;\\n    \\n    function callDFS(arr) {\\n        if(!arr.length) return null;\\n        const node = pre[i++]\\n        const idx = arr.indexOf(pre[i]);\\n        const tree = new TreeNode(node);\\n        tree.left = callDFS(arr.slice(0, idx+1));\\n        tree.right = callDFS(arr.slice(idx+1, arr.indexOf(node)))\\n        return tree;\\n    }\\n    return callDFS(post)\\n};\\n```\\n\\n## Solution-2: Optimized Using Hash Map\\n```javascript\\nvar constructFromPrePost = function(pre, post) {\\n    const map = {}; let i = 0;\\n    \\n    for(let i = 0; i < post.length; i++) {\\n        map[post[i]] = i;\\n    }\\n    \\n    function callDFS(start, end) {\\n        if(start > end || i >= pre.length) return null;\\n        const node = pre[i++], idx = map[pre[i]];\\n        const tree = new TreeNode(node);\\n        if(idx < start || idx > end) return tree;\\n        tree.left = callDFS(start, idx);\\n        tree.right = callDFS(idx+1, map[node]-1)\\n        return tree;\\n    }\\n    return callDFS(0, post.length-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar constructFromPrePost = function(pre, post) {\\n    let i = 0;\\n    \\n    function callDFS(arr) {\\n        if(!arr.length) return null;\\n        const node = pre[i++]\\n        const idx = arr.indexOf(pre[i]);\\n        const tree = new TreeNode(node);\\n        tree.left = callDFS(arr.slice(0, idx+1));\\n        tree.right = callDFS(arr.slice(idx+1, arr.indexOf(node)))\\n        return tree;\\n    }\\n    return callDFS(post)\\n};\\n```\n```javascript\\nvar constructFromPrePost = function(pre, post) {\\n    const map = {}; let i = 0;\\n    \\n    for(let i = 0; i < post.length; i++) {\\n        map[post[i]] = i;\\n    }\\n    \\n    function callDFS(start, end) {\\n        if(start > end || i >= pre.length) return null;\\n        const node = pre[i++], idx = map[pre[i]];\\n        const tree = new TreeNode(node);\\n        if(idx < start || idx > end) return tree;\\n        tree.left = callDFS(start, idx);\\n        tree.right = callDFS(idx+1, map[node]-1)\\n        return tree;\\n    }\\n    return callDFS(0, post.length-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 416491,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nAs we can return any tree matching the given traversals, we can safely assume `pre[i+1]`, if exists, is always a left child of `pre[i]`.\\n\\nThe basic idea is to divide the `pre[i..j]` into three parts `[root] [left-subtree] [right-subtree]`. To defined these boundaries, we make use of the fact that in post-order traversal, everything before the root is under that root. So we need to find `pre[i+1]` in the `post` Why? `pre[i]` is root by defintion and by our assumtion `pre[i+1]` should be the last node in the post-order traversal for that subtree.\\n\\n**PS** Searching time can be reduced by reverse mapping using hashmap on `post`.\\n\\n```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return helper(pre, 0, pre.length-1, post, 0, pre.length-1);\\n    }\\n    private TreeNode helper(int[] pre, int i, int j, int[] post, int s, int e){\\n        if(i > j) return null;\\n        TreeNode curr = new TreeNode(pre[i]);\\n        if(i == j) return curr;\\n        int k=s;\\n        for(; k < e; k++)\\n            if(post[k] == pre[i+1])\\n                break;\\n        int len = k-s+1;\\n        curr.left = helper(pre, i+1, i+len, post, s, k);\\n        curr.right = helper(pre, i+len+1, j, post, k+1, e-1);\\n        return curr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return helper(pre, 0, pre.length-1, post, 0, pre.length-1);\\n    }\\n    private TreeNode helper(int[] pre, int i, int j, int[] post, int s, int e){\\n        if(i > j) return null;\\n        TreeNode curr = new TreeNode(pre[i]);\\n        if(i == j) return curr;\\n        int k=s;\\n        for(; k < e; k++)\\n            if(post[k] == pre[i+1])\\n                break;\\n        int len = k-s+1;\\n        curr.left = helper(pre, i+1, i+len, post, s, k);\\n        curr.right = helper(pre, i+len+1, j, post, k+1, e-1);\\n        return curr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256466,
                "title": "python-recursion-d-c",
                "content": "We can build to tree on recursively building the subtree. We just need to figure out what\\'s the slice of pre and post for subtree.\\n\\nFor example, we have tree as:\\n```\\n\\t 1\\n\\t/ \\\\\\n   2   3\\n  /\\\\   /\\\\\\n 4  5 6  7\\n```\\nSo, pre: [1,2,4,5,3,6,7] and post: [4,5,2,6,7,3,1]\\nRoot node always at the front in preorder while at the back in the post order. That\\'s quite obvious for root node 1.\\n\\nNow let\\'s check the left subtree, with a root node 2. We can use preorder to find left subtree\\'s root node\\'s location while use postorder to count left subtree\\'s nodes\\' number.\\nWe know left subtree roots at 2 as pre[1] (pre[0] is root node). So we can count left subtree\\'s node number as post.index(pre[0]) + 1 = 3 **since all nodes ahead of 2 in post order is within the subtree roots at 2.** (post[4,5,2]). And we mark leftcnt = post.index(pre[0]) + 1 and pass pre[1:lcnt+1], post[:lcnt] down to the left subtree construction. (pre->[2,4,5], post->[4,5,2], preorder and postorder preserve). And rest slice of pre and post[:-1] (post[-1] is root node) belongs to right subtree.\\n\\nWhen preorder list has only one element, it points to a leaf node. And there is no need to build subtree for it. We just return TreeNode(pre[0].val).\\n```\\ndef constructFromPrePost(pre, post):\\n\\tif not pre: return None\\n\\troot = TreeNode(pre[0])\\n\\tif len(pre) > 1:\\n\\t\\tlcnt = post.index(pre[1]) + 1\\n\\t\\troot.left = constructFromPrePost(pre[1:lcnt+1], post[:lcnt])\\n\\t\\troot.right = constructFromPrePost(pre[lcnt+1:], post[lcnt:-1])\\n\\treturn root\\n```",
                "solutionTags": [],
                "code": "```\\n\\t 1\\n\\t/ \\\\\\n   2   3\\n  /\\\\   /\\\\\\n 4  5 6  7\\n```\n```\\ndef constructFromPrePost(pre, post):\\n\\tif not pre: return None\\n\\troot = TreeNode(pre[0])\\n\\tif len(pre) > 1:\\n\\t\\tlcnt = post.index(pre[1]) + 1\\n\\t\\troot.left = constructFromPrePost(pre[1:lcnt+1], post[:lcnt])\\n\\t\\troot.right = constructFromPrePost(pre[lcnt+1:], post[lcnt:-1])\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 225230,
                "title": "clean-java-recursive-solution",
                "content": "\\n```\\nclass Solution {\\n    int preStart;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        preStart = 0;\\n        return helper(pre, post, 0, post.length - 1);\\n    }\\n    \\n    public TreeNode helper(int[] pre, int[] post, int postStart, int postEnd){\\n        if (postStart > postEnd) return null;\\n        \\n        int rootVal = post[postEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        preStart++;\\n        \\n        if (preStart == pre.length || postStart == postEnd){\\n            return root;\\n        }\\n        \\n        int leftVal = pre[preStart];\\n        int tmp = postStart;\\n        for(; tmp <= postEnd; tmp++){\\n            if (post[tmp] == leftVal){\\n                break;\\n            }\\n        }\\n        root.left = helper(pre, post, postStart, tmp);\\n        root.right = helper(pre, post, tmp + 1, postEnd - 1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int preStart;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        preStart = 0;\\n        return helper(pre, post, 0, post.length - 1);\\n    }\\n    \\n    public TreeNode helper(int[] pre, int[] post, int postStart, int postEnd){\\n        if (postStart > postEnd) return null;\\n        \\n        int rootVal = post[postEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        preStart++;\\n        \\n        if (preStart == pre.length || postStart == postEnd){\\n            return root;\\n        }\\n        \\n        int leftVal = pre[preStart];\\n        int tmp = postStart;\\n        for(; tmp <= postEnd; tmp++){\\n            if (post[tmp] == leftVal){\\n                break;\\n            }\\n        }\\n        root.left = helper(pre, post, postStart, tmp);\\n        root.right = helper(pre, post, tmp + 1, postEnd - 1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446533,
                "title": "c-easy-understanding-code-o-n-time-o-n-space",
                "content": "**(1)** First one thing we know that the first element of preorder is root of the tree :)\\n **(2)** Now we have to find the left subtree for this node \\n      Hint : the second element in preorder of that root node always be left node of root. This (second element of preorder) node is lying after all the elements of left subtree in postorder vector ( because of it\\'s arrangement in postorder)\\n**(3)** Now we have to find the right subtree for this node\\n     Hint : all the element of right side of the left element (which we use to make left subtree) in postorder make the right subtree.\\n\\t \\n-->> by recursion for each left and right subtree with boundry condition we can get our tree.\\n-->>The important thing is that we have to make boundry condition for the left subtree and right subtree which we simple make by finding the index of current element in postorder that\\'s why we use hashmap to store index of post order.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    TreeNode* build (vector<int>&pre,vector<int>&post,int &preidx ,int left,int right)\\n    {\\n        if(left>right)\\n            return NULL;\\n        \\n        TreeNode* temp=new TreeNode(pre[preidx]);\\n        if(left==right)\\n            return temp;\\n        \\n        preidx++;\\n        int i=mp[pre[preidx]];                                                      \\n        \\n        temp->left=build(pre,post,preidx,left,i);\\n        temp->right=build(pre,post,preidx,i+1,right-1);\\n        \\n        return temp;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) \\n    {\\n        for(int i=0;i<post.size();i++)\\n        {\\n            mp[post[i]]=i;\\n        }\\n        int preidx=0;\\n        return build(pre,post,preidx,0,pre.size()-1);\\n    }\\n};\\n\\n//Feel free to ask any doubt in comment section;",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    TreeNode* build (vector<int>&pre,vector<int>&post,int &preidx ,int left,int right)\\n    {\\n        if(left>right)\\n            return NULL;\\n        \\n        TreeNode* temp=new TreeNode(pre[preidx]);\\n        if(left==right)\\n            return temp;\\n        \\n        preidx++;\\n        int i=mp[pre[preidx]];                                                      \\n        \\n        temp->left=build(pre,post,preidx,left,i);\\n        temp->right=build(pre,post,preidx,i+1,right-1);\\n        \\n        return temp;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1416245,
                "title": "easy-c-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  TreeNode* construct(vector<int>& pre, vector<int>& post, int s1,int e1,int s2,int e2)\\n  {\\n    if(s1>e1 || s2>e2) return NULL;\\n    TreeNode* root=new TreeNode(pre[s1]);\\n    if(s1==e1) return root;\\n    \\n    int idx=s2;\\n    while(pre[s1+1]!=post[idx])\\n      idx++;\\n    \\n    int b=idx-s2+1;\\n\\n    root->left=construct(pre,post,s1+1,s1+b,s2,idx);\\n    root->right=construct(pre,post,s1+b+1,e1,idx+1,e2-1);\\n    \\n    return root;\\n    \\n  }\\n  \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root= construct(preorder,postorder,0,preorder.size()-1,0,postorder.size()-1);\\n      return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  TreeNode* construct(vector<int>& pre, vector<int>& post, int s1,int e1,int s2,int e2)\\n  {\\n    if(s1>e1 || s2>e2) return NULL;\\n    TreeNode* root=new TreeNode(pre[s1]);\\n    if(s1==e1) return root;\\n    \\n    int idx=s2;\\n    while(pre[s1+1]!=post[idx])\\n      idx++;\\n    \\n    int b=idx-s2+1;\\n\\n    root->left=construct(pre,post,s1+1,s1+b,s2,idx);\\n    root->right=construct(pre,post,s1+b+1,e1,idx+1,e2-1);\\n    \\n    return root;\\n    \\n  }\\n  \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root= construct(preorder,postorder,0,preorder.size()-1,0,postorder.size()-1);\\n      return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939552,
                "title": "full-explanation-best-o-n-solution-no-auxiliary-hash-no-index-search-recursive-python-3",
                "content": "Suggested solutions for this problem are non-optimal. They both use `index` (in the second case, a much worse version by the way). There is no need for that.\\n\\nMy solution iterates both lists forward only, using recursion to reconstruct the tree.\\n\\n```python\\nclass Solution:\\n\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        i, j = 0, 0\\n        def reconstruct():\\n            nonlocal i, j\\n            n = TreeNode(pre[i])\\n            i += 1\\n            if n.val != post[j]:\\n                n.left = reconstruct()\\n                if n.val != post[j]:\\n                    n.right = reconstruct()\\n            j += 1\\n            return n\\n\\n        return reconstruct()\\n```\\n\\nThe essential idea is that `pre` hold values in _descending_ order, and `post` holds _checkpoints_ that indicate when you need to _ascend_ in the reconstructed sub-tree.\\n\\nLet\\'s take for example this tree:\\n```\\n                    1\\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t     2      3\\n\\t\\t\\t    /      /\\n\\t\\t       4      6\\n\\t\\t\\t  / \\\\     \\n\\t\\t     7   5     \\n\\npre=[1,2,4,7,5,3,6]\\npost=[7,5,4,2,6,3,1]\\n```\\t\\t\\t\\t   \\n\\nWe iterate `pre` and create descendant nodes (to the left in this case) until our current node value matches the current value of `post[j]` (`j==0` `post[j] == 7`). That\\'s our first _checkpoint_:\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   /\\n\\t\\t     [7]\\n\\npre=[1,2,4,7,5,3,6]\\n           ^\\npost=[7,5,4,2,6,3,1]\\n      ^\\n```\\n\\nWe are now at node `7`, and `n.val == post[j]`, which means we reached the end of that path and we need to _ascend_ to the parent node, incrementing `j` (now `j=1`, `post[j]==5`) before moving up\\n\\nWe just went back to the parent node `4`, and we need to compare again `post` with `n.val`. They don\\'t match, which means this node still have descendants. Since we have already have a `left` child for node `4`, we need to assign this new node to the right subtree.\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t       [4]\\n\\t\\t\\t   /\\n\\t\\t      7 \\n\\npre=[1,2,4,7,5,3,6]\\n           ^\\npost=[7,5,4,2,6,3,1]\\n        ^\\n```\\n\\nNow we are assigning `5` to the right subtree of node `4`.\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   / \\\\\\n\\t\\t      7  [5]\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n        ^\\n```\\n\\nThe algorithm is recursive, and logic is the same: `n.val == post[j]`, which means we have no more descendants. Then we advance `j` and return to the parent.\\n\\nWe are back to node 4. Notice how `post[j]` matches with the current node in our stack. It is important to realize we are walking back the stack, so the _\"current node in the stack\"_ is not the same thing as our _\"current position in the `pre` list\"_:\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t       [4]\\n\\t\\t\\t   / \\\\\\n\\t\\t      7   5\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n          ^\\n```\\n\\nThat is not a coincidence. This is because our node has both left and right children, and the post-order traversal matches needs to match the current node. We don\\'t even need to check for that in this case. We can just advance `j` again and go up one level in the stack:\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t [2]\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   / \\\\\\n\\t\\t      7   5\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n            ^\\n```\\n\\nIntersting. Our current node matches `post[j]` in this case. That means it has no right child. If it had a right subtree, these numbers wouldn\\'t match (that what has happened to node `4` after processing `7`, right before processing `5`... take a look above).\\nNow that we know node `2` has no right subtree, we just increment `j` and move back to its parent.\\n\\nThe rest of the algorithm is the same (it is recursive :-) ). We will go back to node `1`, realize `post[j]` doesn\\'t match current node value, reconstruct the right subtree for nodes `3` and `6`. Then we start ascending from `6` -> `3` -> `1`\\n\\nIn the final step, we are back to root node `1` and `post[j] == 1` (which is the last index). So we just return the root node. Task is done.\\n\\n---\\n\\nAlso made a version using iterators. Unfortunatelly iterators don\\'t have a `peek` method, (`more_itertools.peekable` would be perfect) so we need to keep a variable with this state.\\n\\n```python\\nclass Solution:\\n\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        pre = map(TreeNode, pre)\\n\\t\\tpost = iter(post)\\n        peek = next(post)\\n\\n        def reconstruct():\\n            nonlocal peek\\n            n = next(pre)\\n            if n.val != peek:\\n                n.left = reconstruct()\\n                if n.val != peek:\\n                    n.right = reconstruct()\\n            peek = next(post, None)\\n            return n\\n\\n        return reconstruct()\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        i, j = 0, 0\\n        def reconstruct():\\n            nonlocal i, j\\n            n = TreeNode(pre[i])\\n            i += 1\\n            if n.val != post[j]:\\n                n.left = reconstruct()\\n                if n.val != post[j]:\\n                    n.right = reconstruct()\\n            j += 1\\n            return n\\n\\n        return reconstruct()\\n```\n```\\n                    1\\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t     2      3\\n\\t\\t\\t    /      /\\n\\t\\t       4      6\\n\\t\\t\\t  / \\\\     \\n\\t\\t     7   5     \\n\\npre=[1,2,4,7,5,3,6]\\npost=[7,5,4,2,6,3,1]\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   /\\n\\t\\t     [7]\\n\\npre=[1,2,4,7,5,3,6]\\n           ^\\npost=[7,5,4,2,6,3,1]\\n      ^\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t       [4]\\n\\t\\t\\t   /\\n\\t\\t      7 \\n\\npre=[1,2,4,7,5,3,6]\\n           ^\\npost=[7,5,4,2,6,3,1]\\n        ^\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   / \\\\\\n\\t\\t      7  [5]\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n        ^\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t       [4]\\n\\t\\t\\t   / \\\\\\n\\t\\t      7   5\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n          ^\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t [2]\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   / \\\\\\n\\t\\t      7   5\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n            ^\\n```\n```python\\nclass Solution:\\n\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        pre = map(TreeNode, pre)\\n\\t\\tpost = iter(post)\\n        peek = next(post)\\n\\n        def reconstruct():\\n            nonlocal peek\\n            n = next(pre)\\n            if n.val != peek:\\n                n.left = reconstruct()\\n                if n.val != peek:\\n                    n.right = reconstruct()\\n            peek = next(post, None)\\n            return n\\n\\n        return reconstruct()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535343,
                "title": "java-recursion-and-iterative",
                "content": "```\\n    int i = 0, j = 0;\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        TreeNode node = new TreeNode(pre[i++]);\\n        if (node.val != post[j]) {\\n            node.left = constructFromPrePost(pre, post);\\n        }\\n        if (node.val != post[j]) {\\n            node.right = constructFromPrePost(pre, post);\\n        }\\n        j++;\\n        return node;\\n    }\\n```\\n\\n```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.offer(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.length; i++){\\n            TreeNode node = new TreeNode(pre[i]);\\n            while(s.getLast().val == post[j]) {\\n                s.pollLast();\\n                j++;  // \\n            }\\n            if (s.getLast().left == null) {\\n                s.getLast().left = node;\\n            } else {\\n                s.getLast().right = node;\\n            }\\n            s.offer(node);\\n        }\\n        return s.getFirst();\\n    }\\n```\\nRef: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/161268/C%2B%2BJavaPython-One-Pass-Real-O(N)",
                "solutionTags": [],
                "code": "```\\n    int i = 0, j = 0;\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        TreeNode node = new TreeNode(pre[i++]);\\n        if (node.val != post[j]) {\\n            node.left = constructFromPrePost(pre, post);\\n        }\\n        if (node.val != post[j]) {\\n            node.right = constructFromPrePost(pre, post);\\n        }\\n        j++;\\n        return node;\\n    }\\n```\n```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.offer(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.length; i++){\\n            TreeNode node = new TreeNode(pre[i]);\\n            while(s.getLast().val == post[j]) {\\n                s.pollLast();\\n                j++;  // \\n            }\\n            if (s.getLast().left == null) {\\n                s.getLast().left = node;\\n            } else {\\n                s.getLast().right = node;\\n            }\\n            s.offer(node);\\n        }\\n        return s.getFirst();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 357699,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    int pre[];\\n    int post[];\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        this.pre = pre;\\n        this.post = post;\\n        return helper(0, pre.length-1, 0, post.length-1);\\n    }\\n    \\n    public TreeNode helper(int pre_start, int pre_end, int post_start, int post_end){\\n        if (post_start > post_end){\\n            return null;\\n        }\\n        \\n        int cur = pre[pre_start];\\n        TreeNode root = new TreeNode(cur);\\n        if (pre_start == pre_end){\\n            return root;\\n        }\\n        int left = pre[pre_start+1];\\n        int index = 0;\\n        for(int i = post_start; i<=post_end; i++){\\n            if (post[i]==left){\\n                index = i;\\n            }\\n        }\\n        root.left = helper(pre_start+1, pre_start+index-post_start+1, post_start, index);\\n        root.right = helper(pre_start+index-post_start+2, pre_end, index+1, post_end-1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int pre[];\\n    int post[];\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        this.pre = pre;\\n        this.post = post;\\n        return helper(0, pre.length-1, 0, post.length-1);\\n    }\\n    \\n    public TreeNode helper(int pre_start, int pre_end, int post_start, int post_end){\\n        if (post_start > post_end){\\n            return null;\\n        }\\n        \\n        int cur = pre[pre_start];\\n        TreeNode root = new TreeNode(cur);\\n        if (pre_start == pre_end){\\n            return root;\\n        }\\n        int left = pre[pre_start+1];\\n        int index = 0;\\n        for(int i = post_start; i<=post_end; i++){\\n            if (post[i]==left){\\n                index = i;\\n            }\\n        }\\n        root.left = helper(pre_start+1, pre_start+index-post_start+1, post_start, index);\\n        root.right = helper(pre_start+index-post_start+2, pre_end, index+1, post_end-1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161379,
                "title": "recursive-easy-to-understand-with-explanation-c",
                "content": "The idea here is that you find preLeft, preRight and postLeft, postRight in every iteration and use preLeft as your root. \\nUse post to get the length of the left subtree, and then use that to recurse. \\n\\nNote that using preorder and postorder we can only find a tree w/o ambiguity if the tree is a full binary tree. The question says that its guaranteed to have an answer.\\n\\n```\\npublic class Solution {\\n\\n    public TreeNode ConstructFromPrePost(int[] pre, int[] post) {\\n        \\n\\t\\treturn ConstructTreeUtil(pre, post, 0, pre.Length-1,  0, post.Length-1);\\n    }\\n\\t\\n\\tprivate TreeNode ConstructTreeUtil(int[] pre, int[] post, int preLeft, int preRight, int postLeft, int postRight)\\n\\t{\\n\\t\\tif(preLeft > preRight || postLeft > postRight)\\t\\treturn null;\\n\\t\\t\\n\\t\\tvar root = new TreeNode(pre[preLeft]);\\n\\n\\t\\tif(preLeft < preRight)\\n\\t\\t{\\n\\t\\t\\tvar leftRootIndexinPost = Array.IndexOf(post, pre[preLeft+1]);\\t\\t\\t// Use this to split;\\n\\t\\t\\tvar len \\t    = leftRootIndexinPost - postLeft;\\n\\t\\n\\t\\t\\troot.left  = ConstructTreeUtil(pre, post, preLeft+1, preLeft+1+len, postLeft, postLeft+len);\\n\\t\\t\\troot.right = ConstructTreeUtil(pre, post, preLeft+len+2, preRight, postLeft+len+1, postRight-1);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn root;\\n\\t}\\n}\\n```\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public TreeNode ConstructFromPrePost(int[] pre, int[] post) {\\n        \\n\\t\\treturn ConstructTreeUtil(pre, post, 0, pre.Length-1,  0, post.Length-1);\\n    }\\n\\t\\n\\tprivate TreeNode ConstructTreeUtil(int[] pre, int[] post, int preLeft, int preRight, int postLeft, int postRight)\\n\\t{\\n\\t\\tif(preLeft > preRight || postLeft > postRight)\\t\\treturn null;\\n\\t\\t\\n\\t\\tvar root = new TreeNode(pre[preLeft]);\\n\\n\\t\\tif(preLeft < preRight)\\n\\t\\t{\\n\\t\\t\\tvar leftRootIndexinPost = Array.IndexOf(post, pre[preLeft+1]);\\t\\t\\t// Use this to split;\\n\\t\\t\\tvar len \\t    = leftRootIndexinPost - postLeft;\\n\\t\\n\\t\\t\\troot.left  = ConstructTreeUtil(pre, post, preLeft+1, preLeft+1+len, postLeft, postLeft+len);\\n\\t\\t\\troot.right = ConstructTreeUtil(pre, post, preLeft+len+2, preRight, postLeft+len+1, postRight-1);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn root;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963421,
                "title": "best-c-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& post, int start, int end, int element){\\n        for(int i = start; i <= end; i++){\\n            if(post[i] == element)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\n    int preIndex = 0;\\n    \\n    TreeNode* solve(vector<int>& pre, vector<int>& post, int start, int end){\\n        // base case\\n        if(start > end || preIndex >= pre.size())\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if(preIndex >= pre.size() || start == end)\\n            return root;\\n        int pos = search(post, start, end, pre[preIndex]);\\n        \\n        root->left = solve(pre, post, start, pos);\\n        root->right = solve(pre, post, pos + 1, end - 1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        return solve(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& post, int start, int end, int element){\\n        for(int i = start; i <= end; i++){\\n            if(post[i] == element)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\n    int preIndex = 0;\\n    \\n    TreeNode* solve(vector<int>& pre, vector<int>& post, int start, int end){\\n        // base case\\n        if(start > end || preIndex >= pre.size())\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if(preIndex >= pre.size() || start == end)\\n            return root;\\n        int pos = search(post, start, end, pre[preIndex]);\\n        \\n        root->left = solve(pre, post, start, pos);\\n        root->right = solve(pre, post, pos + 1, end - 1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        return solve(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066956,
                "title": "simple-approach-o-n-time-preorder-traversal",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pre_idx=0,post_idx=0;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root=new TreeNode(preorder[pre_idx++]);\\n        if(root->val!=postorder[post_idx]){\\n            root->left=constructFromPrePost(preorder,postorder);\\n        }\\n        if(root->val!=postorder[post_idx]){\\n            root->right=constructFromPrePost(preorder,postorder);\\n        }\\n\\n        post_idx++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pre_idx=0,post_idx=0;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root=new TreeNode(preorder[pre_idx++]);\\n        if(root->val!=postorder[post_idx]){\\n            root->left=constructFromPrePost(preorder,postorder);\\n        }\\n        if(root->val!=postorder[post_idx]){\\n            root->right=constructFromPrePost(preorder,postorder);\\n        }\\n\\n        post_idx++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351831,
                "title": "java-explanation-no-hashmap-easy-to-implement",
                "content": "**Intuition**\\n\\nThere are two keys in this problem:\\n\\n(1) First element of preorder is **root**.\\n(2) The **first element of left-subtree** of **preorder[ ]** is the **last element of left-subtree**. It\\'s because the order difference between preorder traversal and postorder traversal. \\nFor example, we have `preorder = [1,2,4,5,3,6,7]` and `postorder = [4,5,2,6,7,3,1]`.\\nNow, we know `1` is **root** and `2` is **first element of left-subtree**.\\n\\nQ. How do we figure out the **left-subtree** and **right-subtree** at this point?\\n\\nA. **Preorder** means we process the **root** -> **left** -> **right**, and because of preorder traversal we can identify the **root** node. **Postorder** process **left** -> **right** -> **root**. Therefore, `[2]` is the first node in left-subtree from **preorder**, and `[2]` is also the last node of left-subtree in **postorder**. \\nTherefore, `[4, 5, 2]` are all left-subtree elements.\\n\\n![image](https://assets.leetcode.com/users/images/585f2b5b-0541-4e92-b123-c95b89b02b13_1660051589.8914473.png)\\n\\n\\nLeave the questions below. I\\'ll try my best to answer the questions within **100 days**. \\n\\n```\\nclass Solution \\n{\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder)\\n    {\\n        // O(n) time | O(h) space\\n        if(preorder == null || postorder == null || preorder.length == 0 || postorder.length == 0)  return null;\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        int mid = 0;\\n        \\n        if(preorder.length == 1)    return root;\\n        \\n        // update mid\\n        for(int i = 0; i < postorder.length; i++)\\n        {\\n            if(preorder[1] == postorder[i])\\n            {\\n                mid = i;\\n                break;\\n            }\\n        }\\n        \\n        root.left = constructFromPrePost(\\n                                            Arrays.copyOfRange(preorder, 1, 1 + mid + 1),\\n                                            Arrays.copyOfRange(postorder, 0, mid + 1));\\n        \\n        root.right = constructFromPrePost(\\n                                            Arrays.copyOfRange(preorder, 1 + mid + 1, preorder.length),\\n                                            Arrays.copyOfRange(postorder, mid + 1, postorder.length - 1));\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder)\\n    {\\n        // O(n) time | O(h) space\\n        if(preorder == null || postorder == null || preorder.length == 0 || postorder.length == 0)  return null;\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        int mid = 0;\\n        \\n        if(preorder.length == 1)    return root;\\n        \\n        // update mid\\n        for(int i = 0; i < postorder.length; i++)\\n        {\\n            if(preorder[1] == postorder[i])\\n            {\\n                mid = i;\\n                break;\\n            }\\n        }\\n        \\n        root.left = constructFromPrePost(\\n                                            Arrays.copyOfRange(preorder, 1, 1 + mid + 1),\\n                                            Arrays.copyOfRange(postorder, 0, mid + 1));\\n        \\n        root.right = constructFromPrePost(\\n                                            Arrays.copyOfRange(preorder, 1 + mid + 1, preorder.length),\\n                                            Arrays.copyOfRange(postorder, mid + 1, postorder.length - 1));\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741226,
                "title": "c-easy-recursive-one-pass",
                "content": "```\\n#define null nullptr\\nclass Solution {\\npublic:\\n    int i = 0;\\n    TreeNode* help(vector<int>& pre, vector<int>& post,int start,int end){\\n        //BAse Case\\n        if(start>end) return null;\\n        if(i>=pre.size()) return null;\\n        int j =-1;\\n        for(int k = start;k<=end;k++)\\n            if(pre[i]==post[k]){\\n                j=k;\\n                break;\\n            }\\n        if(j==-1) return null;\\n        i++;\\n        TreeNode* root = new TreeNode(post[j]);\\n        TreeNode* l = help(pre,post,start,j-1);\\n        root->left=l;\\n        TreeNode* r = help(pre,post,start,j-1);\\n        root->right=r;\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return help(pre,post,0,post.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n#define null nullptr\\nclass Solution {\\npublic:\\n    int i = 0;\\n    TreeNode* help(vector<int>& pre, vector<int>& post,int start,int end){\\n        //BAse Case\\n        if(start>end) return null;\\n        if(i>=pre.size()) return null;\\n        int j =-1;\\n        for(int k = start;k<=end;k++)\\n            if(pre[i]==post[k]){\\n                j=k;\\n                break;\\n            }\\n        if(j==-1) return null;\\n        i++;\\n        TreeNode* root = new TreeNode(post[j]);\\n        TreeNode* l = help(pre,post,start,j-1);\\n        root->left=l;\\n        TreeNode* r = help(pre,post,start,j-1);\\n        root->right=r;\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return help(pre,post,0,post.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647023,
                "title": "concise-java-solution-with-explanation",
                "content": "**Explanation** - We know that first element in pre array is the root. We also know that second element in the pre array is the root of the left subtree. Now if we can find this second element in the post array then all elements before it and including it would belong to the left sub tree and all elements after it (excluding the last element which is the root) will be the elements in the right subtree. We can apply this logic recursively while processing each element in the pre array and build the tree. We use a hashmap for fast lookups in the post array.\\n```\\nclass Solution {\\n\\n    private Map<Integer,Integer> postMap = new HashMap<>();\\n    private int preIdx;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        IntStream.range(0, post.length).forEach(i -> postMap.put(post[i], i));\\n        return buildTree(0, post.length - 1, pre, post);\\n    }\\n    \\n    private TreeNode buildTree(int lo, int hi, int[] pre, int[] post) {\\n        if (preIdx == pre.length || lo > hi) return null;\\n        \\n        TreeNode root = new TreeNode(pre[preIdx++]);\\n        if (lo == hi) return root;\\n        \\n        int leftSubRootPostIdx = postMap.get(pre[preIdx]);\\n        \\n        root.left = buildTree(lo, leftSubRootPostIdx, pre, post);\\n        root.right = buildTree(leftSubRootPostIdx + 1, hi - 1, pre, post);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private Map<Integer,Integer> postMap = new HashMap<>();\\n    private int preIdx;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        IntStream.range(0, post.length).forEach(i -> postMap.put(post[i], i));\\n        return buildTree(0, post.length - 1, pre, post);\\n    }\\n    \\n    private TreeNode buildTree(int lo, int hi, int[] pre, int[] post) {\\n        if (preIdx == pre.length || lo > hi) return null;\\n        \\n        TreeNode root = new TreeNode(pre[preIdx++]);\\n        if (lo == hi) return root;\\n        \\n        int leftSubRootPostIdx = postMap.get(pre[preIdx]);\\n        \\n        root.left = buildTree(lo, leftSubRootPostIdx, pre, post);\\n        root.right = buildTree(leftSubRootPostIdx + 1, hi - 1, pre, post);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486725,
                "title": "c-o-n-solution-faster-than-92-c-submission-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n     int  preindx=0,postindx=0;\\n      TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n         \\n          TreeNode *root = new TreeNode(preorder[preindx++]);\\n          if(root->val!=postorder[postindx]){\\n              root->left=constructFromPrePost(preorder,postorder);\\n          }\\n          if(root->val!=postorder[postindx]){\\n              root->right=constructFromPrePost(preorder,postorder);\\n          }\\n            postindx++;\\n          return root;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int  preindx=0,postindx=0;\\n      TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n         \\n          TreeNode *root = new TreeNode(preorder[preindx++]);\\n          if(root->val!=postorder[postindx]){\\n              root->left=constructFromPrePost(preorder,postorder);\\n          }\\n          if(root->val!=postorder[postindx]){\\n              root->right=constructFromPrePost(preorder,postorder);\\n          }\\n            postindx++;\\n          return root;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467524,
                "title": "simple-c-solution-with-comments-recursive-map",
                "content": "\\tTreeNode* func(vector<int> &preorder, int prestart,int preend,vector<int> &postorder,int poststart,int postend, map<int,int> &postmap) {\\n        if(prestart>preend || poststart>postend) {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[prestart]); // Considering first element of preorder to be root of tree\\n        if(prestart+1<=preend) { \\n\\t\\t\\tint newroot=preorder[prestart+1];   // considering second element of preorder to be root of left subtree\\n\\t\\t\\tint postroot=postmap[newroot];\\n\\t\\t\\tint numsleft=postroot-poststart;\\n\\t\\t\\troot->left=func(preorder,prestart+1,prestart+numsleft+1,postorder,poststart,postroot,postmap); \\n\\t\\t\\troot->right=func(preorder,prestart+numsleft+2,preend,postorder,postroot+1,postend-1,postmap);\\n\\t\\t}\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        map<int,int> postmap;\\n        for(int i=0;i<postorder.size();i++) {\\n            postmap[postorder[i]]=i;\\n        }\\n        return func(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1,postmap);\\n    }",
                "solutionTags": [],
                "code": "\\tTreeNode* func(vector<int> &preorder, int prestart,int preend,vector<int> &postorder,int poststart,int postend, map<int,int> &postmap) {\\n        if(prestart>preend || poststart>postend) {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[prestart]); // Considering first element of preorder to be root of tree\\n        if(prestart+1<=preend) { \\n\\t\\t\\tint newroot=preorder[prestart+1];   // considering second element of preorder to be root of left subtree\\n\\t\\t\\tint postroot=postmap[newroot];\\n\\t\\t\\tint numsleft=postroot-poststart;\\n\\t\\t\\troot->left=func(preorder,prestart+1,prestart+numsleft+1,postorder,poststart,postroot,postmap); \\n\\t\\t\\troot->right=func(preorder,prestart+numsleft+2,preend,postorder,postroot+1,postend-1,postmap);\\n\\t\\t}\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        map<int,int> postmap;\\n        for(int i=0;i<postorder.size();i++) {\\n            postmap[postorder[i]]=i;\\n        }\\n        return func(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1,postmap);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1287488,
                "title": "java-recursive-solution",
                "content": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return preOrPost(pre,0,pre.length-1,post,0,pre.length-1);\\n    }\\n    \\n    public TreeNode preOrPost(int[] pre,int preStart,int preEnd,int[] post,int postStart,int postEnd){\\n        if(preStart>preEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(pre[preStart]);\\n        if(preStart==preEnd){\\n            return root;\\n        }\\n        \\n        int idx=postStart;\\n        while(post[idx]!=pre[preStart+1]){\\n            idx++;\\n        }\\n        \\n        int len=idx-postStart+1;\\n        root.left=preOrPost(pre,preStart+1,preStart+len,post,postStart,idx);\\n        root.right=preOrPost(pre,preStart+len+1,preEnd,post,idx+1,postEnd-1);\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return preOrPost(pre,0,pre.length-1,post,0,pre.length-1);\\n    }\\n    \\n    public TreeNode preOrPost(int[] pre,int preStart,int preEnd,int[] post,int postStart,int postEnd){\\n        if(preStart>preEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(pre[preStart]);\\n        if(preStart==preEnd){\\n            return root;\\n        }\\n        \\n        int idx=postStart;\\n        while(post[idx]!=pre[preStart+1]){\\n            idx++;\\n        }\\n        \\n        int len=idx-postStart+1;\\n        root.left=preOrPost(pre,preStart+1,preStart+len,post,postStart,idx);\\n        root.right=preOrPost(pre,preStart+len+1,preEnd,post,idx+1,postEnd-1);\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946726,
                "title": "python3-consistent-soln-for-105-106-and-889",
                "content": "**Background**\\nGiven a binary tree, there are 3 orders to traverse it: preorder, inorder and postorder, all of which are widely used in practice. Conversely, if a traversal result is provided, one cannot recreate the binary tree as differently structued binary trees could result in the same traversal. But if two traversals are given, then it is possible to build the tree, which is what 105, 106 and 889 on LC are about. \\n\\n[105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)\\n[106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\\n[889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\\n\\n**Iterative approach**\\nHere, we scan through one vector while using the other one to decide to go deeper on the tree or retrace to higher level. In this iterative approach we use a stack to store the nodes that we\\'ve visited and can potentially go back to. \\n\\n105 \\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \\n\\t\\troot = None\\n\\t    stack = []\\n        for x in preorder: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while stack and mp[stack[-1].val] < mp[x]: node = stack.pop() # retrace \\n                node.right = node = TreeNode(x)\\n            stack.append(node)\\n        return root\\n```\\n\\n106 \\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \\n        root = None\\n        stack = []\\n        for x in reversed(postorder): \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] > mp[stack[-1].val]: stack[-1].right = node = TreeNode(x)\\n            else: \\n                while stack and mp[stack[-1].val] > mp[x]: node = stack.pop() # retrace \\n                node.left = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```\\n\\n889 \\n```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(post)}\\n        root = None \\n        stack = []\\n        for x in pre: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while mp[stack[-1].val] < mp[x]: stack.pop() # retrace \\n                stack[-1].right = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```\\n\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \\n\\t\\troot = None\\n\\t    stack = []\\n        for x in preorder: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while stack and mp[stack[-1].val] < mp[x]: node = stack.pop() # retrace \\n                node.right = node = TreeNode(x)\\n            stack.append(node)\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \\n        root = None\\n        stack = []\\n        for x in reversed(postorder): \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] > mp[stack[-1].val]: stack[-1].right = node = TreeNode(x)\\n            else: \\n                while stack and mp[stack[-1].val] > mp[x]: node = stack.pop() # retrace \\n                node.left = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```\n```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(post)}\\n        root = None \\n        stack = []\\n        for x in pre: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while mp[stack[-1].val] < mp[x]: stack.pop() # retrace \\n                stack[-1].right = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 643903,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return construct(pre, 0, pre.size()-1, post, 0, post.size()-1);\\n    }\\n    \\n    TreeNode* construct(vector<int>& pre, int prei, int prej, \\n                        vector<int>& post, int posti, int postj){\\n        if (prei>prej) return NULL;\\n        TreeNode* root = new TreeNode(pre[prei]);\\n        if (prei==prej){\\n            root->left = NULL; root->right = NULL;\\n            return root;\\n        } \\n        int mid = 1;\\n        for (int i=1; i<=prej-prei; i++){\\n            if (pre[prei+i]==post[postj-1] && (i<2 || post[posti+i-2]==pre[prei+1])){\\n                mid = i; break;\\n            }\\n        }\\n        root->left = construct(pre, prei+1, prei+mid-1, post, posti, posti+mid-2);\\n        root->right = construct(pre, prei+mid, prej, post, posti+mid-1, postj-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return construct(pre, 0, pre.size()-1, post, 0, post.size()-1);\\n    }\\n    \\n    TreeNode* construct(vector<int>& pre, int prei, int prej, \\n                        vector<int>& post, int posti, int postj){\\n        if (prei>prej) return NULL;\\n        TreeNode* root = new TreeNode(pre[prei]);\\n        if (prei==prej){\\n            root->left = NULL; root->right = NULL;\\n            return root;\\n        } \\n        int mid = 1;\\n        for (int i=1; i<=prej-prei; i++){\\n            if (pre[prei+i]==post[postj-1] && (i<2 || post[posti+i-2]==pre[prei+1])){\\n                mid = i; break;\\n            }\\n        }\\n        root->left = construct(pre, prei+1, prei+mid-1, post, posti, posti+mid-2);\\n        root->right = construct(pre, prei+mid, prej, post, posti+mid-1, postj-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617458,
                "title": "javascript-solution",
                "content": "```\\nvar constructFromPrePost = function(pre, post) {\\n  return prePostTreeBuilder(0, pre.length - 1, 0, post.length - 1);\\n  \\n  function prePostTreeBuilder(preStart, preEnd, postStart, postEnd) {\\n    if (preStart > preEnd) return null;\\n    \\n    const root = new TreeNode(pre[preStart]);\\n    if (preStart == preEnd) return root;\\n    \\n    const leftVal = pre[preStart + 1];\\n    let leftPostIndex;\\n    \\n    for (leftPostIndex = postStart; leftPostIndex <= postEnd; leftPostIndex++) {\\n      if (post[leftPostIndex] === leftVal) break;\\n    }\\n    \\n    const leftTreeSize = leftPostIndex - postStart;\\n    \\n    const preLeftStart = preStart + 1;\\n    const preLeftEnd = preLeftStart + leftTreeSize;\\n    const leftPostStart = postStart;\\n    const leftPostEnd = leftPostIndex;\\n    \\n    const preRightStart = preLeftEnd + 1;\\n    const preRightEnd = preEnd;\\n    const postRightStart = leftPostIndex + 1;\\n    const postRightEnd = postEnd - 1;\\n    \\n    root.left = prePostTreeBuilder(preLeftStart, preLeftEnd, leftPostStart, leftPostEnd);\\n    root.right = prePostTreeBuilder(preRightStart, preRightEnd, postRightStart, postRightEnd);\\n    \\n    return root;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar constructFromPrePost = function(pre, post) {\\n  return prePostTreeBuilder(0, pre.length - 1, 0, post.length - 1);\\n  \\n  function prePostTreeBuilder(preStart, preEnd, postStart, postEnd) {\\n    if (preStart > preEnd) return null;\\n    \\n    const root = new TreeNode(pre[preStart]);\\n    if (preStart == preEnd) return root;\\n    \\n    const leftVal = pre[preStart + 1];\\n    let leftPostIndex;\\n    \\n    for (leftPostIndex = postStart; leftPostIndex <= postEnd; leftPostIndex++) {\\n      if (post[leftPostIndex] === leftVal) break;\\n    }\\n    \\n    const leftTreeSize = leftPostIndex - postStart;\\n    \\n    const preLeftStart = preStart + 1;\\n    const preLeftEnd = preLeftStart + leftTreeSize;\\n    const leftPostStart = postStart;\\n    const leftPostEnd = leftPostIndex;\\n    \\n    const preRightStart = preLeftEnd + 1;\\n    const preRightEnd = preEnd;\\n    const postRightStart = leftPostIndex + 1;\\n    const postRightEnd = postEnd - 1;\\n    \\n    root.left = prePostTreeBuilder(preLeftStart, preLeftEnd, leftPostStart, leftPostEnd);\\n    root.right = prePostTreeBuilder(preRightStart, preRightEnd, postRightStart, postRightEnd);\\n    \\n    return root;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168714,
                "title": "java-recursive-time-o-n-space-o-n-solution",
                "content": "```java\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if (pre == null || pre.length == 0 || post == null || post.length == 0 || pre.length != post.length) {\\n            return null;\\n        }\\n        \\n        HashMap<Integer, Integer> postMap = new HashMap<>();\\n        \\n        for (int i = 0; i < post.length; i++) {\\n            postMap.put(post[i], i);\\n        }\\n        \\n        return buildTreeHelper(pre, 0, pre.length - 1, post, 0, postMap);\\n    }\\n    \\n    public TreeNode buildTreeHelper(int[] pre, int preStart, int preEnd, int[] post, int postStart, HashMap<Integer, Integer> postMap) {\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        \\n        TreeNode node = new TreeNode(pre[preStart]);\\n        \\n        if (preStart == preEnd) {\\n            return node;\\n        }\\n        \\n        int leftChildPostIndex = postMap.get(pre[preStart + 1]);\\n        int numLeft = leftChildPostIndex - postStart + 1;\\n        \\n        node.left = buildTreeHelper(pre, preStart + 1, preStart + numLeft, post, postStart, postMap);\\n        node.right = buildTreeHelper(pre, preStart + numLeft + 1, preEnd, post, leftChildPostIndex + 1, postMap);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if (pre == null || pre.length == 0 || post == null || post.length == 0 || pre.length != post.length) {\\n            return null;\\n        }\\n        \\n        HashMap<Integer, Integer> postMap = new HashMap<>();\\n        \\n        for (int i = 0; i < post.length; i++) {\\n            postMap.put(post[i], i);\\n        }\\n        \\n        return buildTreeHelper(pre, 0, pre.length - 1, post, 0, postMap);\\n    }\\n    \\n    public TreeNode buildTreeHelper(int[] pre, int preStart, int preEnd, int[] post, int postStart, HashMap<Integer, Integer> postMap) {\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        \\n        TreeNode node = new TreeNode(pre[preStart]);\\n        \\n        if (preStart == preEnd) {\\n            return node;\\n        }\\n        \\n        int leftChildPostIndex = postMap.get(pre[preStart + 1]);\\n        int numLeft = leftChildPostIndex - postStart + 1;\\n        \\n        node.left = buildTreeHelper(pre, preStart + 1, preStart + numLeft, post, postStart, postMap);\\n        node.right = buildTreeHelper(pre, preStart + numLeft + 1, preEnd, post, leftChildPostIndex + 1, postMap);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165409,
                "title": "one-pass-o-n-recursive-solution-beats-100-c-submissions",
                "content": "I simply traverse both arrays and recursively create a new node for each new item in preorder array. I use postorder array to identify when to return from my recursive function, as if current node\\'s value equals to post[j] it means we\\'ve seen all its children already.\\n\\n**Complexity:**\\nO(N) Time O(N) Space\\n\\n**C#**\\n```\\n        public TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {\\n            int i = 0;\\n            int j = 0;\\n            return ConstructTree(pre, ref i, post, ref j);\\n        }\\n\\n        private TreeNode ConstructTree(int[] pre, ref int i, int[] post, ref int j)\\n        {\\n            TreeNode node = new TreeNode(pre[i++]);\\n            if(node.val == post[j])\\n            {\\n                j++;\\n                return node;\\n            }\\n            node.left = ConstructTree(pre, ref i, post, ref j);\\n            if(node.val == post[j])\\n            {\\n                j++;\\n                return node;\\n            }\\n            node.right = ConstructTree(pre, ref i, post, ref j);\\n            j++;\\n            return node;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {\\n            int i = 0;\\n            int j = 0;\\n            return ConstructTree(pre, ref i, post, ref j);\\n        }\\n\\n        private TreeNode ConstructTree(int[] pre, ref int i, int[] post, ref int j)\\n        {\\n            TreeNode node = new TreeNode(pre[i++]);\\n            if(node.val == post[j])\\n            {\\n                j++;\\n                return node;\\n            }\\n            node.left = ConstructTree(pre, ref i, post, ref j);\\n            if(node.val == post[j])\\n            {\\n                j++;\\n                return node;\\n            }\\n            node.right = ConstructTree(pre, ref i, post, ref j);\\n            j++;\\n            return node;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161282,
                "title": "javascript-solution-use-recursion",
                "content": "```\\nvar constructFromPrePost = function(pre, post) {\\n    if(pre.length===0) return null;\\n    if(pre.length===1) return new TreeNode(pre[0]);\\n    let res = new TreeNode(pre[0]);\\n    let leftVal = pre[1], indexOfLeft = post.indexOf(leftVal);\\n    res.left = constructFromPrePost(pre.slice(1, indexOfLeft+2), post.slice(0,indexOfLeft+1));\\n    res.right = constructFromPrePost(pre.slice(indexOfLeft+2), post.slice(indexOfLeft+1));\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar constructFromPrePost = function(pre, post) {\\n    if(pre.length===0) return null;\\n    if(pre.length===1) return new TreeNode(pre[0]);\\n    let res = new TreeNode(pre[0]);\\n    let leftVal = pre[1], indexOfLeft = post.indexOf(leftVal);\\n    res.left = constructFromPrePost(pre.slice(1, indexOfLeft+2), post.slice(0,indexOfLeft+1));\\n    res.right = constructFromPrePost(pre.slice(indexOfLeft+2), post.slice(indexOfLeft+1));\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3305293,
                "title": "beats-100-java-solution-using-recursion-simple-and-clean-code",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) - recursion stack space\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode f(int[] pre, int[] post, int preS, int preE, int postS, int postE){\\n      if(postS>postE) return null;\\n      int rootVal=pre[preS];\\n      TreeNode root=new TreeNode(rootVal);\\n      if(preS==preE) return root;\\n      int p=postS;\\n      for(int i=postS; i<=postE-1; i++){\\n        if(pre[preS+1]==post[i]) {\\n          p=i;\\n          break;\\n        }\\n      }\\n\\n      int lPostS=postS;\\n      int lPostE=p;\\n      int rPostS=p+1;\\n      int rPostE=postE-1;\\n      int lPreS=preS+1;\\n      int lPreE=lPostE-lPostS+preS+1;\\n      int rPreS=lPreE+1;\\n      int rPreE=preE;\\n      root.left=f(pre, post, lPreS, lPreE, lPostS, lPostE);\\n      root.right=f(pre, post, rPreS, rPreE, rPostS, rPostE);\\n      return root;\\n    }\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n      return f(preorder, postorder, 0, preorder.length-1, 0, preorder.length-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode f(int[] pre, int[] post, int preS, int preE, int postS, int postE){\\n      if(postS>postE) return null;\\n      int rootVal=pre[preS];\\n      TreeNode root=new TreeNode(rootVal);\\n      if(preS==preE) return root;\\n      int p=postS;\\n      for(int i=postS; i<=postE-1; i++){\\n        if(pre[preS+1]==post[i]) {\\n          p=i;\\n          break;\\n        }\\n      }\\n\\n      int lPostS=postS;\\n      int lPostE=p;\\n      int rPostS=p+1;\\n      int rPostE=postE-1;\\n      int lPreS=preS+1;\\n      int lPreE=lPostE-lPostS+preS+1;\\n      int rPreS=lPreE+1;\\n      int rPreE=preE;\\n      root.left=f(pre, post, lPreS, lPreE, lPostS, lPostE);\\n      root.right=f(pre, post, rPreS, rPreE, rPostS, rPostE);\\n      return root;\\n    }\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n      return f(preorder, postorder, 0, preorder.length-1, 0, preorder.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814735,
                "title": "c-simple-solution-using-divide-and-conquer",
                "content": "Idea: - \\n1. Create the node from preorder array starting from index 0\\n2. Then search next elment of preorder array in the postorder\\n3. Now the elment present in postorder left to that element(including) is part of left subtree of node and element present on the right side of that element in postorder before the node val is part of right subtree of node\\n\\nFor ex: - Pre [ ] = [1 2 3 4 5 6 7 8] post[ ] = [3 5 4 2 7 8 6 1]  \\n                                             \\n\\tNow, create the root node 1\\n\\tand search 2 in postorder ( 2 is at index 3), the element 3 4 5 2 are in left subtree of 1 and 6 7 8 are in right subtree of 1;\\n\\tthis same will be repeated for 2 and all the elements\\n\\t```\\n\\t\\n\\t                                           1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/      \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 2\\t        6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /    \\\\\\t  /    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3      4    7      8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t5\\n\\t\\n\\t int preIdx = 0;\\n      \\n    int search(vector<int> &postorder, int key, int start, int end)\\n    {\\n        for(int i=start; i<= end; i++)\\n        {\\n            if(postorder[i] == key)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    TreeNode* constructing(vector<int> pre, vector<int> post, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return NULL;\\n        }\\n        if(start == end)\\n        {\\n            return new TreeNode(pre[preIdx++]);\\n        }\\n        \\n        TreeNode* root = new TreeNode(pre[preIdx++]);\\n        int idx2 = search(post, pre[preIdx],start, end);\\n        \\n        root->left = constructing(pre, post, start, idx2);\\n        root->right = constructing(pre, post, idx2+1, end-1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root = constructing(preorder, postorder, 0, postorder.size()-1);\\n        return root;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\t\\n\\t                                           1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/      \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 2\\t        6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /    \\\\\\t  /    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3      4    7      8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t5\\n\\t\\n\\t int preIdx = 0;\\n      \\n    int search(vector<int> &postorder, int key, int start, int end)\\n    {\\n        for(int i=start; i<= end; i++)\\n        {\\n            if(postorder[i] == key)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    TreeNode* constructing(vector<int> pre, vector<int> post, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return NULL;\\n        }\\n        if(start == end)\\n        {\\n            return new TreeNode(pre[preIdx++]);\\n        }\\n        \\n        TreeNode* root = new TreeNode(pre[preIdx++]);\\n        int idx2 = search(post, pre[preIdx],start, end);\\n        \\n        root->left = constructing(pre, post, start, idx2);\\n        root->right = constructing(pre, post, idx2+1, end-1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root = constructing(preorder, postorder, 0, postorder.size()-1);\\n        return root;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2538437,
                "title": "c-easy-to-understand-code",
                "content": "```\\nclass Solution {\\npublic:\\n  map<int,int> mp;\\n  TreeNode* solve(vector<int>&preorder,vector<int>&postorder,int prestart,int preend,int poststart,int postend){\\n    if(prestart>preend)return NULL;\\n    TreeNode*root=new TreeNode(preorder[prestart]);\\n    if(prestart==preend)return root;\\n    int idx=mp[preorder[prestart+1]];\\n    int offset=idx-poststart;\\n    root->left=solve(preorder,postorder,prestart+1,prestart+1+offset,poststart,idx);\\n    root->right=solve(preorder,postorder,prestart+1+offset+1,preend,idx+1,postend-1);\\n    return root;\\n  }\\n  \\n  \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<postorder.size();i++)mp[postorder[i]]=i;\\n      \\n      int prestart=0,poststart=0;\\n      int preend=preorder.size()-1;\\n      int postend=postorder.size()-1;\\n      \\n        return solve(preorder,postorder,prestart,preend,poststart,postend);\\n    }\\n};\\n```\\n\\n**DO UPVOTE IF HELPFULL**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  map<int,int> mp;\\n  TreeNode* solve(vector<int>&preorder,vector<int>&postorder,int prestart,int preend,int poststart,int postend){\\n    if(prestart>preend)return NULL;\\n    TreeNode*root=new TreeNode(preorder[prestart]);\\n    if(prestart==preend)return root;\\n    int idx=mp[preorder[prestart+1]];\\n    int offset=idx-poststart;\\n    root->left=solve(preorder,postorder,prestart+1,prestart+1+offset,poststart,idx);\\n    root->right=solve(preorder,postorder,prestart+1+offset+1,preend,idx+1,postend-1);\\n    return root;\\n  }\\n  \\n  \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<postorder.size();i++)mp[postorder[i]]=i;\\n      \\n      int prestart=0,poststart=0;\\n      int preend=preorder.size()-1;\\n      int postend=postorder.size()-1;\\n      \\n        return solve(preorder,postorder,prestart,preend,poststart,postend);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413877,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :- Brute Force***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(height of tree i.e. O(logN))***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // search element in postorder array\\n    \\n    int search(vector<int>& post, int start, int end, int val)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n            if(post[i] == val)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // pre_idx keeps track of element of preorder array\\n    \\n    int pre_idx = 0;\\n    \\n    // construct tree\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end || pre_idx >= pre.size())\\n            return NULL;\\n        \\n        // create a node put value as pre[pre_idx]\\n        \\n        TreeNode* root = new TreeNode(pre[pre_idx]);\\n        \\n        pre_idx++;\\n        \\n        // if there is only one element in range of [start, end] or pre_idx is the last index of pre array\\n        \\n        if(pre_idx >= pre.size() || start == end)\\n            return root;\\n        \\n        // search the index of pre[pre_idx] in post array\\n       \\n        int idx = search(post, start, end, pre[pre_idx]);\\n        \\n        // construct left subtree\\n        \\n        root -> left = construct(pre, post, start, idx);\\n        \\n        // construct right subtree, as we can see that we are not including the last element of range, because we have already included as root\\n        \\n        root -> right = construct(pre, post, idx + 1, end - 1);\\n        \\n        // return root\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        \\n        return construct(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```\\n\\n* ***Approach 2 :- Optimized***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // mp store the index of corresponding element of postorder\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // pre_idx keeps track of element of preorder array\\n    \\n    int pre_idx = 0;\\n    \\n    // construct tree\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end || pre_idx >= pre.size())\\n            return NULL;\\n        \\n        // create a node put value as pre[pre_idx]\\n        \\n        TreeNode* root = new TreeNode(pre[pre_idx]);\\n        \\n        pre_idx++;\\n        \\n        // if there is only one element in range of [start, end] or pre_idx is the last index of pre array\\n        \\n        if(pre_idx >= pre.size() || start == end)\\n            return root;\\n        \\n        // get the index of pre[pre_idx] from map\\n       \\n        int idx = mp[pre[pre_idx]];\\n        \\n        // construct left subtree\\n        \\n        root -> left = construct(pre, post, start, idx);\\n        \\n        // construct right subtree, as we can see that we are not including the last element of range, because we have already included as root\\n        \\n        root -> right = construct(pre, post, idx + 1, end - 1);\\n        \\n        // return root\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        \\n        // insert the index of element of postorder into map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[postorder[i]] = i;\\n        }\\n        \\n        return construct(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // search element in postorder array\\n    \\n    int search(vector<int>& post, int start, int end, int val)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n            if(post[i] == val)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // pre_idx keeps track of element of preorder array\\n    \\n    int pre_idx = 0;\\n    \\n    // construct tree\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end || pre_idx >= pre.size())\\n            return NULL;\\n        \\n        // create a node put value as pre[pre_idx]\\n        \\n        TreeNode* root = new TreeNode(pre[pre_idx]);\\n        \\n        pre_idx++;\\n        \\n        // if there is only one element in range of [start, end] or pre_idx is the last index of pre array\\n        \\n        if(pre_idx >= pre.size() || start == end)\\n            return root;\\n        \\n        // search the index of pre[pre_idx] in post array\\n       \\n        int idx = search(post, start, end, pre[pre_idx]);\\n        \\n        // construct left subtree\\n        \\n        root -> left = construct(pre, post, start, idx);\\n        \\n        // construct right subtree, as we can see that we are not including the last element of range, because we have already included as root\\n        \\n        root -> right = construct(pre, post, idx + 1, end - 1);\\n        \\n        // return root\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        \\n        return construct(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // mp store the index of corresponding element of postorder\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // pre_idx keeps track of element of preorder array\\n    \\n    int pre_idx = 0;\\n    \\n    // construct tree\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end || pre_idx >= pre.size())\\n            return NULL;\\n        \\n        // create a node put value as pre[pre_idx]\\n        \\n        TreeNode* root = new TreeNode(pre[pre_idx]);\\n        \\n        pre_idx++;\\n        \\n        // if there is only one element in range of [start, end] or pre_idx is the last index of pre array\\n        \\n        if(pre_idx >= pre.size() || start == end)\\n            return root;\\n        \\n        // get the index of pre[pre_idx] from map\\n       \\n        int idx = mp[pre[pre_idx]];\\n        \\n        // construct left subtree\\n        \\n        root -> left = construct(pre, post, start, idx);\\n        \\n        // construct right subtree, as we can see that we are not including the last element of range, because we have already included as root\\n        \\n        root -> right = construct(pre, post, idx + 1, end - 1);\\n        \\n        // return root\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        \\n        // insert the index of element of postorder into map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[postorder[i]] = i;\\n        }\\n        \\n        return construct(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064148,
                "title": "c-iterative-solution",
                "content": "**Some Observations**\\n<ul>\\n<li>If i<sup>th</sup> element is present in preorder any index after j<sup>th</sup> element, then i<sup>th</sup> element can never be a descendant of j<sup>th</sup> element.\\n<li>If i<sup>th</sup> element is present in postorder any index before j<sup>th</sup> element, then jth element can never be a descendant to i<sup>th</sup> element.\\n<li>First element of preorder is always equal to the last element of postorder and it is the value which will be forming the root of the tree.</li>\\n</ul>\\n\\n**Algorithm**\\n\\nA stack is maintained where every stack element is a tuple (i, node), where i represents the index of the element in the preorder and node represents the newly created node with its value as preorder[i]. First, root node with value = preorder[0] is pushed into the stack as (0, root). Next we traverse postorder in reverse direction excluding the last element (since it is already included as root element) and find out the index of this postorder\\'s element in the preorder. If stack\\'s top has index > the index of preorder corresponding to that value, this implies that the current element cannot be a descendant to the element at top of the stack. Since we are reverse traversing the postorder, this also implies that the elements in stack can never be descendant of this element. Hence, we keep pop such elements out till we arrive at a situation when stack\\'s top element has index < current preorder\\'s index. If right of the stack\\'s top element points to NULL, we make it point to newly created node (which we encountered while doing postorder). Else, we make the left pointer of stack\\'s top node to point to the new node and then pop it from the stack. We push the newly created node along with its corresponding index in the preorder for next elements yet to be explored.\\n\\n**Code in C++**\\n\\n```\\nTreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        stack<pair<int, TreeNode *> > st;\\n        int j;\\n        TreeNode *root = new TreeNode(preorder[0]);\\n        st.push(make_pair(0, root));\\n        for(int i = postorder.size()-2; i >= 0; i--) {\\n            for(j = 1; j < preorder.size(); j++) {\\n                if(preorder[j] == postorder[i]) {\\n                    break;\\n                }\\n            }\\n            TreeNode *temp = new TreeNode(preorder[j]);;\\n            while(st.top().first > j) {\\n                st.pop();\\n            }\\n            if(!st.top().second->right) {\\n                st.top().second->right = new TreeNode(preorder[j]);\\n                st.push(make_pair(j, st.top().second->right));\\n            } else {\\n                st.top().second->left = temp;\\n                st.push(make_pair(j, temp));\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        stack<pair<int, TreeNode *> > st;\\n        int j;\\n        TreeNode *root = new TreeNode(preorder[0]);\\n        st.push(make_pair(0, root));\\n        for(int i = postorder.size()-2; i >= 0; i--) {\\n            for(j = 1; j < preorder.size(); j++) {\\n                if(preorder[j] == postorder[i]) {\\n                    break;\\n                }\\n            }\\n            TreeNode *temp = new TreeNode(preorder[j]);;\\n            while(st.top().first > j) {\\n                st.pop();\\n            }\\n            if(!st.top().second->right) {\\n                st.top().second->right = new TreeNode(preorder[j]);\\n                st.push(make_pair(j, st.top().second->right));\\n            } else {\\n                st.top().second->left = temp;\\n                st.push(make_pair(j, temp));\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981974,
                "title": "python-iterative-o-n-solution",
                "content": "We know a few properties of preorder and postorder traversal:\\n- leftmost element in preorder = root\\n- rightmost element in postorder = root\\n- leftmost element in postorder = leftmost node\\n- rightmost element in preorder = rightmost node\\n\\n\\nWe iterate through preorder until we reaches leftmost node, then we backtrack.\\n\\n```python\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder) == 0: return None\\n        root = TreeNode(preorder[0])\\n        stack, i = [root], 0\\n        for n in preorder[1:]:\\n            if stack[-1].val != postorder[i]:\\n                stack[-1].left = left = TreeNode(n)\\n                stack.append(left)\\n            else:\\n                while stack and stack[-1].val == postorder[i]:\\n                    cur = stack.pop()\\n                    i += 1\\n                stack[-1].right = right = TreeNode(n)\\n                stack.append(right)\\n        return root\\n```\\n\\nThis is similar to this [solution](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/1979921/python-iterative-on-solution).",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder) == 0: return None\\n        root = TreeNode(preorder[0])\\n        stack, i = [root], 0\\n        for n in preorder[1:]:\\n            if stack[-1].val != postorder[i]:\\n                stack[-1].left = left = TreeNode(n)\\n                stack.append(left)\\n            else:\\n                while stack and stack[-1].val == postorder[i]:\\n                    cur = stack.pop()\\n                    i += 1\\n                stack[-1].right = right = TreeNode(n)\\n                stack.append(right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917697,
                "title": "c-solution-recursive",
                "content": "class Solution {\\n    TreeNode *helper(vector<int>p,vector<int>post,int &preindex,int l,int h,int size)\\n    {\\n\\t\\n        if(preindex>=size || l>h)return NULL;\\n        TreeNode *root=new TreeNode(p[preindex]);\\n        preindex++;\\n        if(l==h)return root;\\n        int i;\\n        for(i=l;i<=h;i++)\\n        {\\n            if(p[preindex]==post[i])\\n                break;\\n        }\\n        if(i<=h)\\n        {\\n            root->left=helper(p,post,preindex,l,i,size);\\n            root->right=helper(p,post,preindex,i+1,h-1,size);\\n        }\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n\\t\\n        int preindex=0;\\n        return helper(preorder,postorder,preindex,0,preorder.size()-1,preorder.size());\\n        \\n    }\\n};\\n**Please do upvote if you liked it!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    TreeNode *helper(vector<int>p,vector<int>post,int &preindex,int l,int h,int size)\\n    {\\n\\t\\n        if(preindex>=size || l>h)return NULL;\\n        TreeNode *root=new TreeNode(p[preindex]);\\n        preindex++;\\n        if(l==h)return root;\\n        int i;\\n        for(i=l;i<=h;i++)\\n        {\\n            if(p[preindex]==post[i])\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1879578,
                "title": "easy-c-dfs",
                "content": "```\\nclass Solution {\\n    int preIndex = 0;\\n    TreeNode* construct(vector<int>& preorder, vector<int>& postorder, int post_s, int post_e){\\n        if(post_s>post_e) return nullptr;\\n        TreeNode* root = new TreeNode(preorder[preIndex]);\\n        ++preIndex;\\n        if(post_s==post_e) return root;\\n        int post = post_s;\\n        while(postorder[post]!=preorder[preIndex]) ++post;\\n        root->left = construct(preorder,postorder,post_s,post);\\n        root->right = construct(preorder,postorder,post+1,post_e-1);\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return construct(preorder,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int preIndex = 0;\\n    TreeNode* construct(vector<int>& preorder, vector<int>& postorder, int post_s, int post_e){\\n        if(post_s>post_e) return nullptr;\\n        TreeNode* root = new TreeNode(preorder[preIndex]);\\n        ++preIndex;\\n        if(post_s==post_e) return root;\\n        int post = post_s;\\n        while(postorder[post]!=preorder[preIndex]) ++post;\\n        root->left = construct(preorder,postorder,post_s,post);\\n        root->right = construct(preorder,postorder,post+1,post_e-1);\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return construct(preorder,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860564,
                "title": "c-iterative-approach-easy-to-understand",
                "content": "**Solution:**\\n```\\npublic class Solution {\\n    public TreeNode ConstructFromPrePost(int[] preorder, int[] postorder) {\\n        Dictionary<int, TreeNode> dict = new Dictionary<int, TreeNode>();\\n        int n = preorder.Length;\\n        bool[] isRoot = new bool[n];\\n        int[] pos = new int[n + 1];\\n        for(int i = 0; i < n; ++i) {\\n            pos[postorder[i]] = i;\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            int nextRoot = 0;\\n            for(int j = pos[preorder[i]] + 1; j < n; ++j) {\\n                if(isRoot[j]) {\\n                    nextRoot = postorder[j];\\n                    break;\\n                }\\n            }\\n            TreeNode node = new TreeNode(preorder[i], null, null);\\n            dict[preorder[i]] = node;\\n            if(nextRoot != 0) {\\n                TreeNode root = dict[nextRoot];\\n                if(root.left == null) root.left = node;\\n                else root.right = node;\\n            }\\n            isRoot[pos[preorder[i]]] = true;\\n        }\\n        return dict[preorder[0]];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public TreeNode ConstructFromPrePost(int[] preorder, int[] postorder) {\\n        Dictionary<int, TreeNode> dict = new Dictionary<int, TreeNode>();\\n        int n = preorder.Length;\\n        bool[] isRoot = new bool[n];\\n        int[] pos = new int[n + 1];\\n        for(int i = 0; i < n; ++i) {\\n            pos[postorder[i]] = i;\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            int nextRoot = 0;\\n            for(int j = pos[preorder[i]] + 1; j < n; ++j) {\\n                if(isRoot[j]) {\\n                    nextRoot = postorder[j];\\n                    break;\\n                }\\n            }\\n            TreeNode node = new TreeNode(preorder[i], null, null);\\n            dict[preorder[i]] = node;\\n            if(nextRoot != 0) {\\n                TreeNode root = dict[nextRoot];\\n                if(root.left == null) root.left = node;\\n                else root.right = node;\\n            }\\n            isRoot[pos[preorder[i]]] = true;\\n        }\\n        return dict[preorder[0]];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843058,
                "title": "python-well-explained-solution-easy",
                "content": "**\\nPreorder is  -> root -> left -> right\\nPostorder is -> left -> right -> root\\nIf you see the difference between them is the how the root node is accessed\\n\\nIn preorder traversal if a node and its children exists it is guaranteed that children will come after the node . [ node 1 , node 2 , node 3 , node 4, ]\\nif node 2 have a child it will definitely coming after node 2 in preorder traversal\\n\\nThe opposite is true for postorder . \\n\\nOne more think to observe is that if node1 has a child node2 and node2 has a child node3\\nThen node3 will always come after node2 and node2 will always come after node1 in preorder and node3 will always come first then node2 then node3 in postorder\\n\\nSo my intution is based on following two observations\\n1. If for node 1 , node 2 in preorder ( index of node 1 < node 2 ):\\n         node 1 is parent of node2 if and only if node 1 comes after node 2 in postorder\\n\\n2. If the above is not true that means node 2 can never lie in the subtree rooted as node 1 \\n    so we check for nodes before node 1\\n\\t\\n\\tBut which node to check first > Ofcourse the most recent \\n\\tso we make a stack of nodes that can be possible parents\\n\\twhenever we make a new node we add it to stack and when the last item fails to be a \\n\\tparent we know that its era ended and he can\\'t be a parent again so we pop() from stack\\n**\\n\\n\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        n = len(preorder)\\n        d = {postorder[i]:i for i in range(n)}\\n        for i in range(1,n):\\n            b = d[preorder[i]]\\n            while stack:\\n                a = d[stack[-1].val]\\n                if a - b > 0:\\n                    node = stack[-1]\\n                    new =  TreeNode(preorder[i])\\n                    if node.left == None:node.left = new\\n                    else:node.right = new\\n                    stack.append(new)\\n                    break\\n                else: stack.pop()\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        n = len(preorder)\\n        d = {postorder[i]:i for i in range(n)}\\n        for i in range(1,n):\\n            b = d[preorder[i]]\\n            while stack:\\n                a = d[stack[-1].val]\\n                if a - b > 0:\\n                    node = stack[-1]\\n                    new =  TreeNode(preorder[i])\\n                    if node.left == None:node.left = new\\n                    else:node.right = new\\n                    stack.append(new)\\n                    break\\n                else: stack.pop()\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798311,
                "title": "easy-c-intuitive-explanation-with-comments",
                "content": "**Idea :** The idea of this solution is that we first create a root node with the first element of the preorder traversal.\\nAfter this we recursively construct the left and right subtrees by passing the appropriate preorder and postorder traversals for the left and right subtree.\\n\\nWe know that the root of the left subtree will be the next element to the current root in preorder traversal, we use this fact to find the new beginning and ending indexes of preorder and postorder traversals for the left and right subtrees of the current node.\\n\\n```\\nTreeNode<int> *constructTree(vector<int> preorder, vector<int> postorder, int preBeg, int preEnd, int postBeg, int postEnd)\\n    {\\n        if (preBeg > preEnd || postBeg > postEnd || preEnd > preorder.size())\\n            return NULL;\\n\\n        TreeNode<int> *root = new TreeNode<int>(preorder[preBeg]);\\n\\t    \\n\\t\\t// If there is a single element in the preorder traversal, we do not need to further construct its subtrees.\\n        if (preBeg == preEnd)\\n            return root;\\n\\t\\t\\n\\t\\t// Finding the new beginning and ending indexes of the preorder and postorder traversals for the left and right subtrees\\n        int newPreBeg = preBeg + 1, newPreEnd;\\n        int newPostBeg = postBeg, newPostEnd;\\n\\n        for (int i = newPostBeg; i < postEnd; i++)\\n            if (postorder[i] == preorder[newPreBeg])\\n            {\\n                newPostEnd = i;\\n                break;\\n            }\\n\\n        newPreEnd = newPreBeg + newPostEnd - newPostBeg;\\n\\n\\t\\t// Recursively constructing left subtree\\n        root->left = constructTree(preorder, postorder, newPreBeg, newPreEnd, newPostBeg, newPostEnd);\\n        \\n\\t\\t// Recursively constructing the right subtree\\n\\t\\troot->right = constructTree(preorder, postorder, newPreEnd + 1, preEnd, newPostEnd + 1, postEnd - 1);\\n\\n        return root;\\n    }\\n\\n    TreeNode<int> *constructFromPrePost(vector<int> &preorder, vector<int> &postorder)\\n    {\\n        return constructTree(preorder, postorder, 0, preorder.size() - 1, 0, postorder.size() - 1);\\n    }\\n```\\n\\n***Please upvote if you found this useful.***",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nTreeNode<int> *constructTree(vector<int> preorder, vector<int> postorder, int preBeg, int preEnd, int postBeg, int postEnd)\\n    {\\n        if (preBeg > preEnd || postBeg > postEnd || preEnd > preorder.size())\\n            return NULL;\\n\\n        TreeNode<int> *root = new TreeNode<int>(preorder[preBeg]);\\n\\t    \\n\\t\\t// If there is a single element in the preorder traversal, we do not need to further construct its subtrees.\\n        if (preBeg == preEnd)\\n            return root;\\n\\t\\t\\n\\t\\t// Finding the new beginning and ending indexes of the preorder and postorder traversals for the left and right subtrees\\n        int newPreBeg = preBeg + 1, newPreEnd;\\n        int newPostBeg = postBeg, newPostEnd;\\n\\n        for (int i = newPostBeg; i < postEnd; i++)\\n            if (postorder[i] == preorder[newPreBeg])\\n            {\\n                newPostEnd = i;\\n                break;\\n            }\\n\\n        newPreEnd = newPreBeg + newPostEnd - newPostBeg;\\n\\n\\t\\t// Recursively constructing left subtree\\n        root->left = constructTree(preorder, postorder, newPreBeg, newPreEnd, newPostBeg, newPostEnd);\\n        \\n\\t\\t// Recursively constructing the right subtree\\n\\t\\troot->right = constructTree(preorder, postorder, newPreEnd + 1, preEnd, newPostEnd + 1, postEnd - 1);\\n\\n        return root;\\n    }\\n\\n    TreeNode<int> *constructFromPrePost(vector<int> &preorder, vector<int> &postorder)\\n    {\\n        return constructTree(preorder, postorder, 0, preorder.size() - 1, 0, postorder.size() - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514579,
                "title": "cpp-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    int preIndx=0;\\npublic:\\n    TreeNode* getTree(vector<int>& preorder,vector<int>&postorder,int lo,int hi,int sz){\\n        if(lo>hi or preIndx>=sz){\\n            return nullptr;\\n        }\\n        TreeNode* root=new TreeNode(preorder[preIndx++]);\\n        \\n        if(lo==hi){\\n            return root;\\n        }\\n        \\n        int i;\\n        for(i=lo;i<=hi;i++){\\n            if(preorder[preIndx]==postorder[i]){\\n                break;\\n            }\\n        }\\n        \\n        if(i<=hi){\\n            root->left=getTree(preorder,postorder,lo,i,sz);\\n            root->right=getTree(preorder,postorder,i+1,hi-1,sz);\\n        }\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int sz=preorder.size();\\n        TreeNode* ans= getTree(preorder,postorder,0,sz-1,sz);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int preIndx=0;\\npublic:\\n    TreeNode* getTree(vector<int>& preorder,vector<int>&postorder,int lo,int hi,int sz){\\n        if(lo>hi or preIndx>=sz){\\n            return nullptr;\\n        }\\n        TreeNode* root=new TreeNode(preorder[preIndx++]);\\n        \\n        if(lo==hi){\\n            return root;\\n        }\\n        \\n        int i;\\n        for(i=lo;i<=hi;i++){\\n            if(preorder[preIndx]==postorder[i]){\\n                break;\\n            }\\n        }\\n        \\n        if(i<=hi){\\n            root->left=getTree(preorder,postorder,lo,i,sz);\\n            root->right=getTree(preorder,postorder,i+1,hi-1,sz);\\n        }\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int sz=preorder.size();\\n        TreeNode* ans= getTree(preorder,postorder,0,sz-1,sz);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200971,
                "title": "easy-to-understand-java-code-with-explanation",
                "content": "```\\nclass Solution {\\n   // prei used to traverse preorder array , posti used to traverse post order array , both are global so that it becomes easier for us \\n    \\n    //dry run on a piece of paper to understand everything more clearly \\n    \\n    int prei = 0; \\n    int posti = 0;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int val = pre[prei];// preorder values will be hit first - construct tree from peorder \\n        TreeNode node = new TreeNode(val);\\n        if(val==post[posti]){ \\n            posti++; // this node is processed in post order so increment posti\\n            return node;\\n        }\\n        prei++; // prei incremented to construct left subtree \\n        node.left = constructFromPrePost(pre,post); // construct left subtree \\n        if(val==post[posti]){ \\n            posti++; // this node is processed in post order so increment posti\\n            return node;\\n        }\\n        prei++; // increment to construct right subtree \\n        node.right = constructFromPrePost(pre,post); // construct right subtree \\n        if(val==post[posti]){\\n            posti++; // this node is processed in post order so increment posti\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n   // prei used to traverse preorder array , posti used to traverse post order array , both are global so that it becomes easier for us \\n    \\n    //dry run on a piece of paper to understand everything more clearly \\n    \\n    int prei = 0; \\n    int posti = 0;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int val = pre[prei];// preorder values will be hit first - construct tree from peorder \\n        TreeNode node = new TreeNode(val);\\n        if(val==post[posti]){ \\n            posti++; // this node is processed in post order so increment posti\\n            return node;\\n        }\\n        prei++; // prei incremented to construct left subtree \\n        node.left = constructFromPrePost(pre,post); // construct left subtree \\n        if(val==post[posti]){ \\n            posti++; // this node is processed in post order so increment posti\\n            return node;\\n        }\\n        prei++; // increment to construct right subtree \\n        node.right = constructFromPrePost(pre,post); // construct right subtree \\n        if(val==post[posti]){\\n            posti++; // this node is processed in post order so increment posti\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143729,
                "title": "python-easy-one-pass-iterative-o-n-with-full-proof",
                "content": "In a preorder traversal trace, if P is a parent node and L and R are its children, we must have \\nindex(P) < index(L) < index(R).\\n\\nFor postorder traversal trace, the condition we have to satisfy is \\nindex(L) < index(R) < index(P).\\n\\nBut **these necessary conditions are also sufficient.** Suppose we generate a tree T with no preorder (P<L<R) index violations, and no postorder (L < R < P) index violations.\\n\\nIf the correct tree, T\\', is distinct from T beyond left/right mirroring, while having the same vertex set, it must be that we can find two nodes (x, y) such that x is an ancestor of y in T and y is an ancestor of x in T\\'. But **our preorder and postorder conditions are inherited by descendants**:\\n\\nIf PP is the parent of x, then in a **preorder**, we have\\nindex(PP) < index(P)\\nso we also get index(PP) < index(P) < index(P\\'s children)\\n\\nwith the same inheritance pattern holding for **postorders**:\\nindex(P\\'s children) < index(P) < index (PP).\\n\\nSo this is a contradiction, as our tree has x and y in an order compatible with these conditions, and the \\'correct\\' tree has x and y in the opposite order.\\n\\nWe do one pass over post to get a mapping of values to indices. We keep a stack with our current path down from root, such that each path vertex (except root) has a free child spot, and iterate over the preorder. The lowest node in our current path that satisfies the postorder condition gets x as a child, the first free of left or right, and we move on to x as our current bottom of the path.\\n\\nTime: O(n) \\nSpace: O(n) unless we can steal space from the post-array, in which case we only need O(height) for stack\\n\\n\\n```python\\ndef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\tindex_in_post = {post[i]: i for i in range(len(post))}\\n\\tcurr_node = TreeNode(pre[0])\\n\\tpath_from_root = [TreeNode(pre[0])]\\n\\tfor x in pre[1:]:\\n\\t\\tnew_node = TreeNode(x)\\n\\t\\twhile index_in_post[x] >= index_in_post[curr_node.val]:\\n\\t\\t\\tcurr_node = path_from_root.pop()\\n\\t\\tif curr_node.left is None:\\n\\t\\t\\tcurr_node.left = new_node\\n\\t\\t\\tpath_from_root.append(curr_node)\\n\\t\\telse:\\n\\t\\t\\tcurr_node.right = new_node\\n\\t\\tcurr_node = new_node\\n\\treturn path_from_root[0]\\n```",
                "solutionTags": [],
                "code": "```python\\ndef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\tindex_in_post = {post[i]: i for i in range(len(post))}\\n\\tcurr_node = TreeNode(pre[0])\\n\\tpath_from_root = [TreeNode(pre[0])]\\n\\tfor x in pre[1:]:\\n\\t\\tnew_node = TreeNode(x)\\n\\t\\twhile index_in_post[x] >= index_in_post[curr_node.val]:\\n\\t\\t\\tcurr_node = path_from_root.pop()\\n\\t\\tif curr_node.left is None:\\n\\t\\t\\tcurr_node.left = new_node\\n\\t\\t\\tpath_from_root.append(curr_node)\\n\\t\\telse:\\n\\t\\t\\tcurr_node.right = new_node\\n\\t\\tcurr_node = new_node\\n\\treturn path_from_root[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1084806,
                "title": "python-recursive-question-about-the-subtree",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if len(pre) == 0 or len(post) == 0:\\n            return None\\n        if len(pre) == 1:\\n            return TreeNode(pre[0])\\n        currentRootValue = pre[0]\\n        subTreeRootValue = pre[1]\\n        subTreeRootIdx = post.index(subTreeRootValue)\\n        leftSubTree = None\\n        rightSubTree = None\\n        if subTreeRootIdx == len(post) - 2:\\n            rightSubTree = self.constructFromPrePost(pre[1:], post[:-1])\\n        else:\\n            leftSubTree = self.constructFromPrePost(pre[1:subTreeRootIdx + 2], post[:subTreeRootIdx + 1])\\n            rightSubTree = self.constructFromPrePost(pre[subTreeRootIdx + 2:], post[subTreeRootIdx + 1:-1])\\n        return TreeNode(currentRootValue, leftSubTree, rightSubTree)\\n```\\n\\n\\nThis method has the same flavour as Construct Binary Tree from **Inorder and Postorder** Traversal and Construct Binary Tree from **Preorder and Inorder** Traversal.\\nHowever, without the reference of Inorder traversal value, it is in doubt whether the tree has left subtree or not.\\n\\nFor example:\\npre = [1, 2, 4, 5, 3, 6, 7]\\npost = [4, 5, 2, 6, 7, 3, 1]\\npre[1] = 2 is the root of subtree, \\nthe reason why it is the left one is that in post, after post[2] = 2, there are still numbers from the right subtree.\\n\\nHowever, though it passed the test case, I am confused about this pre and post:\\npre = [1, 3, 6, 7]\\npost = [6, 7, 3, 1]\\nbecause 3, 6, 7 can be from the left or right subtree, so there are two binary trees for this pre and post.\\nThough I do the if else in my code, it did not make it clear...\\nWhat do you reckon?",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if len(pre) == 0 or len(post) == 0:\\n            return None\\n        if len(pre) == 1:\\n            return TreeNode(pre[0])\\n        currentRootValue = pre[0]\\n        subTreeRootValue = pre[1]\\n        subTreeRootIdx = post.index(subTreeRootValue)\\n        leftSubTree = None\\n        rightSubTree = None\\n        if subTreeRootIdx == len(post) - 2:\\n            rightSubTree = self.constructFromPrePost(pre[1:], post[:-1])\\n        else:\\n            leftSubTree = self.constructFromPrePost(pre[1:subTreeRootIdx + 2], post[:subTreeRootIdx + 1])\\n            rightSubTree = self.constructFromPrePost(pre[subTreeRootIdx + 2:], post[subTreeRootIdx + 1:-1])\\n        return TreeNode(currentRootValue, leftSubTree, rightSubTree)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921467,
                "title": "c-recursive-solution",
                "content": "```\\nprivate:\\n    TreeNode* createNode(vector<int>& pre, vector<int>& post, int s, int sp, int N)\\n    {\\n        if (N == 0) return NULL;\\n        TreeNode* root = new TreeNode(pre[s]);\\n        if(N == 1) return root;\\n        \\n        int L = 0;\\n        for(int i = sp; i < sp + N; ++i)\\n        {\\n            if(post[i] == pre[s+1])\\n            {\\n                L = i - sp + 1;\\n                break;\\n            }\\n        }\\n        \\n        root -> left = createNode(pre, post, s+1, sp, L);\\n        root -> right = createNode(pre, post, s+L+1, sp+L, N-L-1);\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n       return  createNode(pre, post, 0, 0, pre.size());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:\\n    TreeNode* createNode(vector<int>& pre, vector<int>& post, int s, int sp, int N)\\n    {\\n        if (N == 0) return NULL;\\n        TreeNode* root = new TreeNode(pre[s]);\\n        if(N == 1) return root;\\n        \\n        int L = 0;\\n        for(int i = sp; i < sp + N; ++i)\\n        {\\n            if(post[i] == pre[s+1])\\n            {\\n                L = i - sp + 1;\\n                break;\\n            }\\n        }\\n        \\n        root -> left = createNode(pre, post, s+1, sp, L);\\n        root -> right = createNode(pre, post, s+L+1, sp+L, N-L-1);\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n       return  createNode(pre, post, 0, 0, pre.size());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591122,
                "title": "java-o-n-2-recursive-solution-0-ms-time-100",
                "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    \\n    private TreeNode helper(int[] preorder, int[] postorder, int preStart, int postStart, int length) {\\n        \\n        if(length == 0) return null;\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        if(length == 1) return root;\\n        \\n        int index = 1;\\n        for(; index < length; index++) if(postorder[postStart + index - 1] == preorder[preStart + 1]) break;\\n        \\n        root.left = helper(preorder, postorder, preStart + 1, postStart, index);\\n        root.right = helper(preorder, postorder, preStart + index + 1, postStart + index, length - index - 1);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        \\n        return helper(preorder, postorder, 0, 0, preorder.length);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private TreeNode helper(int[] preorder, int[] postorder, int preStart, int postStart, int length) {\\n        \\n        if(length == 0) return null;\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        if(length == 1) return root;\\n        \\n        int index = 1;\\n        for(; index < length; index++) if(postorder[postStart + index - 1] == preorder[preStart + 1]) break;\\n        \\n        root.left = helper(preorder, postorder, preStart + 1, postStart, index);\\n        root.right = helper(preorder, postorder, preStart + index + 1, postStart + index, length - index - 1);\\n        \\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 469702,
                "title": "c-4ms-98-o-n-solution-o-n-space",
                "content": "The first solution here is the standard `O(N^2)` time `O(N)` space solution.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return makeTree(pre, post, 0, pre.size()-1, 0, post.size()-1);\\n    }\\n    static TreeNode* makeTree(vector<int>& pre, vector<int>& post, const int i1, const int j1, const int i2, const int j2) {\\n        if(i1 > j1) return nullptr;\\n        if(i1 == j1) return new TreeNode(pre[i1]);\\n        TreeNode *n = new TreeNode(pre[i1]);\\n        int next = i2; // Relative index of matching head in post[]\\n        for(int k = i2; k <= j2; ++k)\\n            if(post[k] == pre[i1+1]) {next = k+1-i2; break;}\\n        \\n        n->left = makeTree(pre, post, i1+1, i1+next, i2, i2+next-1); // Convert relative index of post into that of pre[] and post[]\\n        n->right = makeTree(pre, post, i1+next+1, j1, i2+next, j2-1);\\n        return n;\\n        \\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\nIf we hash the look up for `next` , the run-time becomes `O(N)`. Space complexity is still `O(N)`. The solution below uses this and achieves `O(N)` time.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> m;\\n        int size = post.size();\\n        for(int i = 0; i < size; ++i) m[post[i]] = i;\\n        return makeTree(pre, m, 0, pre.size()-1, 0);\\n    }\\n    static TreeNode* makeTree(vector<int>& pre, unordered_map<int, int>& m, const int i1, const int j1, const int i2) {\\n        if(i1 > j1) return nullptr;\\n        if(i1 == j1) return new TreeNode(pre[i1]);\\n        TreeNode *n = new TreeNode(pre[i1]);\\n        int next = i2;\\n        if(m.count(pre[i1+1])) next = m[pre[i1+1]]+1-i2;\\n        n->left = makeTree(pre, m, i1+1, i1+next, i2);\\n        n->right = makeTree(pre, m, i1+next+1, j1, i2+next);\\n        return n;\\n        \\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return makeTree(pre, post, 0, pre.size()-1, 0, post.size()-1);\\n    }\\n    static TreeNode* makeTree(vector<int>& pre, vector<int>& post, const int i1, const int j1, const int i2, const int j2) {\\n        if(i1 > j1) return nullptr;\\n        if(i1 == j1) return new TreeNode(pre[i1]);\\n        TreeNode *n = new TreeNode(pre[i1]);\\n        int next = i2; // Relative index of matching head in post[]\\n        for(int k = i2; k <= j2; ++k)\\n            if(post[k] == pre[i1+1]) {next = k+1-i2; break;}\\n        \\n        n->left = makeTree(pre, post, i1+1, i1+next, i2, i2+next-1); // Convert relative index of post into that of pre[] and post[]\\n        n->right = makeTree(pre, post, i1+next+1, j1, i2+next, j2-1);\\n        return n;\\n        \\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> m;\\n        int size = post.size();\\n        for(int i = 0; i < size; ++i) m[post[i]] = i;\\n        return makeTree(pre, m, 0, pre.size()-1, 0);\\n    }\\n    static TreeNode* makeTree(vector<int>& pre, unordered_map<int, int>& m, const int i1, const int j1, const int i2) {\\n        if(i1 > j1) return nullptr;\\n        if(i1 == j1) return new TreeNode(pre[i1]);\\n        TreeNode *n = new TreeNode(pre[i1]);\\n        int next = i2;\\n        if(m.count(pre[i1+1])) next = m[pre[i1+1]]+1-i2;\\n        n->left = makeTree(pre, m, i1+1, i1+next, i2);\\n        n->right = makeTree(pre, m, i1+next+1, j1, i2+next);\\n        return n;\\n        \\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 403417,
                "title": "all-three-questions-105-106-889",
                "content": "Construct Binary Tree from Inorder and Postorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int index;\\n    int find(vector<int>&inorder,int val,int l,int r)\\n    {\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(inorder[i]==val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n     TreeNode* build(vector<int>&inorder,vector<int>&postorder,int l,int r)\\n     {\\n         if(r<l)\\n             return NULL;\\n        TreeNode* root=new TreeNode(postorder[index--]);\\n        int pos=find(inorder,root->val,l,r);\\n         root->right=build(inorder,postorder,pos+1,r);\\n         root->left=build(inorder,postorder,l,pos-1);\\n         return root;\\n         \\n     }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int n=inorder.size();\\n        index=n-1;\\n       return build(inorder,postorder,0,n-1);  \\n    }\\n};\\n```\\nConstruct Binary Tree from Preorder and Inorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int index=0;\\n     int find(vector<int>&inorder,int val,int l,int r)\\n    {\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(inorder[i]==val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    TreeNode* build(vector<int>& pre, vector<int>& in,int l,int r)\\n    {\\n        if(r<l)\\n            return NULL;\\n        TreeNode* root=new TreeNode(pre[index++]);\\n        int pos=find(in,root->val,l,r);\\n        root->left=build(pre,in,l,pos-1);\\n        root->right=build(pre,in,pos+1,r);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        int n=in.size();\\n        index=0;\\n        return build(pre,in,0,n-1);\\n    }\\n};\\n```\\nConstruct Binary Tree from Preorder and Postorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int preind=0,postind=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root=new TreeNode(pre[preind++]);\\n        if(root->val!=post[postind])\\n            root->left=constructFromPrePost(pre,post);\\n        if(root->val!=post[postind])\\n            root->right=constructFromPrePost(pre,post);\\n        postind++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int index;\\n    int find(vector<int>&inorder,int val,int l,int r)\\n    {\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(inorder[i]==val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n     TreeNode* build(vector<int>&inorder,vector<int>&postorder,int l,int r)\\n     {\\n         if(r<l)\\n             return NULL;\\n        TreeNode* root=new TreeNode(postorder[index--]);\\n        int pos=find(inorder,root->val,l,r);\\n         root->right=build(inorder,postorder,pos+1,r);\\n         root->left=build(inorder,postorder,l,pos-1);\\n         return root;\\n         \\n     }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int n=inorder.size();\\n        index=n-1;\\n       return build(inorder,postorder,0,n-1);  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int index=0;\\n     int find(vector<int>&inorder,int val,int l,int r)\\n    {\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(inorder[i]==val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    TreeNode* build(vector<int>& pre, vector<int>& in,int l,int r)\\n    {\\n        if(r<l)\\n            return NULL;\\n        TreeNode* root=new TreeNode(pre[index++]);\\n        int pos=find(in,root->val,l,r);\\n        root->left=build(pre,in,l,pos-1);\\n        root->right=build(pre,in,pos+1,r);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        int n=in.size();\\n        index=0;\\n        return build(pre,in,0,n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int preind=0,postind=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root=new TreeNode(pre[preind++]);\\n        if(root->val!=post[postind])\\n            root->left=constructFromPrePost(pre,post);\\n        if(root->val!=post[postind])\\n            root->right=constructFromPrePost(pre,post);\\n        postind++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371224,
                "title": "c-implementation",
                "content": "```\\npublic static TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {\\n            var head = new TreeNode(pre[0]);\\n            var stack = new Stack<TreeNode>();\\n            stack.Push(head);\\n            for (int i = 1, j = 0; i < pre.Length; i++)\\n            {\\n                var node = new TreeNode(pre[i]);\\n                while (stack.Peek().val == post[j])\\n                {\\n                    stack.Pop();\\n                    j++;\\n                }\\n\\n                if (stack.Peek().left == null)\\n                    stack.Peek().left = node;\\n                else stack.Peek().right = node;\\n                stack.Push(node);\\n            }\\n\\n            return head;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {\\n            var head = new TreeNode(pre[0]);\\n            var stack = new Stack<TreeNode>();\\n            stack.Push(head);\\n            for (int i = 1, j = 0; i < pre.Length; i++)\\n            {\\n                var node = new TreeNode(pre[i]);\\n                while (stack.Peek().val == post[j])\\n                {\\n                    stack.Pop();\\n                    j++;\\n                }\\n\\n                if (stack.Peek().left == null)\\n                    stack.Peek().left = node;\\n                else stack.Peek().right = node;\\n                stack.Push(node);\\n            }\\n\\n            return head;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349721,
                "title": "javascript-o-n-time-and-o-n-space-solution-with-explanation",
                "content": "TLDR:\\n    - the left node is always to the right of the value in preorder\\n    - the right node is always to the left of the value in postorder\\n    - these two conditions are always true IF we have not already assigned these values as another node\\'s left/right\\n\\nSTEPS\\nOne loop to save reference of value indexes from postorder array into an object so we can later achieve constant time lookup versus using .indexOf() for every item - O(N^2)\\n\\nstarting at pre[0]\\n    - left = preorder[i + 1]\\n    - right = (index of preorder[i] in postorder) - 1\\n\\nSince all numbers are unique, we can have a history object with keys as val and values as the node we created to keep track of which nodes should not be duplicated as left/right.  This also allows us to have constant time access to the node we want to add a left/right\\n     \\n hist = {\\n\\t1: new TreeNode(1),\\n\\t2: new TreeNode(2),\\n\\tetc...\\n }\\n \\n```\\nconst constructFromPrePost = function(pre, post) {\\n    let hist = {};\\n    let postIndexes = {};\\n    let head = new TreeNode(pre[0]);\\n    hist[pre[0]] = head;\\n    \\n    for (let k = 0; k < post.length; k++) {\\n        postIndexes[post[k]] = k;\\n    }\\n\\n    for (let i = 0; i < pre.length; i++) {\\n        let currentNode = hist[pre[i]];\\n        \\n        let leftVal = pre[i+1];\\n        if (leftVal && !hist[leftVal]) {\\n            let leftNode = new TreeNode(leftVal);\\n            currentNode.left = leftNode;\\n            hist[leftVal] = leftNode;\\n        }\\n        \\n        let rightVal = post[postIndexes[pre[i]] - 1];\\n        if (rightVal && !hist[rightVal]) {\\n            let rightNode = new TreeNode(rightVal);\\n            currentNode.right = rightNode;\\n            hist[rightVal] = rightNode;\\n        }\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst constructFromPrePost = function(pre, post) {\\n    let hist = {};\\n    let postIndexes = {};\\n    let head = new TreeNode(pre[0]);\\n    hist[pre[0]] = head;\\n    \\n    for (let k = 0; k < post.length; k++) {\\n        postIndexes[post[k]] = k;\\n    }\\n\\n    for (let i = 0; i < pre.length; i++) {\\n        let currentNode = hist[pre[i]];\\n        \\n        let leftVal = pre[i+1];\\n        if (leftVal && !hist[leftVal]) {\\n            let leftNode = new TreeNode(leftVal);\\n            currentNode.left = leftNode;\\n            hist[leftVal] = leftNode;\\n        }\\n        \\n        let rightVal = post[postIndexes[pre[i]] - 1];\\n        if (rightVal && !hist[rightVal]) {\\n            let rightNode = new TreeNode(rightVal);\\n            currentNode.right = rightNode;\\n            hist[rightVal] = rightNode;\\n        }\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270865,
                "title": "c-true-o-n-time-recursion-beat-100",
                "content": "```\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        // pre: [1 3 6 7], post: [6 7 3 1], you will never know if [3 6 7] is left subtree of root 1 or the right subtree.\\n        int i = 0, j = 0;\\n        return helper(pre, i, post, j);\\n    }\\n\\n    TreeNode* helper(const vector<int>& pre, int& i, const vector<int>& post, int& j) {\\n        if (i == pre.size()) return nullptr;\\n        TreeNode* root = new TreeNode(pre[i++]);\\n        // Simplify the above logic to be as follows:\\n        while (post[j] != root->val) {\\n            if (!root->left)\\n                root->left = helper(pre, i, post, j);\\n            else\\n                root->right = helper(pre, i, post, j);\\n        }\\n        j++;\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        // pre: [1 3 6 7], post: [6 7 3 1], you will never know if [3 6 7] is left subtree of root 1 or the right subtree.\\n        int i = 0, j = 0;\\n        return helper(pre, i, post, j);\\n    }\\n\\n    TreeNode* helper(const vector<int>& pre, int& i, const vector<int>& post, int& j) {\\n        if (i == pre.size()) return nullptr;\\n        TreeNode* root = new TreeNode(pre[i++]);\\n        // Simplify the above logic to be as follows:\\n        while (post[j] != root->val) {\\n            if (!root->left)\\n                root->left = helper(pre, i, post, j);\\n            else\\n                root->right = helper(pre, i, post, j);\\n        }\\n        j++;\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210913,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\n**Time Complexity:** `O(N)` - building a hash-table takes `O(N)` time and recursive reconstruction spends O(1) time per node\\n**Space Complexity:** `O(N + H) = O(N)` - the hash-table size and the maximum depth of function call stack\\n\\n```\\nclass Solution {\\n    Map<Integer, Integer> postOrderMap = new HashMap<>();\\n    int preOrderIndex = 0;\\n\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        for (int i = 0; i < postorder.length; i++) {\\n            postOrderMap.put(postorder[i], i);\\n        }\\n        return constructFromPrePostHelper(preorder, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode constructFromPrePostHelper(int[] preorder, int postOrderStartIndex, int postOrderEndIndex) {\\n        if (postOrderStartIndex > postOrderEndIndex) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preOrderIndex++]);\\n\\n        if (postOrderStartIndex < postOrderEndIndex) {\\n            int postOrderIndex = postOrderMap.get(preorder[preOrderIndex]);\\n            root.left = constructFromPrePostHelper(preorder, postOrderStartIndex, postOrderIndex);\\n            root.right = constructFromPrePostHelper(preorder, postOrderIndex + 1, postOrderEndIndex - 1);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n**Time Complexity:** `O(N)` - building a hash-table takes `O(N)` time and recursive reconstruction spends O(1) time per node\\n**Space Complexity:** `O(N + H) = O(N)` - the hash-table size and the maximum depth of function call stack\\n\\n```\\nclass Solution {\\n    HashMap<Integer, Integer> postMap = new HashMap<>();\\n\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        for (int i = 0; i < postorder.length; i++) {\\n            postMap.put(postorder[i], i);\\n        }\\n        return constructFromPrePostHelper(preorder, 0, preorder.length - 1, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode constructFromPrePostHelper(int[] preorder, int preOrderStartIndex, int preOrderEndIndex, int postOrderStartIndex, int postOrderEndIndex) {\\n        if (postOrderStartIndex > postOrderEndIndex) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preOrderStartIndex++]);\\n\\n        if (preOrderStartIndex <= preOrderEndIndex) {\\n            int postOrderIndex = postMap.get(preorder[preOrderStartIndex]);\\n            int preOrderIndex = preOrderStartIndex + postOrderIndex - postOrderStartIndex;\\n\\n            root.left = constructFromPrePostHelper(preorder, preOrderStartIndex, preOrderIndex, postOrderStartIndex, postOrderIndex);\\n            root.right = constructFromPrePostHelper(preorder, preOrderIndex + 1, preOrderEndIndex, postOrderIndex + 1, postOrderEndIndex - 1);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> postOrderMap = new HashMap<>();\\n    int preOrderIndex = 0;\\n\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        for (int i = 0; i < postorder.length; i++) {\\n            postOrderMap.put(postorder[i], i);\\n        }\\n        return constructFromPrePostHelper(preorder, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode constructFromPrePostHelper(int[] preorder, int postOrderStartIndex, int postOrderEndIndex) {\\n        if (postOrderStartIndex > postOrderEndIndex) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preOrderIndex++]);\\n\\n        if (postOrderStartIndex < postOrderEndIndex) {\\n            int postOrderIndex = postOrderMap.get(preorder[preOrderIndex]);\\n            root.left = constructFromPrePostHelper(preorder, postOrderStartIndex, postOrderIndex);\\n            root.right = constructFromPrePostHelper(preorder, postOrderIndex + 1, postOrderEndIndex - 1);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    HashMap<Integer, Integer> postMap = new HashMap<>();\\n\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        for (int i = 0; i < postorder.length; i++) {\\n            postMap.put(postorder[i], i);\\n        }\\n        return constructFromPrePostHelper(preorder, 0, preorder.length - 1, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode constructFromPrePostHelper(int[] preorder, int preOrderStartIndex, int preOrderEndIndex, int postOrderStartIndex, int postOrderEndIndex) {\\n        if (postOrderStartIndex > postOrderEndIndex) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preOrderStartIndex++]);\\n\\n        if (preOrderStartIndex <= preOrderEndIndex) {\\n            int postOrderIndex = postMap.get(preorder[preOrderStartIndex]);\\n            int preOrderIndex = preOrderStartIndex + postOrderIndex - postOrderStartIndex;\\n\\n            root.left = constructFromPrePostHelper(preorder, preOrderStartIndex, preOrderIndex, postOrderStartIndex, postOrderIndex);\\n            root.right = constructFromPrePostHelper(preorder, preOrderIndex + 1, preOrderEndIndex, postOrderIndex + 1, postOrderEndIndex - 1);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164015,
                "title": "straight-forward-recursion-in-java",
                "content": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int n = pre.length;\\n        if (n==0) return null; \\n        TreeNode root = new TreeNode(pre[0]);\\n        if (n>1) {\\n            int x = pre[1];\\n            int j=0; \\n            while (post[j]!=x)\\n                j++; \\n            root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1, j+2), Arrays.copyOfRange(post, 0, j+1)); \\n            root.right = constructFromPrePost(Arrays.copyOfRange(pre, j+2, n), Arrays.copyOfRange(post, j+1, n-1)); \\n        }\\n        return root; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int n = pre.length;\\n        if (n==0) return null; \\n        TreeNode root = new TreeNode(pre[0]);\\n        if (n>1) {\\n            int x = pre[1];\\n            int j=0; \\n            while (post[j]!=x)\\n                j++; \\n            root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1, j+2), Arrays.copyOfRange(post, 0, j+1)); \\n            root.right = constructFromPrePost(Arrays.copyOfRange(pre, j+2, n), Arrays.copyOfRange(post, j+1, n-1)); \\n        }\\n        return root; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161344,
                "title": "java-recursive-solution",
                "content": "Basically, you need to find the boundary of the left tree in post order array, then use the length to calculate the index\\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if(pre.length == 0 || post.length == 0 || pre.length != post.length)\\n            return null;\\n        return dfs(pre, 0, pre.length - 1, post, 0, post.length - 1);\\n    }\\n    private TreeNode dfs(int[] pre, int ps, int pe, int[] post, int pps, int ppe) {\\n        if(ps > pe || pps > ppe) return null;\\n        TreeNode root = new TreeNode(pre[ps]);\\n        if(ps + 1 > pe) return root;\\n\\t\\t\\t\\t// this is the start of the left tree\\n        int val = pre[ps + 1], idx = pps;\\n        for(; idx < ppe; idx++) {\\n            if(post[idx] == val) break;\\n        }\\n        root.left = dfs(pre, ps + 1, ps + idx - pps + 1, post, pps, idx);\\n        root.right = dfs(pre, ps + idx - pps + 2, pe, post, idx + 1, ppe - 1);\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if(pre.length == 0 || post.length == 0 || pre.length != post.length)\\n            return null;\\n        return dfs(pre, 0, pre.length - 1, post, 0, post.length - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3772052,
                "title": "perhaps-shortest-python-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nModified from [lee215\\'s solution](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solutions/161268/c-java-python-one-pass-real-o-n/), with two index vars replaced by pop operations.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$ extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(postorder.pop())\\n        if root.val != preorder[-1]:\\n            root.right = self.constructFromPrePost(preorder, postorder)\\n        if root.val != preorder[-1]:\\n            root.left = self.constructFromPrePost(preorder, postorder)\\n        preorder.pop()\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(postorder.pop())\\n        if root.val != preorder[-1]:\\n            root.right = self.constructFromPrePost(preorder, postorder)\\n        if root.val != preorder[-1]:\\n            root.left = self.constructFromPrePost(preorder, postorder)\\n        preorder.pop()\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692211,
                "title": "easy-c-solution-beat-97-2",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int preindex=0,posindex=0;\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        if(root->val!=postorder[posindex])\\n            root->left=constructFromPrePost(preorder,postorder);\\n        if(root->val!=postorder[posindex])\\n            root->right=constructFromPrePost(preorder,postorder);\\n        posindex++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n    int preindex=0,posindex=0;\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        if(root->val!=postorder[posindex])\\n            root->left=constructFromPrePost(preorder,postorder);\\n        if(root->val!=postorder[posindex])\\n            root->right=constructFromPrePost(preorder,postorder);\\n        posindex++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617169,
                "title": "easy-to-understand-97-beats-c",
                "content": "\\n# Approach\\nrecursive \\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* helper(int preFirst, int preEnd, vector<int> &preorder, int postFirst, \\n    int postEnd, vector<int> &postorder) {\\n        \\n        if(preFirst > preEnd) return NULL;\\n        int preRoot = preorder[preFirst];\\n\\n        TreeNode* root = new TreeNode(preRoot);\\n        if(preFirst == preEnd) return root;\\n\\n        int postRoot = postFirst;\\n        for(int i=postFirst; i<=postEnd-1; i++) {\\n            if(postorder[i] == preorder[preFirst+1]) {\\n                postRoot = i;\\n                break;\\n            }\\n        }\\n\\n        int postLeftSt = postFirst, postLeftEnd = postRoot;\\n        int postRightSt = postRoot+1, postRightEnd = postEnd - 1;\\n\\n        int preLeftSt = preFirst + 1, preLeftEnd = postLeftEnd - postLeftSt + preFirst + 1;\\n        int preRightSt = preLeftEnd + 1, preRightEnd = preEnd;\\n\\n\\n        root->left = helper(preLeftSt, preLeftEnd, preorder, postLeftSt, postLeftEnd, postorder);\\n\\n        root->right = helper(preRightSt, preRightEnd, preorder, postRightSt, postRightEnd, postorder);\\n\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int n = preorder.size();\\n        return helper(0, n-1, preorder, 0, n-1, postorder);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* helper(int preFirst, int preEnd, vector<int> &preorder, int postFirst, \\n    int postEnd, vector<int> &postorder) {\\n        \\n        if(preFirst > preEnd) return NULL;\\n        int preRoot = preorder[preFirst];\\n\\n        TreeNode* root = new TreeNode(preRoot);\\n        if(preFirst == preEnd) return root;\\n\\n        int postRoot = postFirst;\\n        for(int i=postFirst; i<=postEnd-1; i++) {\\n            if(postorder[i] == preorder[preFirst+1]) {\\n                postRoot = i;\\n                break;\\n            }\\n        }\\n\\n        int postLeftSt = postFirst, postLeftEnd = postRoot;\\n        int postRightSt = postRoot+1, postRightEnd = postEnd - 1;\\n\\n        int preLeftSt = preFirst + 1, preLeftEnd = postLeftEnd - postLeftSt + preFirst + 1;\\n        int preRightSt = preLeftEnd + 1, preRightEnd = preEnd;\\n\\n\\n        root->left = helper(preLeftSt, preLeftEnd, preorder, postLeftSt, postLeftEnd, postorder);\\n\\n        root->right = helper(preRightSt, preRightEnd, preorder, postRightSt, postRightEnd, postorder);\\n\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int n = preorder.size();\\n        return helper(0, n-1, preorder, 0, n-1, postorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511719,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int n = preorder.size() - 1;\\n        return build(preorder, postorder, 0, n, 0, n);\\n    }\\n    TreeNode* build(vector<int>& preorder, vector<int>& postorder,\\n                    int preLeft, int preRight, int postLeft, int postRight)\\n    {\\n        if (preLeft > preRight || postLeft > postRight) return NULL;\\n        TreeNode* ans = new TreeNode(preorder[preLeft]);\\n        if (preLeft == preRight) return ans; \\n        int len = 1;\\n        for (;len < preRight - preLeft; len++)\\n        {\\n            if (preorder[preLeft + 1] == postorder[postLeft + len - 1])\\n                break;\\n        }\\n        ans->left = build(preorder, postorder, preLeft + 1, preLeft + len, postLeft, postLeft + len - 1);\\n        ans->right = build(preorder, postorder, preLeft + len + 1, preRight, postLeft + len, postRight - 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        self.post_indices = {v: idx for idx, v in enumerate(postorder)}\\n        self.pre_index = 0\\n\\n        print(preorder, postorder)\\n        def buildTree(left, right):\\n            if left > right:\\n                return None            \\n            node = TreeNode(val=preorder[self.pre_index])\\n            self.pre_index +=1 \\n            if self.pre_index > len(preorder) - 1 or left == right: # critical\\n                return node                       \\n            post_index = self.post_indices[preorder[self.pre_index]]\\n            node.left = buildTree(left, post_index)\\n            node.right = buildTree(post_index + 1, right-1)\\n            return node\\n        \\n        return buildTree(0, len(preorder)-1)\\n```\\n\\n```Java []\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] PRE, int[] POST) {\\n        return build(PRE, POST);\\n    }\\n    int pre = 0, post = 0;\\n    TreeNode build(int[] PRE, int[] POST) {\\n        TreeNode n = new TreeNode(PRE[pre]);\\n        pre++;\\n        if (n.val != POST[post]) {\\n            n.left = build(PRE, POST);\\n        }\\n        if (n.val != POST[post]) {\\n            n.right = build(PRE, POST);\\n        }\\n        post++;\\n        return n;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int n = preorder.size() - 1;\\n        return build(preorder, postorder, 0, n, 0, n);\\n    }\\n    TreeNode* build(vector<int>& preorder, vector<int>& postorder,\\n                    int preLeft, int preRight, int postLeft, int postRight)\\n    {\\n        if (preLeft > preRight || postLeft > postRight) return NULL;\\n        TreeNode* ans = new TreeNode(preorder[preLeft]);\\n        if (preLeft == preRight) return ans; \\n        int len = 1;\\n        for (;len < preRight - preLeft; len++)\\n        {\\n            if (preorder[preLeft + 1] == postorder[postLeft + len - 1])\\n                break;\\n        }\\n        ans->left = build(preorder, postorder, preLeft + 1, preLeft + len, postLeft, postLeft + len - 1);\\n        ans->right = build(preorder, postorder, preLeft + len + 1, preRight, postLeft + len, postRight - 1);\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        self.post_indices = {v: idx for idx, v in enumerate(postorder)}\\n        self.pre_index = 0\\n\\n        print(preorder, postorder)\\n        def buildTree(left, right):\\n            if left > right:\\n                return None            \\n            node = TreeNode(val=preorder[self.pre_index])\\n            self.pre_index +=1 \\n            if self.pre_index > len(preorder) - 1 or left == right: # critical\\n                return node                       \\n            post_index = self.post_indices[preorder[self.pre_index]]\\n            node.left = buildTree(left, post_index)\\n            node.right = buildTree(post_index + 1, right-1)\\n            return node\\n        \\n        return buildTree(0, len(preorder)-1)\\n```\n```Java []\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] PRE, int[] POST) {\\n        return build(PRE, POST);\\n    }\\n    int pre = 0, post = 0;\\n    TreeNode build(int[] PRE, int[] POST) {\\n        TreeNode n = new TreeNode(PRE[pre]);\\n        pre++;\\n        if (n.val != POST[post]) {\\n            n.left = build(PRE, POST);\\n        }\\n        if (n.val != POST[post]) {\\n            n.right = build(PRE, POST);\\n        }\\n        post++;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502061,
                "title": "easy-c-solution-using-recursion",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* dfs(vector<int>& preorder,int prestart,int preend, vector<int>& postorder,int poststart,int postend)\\n    {\\n        if(prestart>preend)\\n        {\\n            return NULL;\\n        }\\n        if(poststart>postend)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[prestart]);\\n        if(prestart==preend)\\n        {\\n            return root;\\n        }\\n        int postindex=poststart;\\n        while(postorder[postindex]!=preorder[prestart+1])\\n        {\\n            postindex++;\\n        }\\n        int len= postindex-poststart+1;\\n        root->left=dfs(preorder,prestart+1,prestart+len,postorder,poststart,postindex);\\n        root->right=dfs(preorder,prestart+len+1,preend,postorder,postindex+1,postend-1);\\n        return root;\\n\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return dfs(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* dfs(vector<int>& preorder,int prestart,int preend, vector<int>& postorder,int poststart,int postend)\\n    {\\n        if(prestart>preend)\\n        {\\n            return NULL;\\n        }\\n        if(poststart>postend)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[prestart]);\\n        if(prestart==preend)\\n        {\\n            return root;\\n        }\\n        int postindex=poststart;\\n        while(postorder[postindex]!=preorder[prestart+1])\\n        {\\n            postindex++;\\n        }\\n        int len= postindex-poststart+1;\\n        root->left=dfs(preorder,prestart+1,prestart+len,postorder,poststart,postindex);\\n        root->right=dfs(preorder,prestart+len+1,preend,postorder,postindex+1,postend-1);\\n        return root;\\n\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return dfs(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417213,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<bool>visited;\\nvector<int>pre,post;\\nvoid f(TreeNode* root,vector<int>& preorder, vector<int>& postorder){\\n    int d = root->val;\\n    int pr = pre[d];\\n    int pst = post[d];\\n\\n    for(int j = pr + 1;j < preorder.size();j++){\\n        if(!visited[preorder[j]] and post[d] > post[preorder[j]]){\\n            visited[preorder[j]] = 1;\\n            root->left = new TreeNode(preorder[j]);\\n            f(root->left,preorder,postorder);\\n            break;\\n        }\\n    }\\n\\n    for(int j = pst - 1;j >= 0;j--){\\n        if(!visited[postorder[j]] and pre[d] < pre[postorder[j]]){\\n            visited[postorder[j]] = 1;\\n            root->right = new TreeNode(postorder[j]);\\n            f(root->right,preorder,postorder);\\n            break;\\n        }\\n    }\\n\\n\\n}\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        visited.resize(31,false);\\n        pre.resize(31,0);\\n        post.resize(31,0);\\n        for(int i = 0;i < preorder.size();i++)pre[preorder[i]] = i;\\n        for(int i = 0;i < postorder.size();i++)post[postorder[i]] = i;\\n\\n        TreeNode* root = new TreeNode(preorder[0]);\\n\\n        f(root,preorder,postorder);\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<bool>visited;\\nvector<int>pre,post;\\nvoid f(TreeNode* root,vector<int>& preorder, vector<int>& postorder){\\n    int d = root->val;\\n    int pr = pre[d];\\n    int pst = post[d];\\n\\n    for(int j = pr + 1;j < preorder.size();j++){\\n        if(!visited[preorder[j]] and post[d] > post[preorder[j]]){\\n            visited[preorder[j]] = 1;\\n            root->left = new TreeNode(preorder[j]);\\n            f(root->left,preorder,postorder);\\n            break;\\n        }\\n    }\\n\\n    for(int j = pst - 1;j >= 0;j--){\\n        if(!visited[postorder[j]] and pre[d] < pre[postorder[j]]){\\n            visited[postorder[j]] = 1;\\n            root->right = new TreeNode(postorder[j]);\\n            f(root->right,preorder,postorder);\\n            break;\\n        }\\n    }\\n\\n\\n}\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        visited.resize(31,false);\\n        pre.resize(31,0);\\n        post.resize(31,0);\\n        for(int i = 0;i < preorder.size();i++)pre[preorder[i]] = i;\\n        for(int i = 0;i < postorder.size();i++)post[postorder[i]] = i;\\n\\n        TreeNode* root = new TreeNode(preorder[0]);\\n\\n        f(root,preorder,postorder);\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777642,
                "title": "c-simple-solution",
                "content": "\\tTreeNode *maketree(vector<int>& preorder, vector<int>& postorder,int &preidx,int left,int right,int size)\\n    {\\n        if(left>right || preidx>=size)\\n            return NULL;\\n        \\n        TreeNode *root=new TreeNode(preorder[preidx]);\\n        preidx++;\\n        if(left==right)\\n            return root;\\n        int i=0;\\n        for(i=left;i<=right;i++)\\n        {\\n            if(preorder[preidx]==postorder[i])\\n                break;\\n        }\\n        if(i<=right)\\n        {\\n            root->left=maketree(preorder,postorder,preidx,left,i,size);\\n            root->right=maketree(preorder,postorder,preidx,i+1,right-1,size);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) \\n    {\\n        int preidx=0;\\n        return maketree(preorder,postorder,preidx,0,preorder.size()-1,preorder.size());    \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tTreeNode *maketree(vector<int>& preorder, vector<int>& postorder,int &preidx,int left,int right,int size)\\n    {\\n        if(left>right || preidx>=size)\\n            return NULL;\\n        \\n        TreeNode *root=new TreeNode(preorder[preidx]);\\n        preidx++;\\n        if(left==right)\\n            return root;\\n        int i=0;\\n        for(i=left;i<=right;i++)\\n        {\\n            if(preorder[preidx]==postorder[i])\\n                break;\\n        }\\n        if(i<=right)\\n        {\\n            root->left=maketree(preorder,postorder,preidx,left,i,size);\\n            root->right=maketree(preorder,postorder,preidx,i+1,right-1,size);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) \\n    {\\n        int preidx=0;\\n        return maketree(preorder,postorder,preidx,0,preorder.size()-1,preorder.size());    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2510576,
                "title": "java-2ms-easy-explained-solution",
                "content": "Let us consider the two given arrays as pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7} and post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}; \\n\\nIn pre[], the leftmost element is root of tree. Since the tree is full and array size is more than 1. The value next to 1 in pre[], must be left child of root. So we know 1 is root and 2 is left child. How to find the all nodes in left subtree? We know 2 is root of all nodes in left subtree. All nodes before 2 in post[] must be in left subtree. Now we know 1 is root, elements {8, 9, 4, 5, 2} are in left subtree, and the elements {6, 7, 3} are in right subtree. \\n\\t\"\\t\\t\\t       1\\n                /           \\\\\\\\\\n               /               \\\\\\\\\\n     {8, 9, 4, 5, 2}        {6, 7, 3}  \"\\nWe recursively follow the approach.\\n\\t\\t    1\\n        /       \\\\\\\\\\n      2           3\\n    /  \\\\\\\\        /  \\\\\\\\\\n   4     5      6    7\\n  / \\\\\\\\  \\n8     9 \\n\\nTime Complexity: O(h), Space Auxiliary Space :O(h)\\n// h is the height of the tree.\\n\\n\\n-----------------------------------------CODE--------------------------------------------------------------------------\\n\\nclass Solution {\\n    int p=0;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = preorder.length;\\n        return construct(preorder, postorder, 0, n-1, n);        \\n    }\\n    \\n    private TreeNode construct(int[] pre, int[] post, int l, int h, int n){\\n        if(p>=n || l>h)\\n            return null;\\n        TreeNode node = new TreeNode(pre[p]);\\n        p++;\\n        if(l==h || p>=n)\\n            return node;\\n        int i;\\n        for(i=l;i<=h;i++)\\n            if(pre[p]==post[i])\\n                break;\\n        if(i<=h){\\n            node.left = construct(pre, post, l, i, n);\\n            node.right = construct(pre, post, i+1, h-1, n);\\n        }\\n        return node;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    int p=0;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = preorder.length;\\n        return construct(preorder, postorder, 0, n-1, n);        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2475027,
                "title": "c-neat-and-clean-recursive-code-easy-understanding",
                "content": "```\\n/*\\n* prsi = preorder starting index\\n* prei = preorder ending index\\n* posi = postorder starting index\\n* poei = postorder ending index\\n*/\\nclass Solution {\\nprivate:\\n  TreeNode *constructTree(vector<int> &pre, int prsi, int prei, vector<int> &post, int posi, int poei){\\n    if(prsi>prei) return NULL;\\n    TreeNode *root = new TreeNode(pre[prsi]);\\n\\t//if one element is present no order to check for it\\'s left part and right part or u may say base case\\n    if(prsi==prei) return root;\\n    int idx = posi;\\n    while(post[idx]!=pre[prsi+1]) idx++;\\n    int totalElem = idx-posi+1;\\n\\t//recursive call to construct left subtree and right subtree\\n    root->left = constructTree(pre, prsi+1, prsi+totalElem, post, posi, idx);\\n    root->right = constructTree(pre, prsi+totalElem+1, prei, post, idx+1, poei-1);\\n    return root;\\n  }\\npublic:\\n  TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder){\\n    return constructTree(preorder, 0, preorder.size()-1, postorder, 0, postorder.size()-1);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n* prsi = preorder starting index\\n* prei = preorder ending index\\n* posi = postorder starting index\\n* poei = postorder ending index\\n*/\\nclass Solution {\\nprivate:\\n  TreeNode *constructTree(vector<int> &pre, int prsi, int prei, vector<int> &post, int posi, int poei){\\n    if(prsi>prei) return NULL;\\n    TreeNode *root = new TreeNode(pre[prsi]);\\n\\t//if one element is present no order to check for it\\'s left part and right part or u may say base case\\n    if(prsi==prei) return root;\\n    int idx = posi;\\n    while(post[idx]!=pre[prsi+1]) idx++;\\n    int totalElem = idx-posi+1;\\n\\t//recursive call to construct left subtree and right subtree\\n    root->left = constructTree(pre, prsi+1, prsi+totalElem, post, posi, idx);\\n    root->right = constructTree(pre, prsi+totalElem+1, prei, post, idx+1, poei-1);\\n    return root;\\n  }\\npublic:\\n  TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder){\\n    return constructTree(preorder, 0, preorder.size()-1, postorder, 0, postorder.size()-1);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452364,
                "title": "do-you-wanna-build-a-binary-tree-a-problem-set-explained-with-figures",
                "content": "## 0. Preliminary\\n### Inorder\\nAn inorder traversal technique follows the\\xA0**Left Root Right** policy. Here, Left Root Right means that the left subtree of the root node is traversed first, then the root node, and then the right subtree of the root node is traversed.\\n### Preorder\\nIn preorder traversal, first, root node is visited, then left sub-tree and after that right sub-tree is visited. The process of preorder traversal can be represented as: **root\\xA0\\u2192\\xA0left\\xA0\\u2192\\xA0right**\\n### Postorder\\nThe postorder traversal technique follows the\\xA0**Left Right Root**\\xA0policy. Here, Left Right Root means the left subtree of the root node is traversed first, then the right subtree, and finally, the root node is traversed.\\n## 1. [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\\n![image](https://assets.leetcode.com/users/images/f3291d64-bcc9-429b-b360-b1739023eadd_1661753418.4619062.png)\\n\\n\\nHow to improve efficiency?\\n- Create a map for `inorder`\\n- Turn `preorder` into a queue, since `popleft` is O(1) operation\\n```\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        preorder = deque(preorder)\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root_index = inorder_map[preorder.popleft()]\\n            root = TreeNode(inorder[root_index], dfs(start, root_index-1), dfs(root_index+1, end))\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\\n\\n## 2. [Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\\n![image](https://assets.leetcode.com/users/images/352aad74-b9e8-49a5-bc4b-4d00d46fdfd6_1660981274.7573395.png)\\n```\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root = TreeNode(postorder.pop())\\n            root_index = inorder_map[root.val]\\n            root.right = dfs(root_index+1, end)  # have to put right before left because postorder.pop will return the right node first\\n            root.left = dfs(start, root_index-1)\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\\n## 3. [Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\\n![image](https://assets.leetcode.com/users/images/9e0a3581-d415-4359-a603-a02663830f54_1660981157.1101289.png)\\n```\\nclass Solution(object):\\n    def constructFromPrePost(self, preorder, postorder):\\n        preorder_map = {v:i for i, v in enumerate(preorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            if start == end: return TreeNode(postorder.pop())\\n            root = TreeNode(postorder.pop())\\n            print(postorder, start, end)\\n            right_start = preorder_map[postorder[-1]]\\n            root.right = dfs(right_start, end)\\n            root.left = dfs(start+1, right_start-1)\\n            return root\\n        \\n        return dfs(0, len(preorder)-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        preorder = deque(preorder)\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root_index = inorder_map[preorder.popleft()]\\n            root = TreeNode(inorder[root_index], dfs(start, root_index-1), dfs(root_index+1, end))\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\n```\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root = TreeNode(postorder.pop())\\n            root_index = inorder_map[root.val]\\n            root.right = dfs(root_index+1, end)  # have to put right before left because postorder.pop will return the right node first\\n            root.left = dfs(start, root_index-1)\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\n```\\nclass Solution(object):\\n    def constructFromPrePost(self, preorder, postorder):\\n        preorder_map = {v:i for i, v in enumerate(preorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            if start == end: return TreeNode(postorder.pop())\\n            root = TreeNode(postorder.pop())\\n            print(postorder, start, end)\\n            right_start = preorder_map[postorder[-1]]\\n            root.right = dfs(right_start, end)\\n            root.left = dfs(start+1, right_start-1)\\n            return root\\n        \\n        return dfs(0, len(preorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419272,
                "title": "intuition-explained-o-n-c-solution",
                "content": "```\\nint i=0;\\n    unordered_map<int,int> m;\\n    \\n    TreeNode* solve(vector<int>& pre, vector<int>& post,int start,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        \\n            TreeNode* root= new TreeNode(pre[i++]);  //preordeer wala element root bnado\\n        \\n        //start==end hai to exit kro vrna endless loop me fas skta (start,idx) and for last element i++ will be out of bounds in preorder so in that case also return root\\n        \\n            if(i>=pre.size() or start==end)\\n                return root;\\n        \\n        //preorder ka agla element root->left ka head hai prr left subtree me kitne elements ayege ye decide krega postorder traversal start se idx tak left part hai idx+1 se end-1 tka right part hai . end of postorder = root;\\n        \\n        int idx=m[pre[i]];  \\n        \\n        root->left=solve(pre,post,start,idx);\\n        root->right=solve(pre,post,idx+1,end-1);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        for(int i=0;i<post.size();i++)  //for O(1) searchibg store in map\\n            m[post[i]]=i;\\n        \\n        return solve(pre,post,0,post.size()-1);\\n    }",
                "solutionTags": [],
                "code": "```\\nint i=0;\\n    unordered_map<int,int> m;\\n    \\n    TreeNode* solve(vector<int>& pre, vector<int>& post,int start,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        \\n            TreeNode* root= new TreeNode(pre[i++]);  //preordeer wala element root bnado\\n        \\n        //start==end hai to exit kro vrna endless loop me fas skta (start,idx) and for last element i++ will be out of bounds in preorder so in that case also return root\\n        \\n            if(i>=pre.size() or start==end)\\n                return root;\\n        \\n        //preorder ka agla element root->left ka head hai prr left subtree me kitne elements ayege ye decide krega postorder traversal start se idx tak left part hai idx+1 se end-1 tka right part hai . end of postorder = root;\\n        \\n        int idx=m[pre[i]];  \\n        \\n        root->left=solve(pre,post,start,idx);\\n        root->right=solve(pre,post,idx+1,end-1);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        for(int i=0;i<post.size();i++)  //for O(1) searchibg store in map\\n            m[post[i]]=i;\\n        \\n        return solve(pre,post,0,post.size()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2406697,
                "title": "c-recursive-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int> &preorder,unordered_map<int,int> &mp,\\n                   int pre_start,int pre_end,int post_start,int post_end)\\n    {\\n        if(pre_start>pre_end || post_start>post_end)\\n            return NULL;\\n        \\n        TreeNode *root=new TreeNode(preorder[pre_start]);\\n        if(pre_start==pre_end)\\n            return root;\\n        \\n        int temp=mp[preorder[pre_start+1]];\\n        int len=temp-post_start+1;\\n        \\n        root->left=solve(preorder, mp, pre_start+1, pre_start+len,\\n                        post_start,temp);\\n        root->right=solve(preorder, mp, pre_start+len+1, pre_end,\\n                         temp+1,post_end-1);\\n            \\n        return root;    \\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        unordered_map<int,int> mp;\\n        int n=postorder.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[postorder[i]]=i;\\n        }\\n        return solve(preorder,mp,0,n-1,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int> &preorder,unordered_map<int,int> &mp,\\n                   int pre_start,int pre_end,int post_start,int post_end)\\n    {\\n        if(pre_start>pre_end || post_start>post_end)\\n            return NULL;\\n        \\n        TreeNode *root=new TreeNode(preorder[pre_start]);\\n        if(pre_start==pre_end)\\n            return root;\\n        \\n        int temp=mp[preorder[pre_start+1]];\\n        int len=temp-post_start+1;\\n        \\n        root->left=solve(preorder, mp, pre_start+1, pre_start+len,\\n                        post_start,temp);\\n        root->right=solve(preorder, mp, pre_start+len+1, pre_end,\\n                         temp+1,post_end-1);\\n            \\n        return root;    \\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        unordered_map<int,int> mp;\\n        int n=postorder.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[postorder[i]]=i;\\n        }\\n        return solve(preorder,mp,0,n-1,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378712,
                "title": "python-simple-recursion",
                "content": "\\n    def constructFromPrePost(self, preorder, postorder):\\n        if not preorder and not postorder:\\n            return None\\n        \\n        if len(preorder) == 1:\\n            return TreeNode(preorder[0])\\n        \\n        idx = postorder.index(preorder[1])\\n        \\n        root = TreeNode(preorder[0])\\n        root.left = self.constructFromPrePost(preorder[1:idx+2], postorder[:idx+1])\\n        root.right = self.constructFromPrePost(preorder[idx+2:], postorder[idx+1:-1])\\n        \\n        return root",
                "solutionTags": [],
                "code": "\\n    def constructFromPrePost(self, preorder, postorder):\\n        if not preorder and not postorder:\\n            return None\\n        \\n        if len(preorder) == 1:\\n            return TreeNode(preorder[0])\\n        \\n        idx = postorder.index(preorder[1])\\n        \\n        root = TreeNode(preorder[0])\\n        root.left = self.constructFromPrePost(preorder[1:idx+2], postorder[:idx+1])\\n        root.right = self.constructFromPrePost(preorder[idx+2:], postorder[idx+1:-1])\\n        \\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 2343606,
                "title": "python-recursive-solution",
                "content": "Below is the code\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n\\n        def build(preorder, preStart, preEnd, postorder, postStart, postEnd):\\n            if preStart > preEnd:\\n                return\\n            elif preStart == preEnd:\\n                return TreeNode(preorder[preStart])\\n            \\n            rootVal = preorder[preStart]\\n            leftRootVal = preorder[preStart + 1]\\n            index = valToIndex[leftRootVal]\\n            root = TreeNode(rootVal)\\n            leftSize = index - postStart + 1\\n            \\n            root.left = build(preorder, preStart + 1, preStart + leftSize,\\npostorder, postStart, index)\\n            root.right = build(preorder, preStart + leftSize + 1, preEnd,\\npostorder, index + 1, postEnd - 1)\\n            \\n            return root\\n        \\n        valToIndex = {}\\n        for i in range(len(postorder)):\\n            valToIndex[postorder[i]] = i\\n        \\n        return build(preorder, 0, len(preorder) - 1, postorder, 0, len(postorder) - 1)\\n```\\n\\nLeave a comment if you have questions !",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n\\n        def build(preorder, preStart, preEnd, postorder, postStart, postEnd):\\n            if preStart > preEnd:\\n                return\\n            elif preStart == preEnd:\\n                return TreeNode(preorder[preStart])\\n            \\n            rootVal = preorder[preStart]\\n            leftRootVal = preorder[preStart + 1]\\n            index = valToIndex[leftRootVal]\\n            root = TreeNode(rootVal)\\n            leftSize = index - postStart + 1\\n            \\n            root.left = build(preorder, preStart + 1, preStart + leftSize,\\npostorder, postStart, index)\\n            root.right = build(preorder, preStart + leftSize + 1, preEnd,\\npostorder, index + 1, postEnd - 1)\\n            \\n            return root\\n        \\n        valToIndex = {}\\n        for i in range(len(postorder)):\\n            valToIndex[postorder[i]] = i\\n        \\n        return build(preorder, 0, len(preorder) - 1, postorder, 0, len(postorder) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285366,
                "title": "iterative-stack-based-post-order-traversal",
                "content": "```\\n# include \"stdio.h\"\\n# include \"stdlib.h\"\\n# include \"stdbool.h\"\\n\\nstruct TreeNode {\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nstruct TreeNode* createTreeNode(int val) {\\n    struct TreeNode* new_tree_node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n    new_tree_node->val = val;\\n    new_tree_node->left = NULL;\\n    new_tree_node->right = NULL;\\n    return new_tree_node;\\n}\\n\\nstruct StackElement{\\n    struct TreeNode* node;\\n    struct StackElement* next;\\n};\\n\\nstruct Stack{\\n    struct StackElement* top;\\n};\\n\\nstruct StackElement* createStackElement(struct TreeNode* node){\\n    struct StackElement* new_stack_element = (struct StackElement*)malloc(sizeof(struct StackElement));\\n    new_stack_element->node = node;\\n    new_stack_element->next = NULL;\\n    return new_stack_element;\\n}\\n\\nstruct Stack* createStack(){\\n    struct Stack* new_stack = (struct Stack*)malloc(sizeof(struct Stack));\\n    new_stack->top = NULL;\\n    return new_stack;\\n}\\n\\nvoid deleteStackElement(struct StackElement* stack_element){\\n    free(stack_element);\\n}\\n\\nstruct TreeNode* peekStack(struct Stack* stack){\\n    struct StackElement* top_element = stack->top;\\n    if(top_element) return top_element->node;\\n    return NULL;\\n}\\n\\nvoid addToStack(struct Stack* stack, struct TreeNode* node){\\n    struct StackElement* new_stack_element = createStackElement(node);\\n    new_stack_element->next = stack->top;\\n    stack->top = new_stack_element;\\n}\\n\\nstruct TreeNode* popFromStack(struct Stack* stack){\\n    struct StackElement* top_element = stack->top;\\n    if(top_element){\\n        stack->top = top_element->next;\\n        struct TreeNode* node_to_return = top_element->node;\\n        deleteStackElement(top_element);\\n        return node_to_return;\\n    }\\n    return NULL;\\n}\\n\\nvoid deleteStack(struct Stack* stack){\\n    while(popFromStack(stack));\\n    free(stack);\\n}\\n\\nstruct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }\\n        }\\n        // otherwise add the current node to the stack\\n        else addToStack(stack, new_node);\\n\\n        pre_order_pointer++;\\n    }\\n    deleteStack(stack);\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n# include \"stdio.h\"\\n# include \"stdlib.h\"\\n# include \"stdbool.h\"\\n\\nstruct TreeNode {\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nstruct TreeNode* createTreeNode(int val) {\\n    struct TreeNode* new_tree_node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n    new_tree_node->val = val;\\n    new_tree_node->left = NULL;\\n    new_tree_node->right = NULL;\\n    return new_tree_node;\\n}\\n\\nstruct StackElement{\\n    struct TreeNode* node;\\n    struct StackElement* next;\\n};\\n\\nstruct Stack{\\n    struct StackElement* top;\\n};\\n\\nstruct StackElement* createStackElement(struct TreeNode* node){\\n    struct StackElement* new_stack_element = (struct StackElement*)malloc(sizeof(struct StackElement));\\n    new_stack_element->node = node;\\n    new_stack_element->next = NULL;\\n    return new_stack_element;\\n}\\n\\nstruct Stack* createStack(){\\n    struct Stack* new_stack = (struct Stack*)malloc(sizeof(struct Stack));\\n    new_stack->top = NULL;\\n    return new_stack;\\n}\\n\\nvoid deleteStackElement(struct StackElement* stack_element){\\n    free(stack_element);\\n}\\n\\nstruct TreeNode* peekStack(struct Stack* stack){\\n    struct StackElement* top_element = stack->top;\\n    if(top_element) return top_element->node;\\n    return NULL;\\n}\\n\\nvoid addToStack(struct Stack* stack, struct TreeNode* node){\\n    struct StackElement* new_stack_element = createStackElement(node);\\n    new_stack_element->next = stack->top;\\n    stack->top = new_stack_element;\\n}\\n\\nstruct TreeNode* popFromStack(struct Stack* stack){\\n    struct StackElement* top_element = stack->top;\\n    if(top_element){\\n        stack->top = top_element->next;\\n        struct TreeNode* node_to_return = top_element->node;\\n        deleteStackElement(top_element);\\n        return node_to_return;\\n    }\\n    return NULL;\\n}\\n\\nvoid deleteStack(struct Stack* stack){\\n    while(popFromStack(stack));\\n    free(stack);\\n}\\n\\nstruct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }\\n        }\\n        // otherwise add the current node to the stack\\n        else addToStack(stack, new_node);\\n\\n        pre_order_pointer++;\\n    }\\n    deleteStack(stack);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282905,
                "title": "c-faster-soln",
                "content": "class Solution {\\npublic:\\n    \\n    TreeNode* construct(vector<int>& pre, int prei, int prej, \\n                        vector<int>& post, int posti, int postj){\\n        if (prei>prej) return NULL;\\n        TreeNode* root = new TreeNode(pre[prei]);\\n        if (prei==prej){\\n            root->left = NULL; root->right = NULL;\\n            return root;\\n        } \\n        int mid = 1;\\n        for (int i=1; i<=prej-prei; i++){\\n            if (pre[prei+i]==post[postj-1] && (i<2 || post[posti+i-2]==pre[prei+1])){\\n                mid = i; break;\\n            }\\n        }\\n        root->left = construct(pre, prei+1, prei+mid-1, post, posti, posti+mid-2);\\n        root->right = construct(pre, prei+mid, prej, post, posti+mid-1, postj-1);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int prestart = 0;\\n        int preend = preorder.size()-1;\\n        \\n        int poststart = 0;\\n        int postend = postorder.size()-1;\\n        return construct(preorder,prestart,preend,postorder,poststart,postend);\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode* construct(vector<int>& pre, int prei, int prej, \\n                        vector<int>& post, int posti, int postj){\\n        if (prei>prej) return NULL;\\n        TreeNode* root = new TreeNode(pre[prei]);\\n        if (prei==prej){\\n            root->left = NULL; root->right = NULL;\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2249594,
                "title": "easy-java-implementation-with-explanation",
                "content": "As we know that the first node during preorder traversal is root and the last node during post order traversal is node. We are using this concept to build a binary tree with preorder and postorder traversal.\\n\\nApproach:\\n* Take a helper function which will return a TreeNode and pass 6 arguments- Preorder, preorder start index, preorder end index, Postorder, postorder start index, postorder end index.\\n* Since we are solving this recursively the base case would be if the preorder start index == preorder end index or it can be postorder start index == postorder end index i.e there is only one element in preorder and postorder and we surely know that this is the root node. So construct a node and return it.\\n* If the above condition is not true then we will update the four pointers pre start, pre end , post start, post end.\\n* The first element in preorder traversal is the root and the second element is going to come under the left subtree(here we are considering only full binary trees) so this becomes the preorder start index.\\n* To calculate the pre order end index we need to know the count of elements in the left sub tree . This can be done using the post order traversal.\\n* Iterate throught the post order and look for the index of the element preorder[preorder start +1] in post order.This index will become postorder end index for the leftSub tree.\\n* The count of elements in leftSub Tree will be postorder start index - index + 1.\\n* Now pre order end index = preorder start + count and post order start remain the same.\\n* Pass these arguments to get the left sub tree for root. and for root we will again calculate the 4 pointers\\n* Preorder start = preorder start + 1, preorder end = preorder end, \\n* Postorder start = index+1, postorder end = postorder end -1.\\n* Pass these arguments to get the right sub Tree of the root.\\n* And finally return the root.\\n\\n\\n\\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        \\n        int ps = 0, pe=preorder.length-1;\\n        int pos = 0, poe= postorder.length-1;\\n        \\n        return constructTree(preorder,ps,pe,postorder,pos,poe);\\n    }\\n    \\n    public TreeNode constructTree(int[] preorder, int ps, int pe, int[] postorder, int pos,int poe){\\n        \\n        if(ps > pe) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[ps]);\\n        \\n        if(ps - pe == 0) return root;\\n        \\n        int index = -1;\\n        for(int i=poe-1; i >= pos; i--){\\n            if(postorder[i] == preorder[ps+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int count = index - pos + 1;\\n        \\n        root.left = constructTree(preorder, ps+1,ps+count, postorder, pos, index );\\n        root.right = constructTree(preorder, ps+count + 1, pe, postorder,index+1, poe-1);\\n        \\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        \\n        int ps = 0, pe=preorder.length-1;\\n        int pos = 0, poe= postorder.length-1;\\n        \\n        return constructTree(preorder,ps,pe,postorder,pos,poe);\\n    }\\n    \\n    public TreeNode constructTree(int[] preorder, int ps, int pe, int[] postorder, int pos,int poe){\\n        \\n        if(ps > pe) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[ps]);\\n        \\n        if(ps - pe == 0) return root;\\n        \\n        int index = -1;\\n        for(int i=poe-1; i >= pos; i--){\\n            if(postorder[i] == preorder[ps+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int count = index - pos + 1;\\n        \\n        root.left = constructTree(preorder, ps+1,ps+count, postorder, pos, index );\\n        root.right = constructTree(preorder, ps+count + 1, pe, postorder,index+1, poe-1);\\n        \\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242692,
                "title": "java-faster-than-99-31-memory-less-than-77-45",
                "content": "```\\n\\'\\'\\'\\nclass Solution {\\n    public int findRoot(int[] postorder,int start, int end, int root)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n           if(postorder[i] == root) return i;\\n        }\\n    \\n        return -1;\\n    }\\n    \\n    public TreeNode buildFullBT(int[] postorder, int[] preorder, int preStart, int preEnd, int poStart, int poEnd)\\n    {\\n        \\n        if(preStart > preEnd) return null;\\n         if(preStart==preEnd) return new TreeNode(preorder[preStart]);\\n             \\n            \\n        TreeNode node  = new TreeNode(preorder[preStart]); \\n        int rootIndex = findRoot(postorder,poStart, poEnd, preorder[preStart + 1]);\\n        node.left = buildFullBT(postorder, preorder, preStart + 1, preStart + rootIndex - poStart + 1, poStart, rootIndex);\\n        \\n        node.right = buildFullBT(postorder, preorder, preEnd - poEnd + rootIndex + 2, preEnd, rootIndex + 1,\\n                                poEnd - 1);\\n        \\n        return node;\\n    }\\n        \\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder)\\n    {\\n        \\n        return buildFullBT(postorder, preorder,0, preorder.length - 1, 0, postorder.length - 1);\\n        \\n        \\n        \\n    }\\n}\\n\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\n\\'\\'\\'\\nclass Solution {\\n    public int findRoot(int[] postorder,int start, int end, int root)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n           if(postorder[i] == root) return i;\\n        }\\n    \\n        return -1;\\n    }\\n    \\n    public TreeNode buildFullBT(int[] postorder, int[] preorder, int preStart, int preEnd, int poStart, int poEnd)\\n    {\\n        \\n        if(preStart > preEnd) return null;\\n         if(preStart==preEnd) return new TreeNode(preorder[preStart]);\\n             \\n            \\n        TreeNode node  = new TreeNode(preorder[preStart]); \\n        int rootIndex = findRoot(postorder,poStart, poEnd, preorder[preStart + 1]);\\n        node.left = buildFullBT(postorder, preorder, preStart + 1, preStart + rootIndex - poStart + 1, poStart, rootIndex);\\n        \\n        node.right = buildFullBT(postorder, preorder, preEnd - poEnd + rootIndex + 2, preEnd, rootIndex + 1,\\n                                poEnd - 1);\\n        \\n        return node;\\n    }\\n        \\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder)\\n    {\\n        \\n        return buildFullBT(postorder, preorder,0, preorder.length - 1, 0, postorder.length - 1);\\n        \\n        \\n        \\n    }\\n}\\n\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242505,
                "title": "python3-same-template-to-solve-3-binary-tree-construction-problems",
                "content": "**Construct using Preorder and Postorder**\\n\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return\\n        \\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n        index = postorder.index(preorder[1])\\n        root.left = self.constructFromPrePost(preorder[1:index+2], postorder[:index+1])\\n        root.right = self.constructFromPrePost(preorder[index+2:], postorder[index+1:-1])\\n        return root\\n```\\n\\n**Construct using Preorder and Inorder**\\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder:\\n            return\\n        \\n        root = TreeNode(preorder[0])\\n        mid = inorder.index(preorder[0])\\n        root.left = self.buildTree(preorder[1: mid+1], inorder[:mid])\\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\\n        return root\\n```\\n\\n**Construct using Postorder and Inorder**\\n\\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not postorder or not inorder:\\n            return\\n        \\n        root = TreeNode(postorder[-1])\\n        mid = inorder.index(postorder[-1])\\n        root.left = self.buildTree(inorder[:mid], postorder[:mid])\\n        root.right = self.buildTree(inorder[mid+1:], postorder[mid:-1])\\n        return root\\n        \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return\\n        \\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n        index = postorder.index(preorder[1])\\n        root.left = self.constructFromPrePost(preorder[1:index+2], postorder[:index+1])\\n        root.right = self.constructFromPrePost(preorder[index+2:], postorder[index+1:-1])\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder:\\n            return\\n        \\n        root = TreeNode(preorder[0])\\n        mid = inorder.index(preorder[0])\\n        root.left = self.buildTree(preorder[1: mid+1], inorder[:mid])\\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not postorder or not inorder:\\n            return\\n        \\n        root = TreeNode(postorder[-1])\\n        mid = inorder.index(postorder[-1])\\n        root.left = self.buildTree(inorder[:mid], postorder[:mid])\\n        root.right = self.buildTree(inorder[mid+1:], postorder[mid:-1])\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222353,
                "title": "java-solution-very-easy-approach-easy-and-simple-to-understand",
                "content": "```\\nclass Solution {\\n    TreeNode tree_builder(int[] preorder,int preStart,int preEnd, int[] postorder,int poStart,int posEnd){\\n        if(preStart>preEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(preorder[preStart]);\\n        if(preStart==preEnd)return root;\\n        int idx=poStart;\\n        while(postorder[idx]!=preorder[preStart+1]){\\n            idx++;\\n        }\\n        int total_elements=(idx-poStart)+1;\\n        root.left=tree_builder(preorder,preStart+1,preStart+total_elements,postorder,poStart,idx);\\n        root.right=tree_builder(preorder,preStart+total_elements+1,preEnd,postorder,idx+1,posEnd-1);\\n        \\n        return root;\\n    }\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        return tree_builder(preorder,0,preorder.length-1,postorder,0,postorder.length-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode tree_builder(int[] preorder,int preStart,int preEnd, int[] postorder,int poStart,int posEnd){\\n        if(preStart>preEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(preorder[preStart]);\\n        if(preStart==preEnd)return root;\\n        int idx=poStart;\\n        while(postorder[idx]!=preorder[preStart+1]){\\n            idx++;\\n        }\\n        int total_elements=(idx-poStart)+1;\\n        root.left=tree_builder(preorder,preStart+1,preStart+total_elements,postorder,poStart,idx);\\n        root.right=tree_builder(preorder,preStart+total_elements+1,preEnd,postorder,idx+1,posEnd-1);\\n        \\n        return root;\\n    }\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        return tree_builder(preorder,0,preorder.length-1,postorder,0,postorder.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219852,
                "title": "c-easy-recursion",
                "content": "Please Upvote :)\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int vis[32];\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        memset(vis,0,sizeof(vis));\\n        return fun(preorder,0,postorder,postorder.size()-1);\\n    }\\n    TreeNode* fun(vector<int>& pre,int p,vector<int>& post,int q)\\n    {\\n        //cout<<\"Initial : \\\\t\"<<p<<\"\\\\t\"<<q<<endl;\\n        TreeNode* root=new TreeNode(pre[p]);\\n        vis[root->val]=1;\\n        p++;\\n        q--;\\n        //cout<<root->val<<\"\\\\t\"<<p<<\"\\\\t\"<<q<<endl;\\n        \\n        if(q<0 || p>=pre.size())\\n            return root;\\n        \\n        if(vis[pre[p]]==0)\\n        {\\n            int j=q;\\n            while(j>0 && post[j]!=pre[p])\\n                j--;\\n            if(post[j]==pre[p])\\n                root->left=fun(pre,p,post,j);\\n        }\\n        if(vis[post[q]]==0)\\n        {\\n            int j=p;\\n            while(j<pre.size()-1 && pre[j]!=post[q])\\n                j++;\\n            if(pre[j]==post[q])\\n            root->right=fun(pre,j,post,q);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int vis[32];\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        memset(vis,0,sizeof(vis));\\n        return fun(preorder,0,postorder,postorder.size()-1);\\n    }\\n    TreeNode* fun(vector<int>& pre,int p,vector<int>& post,int q)\\n    {\\n        //cout<<\"Initial : \\\\t\"<<p<<\"\\\\t\"<<q<<endl;\\n        TreeNode* root=new TreeNode(pre[p]);\\n        vis[root->val]=1;\\n        p++;\\n        q--;\\n        //cout<<root->val<<\"\\\\t\"<<p<<\"\\\\t\"<<q<<endl;\\n        \\n        if(q<0 || p>=pre.size())\\n            return root;\\n        \\n        if(vis[pre[p]]==0)\\n        {\\n            int j=q;\\n            while(j>0 && post[j]!=pre[p])\\n                j--;\\n            if(post[j]==pre[p])\\n                root->left=fun(pre,p,post,j);\\n        }\\n        if(vis[post[q]]==0)\\n        {\\n            int j=p;\\n            while(j<pre.size()-1 && pre[j]!=post[q])\\n                j++;\\n            if(pre[j]==post[q])\\n            root->right=fun(pre,j,post,q);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2182173,
                "title": "java-solution-recursive-both-approach-using-hashmap-and-normal",
                "content": "**No Extra Space : 2MS**\\n```\\nclass Solution {\\n    static int index;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        if(preorder.length != postorder.length) return null;\\n        index = 0;\\n        TreeNode root = Solve(preorder,postorder,0,postorder.length-1);\\n        return root;\\n    }\\n    \\n    public TreeNode Solve(int[] preorder, int[] postorder, int start, int end){\\n        if(index >= postorder.length || start > end ){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        if(start == end || index >= postorder.length){\\n            return root;\\n        }\\n        \\n        int mid;\\n        for(mid=start; mid<=end; mid++){\\n            if(postorder[mid] == preorder[index]){\\n                break;\\n            }\\n        }\\n        \\n        if(mid<=end){\\n            root.left = Solve(preorder,postorder,start,mid);\\n            root.right = Solve(preorder,postorder,mid+1,end-1);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```\\n\\n\\n**Using Extra Space , HashMap : 1MS**\\n```\\nclass Solution {\\n    static int index;\\n    static HashMap<Integer,Integer> map = new HashMap<>();\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        if(preorder.length != postorder.length) return null;\\n        index = 0;\\n        for(int i=0;i<postorder.length;i++){\\n            map.put(postorder[i],i);\\n        }\\n        TreeNode root = Solve(preorder,postorder,0,postorder.length-1);\\n        return root;\\n    }\\n    \\n    public TreeNode Solve(int[] preorder, int[] postorder, int start, int end){\\n        if(index >= postorder.length || start > end ){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        if(start == end || index >= postorder.length){\\n            return root;\\n        }\\n        \\n        \\n        \\n        int mid = map.get(preorder[index]);\\n        \\n        if(mid<=end){\\n            root.left = Solve(preorder,postorder,start,mid);\\n            root.right = Solve(preorder,postorder,mid+1,end-1);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static int index;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        if(preorder.length != postorder.length) return null;\\n        index = 0;\\n        TreeNode root = Solve(preorder,postorder,0,postorder.length-1);\\n        return root;\\n    }\\n    \\n    public TreeNode Solve(int[] preorder, int[] postorder, int start, int end){\\n        if(index >= postorder.length || start > end ){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        if(start == end || index >= postorder.length){\\n            return root;\\n        }\\n        \\n        int mid;\\n        for(mid=start; mid<=end; mid++){\\n            if(postorder[mid] == preorder[index]){\\n                break;\\n            }\\n        }\\n        \\n        if(mid<=end){\\n            root.left = Solve(preorder,postorder,start,mid);\\n            root.right = Solve(preorder,postorder,mid+1,end-1);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static int index;\\n    static HashMap<Integer,Integer> map = new HashMap<>();\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        if(preorder.length != postorder.length) return null;\\n        index = 0;\\n        for(int i=0;i<postorder.length;i++){\\n            map.put(postorder[i],i);\\n        }\\n        TreeNode root = Solve(preorder,postorder,0,postorder.length-1);\\n        return root;\\n    }\\n    \\n    public TreeNode Solve(int[] preorder, int[] postorder, int start, int end){\\n        if(index >= postorder.length || start > end ){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        if(start == end || index >= postorder.length){\\n            return root;\\n        }\\n        \\n        \\n        \\n        int mid = map.get(preorder[index]);\\n        \\n        if(mid<=end){\\n            root.left = Solve(preorder,postorder,start,mid);\\n            root.right = Solve(preorder,postorder,mid+1,end-1);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147478,
                "title": "cpp-tree",
                "content": "```\\nNode* HelperFunction(vector<int> preorder, int preorderStartIdx, int preorderEndIdx,\\n                     vector<int> postorder, int postorderStartIdx, int postorderEndIdx) {\\n\\tif (preorderStartIdx > preorderEndIdx) return NULL;\\n\\n\\tNode* node = new Node(postorder[postorderEndIdx]);\\n\\t//edge case\\n\\tif (preorderStartIdx == preorderEndIdx) return node;\\n\\n\\tint idx = postorderStartIdx;\\n\\twhile (postorder[idx] != preorder[preorderStartIdx + 1]) idx++;\\n\\tint countOfElements = idx - postorderStartIdx + 1;\\n\\n\\t//recursive calls\\n\\tnode->left = HelperFunction(preorder, preorderStartIdx + 1, preorderStartIdx + countOfElements, postorder, postorderStartIdx, idx);\\n\\tnode->right = HelperFunction(preorder, preorderStartIdx + countOfElements + 1, preorderEndIdx, postorder, idx + 1, postorderEndIdx - 1);\\n\\n\\treturn node;\\n}\\n\\nNode* constructBTFromPostorderAndpreorder(vector<int> postorder, vector<int> preorder) {\\n\\tint n = preorder.size();\\n\\treturn HelperFunction(preorder, 0, n - 1, postorder, 0 , n - 1);\\n}",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nNode* HelperFunction(vector<int> preorder, int preorderStartIdx, int preorderEndIdx,\\n                     vector<int> postorder, int postorderStartIdx, int postorderEndIdx) {\\n\\tif (preorderStartIdx > preorderEndIdx) return NULL;\\n\\n\\tNode* node = new Node(postorder[postorderEndIdx]);\\n\\t//edge case\\n\\tif (preorderStartIdx == preorderEndIdx) return node;\\n\\n\\tint idx = postorderStartIdx;\\n\\twhile (postorder[idx] != preorder[preorderStartIdx + 1]) idx++;\\n\\tint countOfElements = idx - postorderStartIdx + 1;\\n\\n\\t//recursive calls\\n\\tnode->left = HelperFunction(preorder, preorderStartIdx + 1, preorderStartIdx + countOfElements, postorder, postorderStartIdx, idx);\\n\\tnode->right = HelperFunction(preorder, preorderStartIdx + countOfElements + 1, preorderEndIdx, postorder, idx + 1, postorderEndIdx - 1);\\n\\n\\treturn node;\\n}\\n\\nNode* constructBTFromPostorderAndpreorder(vector<int> postorder, vector<int> preorder) {\\n\\tint n = preorder.size();\\n\\treturn HelperFunction(preorder, 0, n - 1, postorder, 0 , n - 1);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2136783,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def build(preLeft, preRight):\\n            if preLeft > preRight:\\n                return None\\n            \\n            # food for thought: why do we need this base case?\\n            if preLeft == preRight:\\n                root = TreeNode(postorder[self.postIdx])\\n                self.postIdx -= 1\\n                return root\\n            \\n            rootVal = postorder[self.postIdx]\\n            root = TreeNode(rootVal)\\n            self.postIdx -= 1\\n            \\n            cutIdx = mp[postorder[self.postIdx]]\\n            root.right = build(cutIdx, preRight)\\n            root.left = build(preLeft + 1, cutIdx - 1)\\n            return root\\n            \\n        \\n        self.postIdx = len(postorder) - 1\\n        mp = {val : idx for idx, val in enumerate(preorder)}\\n        return build(0, len(preorder) - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def build(preLeft, preRight):\\n            if preLeft > preRight:\\n                return None\\n            \\n            # food for thought: why do we need this base case?\\n            if preLeft == preRight:\\n                root = TreeNode(postorder[self.postIdx])\\n                self.postIdx -= 1\\n                return root\\n            \\n            rootVal = postorder[self.postIdx]\\n            root = TreeNode(rootVal)\\n            self.postIdx -= 1\\n            \\n            cutIdx = mp[postorder[self.postIdx]]\\n            root.right = build(cutIdx, preRight)\\n            root.left = build(preLeft + 1, cutIdx - 1)\\n            return root\\n            \\n        \\n        self.postIdx = len(postorder) - 1\\n        mp = {val : idx for idx, val in enumerate(preorder)}\\n        return build(0, len(preorder) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078080,
                "title": "simple-js-solution-w-comments-dfs",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 113 ms, faster than 72.50% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\n// Memory Usage: 45.3 MB, less than 18.33% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\nconst constructFromPrePost = (preorder, postorder) => {\\n\\tlet preIdx = 0;\\n\\tlet postIdx = 0;\\n\\n\\tconst traverse = () => {\\n\\t\\tconst root = new TreeNode(preorder[preIdx++]);\\n\\n\\t\\t// when preorder[preIdx] !== postorder[postIdx], create current Left/Right subtree\\n\\t\\t// when preorder[preIdx] === postorder[postIdx], completed building current Left/Right subtree\\n\\t\\tif (root.val !== postorder[postIdx]) root.left = traverse();\\n\\t\\tif (root.val !== postorder[postIdx]) root.right = traverse();\\n\\n\\t\\t// increment postIdx to switch on to other side of the subtree\\n\\t\\tpostIdx++;\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\treturn traverse();\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 113 ms, faster than 72.50% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\n// Memory Usage: 45.3 MB, less than 18.33% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\nconst constructFromPrePost = (preorder, postorder) => {\\n\\tlet preIdx = 0;\\n\\tlet postIdx = 0;\\n\\n\\tconst traverse = () => {\\n\\t\\tconst root = new TreeNode(preorder[preIdx++]);\\n\\n\\t\\t// when preorder[preIdx] !== postorder[postIdx], create current Left/Right subtree\\n\\t\\t// when preorder[preIdx] === postorder[postIdx], completed building current Left/Right subtree\\n\\t\\tif (root.val !== postorder[postIdx]) root.left = traverse();\\n\\t\\tif (root.val !== postorder[postIdx]) root.right = traverse();\\n\\n\\t\\t// increment postIdx to switch on to other side of the subtree\\n\\t\\tpostIdx++;\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\treturn traverse();\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052580,
                "title": "python-recursive-solutoin",
                "content": "```\\ndef constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        \\n        root = TreeNode(preorder.pop(0))\\n        postorder.pop(-1)\\n        \\n        if preorder:\\n            char = preorder[0]\\n            i = postorder.index(char)\\n            root.left = self.constructFromPrePost(preorder[0: i + 1], postorder[0:i+1])\\n            root.right = self.constructFromPrePost(preorder[i+1:], postorder[i+1:])\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        \\n        root = TreeNode(preorder.pop(0))\\n        postorder.pop(-1)\\n        \\n        if preorder:\\n            char = preorder[0]\\n            i = postorder.index(char)\\n            root.left = self.constructFromPrePost(preorder[0: i + 1], postorder[0:i+1])\\n            root.right = self.constructFromPrePost(preorder[i+1:], postorder[i+1:])\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2044852,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int preInd = 0, postInd = 0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode *root = new TreeNode(pre[preInd++]);\\n        if(root->val != post[postInd]) {\\n            root->left = constructFromPrePost(pre, post);\\n        }\\n        if(root->val != post[postInd]) {\\n            root->right = constructFromPrePost(pre, post);\\n        }\\n        postInd++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int preInd = 0, postInd = 0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode *root = new TreeNode(pre[preInd++]);\\n        if(root->val != post[postInd]) {\\n            root->left = constructFromPrePost(pre, post);\\n        }\\n        if(root->val != post[postInd]) {\\n            root->right = constructFromPrePost(pre, post);\\n        }\\n        postInd++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940467,
                "title": "python-3-reursive-9-line",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder: return None\\n        n = len(preorder)\\n        if n == 1:\\n            return TreeNode(preorder[0])\\n        \\n        root = TreeNode(preorder[0])\\n        idx = postorder.index(preorder[1])\\n        root.left = self.constructFromPrePost(preorder[1:idx + 2], postorder[:idx + 1])\\n        root.right = self.constructFromPrePost(preorder[idx + 2:], postorder[idx + 1:- 1])\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder: return None\\n        n = len(preorder)\\n        if n == 1:\\n            return TreeNode(preorder[0])\\n        \\n        root = TreeNode(preorder[0])\\n        idx = postorder.index(preorder[1])\\n        root.left = self.constructFromPrePost(preorder[1:idx + 2], postorder[:idx + 1])\\n        root.right = self.constructFromPrePost(preorder[idx + 2:], postorder[idx + 1:- 1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812417,
                "title": "java-o-n-clean-solutions",
                "content": "Here I provide 1 solutions with 2 different implementations. \\nThe longer and slower one comes first (but may be easier to follow).\\n\\nWe can build the tree by doing a preorder traversal with the only added constraint that **parent post index > child post index**.\\n\\nIn general, when it comes to following two different traversals, we can just simulate the process straight up with 1 traversal + the constraint from the other traversal mixed in.\\n\\n**Solution 1 (Queue):** [<ins>Average Speed</ins>]\\n```Java\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = postorder.length;\\n        int[] post = new int[n + 1];\\n        for (int i = 0; i < n; i++){\\n            post[postorder[i]] = i; // quick lookup array\\n        }\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int p : preorder){\\n            queue.offer(p);\\n        }\\n        return build(queue, queue.peek(), preorder, post);\\n    }\\n\\n    private TreeNode build(Queue<Integer> queue, int parent, int[] pre, int[] post){\\n        if (queue.isEmpty()) return null;\\n        if (post[queue.peek()] > post[parent]) return null;  \\n        int val = queue.poll();\\n        return new TreeNode(val, build(queue, val, pre, post), \\n                                 build(queue, val, pre, post));\\n    }\\n}\\n```\\n\\nHere is the array version for those who dislike queue. \\nIt runs faster because of less overhead and one less O(n) processing loop in the beginning.\\n\\n**Solution 2 (Array)** [<ins>Beat 90% Speed</ins>]:\\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = postorder.length;\\n        int[] post = new int[n + 1];\\n        for (int i = 0; i < n; i++){\\n            post[postorder[i]] = i;\\n        }\\n        return build(new int[]{0}, 0, preorder, post);\\n    }\\n\\n    private TreeNode build(int[] cur, int parent, int[] pre, int[] post){\\n        if (cur[0] >= pre.length) return null;\\n        if (post[pre[cur[0]]] > post[pre[parent]]) return null;\\n        int idx = cur[0]++;\\n        return new TreeNode(pre[idx], \\n                            build(cur, idx, pre, post), \\n                            build(cur, idx, pre, post));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = postorder.length;\\n        int[] post = new int[n + 1];\\n        for (int i = 0; i < n; i++){\\n            post[postorder[i]] = i; // quick lookup array\\n        }\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int p : preorder){\\n            queue.offer(p);\\n        }\\n        return build(queue, queue.peek(), preorder, post);\\n    }\\n\\n    private TreeNode build(Queue<Integer> queue, int parent, int[] pre, int[] post){\\n        if (queue.isEmpty()) return null;\\n        if (post[queue.peek()] > post[parent]) return null;  \\n        int val = queue.poll();\\n        return new TreeNode(val, build(queue, val, pre, post), \\n                                 build(queue, val, pre, post));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = postorder.length;\\n        int[] post = new int[n + 1];\\n        for (int i = 0; i < n; i++){\\n            post[postorder[i]] = i;\\n        }\\n        return build(new int[]{0}, 0, preorder, post);\\n    }\\n\\n    private TreeNode build(int[] cur, int parent, int[] pre, int[] post){\\n        if (cur[0] >= pre.length) return null;\\n        if (post[pre[cur[0]]] > post[pre[parent]]) return null;\\n        int idx = cur[0]++;\\n        return new TreeNode(pre[idx], \\n                            build(cur, idx, pre, post), \\n                            build(cur, idx, pre, post));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770133,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def construct(self, pre, post):\\n        if post:\\n            if len(post) == 1:\\n                return TreeNode(pre.pop(0))\\n            root_val = pre.pop(0)\\n            ind = post.index(pre[0])\\n            root = TreeNode(root_val)\\n            root.left = self.construct(pre, post[:ind+1])\\n            root.right = self.construct(pre, post[ind+1:-1])\\n            return root\\n        \\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        return self.construct(preorder, postorder)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def construct(self, pre, post):\\n        if post:\\n            if len(post) == 1:\\n                return TreeNode(pre.pop(0))\\n            root_val = pre.pop(0)\\n            ind = post.index(pre[0])\\n            root = TreeNode(root_val)\\n            root.left = self.construct(pre, post[:ind+1])\\n            root.right = self.construct(pre, post[ind+1:-1])\\n            return root\\n        \\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        return self.construct(preorder, postorder)",
                "codeTag": "Java"
            },
            {
                "id": 1689086,
                "title": "java-dfs-o-n-beats-100",
                "content": "Please upvote if you find it helpful! Or leave comments or suggestions below!\\nI will try my best to answer them! Thank you so much!!\\n\\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        return dfs(preorder, 0, preorder.length-1, postorder, 0, postorder.length-1);\\n    }\\n    \\n    private TreeNode dfs(int[] preorder, int preLeft, int preRight, int[] postorder, int postLeft, int postRight) {\\n        if (preLeft == preRight) return new TreeNode(preorder[preLeft]);\\n        \\n        TreeNode curRoot = new TreeNode(preorder[preLeft]);\\n        int leftChildIdx = findIdx(postorder, postLeft, postRight, preorder[preLeft + 1]); \\n        int numOfLeftChild = leftChildIdx - postLeft + 1;   \\n        \\n        if (leftChildIdx == (postRight - 1)) {\\n            // if this node has only one child, then it could be right or left child.\\n            curRoot.left = dfs(preorder, preLeft + 1, preRight, postorder, postLeft, postRight - 1);\\n        } else {\\n            curRoot.left = dfs(preorder, preLeft + 1, preLeft + numOfLeftChild, postorder, postLeft, postLeft + numOfLeftChild - 1);\\n            curRoot.right = dfs(preorder, preLeft + numOfLeftChild + 1, preRight, postorder, postLeft + numOfLeftChild, postRight - 1);\\n        }\\n        \\n        return curRoot;\\n    }\\n    \\n    private int findIdx(int[] postorder, int postLeft, int postRight, int target) {\\n        \\n        for (int i = postLeft; i <= postRight; i++) {\\n            if (postorder[i] == target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        return dfs(preorder, 0, preorder.length-1, postorder, 0, postorder.length-1);\\n    }\\n    \\n    private TreeNode dfs(int[] preorder, int preLeft, int preRight, int[] postorder, int postLeft, int postRight) {\\n        if (preLeft == preRight) return new TreeNode(preorder[preLeft]);\\n        \\n        TreeNode curRoot = new TreeNode(preorder[preLeft]);\\n        int leftChildIdx = findIdx(postorder, postLeft, postRight, preorder[preLeft + 1]); \\n        int numOfLeftChild = leftChildIdx - postLeft + 1;   \\n        \\n        if (leftChildIdx == (postRight - 1)) {\\n            // if this node has only one child, then it could be right or left child.\\n            curRoot.left = dfs(preorder, preLeft + 1, preRight, postorder, postLeft, postRight - 1);\\n        } else {\\n            curRoot.left = dfs(preorder, preLeft + 1, preLeft + numOfLeftChild, postorder, postLeft, postLeft + numOfLeftChild - 1);\\n            curRoot.right = dfs(preorder, preLeft + numOfLeftChild + 1, preRight, postorder, postLeft + numOfLeftChild, postRight - 1);\\n        }\\n        \\n        return curRoot;\\n    }\\n    \\n    private int findIdx(int[] postorder, int postLeft, int postRight, int target) {\\n        \\n        for (int i = postLeft; i <= postRight; i++) {\\n            if (postorder[i] == target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678044,
                "title": "o-n-time-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    int p=0;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        p=preorder.length-1;\\n        return generateTree(preorder,postorder,0,preorder.length-1);\\n    }\\n    public TreeNode generateTree(int[] preorder,int [] postorder,int s,int e){\\n        if(s>e) return null;\\n        TreeNode node = new TreeNode(postorder[p],null,null);\\n        int k=e+1;\\n        p--;\\n        for(int i=s+1;i<=e;i++){\\n            if(preorder[i] == postorder[p]){\\n                k=i;break;\\n            }\\n        }\\n        TreeNode right = generateTree(preorder,postorder,k,e);\\n        TreeNode left = generateTree(preorder,postorder,s+1,k-1);\\n        node.left = left;\\n        node.right = right;\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int p=0;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        p=preorder.length-1;\\n        return generateTree(preorder,postorder,0,preorder.length-1);\\n    }\\n    public TreeNode generateTree(int[] preorder,int [] postorder,int s,int e){\\n        if(s>e) return null;\\n        TreeNode node = new TreeNode(postorder[p],null,null);\\n        int k=e+1;\\n        p--;\\n        for(int i=s+1;i<=e;i++){\\n            if(preorder[i] == postorder[p]){\\n                k=i;break;\\n            }\\n        }\\n        TreeNode right = generateTree(preorder,postorder,k,e);\\n        TreeNode left = generateTree(preorder,postorder,s+1,k-1);\\n        node.left = left;\\n        node.right = right;\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651685,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void printvec (vector<int> p) {\\n        cout << \"print vec \" << endl;\\n        \\n        for(auto i : p) {\\n            cout << i << \" \";\\n        }\\n        cout << endl;\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int> postorder, int &index) {\\n        if (postorder.size() == 0) return NULL;\\n        if (index >= preorder.size()) return NULL;\\n        //cout << \"index is \" << index << endl;\\n        //printvec(postorder);\\n        \\n        TreeNode* temp = new TreeNode(preorder[index]);\\n        postorder.pop_back();\\n        index++;\\n        if (index >= preorder.size() || postorder.size() == 0) {\\n            return temp;\\n        }\\n        vector<int> post1;\\n        vector<int> post2;\\n        int i = 0;\\n        while (postorder[i] != preorder[index]) {\\n            post1.push_back(postorder[i]);\\n            i++;\\n        }\\n        post1.push_back(postorder[i]);\\n        i++;\\n        temp->left = helper(preorder, post1, index);\\n        while(i < postorder.size()) {\\n            post2.push_back(postorder[i]);\\n            i++;\\n        }\\n        \\n        temp->right =  helper(preorder, post2, index);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int index = 0;\\n        return helper(preorder, postorder, index);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void printvec (vector<int> p) {\\n        cout << \"print vec \" << endl;\\n        \\n        for(auto i : p) {\\n            cout << i << \" \";\\n        }\\n        cout << endl;\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int> postorder, int &index) {\\n        if (postorder.size() == 0) return NULL;\\n        if (index >= preorder.size()) return NULL;\\n        //cout << \"index is \" << index << endl;\\n        //printvec(postorder);\\n        \\n        TreeNode* temp = new TreeNode(preorder[index]);\\n        postorder.pop_back();\\n        index++;\\n        if (index >= preorder.size() || postorder.size() == 0) {\\n            return temp;\\n        }\\n        vector<int> post1;\\n        vector<int> post2;\\n        int i = 0;\\n        while (postorder[i] != preorder[index]) {\\n            post1.push_back(postorder[i]);\\n            i++;\\n        }\\n        post1.push_back(postorder[i]);\\n        i++;\\n        temp->left = helper(preorder, post1, index);\\n        while(i < postorder.size()) {\\n            post2.push_back(postorder[i]);\\n            i++;\\n        }\\n        \\n        temp->right =  helper(preorder, post2, index);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int index = 0;\\n        return helper(preorder, postorder, index);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1615841,
                "title": "python3-both-o-n-2-and-o-n-solution",
                "content": "**O(N^2)** solution\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def findRootOfLeftSubTreeInPostorderArray(num):\\n            for i in range(len(postorder)):\\n                if postorder[i] == num:\\n                    return i\\n        \\n        def dfs(preStart, preEnd, postStart, postEnd):\\n            if preStart>preEnd: return None\\n            root = TreeNode(preorder[preStart])            \\n            if preStart == preEnd: return root\\n            \\n            idx = findRootOfLeftSubTreeInPostorderArray(preorder[preStart+1])\\n            l = idx - postStart + 1\\n            root.left = dfs(preStart+1, preStart+l, postStart, idx)\\n            root.right = dfs(preStart+l+1, preEnd, idx+1, postEnd)\\n            \\n            return root\\n               \\n        return dfs(0, len(preorder)-1, 0, len(postorder)-1)\\n````\\nOptimize above code using dictionary(in python)/ hashmap(in java) to **O(N)**\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        \\n        def dfs(preStart, preEnd, postStart, postEnd):\\n            if preStart>preEnd: return None\\n            root = TreeNode(preorder[preStart])            \\n            if preStart == preEnd: return root\\n            \\n            idx = postorderMap[preorder[preStart+1]]\\n            l = idx - postStart + 1\\n            root.left = dfs(preStart+1, preStart+l, postStart, idx)\\n            root.right = dfs(preStart+l+1, preEnd, idx+1, postEnd)\\n            \\n            return root\\n        \\n        postorderMap = {}\\n        for i, value in enumerate(postorder):\\n            postorderMap[value] = i\\n            \\n        return dfs(0, len(preorder)-1, 0, len(postorder)-1)\\n```\\nFor optimized soln extra space increases the space complexity to O(len(postorder)) ~ O(N)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def findRootOfLeftSubTreeInPostorderArray(num):\\n            for i in range(len(postorder)):\\n                if postorder[i] == num:\\n                    return i\\n        \\n        def dfs(preStart, preEnd, postStart, postEnd):\\n            if preStart>preEnd: return None\\n            root = TreeNode(preorder[preStart])            \\n            if preStart == preEnd: return root\\n            \\n            idx = findRootOfLeftSubTreeInPostorderArray(preorder[preStart+1])\\n            l = idx - postStart + 1\\n            root.left = dfs(preStart+1, preStart+l, postStart, idx)\\n            root.right = dfs(preStart+l+1, preEnd, idx+1, postEnd)\\n            \\n            return root\\n               \\n        return dfs(0, len(preorder)-1, 0, len(postorder)-1)\\n```\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        \\n        def dfs(preStart, preEnd, postStart, postEnd):\\n            if preStart>preEnd: return None\\n            root = TreeNode(preorder[preStart])            \\n            if preStart == preEnd: return root\\n            \\n            idx = postorderMap[preorder[preStart+1]]\\n            l = idx - postStart + 1\\n            root.left = dfs(preStart+1, preStart+l, postStart, idx)\\n            root.right = dfs(preStart+l+1, preEnd, idx+1, postEnd)\\n            \\n            return root\\n        \\n        postorderMap = {}\\n        for i, value in enumerate(postorder):\\n            postorderMap[value] = i\\n            \\n        return dfs(0, len(preorder)-1, 0, len(postorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594376,
                "title": "python-devide-and-conquer-with-explaination",
                "content": "```\\ndef constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n\\t\"\"\"\\n\\t\\tpre:1,2,4,5,3,6,7\\n\\t\\tpost:4,5,2,6,7,3,1\\n\\t\\t=> \\n\\t\\troot=1\\n\\t\\tleft node-----       ----------post_idx\\n\\t\\t\\t\\t\\t |       |\\n\\t\\t\\t\\tpre:(2,4,5),(3,6,7)\\n\\t\\t\\t\\tpost:(4,5,2),(6,7,3)\\n\\t\\t------pre_idx-----^        ^----right node\\n\\n\\t\\tpre_idx = post.index(2) = 2\\n\\t\\tpost_idx = pre.index(3) = 3\\n\\t\\t1.left = pre:[2,4,5]=pre[:3]=pre[:pre_idx+1], post:[4,5,2]=post[:3]=post[:pre_idx+1]\\n\\t\\t1.right = pre:[3,6,7]=pre[3:]=pre[post_idx:], post:[6,7,3]=post[3:]=post[pre_idx+1:]\\n\\n\\t\"\"\"\\n\\tdef build(pre, post):\\n\\t\\tif len(pre) != len(post):\\n\\t\\t\\treturn None\\n\\t\\troot = TreeNode(pre.pop(0)) # root node is the first in pre order\\n\\t\\tpost.remove(root.val) # remove it from post order\\n\\n\\t\\tif not pre:\\n\\t\\t\\treturn root\\n\\t\\tpre_idx = post.index(pre[0]) # assume pre[0] is the left node, find its index in post order\\n\\t\\tpost_idx = pre.index(post[-1]) # assume post[-1] is the right node, find its index in pre order\\n\\t\\troot.left = build(pre[:pre_idx+1], post[:pre_idx+1]) # devide and conquer\\n\\t\\troot.right = build(pre[post_idx:], post[pre_idx+1:])\\n\\t\\treturn root\\n\\treturn build(preorder, postorder)\\n```",
                "solutionTags": [],
                "code": "```\\ndef constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n\\t\"\"\"\\n\\t\\tpre:1,2,4,5,3,6,7\\n\\t\\tpost:4,5,2,6,7,3,1\\n\\t\\t=> \\n\\t\\troot=1\\n\\t\\tleft node-----       ----------post_idx\\n\\t\\t\\t\\t\\t |       |\\n\\t\\t\\t\\tpre:(2,4,5),(3,6,7)\\n\\t\\t\\t\\tpost:(4,5,2),(6,7,3)\\n\\t\\t------pre_idx-----^        ^----right node\\n\\n\\t\\tpre_idx = post.index(2) = 2\\n\\t\\tpost_idx = pre.index(3) = 3\\n\\t\\t1.left = pre:[2,4,5]=pre[:3]=pre[:pre_idx+1], post:[4,5,2]=post[:3]=post[:pre_idx+1]\\n\\t\\t1.right = pre:[3,6,7]=pre[3:]=pre[post_idx:], post:[6,7,3]=post[3:]=post[pre_idx+1:]\\n\\n\\t\"\"\"\\n\\tdef build(pre, post):\\n\\t\\tif len(pre) != len(post):\\n\\t\\t\\treturn None\\n\\t\\troot = TreeNode(pre.pop(0)) # root node is the first in pre order\\n\\t\\tpost.remove(root.val) # remove it from post order\\n\\n\\t\\tif not pre:\\n\\t\\t\\treturn root\\n\\t\\tpre_idx = post.index(pre[0]) # assume pre[0] is the left node, find its index in post order\\n\\t\\tpost_idx = pre.index(post[-1]) # assume post[-1] is the right node, find its index in pre order\\n\\t\\troot.left = build(pre[:pre_idx+1], post[:pre_idx+1]) # devide and conquer\\n\\t\\troot.right = build(pre[post_idx:], post[pre_idx+1:])\\n\\t\\treturn root\\n\\treturn build(preorder, postorder)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1570887,
                "title": "c-o-n-easy-to-understand",
                "content": "Logic very similar to my [this](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/492724/very-easy-to-understand-recursive-solution-with-explanation-and-diagram) explanation of Leetcode 106\\n```\\nmap<int, int> mapp;\\nclass Solution {\\npublic:\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int>& postorder, int preS, int preE, int posS, int posE){\\n        if((preS>preE) || (posS>posE)) return NULL;\\n        int rootData = preorder[preS];\\n        TreeNode* root = new TreeNode(rootData);\\n        if(preS==preE || posS==posE) return root;\\n        int rpreE = preE;\\n        int lposS = posS;\\n        int lpreS = preS+1;\\n        int rposE = posE-1;\\n        \\n        //following line is the main logic \\n        int lposE= mapp[preorder[preS+1]];\\n\\n        int rposS = lposE+1;\\n        int lpreE = lpreS+lposE-lposS;\\n        int rpreS = lpreE+1;\\n        root->left = helper(preorder, postorder, lpreS, lpreE, lposS, lposE);\\n        root->right = helper(preorder, postorder, rpreS, rpreE, rposS, rposE);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        mapp.clear();\\n        for(int i=0; i<postorder.size(); i++){\\n            mapp[postorder[i]]=i;\\n        }\\n        return helper(preorder, postorder, 0, preorder.size()-1, 0, postorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nmap<int, int> mapp;\\nclass Solution {\\npublic:\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int>& postorder, int preS, int preE, int posS, int posE){\\n        if((preS>preE) || (posS>posE)) return NULL;\\n        int rootData = preorder[preS];\\n        TreeNode* root = new TreeNode(rootData);\\n        if(preS==preE || posS==posE) return root;\\n        int rpreE = preE;\\n        int lposS = posS;\\n        int lpreS = preS+1;\\n        int rposE = posE-1;\\n        \\n        //following line is the main logic \\n        int lposE= mapp[preorder[preS+1]];\\n\\n        int rposS = lposE+1;\\n        int lpreE = lpreS+lposE-lposS;\\n        int rpreS = lpreE+1;\\n        root->left = helper(preorder, postorder, lpreS, lpreE, lposS, lposE);\\n        root->right = helper(preorder, postorder, rpreS, rpreE, rposS, rposE);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        mapp.clear();\\n        for(int i=0; i<postorder.size(); i++){\\n            mapp[postorder[i]]=i;\\n        }\\n        return helper(preorder, postorder, 0, preorder.size()-1, 0, postorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569258,
                "title": "c-stack-based-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        stack<TreeNode*> stk;\\n        int j = 0;\\n        TreeNode* head = nullptr;\\n        for (int i = 0; i < preorder.size(); i++) {\\n            TreeNode* node = new TreeNode(preorder[i]);\\n            if (i == 0) head = node;\\n            if (!stk.empty()) {\\n                if (!stk.top()->left)\\n                    stk.top()->left = node;\\n                else\\n                    stk.top()->right = node;\\n            }\\n            stk.push(node);\\n            while (!stk.empty() && postorder[j] == stk.top()->val) {\\n                stk.pop();\\n                j++;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        stack<TreeNode*> stk;\\n        int j = 0;\\n        TreeNode* head = nullptr;\\n        for (int i = 0; i < preorder.size(); i++) {\\n            TreeNode* node = new TreeNode(preorder[i]);\\n            if (i == 0) head = node;\\n            if (!stk.empty()) {\\n                if (!stk.top()->left)\\n                    stk.top()->left = node;\\n                else\\n                    stk.top()->right = node;\\n            }\\n            stk.push(node);\\n            while (!stk.empty() && postorder[j] == stk.top()->val) {\\n                stk.pop();\\n                j++;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564989,
                "title": "c-easy-solution-using-map",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        unordered_map<int,TreeNode*> m;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        m[preorder[0]]=root;\\n        for(int i=1;i<preorder.size();++i){\\n            int j=0;\\n            for(;j<postorder.size();++j)\\n                if(preorder[i]==postorder[j]) break;\\n            TreeNode* temp=new TreeNode(postorder[j]);\\n            for(int n=j;n<postorder.size();++n){\\n                if(m.find(postorder[n])!=m.end()){\\n                    if(m[postorder[n]]->left==NULL){\\n                        m[postorder[n]]->left=temp;\\n                        break;\\n                    }else{\\n                        m[postorder[n]]->right=temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            m[postorder[j]]=temp;\\n        }\\n        return root;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        unordered_map<int,TreeNode*> m;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        m[preorder[0]]=root;\\n        for(int i=1;i<preorder.size();++i){\\n            int j=0;\\n            for(;j<postorder.size();++j)\\n                if(preorder[i]==postorder[j]) break;\\n            TreeNode* temp=new TreeNode(postorder[j]);\\n            for(int n=j;n<postorder.size();++n){\\n                if(m.find(postorder[n])!=m.end()){\\n                    if(m[postorder[n]]->left==NULL){\\n                        m[postorder[n]]->left=temp;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1547796,
                "title": "python-recursion-solution-with-my-personal-thought-process",
                "content": "Before I saw this question, I been solving around 300 Google  questions with mixture of Easy, and mostly medium. AND STILL, this question was definitely difficult for me. Took me an hour to solve or little more.\\n\\n*Key here is that everytime you are stuck solving this question, think of the characteristics of preoder and postorder again\\n\\n**Preorder** will define you what the root is. (if you understand preorder, you know it prints the value of the first encounter node first. For example, [1,2,4] in this case  shows that root is 1 and left node is 2 and right node  is 4\\n\\n**Postorder** will print the last element or leaf first of the left side. Thus, [2,4,1] in this case, 2 is bottom left side. \\n\\nTo come up with the solution, the key is to figure out this\\n\\n**If the current value of preorder  == first element of the postorder, that\\'s when you stop the recursion and return the node itself.**\\n\\nFor example, [2,4,1] -> we will hit bottom of the leaf node at 2. Then since preorder[index] == postorder[0], return TreeNode(2). Now at TreeNode(1), 1 is not the value on the front of postorder[0] now since 2 is gone. (postorder = [4,1]) at this point. Then  we iterate preorder and go through another recursion again. Then we generate TreeNode(4) and 4 is now at the front of postorder[0], we pop that value and return TreeNode(4). We repeat this process unil index < len(preorder) and postorder[0] != curr_value\\n\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def dfs(index):\\n            node = TreeNode(preorder[index])\\n            while postorder[0] != node.val and index+1 < len(preorder):\\n                if not node.left:\\n                    node.left, index = dfs(index+1)\\n                else:\\n                    node.right, index = dfs(index+1)\\n\\n            postorder.pop(0)\\n            return node, index\\n        \\n        root, index = dfs(0)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def dfs(index):\\n            node = TreeNode(preorder[index])\\n            while postorder[0] != node.val and index+1 < len(preorder):\\n                if not node.left:\\n                    node.left, index = dfs(index+1)\\n                else:\\n                    node.right, index = dfs(index+1)\\n\\n            postorder.pop(0)\\n            return node, index\\n        \\n        root, index = dfs(0)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498906,
                "title": "python-simple-solution-recursive-intuitive",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder, postorder):\\n        q = deque(preorder)\\n        def dfs(post):\\n            if not post or not q:\\n                return \\n            if q[0] not in post:\\n                return \\n            cur = q.popleft()\\n            curNode = TreeNode(cur)\\n            split = post.index(cur)\\n            curNode.left = dfs(post[:split])\\n            curNode.right = dfs(post[:split])\\n            return curNode\\n        return dfs(postorder)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder, postorder):\\n        q = deque(preorder)\\n        def dfs(post):\\n            if not post or not q:\\n                return \\n            if q[0] not in post:\\n                return \\n            cur = q.popleft()\\n            curNode = TreeNode(cur)\\n            split = post.index(cur)\\n            curNode.left = dfs(post[:split])\\n            curNode.right = dfs(post[:split])\\n            return curNode\\n        return dfs(postorder)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352150,
                "title": "c-solution-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    void fillMaps(vector<int> vec, unordered_map<int, int>& map) {\\n        for(int i=0;i<vec.size();i++) \\n            map[vec[i]] = i;\\n        return ;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> preMap;\\n        unordered_map<int, int> postMap;\\n        fillMaps(pre, preMap);\\n        fillMaps(post, postMap);\\n        set<int> visited;\\n        queue<TreeNode*> q;\\n        TreeNode* root = new TreeNode(pre[0]);\\n        q.push(root);\\n        visited.insert(pre[0]);\\n        while(!q.empty()) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            int l = preMap[curr->val]+1;\\n            int r = postMap[curr->val]-1;\\n            if(l < pre.size() && visited.find(pre[l]) == visited.end()) {\\n                TreeNode* lft = new TreeNode(pre[l]);\\n                curr->left = lft;\\n                q.push(lft);\\n                visited.insert(pre[l]);\\n            }\\n            if(r >= 0 && visited.find(post[r]) == visited.end()) {\\n                TreeNode* rht = new TreeNode(post[r]);\\n                curr->right = rht;\\n                q.push(rht);\\n                visited.insert(post[r]);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void fillMaps(vector<int> vec, unordered_map<int, int>& map) {\\n        for(int i=0;i<vec.size();i++) \\n            map[vec[i]] = i;\\n        return ;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> preMap;\\n        unordered_map<int, int> postMap;\\n        fillMaps(pre, preMap);\\n        fillMaps(post, postMap);\\n        set<int> visited;\\n        queue<TreeNode*> q;\\n        TreeNode* root = new TreeNode(pre[0]);\\n        q.push(root);\\n        visited.insert(pre[0]);\\n        while(!q.empty()) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            int l = preMap[curr->val]+1;\\n            int r = postMap[curr->val]-1;\\n            if(l < pre.size() && visited.find(pre[l]) == visited.end()) {\\n                TreeNode* lft = new TreeNode(pre[l]);\\n                curr->left = lft;\\n                q.push(lft);\\n                visited.insert(pre[l]);\\n            }\\n            if(r >= 0 && visited.find(post[r]) == visited.end()) {\\n                TreeNode* rht = new TreeNode(post[r]);\\n                curr->right = rht;\\n                q.push(rht);\\n                visited.insert(post[r]);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347037,
                "title": "100-faster-java-solution-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return construct(pre,0,pre.length-1,post,0,post.length-1);\\n    }\\n    public TreeNode construct(int[] pre,int preSI,int preEI,int[] post,int postSI,int postEI){\\n        if(preSI>preEI){\\n            return null;\\n        }\\n        TreeNode root=new TreeNode(pre[preSI]);\\n        int postIdx=postSI;\\n        if(preSI==preEI){\\n            return root;\\n        }\\n        while(post[postIdx]!=pre[preSI+1]){\\n            postIdx++;\\n        }\\n        int tnel=postIdx-postSI+1;\\n        root.left=construct(pre,preSI+1,preSI+tnel,post,postSI,postIdx-1);\\n        root.right=construct(pre,preSI+tnel+1,preEI,post,postIdx+1,postEI);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return construct(pre,0,pre.length-1,post,0,post.length-1);\\n    }\\n    public TreeNode construct(int[] pre,int preSI,int preEI,int[] post,int postSI,int postEI){\\n        if(preSI>preEI){\\n            return null;\\n        }\\n        TreeNode root=new TreeNode(pre[preSI]);\\n        int postIdx=postSI;\\n        if(preSI==preEI){\\n            return root;\\n        }\\n        while(post[postIdx]!=pre[preSI+1]){\\n            postIdx++;\\n        }\\n        int tnel=postIdx-postSI+1;\\n        root.left=construct(pre,preSI+1,preSI+tnel,post,postSI,postIdx-1);\\n        root.right=construct(pre,preSI+tnel+1,preEI,post,postIdx+1,postEI);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255710,
                "title": "a-simple-clean-c-solution",
                "content": "class Solution {\\npublic:\\n    TreeNode* helper(vector<int>& pre, unordered_map<int,int>&mp, int start, int end, int& index)\\n    {\\n        if ( start > end )\\n            return NULL; \\n        \\n        TreeNode* root = new TreeNode(pre[index]);\\n        \\n        index++;\\n        if ( start == end )\\n            return root ; \\n      \\n        int i = mp[pre[index]];\\n        \\n        root->left = helper(pre, mp, start, i, index);\\n        root->right = helper(pre, mp, i+1, end-1, index);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        \\n        unordered_map<int, int> mp;\\n        \\n        for ( int i = 0; i < post.size(); i++)\\n            mp[post[i]]=i; \\n        int index = 0; \\n        return helper(pre, mp, 0, post.size()-1, index);\\n         \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* helper(vector<int>& pre, unordered_map<int,int>&mp, int start, int end, int& index)\\n    {\\n        if ( start > end )\\n            return NULL; \\n        \\n        TreeNode* root = new TreeNode(pre[index]);\\n        \\n        index++;\\n        if ( start == end )\\n            return root ; \\n      \\n        int i = mp[pre[index]];\\n        \\n        root->left = helper(pre, mp, start, i, index);\\n        root->right = helper(pre, mp, i+1, end-1, index);\\n        \\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1204103,
                "title": "c-recursive-solution-with-explanation",
                "content": "We know, **prorder**: Root->Left->Right & **postorder**: Left->Right->Root\\nLet us take the sample test case given,\\npre = [1,2,3,4,5,6,7] & post = [4,5,2,6,7,3,1]\\nLet *n* be the size of vectors.\\nOn observation we can notice two facts:\\n1. **```pre[0]```** will be the root of tree and **```pre[0] = post[n-1]```**\\n2. Second last element of post (**```post[n-2]```**) will be the root of right subtree.\\n\\nUsing these facts we can make recursive calls, and passing the split arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        if(pre.size()<1)\\n            return nullptr;\\n        int n = pre.size();\\n        int val = pre[0];\\n        TreeNode* root = new TreeNode(val);\\n        if(n==1)\\n            return root;\\n        int x = post[n-2];\\n        int ind = 0;\\n        for(int i=0;i<n;i++){\\n            if(pre[i]==x){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        vector<int> preL(pre.begin()+1, pre.begin()+ind);\\n        vector<int> preR(pre.begin()+ind, pre.end());\\n        \\n        vector<int> postL(post.begin(), post.begin()+ind-1);\\n        vector<int> postR(post.begin()+ind-1, post.end()-1);\\n        \\n        root->left = constructFromPrePost(preL, postL);\\n        root->right = constructFromPrePost(preR, postR);\\n        \\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```pre[0]```\n```pre[0] = post[n-1]```\n```post[n-2]```\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        if(pre.size()<1)\\n            return nullptr;\\n        int n = pre.size();\\n        int val = pre[0];\\n        TreeNode* root = new TreeNode(val);\\n        if(n==1)\\n            return root;\\n        int x = post[n-2];\\n        int ind = 0;\\n        for(int i=0;i<n;i++){\\n            if(pre[i]==x){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        vector<int> preL(pre.begin()+1, pre.begin()+ind);\\n        vector<int> preR(pre.begin()+ind, pre.end());\\n        \\n        vector<int> postL(post.begin(), post.begin()+ind-1);\\n        vector<int> postR(post.begin()+ind-1, post.end()-1);\\n        \\n        root->left = constructFromPrePost(preL, postL);\\n        root->right = constructFromPrePost(preR, postR);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197039,
                "title": "python3-preorder-dfs-36",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        #strategy: Preorder DFS\\n        #pos_pre and pos_post finds the pos of each element in the two arrays\\n        self.pos_pre, self.pos_post = [-1] * (len(pre) + 1), [-1] * (len(pre) + 1)\\n        for i in range(len(pre)):\\n            self.pos_pre[pre[i]] = i\\n            self.pos_post[post[i]] = i\\n        return self.dfs(pre, post, 0, len(pre) - 1)\\n    def dfs(self, pre, post, left, right) -> TreeNode:\\n        #out of bounds\\n        if left > right:\\n            return None\\n        #left will always be the root node since it is preorder\\n        curr = TreeNode(pre[left])\\n        #once they equal there are no more left or right nodes \\n        if left == right:\\n            return curr\\n        #find the right node which is to the left of the node in the post array since post is left, right, root\\n        right_node = post[self.pos_post[curr.val] - 1]\\n        #the starting pos of left will be left + 1 since pre is root, left, right\\n        curr.left = self.dfs(pre, post, left + 1, self.pos_pre[right_node] - 1)\\n        #the starting pos of right will be at the right node to the end\\n        curr.right = self.dfs(pre, post, self.pos_pre[right_node], right)\\n        return curr\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        #strategy: Preorder DFS\\n        #pos_pre and pos_post finds the pos of each element in the two arrays\\n        self.pos_pre, self.pos_post = [-1] * (len(pre) + 1), [-1] * (len(pre) + 1)\\n        for i in range(len(pre)):\\n            self.pos_pre[pre[i]] = i\\n            self.pos_post[post[i]] = i\\n        return self.dfs(pre, post, 0, len(pre) - 1)\\n    def dfs(self, pre, post, left, right) -> TreeNode:\\n        #out of bounds\\n        if left > right:\\n            return None\\n        #left will always be the root node since it is preorder\\n        curr = TreeNode(pre[left])\\n        #once they equal there are no more left or right nodes \\n        if left == right:\\n            return curr\\n        #find the right node which is to the left of the node in the post array since post is left, right, root\\n        right_node = post[self.pos_post[curr.val] - 1]\\n        #the starting pos of left will be left + 1 since pre is root, left, right\\n        curr.left = self.dfs(pre, post, left + 1, self.pos_pre[right_node] - 1)\\n        #the starting pos of right will be at the right node to the end\\n        curr.right = self.dfs(pre, post, self.pos_pre[right_node], right)\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183412,
                "title": "o-n-o-n-summary-of-preorder-postorder-lc889-vs-preorder-inorder-lc105-to-construct-tree",
                "content": "I got the idea to solve LC889 problem from LC105. And the solutions are almost same, only small difference. So I summarized it here for all LeetCoders =). It make me feel good that if I can solve problems with similar steps =P\\nTime O(n)\\nSpace O(n)\\nReady? Go!\\nLC889 preorder+postorder:\\n```\\nclass Solution {\\n    \\n    int id=0;\\n    HashMap<Integer,Integer> m=new HashMap<>();\\n    public TreeNode constructFromPrePost(int[] preor, int[] post) {\\n        for(int i=0;i<post.length;i++)\\n        {\\n            m.put(post[i],i);\\n        }\\n        return helper(preor,post,0,post.length-1);\\n        \\n    }\\n    public TreeNode helper(int[] preor, int[] post, int l, int r) {\\n        if(l>r) return null;\\n        TreeNode root=new TreeNode(preor[id]);\\n        id++;\\n        if(l==r) return root;\\n        \\n        int pos=m.get(preor[id]);  \\n        \\n        root.left=helper(preor,post,l,pos);\\n        root.right=helper(preor,post,pos+1,r-1);\\n        return root;\\n        \\n    }\\n    \\n}\\n```\\n\\nLC105 preorder + inorder:\\n```\\nclass Solution {\\n    int id=0;\\n    HashMap<Integer,Integer> m=new HashMap<>();\\n    public TreeNode buildTree(int[] preor, int[] inor) {\\n        for(int i=0;i<inor.length;i++)\\n        {\\n            m.put(inor[i],i);\\n        }\\n        return helper(preor,inor,0,inor.length-1);\\n        \\n    }\\n    public TreeNode helper(int[] preor, int[] inor, int l, int r) {\\n        if(l>r) return null;\\n        int pos=m.get(preor[id]);\\n        TreeNode root=new TreeNode(preor[id]);\\n        id++;\\n        root.left=helper(preor,inor,l,pos-1);\\n        root.right=helper(preor,inor,pos+1,r);\\n        return root;\\n        \\n    }\\n    \\n}\\n```\\n\\nBasically, the difference here is \\n1. LC 889 have: **if(l==r) return root;**\\n2. LC899: **id++ need to be before get pos and return!**\\n2. LC 889: root.left=helper(preor,post,l,**pos**);\\n3. LC889: root.right=helper(preor,post,pos+1,**r-1**);\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int id=0;\\n    HashMap<Integer,Integer> m=new HashMap<>();\\n    public TreeNode constructFromPrePost(int[] preor, int[] post) {\\n        for(int i=0;i<post.length;i++)\\n        {\\n            m.put(post[i],i);\\n        }\\n        return helper(preor,post,0,post.length-1);\\n        \\n    }\\n    public TreeNode helper(int[] preor, int[] post, int l, int r) {\\n        if(l>r) return null;\\n        TreeNode root=new TreeNode(preor[id]);\\n        id++;\\n        if(l==r) return root;\\n        \\n        int pos=m.get(preor[id]);  \\n        \\n        root.left=helper(preor,post,l,pos);\\n        root.right=helper(preor,post,pos+1,r-1);\\n        return root;\\n        \\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    int id=0;\\n    HashMap<Integer,Integer> m=new HashMap<>();\\n    public TreeNode buildTree(int[] preor, int[] inor) {\\n        for(int i=0;i<inor.length;i++)\\n        {\\n            m.put(inor[i],i);\\n        }\\n        return helper(preor,inor,0,inor.length-1);\\n        \\n    }\\n    public TreeNode helper(int[] preor, int[] inor, int l, int r) {\\n        if(l>r) return null;\\n        int pos=m.get(preor[id]);\\n        TreeNode root=new TreeNode(preor[id]);\\n        id++;\\n        root.left=helper(preor,inor,l,pos-1);\\n        root.right=helper(preor,inor,pos+1,r);\\n        return root;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174053,
                "title": "recursive-with-pictures",
                "content": "**Recursive helper, 2 pass :** `time O(N), space O(N)`\\n```\\nclass Solution \\n{\\n    int m_post[31];\\n\\n    TreeNode* f(vector<int>& pre, int i, int j, int J)\\n    {\\n        if(j>J)  return nullptr;\\n        int y{j!=J ? m_post[pre[i+1]] : j-1};\\n        return new TreeNode(pre[i], f(pre, i+1, j, y), f(pre, i+2+y-j, y+1, J-1));\\n    }\\npublic:    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) \\n    {\\n        for(auto i{0}; i<size(post); m_post[post[i]]=i, ++i);\\n        return f(pre, 0, 0, size(post)-1);     \\n    }\\n};\\n```\\n\\nLookup `m_post` used to quickly search symbol in `post`.\\n\\n![image](https://assets.leetcode.com/users/images/bf10beff-8f36-4818-9fa2-da8479194c87_1620861266.9687319.png)\\n\\nNote that if `pre[i+1]!=post[J-1]` we have no left or no right subtree (we are free to choose, they have the same `pre` and `post`). I chose the left subtree.\\n\\n![image](https://assets.leetcode.com/users/images/7954ab76-2067-455e-8681-cc289d6a0a64_1620861409.2561164.png)\\n\\nThis problem is one of the three similar problems:\\n* [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) \\u279F [SOLUTION](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/1204573/recursive)\\n* [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) \\u279F [SOLUTION](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/1204516/recursive)\\n* [889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) \\u279F [SOLUTION](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/1174053/recursive-with-pictures)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    int m_post[31];\\n\\n    TreeNode* f(vector<int>& pre, int i, int j, int J)\\n    {\\n        if(j>J)  return nullptr;\\n        int y{j!=J ? m_post[pre[i+1]] : j-1};\\n        return new TreeNode(pre[i], f(pre, i+1, j, y), f(pre, i+2+y-j, y+1, J-1));\\n    }\\npublic:    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) \\n    {\\n        for(auto i{0}; i<size(post); m_post[post[i]]=i, ++i);\\n        return f(pre, 0, 0, size(post)-1);     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156973,
                "title": "easy-to-understand-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int k=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n       return construct(pre,post,0,pre.size()-1);\\n        \\n    }\\n     TreeNode* construct(vector<int>& pre, vector<int>& post,int start,int end) {\\n         if(k >= pre.size() || start>end )\\n             return NULL;\\n        TreeNode* node = new TreeNode(pre[k++]);\\n         if(start == end){\\n             return node;\\n         }\\n         int i;\\n         for( i= start;i<=end;i++){\\n             if(post[i] == pre[k])\\n                 break;\\n         }\\n     \\n         node->left = construct(pre,post,start,i);\\n         node->right = construct(pre,post,i+1,end-1);\\n         \\n         return node;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int k=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n       return construct(pre,post,0,pre.size()-1);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1127607,
                "title": "python-3-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        \\n        if not pre or not post:\\n            return None\\n        if len(pre) == 1:\\n            return TreeNode(pre[0])\\n        \\n        root = TreeNode(pre[0])\\n        \\n        pos = post.index(pre[1]) + 1\\n        root.left = self.constructFromPrePost(pre[1 : 1 + pos], post[ : pos])\\n        root.right = self.constructFromPrePost(pre[1 + pos : ], post[pos : -1])\\n        \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        \\n        if not pre or not post:\\n            return None\\n        if len(pre) == 1:\\n            return TreeNode(pre[0])\\n        \\n        root = TreeNode(pre[0])\\n        \\n        pos = post.index(pre[1]) + 1\\n        root.left = self.constructFromPrePost(pre[1 : 1 + pos], post[ : pos])\\n        root.right = self.constructFromPrePost(pre[1 + pos : ], post[pos : -1])\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083362,
                "title": "javascript-simple-dfs-with-explanation-78-faster",
                "content": "Runtime: 96 ms, faster than 78.00% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\nMemory Usage: 42.3 MB, less than 31.00% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\n\\nTo solve this question, you must first identify the pattern of Preorder and Post order.\\nPattern:\\nPreorder: Root -> Left -> Right\\nPostorder: Left -> Right -> Root\\n\\nHow do I find the end of the left and right?\\nthe first value after the root in preorder is the end of the left tree in the post order! :D\\n\\n```\\nvar constructFromPrePost = function(pre, post) {\\n    if(pre.length === 0) {\\n        return null;\\n    }\\n    if(pre.length === 1) {\\n        return new TreeNode(pre[0]);\\n    }\\n    \\n    let root = pre[0];\\n    let leftEndVal = pre[1];\\n    let leftEnd = post.indexOf(leftEndVal);\\n    \\n    let leftTree = constructFromPrePost(pre.slice(1, leftEnd + 2), post.slice(0, leftEnd + 1));\\n    let rightTree = constructFromPrePost(pre.slice(leftEnd + 2,  pre.length), post.slice(leftEnd + 1, post.length));\\n    \\n    return new TreeNode(root, leftTree, rightTree);\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar constructFromPrePost = function(pre, post) {\\n    if(pre.length === 0) {\\n        return null;\\n    }\\n    if(pre.length === 1) {\\n        return new TreeNode(pre[0]);\\n    }\\n    \\n    let root = pre[0];\\n    let leftEndVal = pre[1];\\n    let leftEnd = post.indexOf(leftEndVal);\\n    \\n    let leftTree = constructFromPrePost(pre.slice(1, leftEnd + 2), post.slice(0, leftEnd + 1));\\n    let rightTree = constructFromPrePost(pre.slice(leftEnd + 2,  pre.length), post.slice(leftEnd + 1, post.length));\\n    \\n    return new TreeNode(root, leftTree, rightTree);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015731,
                "title": "python-dfs-w-comment",
                "content": "```py\\n\\'\\'\\'\\npreorder:(root,(left),(right))\\npostorder((left),(right), root)\\nthe key here is to determine the length of left\\nwhich need to be determined by postorder array\\n\\'\\'\\'\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        def dfs(i, j, n):\\n            #1. when n <=0, we have no node to traverse\\n            if n <= 0 :\\n                return None\\n\\n            root = TreeNode(pre[i]) #the first node must be root of the subtree\\n            #2. when n == 1, we know that only one node left\\n            # itself is the subtree\\n            if n == 1:\\n                return root\\n            \\n            # 3 find the length of left subtree\\n            # whose parent is curret root\\n            k = j\\n            while post[k] != pre[i+1]:\\n                k += 1\\n            l = k-j + 1 # this is the length\\n            root.left = dfs(i+1, j, l)\\n            root.right = dfs(i+l+1, k+1, n-l-1)\\n            return root\\n        \\n        return dfs(0, 0, len(pre))\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```py\\n\\'\\'\\'\\npreorder:(root,(left),(right))\\npostorder((left),(right), root)\\nthe key here is to determine the length of left\\nwhich need to be determined by postorder array\\n\\'\\'\\'\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        def dfs(i, j, n):\\n            #1. when n <=0, we have no node to traverse\\n            if n <= 0 :\\n                return None\\n\\n            root = TreeNode(pre[i]) #the first node must be root of the subtree\\n            #2. when n == 1, we know that only one node left\\n            # itself is the subtree\\n            if n == 1:\\n                return root\\n            \\n            # 3 find the length of left subtree\\n            # whose parent is curret root\\n            k = j\\n            while post[k] != pre[i+1]:\\n                k += 1\\n            l = k-j + 1 # this is the length\\n            root.left = dfs(i+1, j, l)\\n            root.right = dfs(i+l+1, k+1, n-l-1)\\n            return root\\n        \\n        return dfs(0, 0, len(pre))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992832,
                "title": "c-o-n-recursive-dfs-10ms-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return helper(pre,post,0,0,pre.size());\\n    }\\n    TreeNode* helper(vector<int>& pre, vector<int>& post, int pi, int poi, int len){\\n        //index pi and poi will tell which part of arrays to consider \\n        //pi tells to take pre from index pi+len same does poi for post\\n        if(len==0)return nullptr;\\n        //creating the root\\n        TreeNode* root = new TreeNode(pre[pi]);\\n        //if no more elemnts left\\n        if(len==1)return root;\\n        //finding length of left subtree\\n        int L;\\n        for(L =0; L<len;L++){\\n            if (pre[pi+1] == post[poi+L]){\\n                break;\\n            }\\n        }\\n        L+=1; //because index starts from zero so length will be 1 more;\\n        //collect the new indexes and construct left and right subtree recursively\\n        root->left = helper(pre,post,pi+1,poi,L);\\n        root->right = helper(pre,post,pi+L+1,poi+L,len-1-L);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return helper(pre,post,0,0,pre.size());\\n    }\\n    TreeNode* helper(vector<int>& pre, vector<int>& post, int pi, int poi, int len){\\n        //index pi and poi will tell which part of arrays to consider \\n        //pi tells to take pre from index pi+len same does poi for post\\n        if(len==0)return nullptr;\\n        //creating the root\\n        TreeNode* root = new TreeNode(pre[pi]);\\n        //if no more elemnts left\\n        if(len==1)return root;\\n        //finding length of left subtree\\n        int L;\\n        for(L =0; L<len;L++){\\n            if (pre[pi+1] == post[poi+L]){\\n                break;\\n            }\\n        }\\n        L+=1; //because index starts from zero so length will be 1 more;\\n        //collect the new indexes and construct left and right subtree recursively\\n        root->left = helper(pre,post,pi+1,poi,L);\\n        root->right = helper(pre,post,pi+L+1,poi+L,len-1-L);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946704,
                "title": "python3-stack-o-n",
                "content": "**Algo**\\nGo through `pre` and add nodes to the tree. The reletive position can be derived from their order in `post`. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(post)}\\n        \\n        root = None \\n        stack = []\\n        for x in pre: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while mp[stack[-1].val] < mp[x]: stack.pop()\\n                stack[-1].right = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexcity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(post)}\\n        \\n        root = None \\n        stack = []\\n        for x in pre: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while mp[stack[-1].val] < mp[x]: stack.pop()\\n                stack[-1].right = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 921228,
                "title": "divide-and-conquer-o-n-solution-with-help-of-hashmap-java",
                "content": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Map<Integer, Integer> preIndexMap = new HashMap();\\n        for(int i = 0; i < pre.length; i++) {\\n            preIndexMap.put(pre[i], i);\\n        }\\n        return constructTree(pre, post, 0, pre.length-1, 0, pre.length -1, preIndexMap);\\n    }\\n    \\n    private TreeNode constructTree(int[] pre, int[] post, int preLeft, \\n                                   int preRight, int postLeft, int postRight, \\n                                   Map<Integer, Integer> map) {\\n        if(preLeft > preRight || postLeft > postRight)  return null;\\n        TreeNode root = new TreeNode(post[postRight]);\\n        if(preLeft == preRight) return root;\\n        int elem = post[postRight-1];\\n        int preMid = map.get(elem);\\n        int postMid = postRight-1-preRight+preMid;\\n        root.right = constructTree(pre, post, preMid, preRight, postMid, postRight-1, map);\\n        root.left = constructTree(pre, post, preLeft+1, preMid-1, postLeft, postMid-1, map);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Map<Integer, Integer> preIndexMap = new HashMap();\\n        for(int i = 0; i < pre.length; i++) {\\n            preIndexMap.put(pre[i], i);\\n        }\\n        return constructTree(pre, post, 0, pre.length-1, 0, pre.length -1, preIndexMap);\\n    }\\n    \\n    private TreeNode constructTree(int[] pre, int[] post, int preLeft, \\n                                   int preRight, int postLeft, int postRight, \\n                                   Map<Integer, Integer> map) {\\n        if(preLeft > preRight || postLeft > postRight)  return null;\\n        TreeNode root = new TreeNode(post[postRight]);\\n        if(preLeft == preRight) return root;\\n        int elem = post[postRight-1];\\n        int preMid = map.get(elem);\\n        int postMid = postRight-1-preRight+preMid;\\n        root.right = constructTree(pre, post, preMid, preRight, postMid, postRight-1, map);\\n        root.left = constructTree(pre, post, preLeft+1, preMid-1, postLeft, postMid-1, map);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903457,
                "title": "without-using-4-variables-prestart-preend-poststart-postend-and-with-using-4-variables",
                "content": "2 Methods to do this question :-\\n1) . By using  4 variables (prestart,preend,poststart,postend) \\n     in code i have use [a,b] for pre array and [c,d] for post array.\\n2) By using 2 variables (pre_indx,pos_indx)\\n2nd one is tricky  method\\n**1st One**\\n```\\nclass Solution {\\npublic:           //  indexing based solution\\n    unordered_map<int,int> mp;\\n    \\n    TreeNode* construct(vector<int>& pre,vector<int>& post,int a,int b,int c,int d){\\n        if(a>b)return nullptr;\\n        TreeNode* root=new TreeNode(pre[a]);\\n        \\n        //base case\\n        if(a==b)return root;\\n        //finding the index of pre[a+1] in post[] array\\n        int indx=mp[pre[a+1]];\\n        //finding the length of left_subtree array from post[] array\\n        int len=indx-c+1;   // length of left_subtree \\n        // construct root- left and root- right subtreee\\n        root->left=construct(pre,post,a+1,a+len,c,c+len-1);\\n        root->right=construct(pre,post,a+len+1,b,indx+1,d-1);\\n        return root;\\n    }\\n\\t\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        for(int i=0;i<post.size();i++){\\n            mp[post[i]]=i;\\n        }\\n        return construct(pre,post,0,pre.size()-1,0,post.size()-1);\\n    }\\n};\\n```\\n**Time complexity: O(N^2)**\\n**2nd One**\\n```\\nclass Solution {\\npublic:       // without 4  variables(prestart,preend,posstart,posend)\\n    //     using 2 variables(pre_indx ,pos_indx)\\n     int pre_indx=0,pos_indx=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root=new TreeNode(pre[pre_indx++]);\\n        if(root->val!=post[pos_indx]){\\n            root->left=constructFromPrePost(pre,post);\\n        }\\n        if(root->val!=post[pos_indx]){\\n            root->right=constructFromPrePost(pre,post);\\n        }\\n        pos_indx++;\\n        return root;\\n    }\\n};\\n```\\n**Time complexity: O(N)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:           //  indexing based solution\\n    unordered_map<int,int> mp;\\n    \\n    TreeNode* construct(vector<int>& pre,vector<int>& post,int a,int b,int c,int d){\\n        if(a>b)return nullptr;\\n        TreeNode* root=new TreeNode(pre[a]);\\n        \\n        //base case\\n        if(a==b)return root;\\n        //finding the index of pre[a+1] in post[] array\\n        int indx=mp[pre[a+1]];\\n        //finding the length of left_subtree array from post[] array\\n        int len=indx-c+1;   // length of left_subtree \\n        // construct root- left and root- right subtreee\\n        root->left=construct(pre,post,a+1,a+len,c,c+len-1);\\n        root->right=construct(pre,post,a+len+1,b,indx+1,d-1);\\n        return root;\\n    }\\n\\t\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        for(int i=0;i<post.size();i++){\\n            mp[post[i]]=i;\\n        }\\n        return construct(pre,post,0,pre.size()-1,0,post.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:       // without 4  variables(prestart,preend,posstart,posend)\\n    //     using 2 variables(pre_indx ,pos_indx)\\n     int pre_indx=0,pos_indx=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root=new TreeNode(pre[pre_indx++]);\\n        if(root->val!=post[pos_indx]){\\n            root->left=constructFromPrePost(pre,post);\\n        }\\n        if(root->val!=post[pos_indx]){\\n            root->right=constructFromPrePost(pre,post);\\n        }\\n        pos_indx++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898962,
                "title": "linear-space-time-complexity-using-hash",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        n = len(pre)\\n        if n == 0:\\n            return None\\n        post_hash = dict(zip(post, range(n)))\\n        root = TreeNode(pre[0])\\n        stack = [root]\\n        i = 1\\n        while i < n:\\n            current = stack[-1]\\n            if post_hash[pre[i]] == post_hash[current.val]:\\n                i += 1\\n            elif post_hash[pre[i]] < post_hash[current.val]:\\n                node = TreeNode(pre[i])\\n                if current.left is None:\\n                    current.left = node\\n                    stack.append(current.left)\\n                else:\\n                    current.right = node\\n                    stack.append(current.right)\\n                i += 1\\n            else:\\n                stack.pop()\\n            \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        n = len(pre)\\n        if n == 0:\\n            return None\\n        post_hash = dict(zip(post, range(n)))\\n        root = TreeNode(pre[0])\\n        stack = [root]\\n        i = 1\\n        while i < n:\\n            current = stack[-1]\\n            if post_hash[pre[i]] == post_hash[current.val]:\\n                i += 1\\n            elif post_hash[pre[i]] < post_hash[current.val]:\\n                node = TreeNode(pre[i])\\n                if current.left is None:\\n                    current.left = node\\n                    stack.append(current.left)\\n                else:\\n                    current.right = node\\n                    stack.append(current.right)\\n                i += 1\\n            else:\\n                stack.pop()\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870006,
                "title": "standard-java-solution",
                "content": "### Theory\\nIf you haven\\'t done this type of problem before - it can be quite tricky to see the pattern. Even if you have seen it before, the hard part will be maintaining four pointers spanning two arrays, and finding the recursive pattern.\\n\\nCredit: https://www.youtube.com/watch?v=3XYxGKeC_Ew\\n\\n### Solution\\n```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return recurse(pre, post, 0, pre.length - 1, 0, post.length - 1);\\n    }\\n    \\n    private TreeNode recurse(int[] pre, int[] post, int preStart, int preEnd, int postStart, int postEnd) {\\n        if (preStart > preEnd) return null;\\n        TreeNode newNode = new TreeNode(pre[preStart]);\\n        if (preStart == preEnd) return newNode;\\n        int postIndex = postStart;\\n        while (post[postIndex] != pre[preStart + 1]) postIndex++;\\n        int len = postIndex - postStart + 1;\\n            \\n        newNode.left = recurse(pre, post, preStart + 1, preStart + len, postStart, postIndex);\\n        newNode.right = recurse(pre, post, preStart + 1 + len, preEnd, postIndex + 1, postEnd - 1);\\n        return newNode;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return recurse(pre, post, 0, pre.length - 1, 0, post.length - 1);\\n    }\\n    \\n    private TreeNode recurse(int[] pre, int[] post, int preStart, int preEnd, int postStart, int postEnd) {\\n        if (preStart > preEnd) return null;\\n        TreeNode newNode = new TreeNode(pre[preStart]);\\n        if (preStart == preEnd) return newNode;\\n        int postIndex = postStart;\\n        while (post[postIndex] != pre[preStart + 1]) postIndex++;\\n        int len = postIndex - postStart + 1;\\n            \\n        newNode.left = recurse(pre, post, preStart + 1, preStart + len, postStart, postIndex);\\n        newNode.right = recurse(pre, post, preStart + 1 + len, preEnd, postIndex + 1, postEnd - 1);\\n        return newNode;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865892,
                "title": "short-python3-recursive-solution-beats-100",
                "content": "Self explanatory clean solution:\\n```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if pre:\\n            root = TreeNode(pre.pop(0))\\n            if pre:\\n                ind = post.index(pre[0])\\n                root.left = self.constructFromPrePost(pre[:ind+1],post[:ind+1])\\n                root.right = self.constructFromPrePost(pre[ind+1:],post[ind+1:])\\n            return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if pre:\\n            root = TreeNode(pre.pop(0))\\n            if pre:\\n                ind = post.index(pre[0])\\n                root.left = self.constructFromPrePost(pre[:ind+1],post[:ind+1])\\n                root.right = self.constructFromPrePost(pre[ind+1:],post[ind+1:])\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829141,
                "title": "c-intuitive-o-n-solution-no-complex-indexing-logic",
                "content": "Let x be the current node\\n- the node following x in preorder is x\\'s left child if its not visited already\\n- the node preceding x in postorder is x\\'s right child if its not visited already\\n\\n```\\nclass Solution {\\n    unordered_map<int, int> postIndices, preIndices;\\n    vector<bool> visited;\\n    \\n    void construct(TreeNode* curNode, int index, vector<int>& pre, vector<int>& post) {\\n        if (!curNode)\\n            return;\\n        \\n        int cur = curNode->val;\\n        int leftChildIndex = preIndices[cur] + 1;\\n        int rightChildIndex = postIndices[cur] - 1;\\n        \\n        if (leftChildIndex < pre.size() and !visited[pre[leftChildIndex]]) {\\n            curNode->left = new TreeNode(pre[leftChildIndex]);\\n            visited[pre[leftChildIndex]] = true;\\n        }\\n        \\n        if (rightChildIndex >= 0 and !visited[post[rightChildIndex]]) {\\n            curNode->right = new TreeNode(post[rightChildIndex]);\\n            visited[post[rightChildIndex]] = true;\\n        }\\n        \\n        construct(curNode->left, leftChildIndex, pre, post);\\n        construct(curNode->right, rightChildIndex, pre, post);                \\n    }\\n    \\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        int index = 0;\\n        visited.resize(pre.size()+1);\\n        \\n        for (int i = 0; i < post.size(); i++)\\n            preIndices[pre[i]] = i, postIndices[post[i]] = i;\\n        \\n        auto newNode = new TreeNode(pre[index]);\\n        visited[pre[index]] = true;;\\n        \\n        construct(newNode, index, pre, post);\\n        \\n        return newNode;\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    unordered_map<int, int> postIndices, preIndices;\\n    vector<bool> visited;\\n    \\n    void construct(TreeNode* curNode, int index, vector<int>& pre, vector<int>& post) {\\n        if (!curNode)\\n            return;\\n        \\n        int cur = curNode->val;\\n        int leftChildIndex = preIndices[cur] + 1;\\n        int rightChildIndex = postIndices[cur] - 1;\\n        \\n        if (leftChildIndex < pre.size() and !visited[pre[leftChildIndex]]) {\\n            curNode->left = new TreeNode(pre[leftChildIndex]);\\n            visited[pre[leftChildIndex]] = true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 821866,
                "title": "c-one-pass-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int preInd;\\n    unordered_map<int,int>mp;\\n    TreeNode * rec(vector<int>& pre, vector<int>& post,int l, int r){\\n        if(l == r)return new TreeNode(pre[preInd++]);\\n        if(l > r)return NULL;\\n        TreeNode * curr = new TreeNode(pre[preInd++]);\\n        int t = mp[pre[preInd]];\\n        curr->left = rec(pre,post,l,t);\\n        curr->right = rec(pre,post,t + 1,r-1);\\n        return curr;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        preInd = 0;\\n        for(int i = 0; i < post.size(); i++)mp[post[i]] = i;\\n        return rec(pre,post,0,post.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int preInd;\\n    unordered_map<int,int>mp;\\n    TreeNode * rec(vector<int>& pre, vector<int>& post,int l, int r){\\n        if(l == r)return new TreeNode(pre[preInd++]);\\n        if(l > r)return NULL;\\n        TreeNode * curr = new TreeNode(pre[preInd++]);\\n        int t = mp[pre[preInd]];\\n        curr->left = rec(pre,post,l,t);\\n        curr->right = rec(pre,post,t + 1,r-1);\\n        return curr;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        preInd = 0;\\n        for(int i = 0; i < post.size(); i++)mp[post[i]] = i;\\n        return rec(pre,post,0,post.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767348,
                "title": "java-o-n-dfs-with-explaination-video",
                "content": "The algorithm follows the explaination in the video:\\n[https://www.youtube.com/watch?v=5lWJpTEnyow](http://)\\n```\\npublic class prepost{\\n  int[] pre;\\n  int[] post;\\n  HashMap<Integer,Integer> preMap = new HashMap();\\n  HashMap<Integer,Integer> postMap = new HashMap();\\n  public TreeNode constructFromPrePost(int[] pre, int[] post){\\n    this.pre = pre;\\n    this.post = post;\\n    for(int i=0;i<pre.length;i++){\\n      this.preMap.put(pre[i],i);\\n      this.postMap.put(post[i],i);\\n    }\\n    return helper(0,pre.length-1,0,post.length-1);\\n\\n  }\\n  public TreeNode helper(int pre_left, int pre_right, int post_left, int post_right){\\n    if(post_left>post_right){\\n      return null;\\n    }\\n    int val = pre[pre_left];\\n    TreeNode root = new TreeNode(val);\\n    if(pre_left == pre_right || post_left == post_right){\\n      return root;\\n    }\\n    int postIndex = postMap.get(pre[pre_left+1]);\\n    int preIndex = preMap.get(post[post_right-1]);\\n    root.left = helper(pre_left+1,preIndex-1,post_left,postIndex);\\n    root.left = helper(preIndex,pre_right,postIndex+1,post_right-1);\\n    return root;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class prepost{\\n  int[] pre;\\n  int[] post;\\n  HashMap<Integer,Integer> preMap = new HashMap();\\n  HashMap<Integer,Integer> postMap = new HashMap();\\n  public TreeNode constructFromPrePost(int[] pre, int[] post){\\n    this.pre = pre;\\n    this.post = post;\\n    for(int i=0;i<pre.length;i++){\\n      this.preMap.put(pre[i],i);\\n      this.postMap.put(post[i],i);\\n    }\\n    return helper(0,pre.length-1,0,post.length-1);\\n\\n  }\\n  public TreeNode helper(int pre_left, int pre_right, int post_left, int post_right){\\n    if(post_left>post_right){\\n      return null;\\n    }\\n    int val = pre[pre_left];\\n    TreeNode root = new TreeNode(val);\\n    if(pre_left == pre_right || post_left == post_right){\\n      return root;\\n    }\\n    int postIndex = postMap.get(pre[pre_left+1]);\\n    int preIndex = preMap.get(post[post_right-1]);\\n    root.left = helper(pre_left+1,preIndex-1,post_left,postIndex);\\n    root.left = helper(preIndex,pre_right,postIndex+1,post_right-1);\\n    return root;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640386,
                "title": "go-0ms-recursive-solution",
                "content": "```\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    if len(pre) == 0 {\\n        return nil\\n    }\\n    root := &TreeNode{Val: pre[0]}\\n    if len(pre) == 1 {\\n        return root\\n    }\\n    \\n    L := indexOf(pre[1], post) + 1   \\n\\n    root.Left = constructFromPrePost(pre[1:L+1], post[:L])\\n    root.Right = constructFromPrePost(pre[L+1:], post[L:])\\n    \\n    return root\\n}\\n\\nfunc indexOf(element int, data []int) (int) {\\n   for k, v := range data {\\n       if element == v {\\n           return k\\n       }\\n   }\\n   return -1    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    if len(pre) == 0 {\\n        return nil\\n    }\\n    root := &TreeNode{Val: pre[0]}\\n    if len(pre) == 1 {\\n        return root\\n    }\\n    \\n    L := indexOf(pre[1], post) + 1   \\n\\n    root.Left = constructFromPrePost(pre[1:L+1], post[:L])\\n    root.Right = constructFromPrePost(pre[L+1:], post[L:])\\n    \\n    return root\\n}\\n\\nfunc indexOf(element int, data []int) (int) {\\n   for k, v := range data {\\n       if element == v {\\n           return k\\n       }\\n   }\\n   return -1    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618997,
                "title": "fully-explained-fast-c-recursive-solution",
                "content": "The solution beats about 80% of the submissions in terms of speed.\\nThe code is similar to [this discuss thread](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/161286/C%2B%2B-O(N)-recursive-solution), I just explained it a little better and added tons of comments and better variable names.\\n```\\nclass Solution\\n{\\n    unordered_map<int, int> lookup;\\n\\npublic:\\n    TreeNode *constructFromPrePost(vector<int> &pre, vector<int> &post)\\n    {\\n        // create a hashmap for post order array for faster lookup\\n        for (int i = 0; i < post.size(); ++i)\\n        {\\n            lookup[post[i]] = i;\\n        }\\n        return helper(0, pre.size() - 1, 0, post.size() - 1, pre, post);\\n    }\\n\\n    /*\\n    * [root][......left......][...right..]  ---pre\\n    * [......left......][...right..][root]  ---post\\n    */\\n    TreeNode *helper(int preStart, int preEnd, int postStart, int postEnd, vector<int> &pre, vector<int> &post)\\n    {\\n\\n        TreeNode *root = new TreeNode(pre[preStart]);\\n\\n        // this node deosn\\'t have any children\\n        if (preStart == preEnd)\\n        {\\n            return root;\\n        }\\n\\n        // Index of root of left subtree in preorder\\n        int RootLeftSubTree = pre[preStart + 1];\\n        // Index of root of left subtree in postorder\\n        int RootLeftSubTreePostIdx = lookup[RootLeftSubTree];\\n\\n        // Number of elements in the left subtree\\n        int elementsInLeftSubTree = RootLeftSubTreePostIdx - postStart + 1;\\n\\n        /*\\n        * For left subtree\\n        * pre starts from preStart + 1, i.e. the very next element\\n        * pre ends at preStart + elementsInLeftSubTree - 1\\n        * post starts at postStart (remains same)\\n        * post ends at the RootLeftSubTreePostIdx (the rightmost element (the root of left subtree) in the post array)\\n        */\\n        root->left = helper(preStart + 1, preStart + elementsInLeftSubTree, postStart, RootLeftSubTreePostIdx, pre, post);\\n\\n        // if you run out of nodes for right subTree, return the root and\\n        // let root->right remain NULL\\n        if (RootLeftSubTreePostIdx + 1 == postEnd)\\n        {\\n            return root;\\n        }\\n\\n        /*\\n        * For right subtree\\n        * pre starts at 1 position after the last left subtree element\\n        * pre ends at preEnd (remains same)\\n        * post starts at RootLeftSubTreePostIdx + 1\\n        * post ends at 1 position to the left of postEnd (as postEnd is always current root)\\n        */\\n        root->right = helper(preStart + elementsInLeftSubTree + 1, preEnd, RootLeftSubTreePostIdx + 1, postEnd - 1, pre, post);\\n\\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    unordered_map<int, int> lookup;\\n\\npublic:\\n    TreeNode *constructFromPrePost(vector<int> &pre, vector<int> &post)\\n    {\\n        // create a hashmap for post order array for faster lookup\\n        for (int i = 0; i < post.size(); ++i)\\n        {\\n            lookup[post[i]] = i;\\n        }\\n        return helper(0, pre.size() - 1, 0, post.size() - 1, pre, post);\\n    }\\n\\n    /*\\n    * [root][......left......][...right..]  ---pre\\n    * [......left......][...right..][root]  ---post\\n    */\\n    TreeNode *helper(int preStart, int preEnd, int postStart, int postEnd, vector<int> &pre, vector<int> &post)\\n    {\\n\\n        TreeNode *root = new TreeNode(pre[preStart]);\\n\\n        // this node deosn\\'t have any children\\n        if (preStart == preEnd)\\n        {\\n            return root;\\n        }\\n\\n        // Index of root of left subtree in preorder\\n        int RootLeftSubTree = pre[preStart + 1];\\n        // Index of root of left subtree in postorder\\n        int RootLeftSubTreePostIdx = lookup[RootLeftSubTree];\\n\\n        // Number of elements in the left subtree\\n        int elementsInLeftSubTree = RootLeftSubTreePostIdx - postStart + 1;\\n\\n        /*\\n        * For left subtree\\n        * pre starts from preStart + 1, i.e. the very next element\\n        * pre ends at preStart + elementsInLeftSubTree - 1\\n        * post starts at postStart (remains same)\\n        * post ends at the RootLeftSubTreePostIdx (the rightmost element (the root of left subtree) in the post array)\\n        */\\n        root->left = helper(preStart + 1, preStart + elementsInLeftSubTree, postStart, RootLeftSubTreePostIdx, pre, post);\\n\\n        // if you run out of nodes for right subTree, return the root and\\n        // let root->right remain NULL\\n        if (RootLeftSubTreePostIdx + 1 == postEnd)\\n        {\\n            return root;\\n        }\\n\\n        /*\\n        * For right subtree\\n        * pre starts at 1 position after the last left subtree element\\n        * pre ends at preEnd (remains same)\\n        * post starts at RootLeftSubTreePostIdx + 1\\n        * post ends at 1 position to the left of postEnd (as postEnd is always current root)\\n        */\\n        root->right = helper(preStart + elementsInLeftSubTree + 1, preEnd, RootLeftSubTreePostIdx + 1, postEnd - 1, pre, post);\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589318,
                "title": "recursion-explained",
                "content": "How it works:\\nwe know there can be many trees possible  for given pre and post order traversal\\n\\nbase case:\\n  tree is empty return null\\n  len==1 return creating node with that value (post orders last element popped)\\n  \\nRecursive step:\\nlast node in post is definately root\\nso we pop it and make treeNode of it\\t\\t\\nThen consider node that is just befor earlier popped node in post\\ni.e. current last node in post\\nwell till position of this node except first value in pre elements are part of left subtree\\nand from this position till last element in pre are of right subtree\\n\\nNote we call right part of subtree first as we are popping last element from post\\nso that should belong to right subtree first\\n\\n\\t\\t\\n\\t\\t\\n\\t\\tdef helper(pre,post):\\n        \\tif not pre:\\n                return None\\n            \\n            if len(pre)==1:\\n                return TreeNode(post.pop())\\n            \\n            \\n            node=TreeNode(post.pop())\\n            ind=pre.index(post[-1])\\n            \\n            node.right=helper(pre[ind:],post)\\n            node.left=helper(pre[1:ind],post)\\n            \\n            return node\\n        \\n        return helper(pre,post)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "How it works:\\nwe know there can be many trees possible  for given pre and post order traversal\\n\\nbase case:\\n  tree is empty return null\\n  len==1 return creating node with that value (post orders last element popped)\\n  \\nRecursive step:\\nlast node in post is definately root\\nso we pop it and make treeNode of it\\t\\t\\nThen consider node that is just befor earlier popped node in post\\ni.e. current last node in post\\nwell till position of this node except first value in pre elements are part of left subtree\\nand from this position till last element in pre are of right subtree\\n\\nNote we call right part of subtree first as we are popping last element from post\\nso that should belong to right subtree first\\n\\n\\t\\t\\n\\t\\t\\n\\t\\tdef helper(pre,post):\\n        \\tif not pre:\\n                return None\\n            \\n            if len(pre)==1:\\n                return TreeNode(post.pop())\\n            \\n            \\n            node=TreeNode(post.pop())\\n            ind=pre.index(post[-1])\\n            \\n            node.right=helper(pre[ind:],post)\\n            node.left=helper(pre[1:ind],post)\\n            \\n            return node\\n        \\n        return helper(pre,post)",
                "codeTag": "Python3"
            },
            {
                "id": 484209,
                "title": "java-stack-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        int i = 0, j = 0;\\n        while(i < pre.length) {\\n            TreeNode newNode = new TreeNode(pre[i]);\\n            if(!stack.isEmpty()) {\\n                if(post[j] != stack.peek().val) {\\n                    stack.peek().left = newNode;\\n                } else {\\n                    while(stack.peek().val == post[j]) {\\n                        stack.pop();\\n                        ++j;\\n                    }\\n                    stack.peek().right = newNode;\\n                }\\n            }\\n            stack.push(newNode);\\n            ++i;\\n        }\\n        TreeNode root = null;\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n        }\\n\\n        return root;     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        int i = 0, j = 0;\\n        while(i < pre.length) {\\n            TreeNode newNode = new TreeNode(pre[i]);\\n            if(!stack.isEmpty()) {\\n                if(post[j] != stack.peek().val) {\\n                    stack.peek().left = newNode;\\n                } else {\\n                    while(stack.peek().val == post[j]) {\\n                        stack.pop();\\n                        ++j;\\n                    }\\n                    stack.peek().right = newNode;\\n                }\\n            }\\n            stack.push(newNode);\\n            ++i;\\n        }\\n        TreeNode root = null;\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n        }\\n\\n        return root;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478961,
                "title": "summary-of-reconstruction-from-traversal",
                "content": "```C++\\n#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n#include <vector>\\nusing namespace std;\\n\\n/**\\n * https://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/\\n * Four kinds of traversal: preorder, inorder, postorder, level-order.\\n * Given 2 traversal sequences, if can construct the general binary tree without \\n * ambuigity if and only if one of the sequence is an inorder traversal.\\n * \\n * Example:\\n * A        A\\n *  \\\\      /\\n *   B    B\\n * The above 2 binary trees have the same preorder of AB, postorder of BA, and \\n * level-order of AB. The tree cannot be reconstructed even with 3 of them.\\n */\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\n// utility functions\\nvoid printInorder(TreeNode* node) {\\n    if (node == NULL) return;\\n    printInorder(node->left);\\n    cout << node->val << \" \";\\n    printInorder(node->right);\\n}\\n\\nvoid printTree(TreeNode* node) {\\n    printInorder(node);\\n    cout << endl;\\n}\\n\\n\\n/** Inorder + preorder (1) */\\n// https://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/\\n// Time: O(n ^ 2), worst case when tree is skewed. T(n) = T(n-1) + n.\\n//       O(nlgn), if the tree is balanced. T(n) = 2T(n/2) + n.\\nclass ConstructFromPreIn {\\n   private:\\n    int preIndex = 0;\\n\\n    int search(vector<int>& v, int l, int r, int val) {\\n        for (int i = l; i <= r; ++i) {\\n            if (v[i] == val) return i;\\n        }\\n        return -1;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& pre, int inStart, int inEnd) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preIndex++]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = search(in, inStart, inEnd, node->val);\\n        node->left = construct(in, pre, inStart, inIndex - 1);\\n        node->right = construct(in, pre, inIndex + 1, inEnd);\\n\\n        return node;\\n    }\\n\\n    TreeNode* construct(vector<int>& in, vector<int>& pre) {\\n        return construct(in, pre, 0, in.size() - 1);\\n    }\\n};\\n\\n\\n/** Inorder + preorder (2) */\\n// Time: O(n). Each preIndex takes O(1) time.\\nclass ConstructFromPreInFast {\\n   private:\\n    int preIndex = 0;\\n\\n    TreeNode* constructHelper(vector<int>& in, vector<int>& pre, int inStart,\\n                              int inEnd, unordered_map<int, int>& map) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preIndex++]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = map[node->val];\\n        node->left = constructHelper(in, pre, inStart, inIndex - 1, map);\\n        node->right = constructHelper(in, pre, inIndex + 1, inEnd, map);\\n\\n        return node;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& pre) {\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < in.size(); ++i) map[in[i]] = i;\\n        return constructHelper(in, pre, 0, in.size() - 1, map);\\n    }\\n};\\n\\n\\n/** postorder + inorder */\\n// https://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/\\nclass ConstructFromInPost {\\n   private:\\n    int postIndex;\\n\\n    TreeNode* constructHelper(vector<int>& in, vector<int>& post, int inStart,\\n                              int inEnd, unordered_map<int, int>& map) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(post[postIndex--]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = map[node->val];\\n        // The order matters\\n        node->right = constructHelper(in, post, inIndex + 1, inEnd, map);\\n        node->left = constructHelper(in, post, inStart, inIndex - 1, map);\\n\\n        return node;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& post) {\\n        this->postIndex = post.size() - 1;\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < in.size(); ++i) map[in[i]] = i;\\n        return constructHelper(in, post, 0, in.size() - 1, map);\\n    }\\n};\\n\\n\\n/** preorder + postorder */\\n// Idea from, slightly different implementation:\\n// https://www.geeksforgeeks.org/full-and-complete-binary-tree-from-given-preorder-and-postorder-traversals/\\nclass PrePost {\\n   public:\\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int preStart, int preEnd,\\n                        int postStart, int postEnd, unordered_map<int, int>& postMap) {\\n        // \"preEnd - preStart == postEnd - postStart\" should be maintained.\\n        if (preStart > preEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preStart]);\\n        if (preStart == preEnd) return node;\\n\\n        // preStart < preEnd\\n        int postIndex = postMap[pre[preStart + 1]];\\n\\n        int leftPreStart = preStart + 1;\\n        int leftPreEnd = leftPreStart + (postIndex - postStart);\\n        int leftPostStart = postStart;\\n        int leftPostEnd = postIndex;\\n        node->left = construct(pre, post, leftPreStart, leftPreEnd, leftPostStart, leftPostEnd, postMap);\\n\\n        int rightPreStart = leftPreEnd + 1;\\n        int rightPreEnd = preEnd;\\n        int rightPostStart = postIndex + 1;\\n        int rightPostEnd = postEnd - 1;\\n        node->right = construct(pre, post, rightPreStart, rightPreEnd, rightPostStart, rightPostEnd, postMap);\\n        return node;\\n    }\\n\\n    TreeNode* construct(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < post.size(); ++i) map[post[i]] = i;\\n        return construct(pre, post, 0, pre.size() - 1, 0, post.size() - 1, map);\\n    }\\n};\\n\\nvoid preInFunc() {\\n    ConstructFromPreIn* inPre;\\n    ConstructFromPreInFast* inPreFast;\\n\\n    vector<int> in1 = {4, 2, 5, 1, 6, 3, 7};\\n    vector<int> pre1 = {1, 2, 4, 5, 3, 6, 7};\\n    inPre = new ConstructFromPreIn();\\n    inPreFast = new ConstructFromPreInFast();\\n    printTree(inPre->construct(in1, pre1));\\n    printTree(inPreFast->construct(in1, pre1));\\n\\n    vector<int> in2 = {4, 2, 5, 1, 6, 3};\\n    vector<int> pre2 = {1, 2, 4, 5, 3, 6};\\n    inPre = new ConstructFromPreIn();\\n    inPreFast = new ConstructFromPreInFast();\\n    printTree(inPre->construct(in2, pre2));\\n    printTree(inPreFast->construct(in2, pre2));\\n}\\n\\nvoid inPostFunc() {\\n    ConstructFromInPost* inPost;\\n\\n    vector<int> in1 = {4, 2, 5, 1, 6, 3, 7};\\n    vector<int> post1 = {4, 5, 2, 6, 7, 3, 1};\\n    inPost = new ConstructFromInPost();\\n    printTree(inPost->construct(in1, post1));\\n}\\n\\nvoid prePostFunc() {\\n    vector<int> pre1 = {1, 2, 4, 5, 3, 6, 7};\\n    vector<int> post1 = {4, 5, 2, 6, 7, 3, 1};\\n    printTree((new PrePost())->construct(pre1, post1));\\n\\n    vector<int> pre2 = {1, 2, 4, 5, 3, 6};\\n    vector<int> post2 = {4, 5, 2, 6, 3, 1};\\n    printTree((new PrePost())->construct(pre2, post2));\\n}\\n\\nint main() {\\n    preInFunc();\\n    inPostFunc();\\n    prePostFunc();\\n}\\n```",
                "solutionTags": [],
                "code": "```C++\\n#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n#include <vector>\\nusing namespace std;\\n\\n/**\\n * https://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/\\n * Four kinds of traversal: preorder, inorder, postorder, level-order.\\n * Given 2 traversal sequences, if can construct the general binary tree without \\n * ambuigity if and only if one of the sequence is an inorder traversal.\\n * \\n * Example:\\n * A        A\\n *  \\\\      /\\n *   B    B\\n * The above 2 binary trees have the same preorder of AB, postorder of BA, and \\n * level-order of AB. The tree cannot be reconstructed even with 3 of them.\\n */\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\n// utility functions\\nvoid printInorder(TreeNode* node) {\\n    if (node == NULL) return;\\n    printInorder(node->left);\\n    cout << node->val << \" \";\\n    printInorder(node->right);\\n}\\n\\nvoid printTree(TreeNode* node) {\\n    printInorder(node);\\n    cout << endl;\\n}\\n\\n\\n/** Inorder + preorder (1) */\\n// https://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/\\n// Time: O(n ^ 2), worst case when tree is skewed. T(n) = T(n-1) + n.\\n//       O(nlgn), if the tree is balanced. T(n) = 2T(n/2) + n.\\nclass ConstructFromPreIn {\\n   private:\\n    int preIndex = 0;\\n\\n    int search(vector<int>& v, int l, int r, int val) {\\n        for (int i = l; i <= r; ++i) {\\n            if (v[i] == val) return i;\\n        }\\n        return -1;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& pre, int inStart, int inEnd) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preIndex++]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = search(in, inStart, inEnd, node->val);\\n        node->left = construct(in, pre, inStart, inIndex - 1);\\n        node->right = construct(in, pre, inIndex + 1, inEnd);\\n\\n        return node;\\n    }\\n\\n    TreeNode* construct(vector<int>& in, vector<int>& pre) {\\n        return construct(in, pre, 0, in.size() - 1);\\n    }\\n};\\n\\n\\n/** Inorder + preorder (2) */\\n// Time: O(n). Each preIndex takes O(1) time.\\nclass ConstructFromPreInFast {\\n   private:\\n    int preIndex = 0;\\n\\n    TreeNode* constructHelper(vector<int>& in, vector<int>& pre, int inStart,\\n                              int inEnd, unordered_map<int, int>& map) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preIndex++]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = map[node->val];\\n        node->left = constructHelper(in, pre, inStart, inIndex - 1, map);\\n        node->right = constructHelper(in, pre, inIndex + 1, inEnd, map);\\n\\n        return node;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& pre) {\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < in.size(); ++i) map[in[i]] = i;\\n        return constructHelper(in, pre, 0, in.size() - 1, map);\\n    }\\n};\\n\\n\\n/** postorder + inorder */\\n// https://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/\\nclass ConstructFromInPost {\\n   private:\\n    int postIndex;\\n\\n    TreeNode* constructHelper(vector<int>& in, vector<int>& post, int inStart,\\n                              int inEnd, unordered_map<int, int>& map) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(post[postIndex--]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = map[node->val];\\n        // The order matters\\n        node->right = constructHelper(in, post, inIndex + 1, inEnd, map);\\n        node->left = constructHelper(in, post, inStart, inIndex - 1, map);\\n\\n        return node;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& post) {\\n        this->postIndex = post.size() - 1;\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < in.size(); ++i) map[in[i]] = i;\\n        return constructHelper(in, post, 0, in.size() - 1, map);\\n    }\\n};\\n\\n\\n/** preorder + postorder */\\n// Idea from, slightly different implementation:\\n// https://www.geeksforgeeks.org/full-and-complete-binary-tree-from-given-preorder-and-postorder-traversals/\\nclass PrePost {\\n   public:\\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int preStart, int preEnd,\\n                        int postStart, int postEnd, unordered_map<int, int>& postMap) {\\n        // \"preEnd - preStart == postEnd - postStart\" should be maintained.\\n        if (preStart > preEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preStart]);\\n        if (preStart == preEnd) return node;\\n\\n        // preStart < preEnd\\n        int postIndex = postMap[pre[preStart + 1]];\\n\\n        int leftPreStart = preStart + 1;\\n        int leftPreEnd = leftPreStart + (postIndex - postStart);\\n        int leftPostStart = postStart;\\n        int leftPostEnd = postIndex;\\n        node->left = construct(pre, post, leftPreStart, leftPreEnd, leftPostStart, leftPostEnd, postMap);\\n\\n        int rightPreStart = leftPreEnd + 1;\\n        int rightPreEnd = preEnd;\\n        int rightPostStart = postIndex + 1;\\n        int rightPostEnd = postEnd - 1;\\n        node->right = construct(pre, post, rightPreStart, rightPreEnd, rightPostStart, rightPostEnd, postMap);\\n        return node;\\n    }\\n\\n    TreeNode* construct(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < post.size(); ++i) map[post[i]] = i;\\n        return construct(pre, post, 0, pre.size() - 1, 0, post.size() - 1, map);\\n    }\\n};\\n\\nvoid preInFunc() {\\n    ConstructFromPreIn* inPre;\\n    ConstructFromPreInFast* inPreFast;\\n\\n    vector<int> in1 = {4, 2, 5, 1, 6, 3, 7};\\n    vector<int> pre1 = {1, 2, 4, 5, 3, 6, 7};\\n    inPre = new ConstructFromPreIn();\\n    inPreFast = new ConstructFromPreInFast();\\n    printTree(inPre->construct(in1, pre1));\\n    printTree(inPreFast->construct(in1, pre1));\\n\\n    vector<int> in2 = {4, 2, 5, 1, 6, 3};\\n    vector<int> pre2 = {1, 2, 4, 5, 3, 6};\\n    inPre = new ConstructFromPreIn();\\n    inPreFast = new ConstructFromPreInFast();\\n    printTree(inPre->construct(in2, pre2));\\n    printTree(inPreFast->construct(in2, pre2));\\n}\\n\\nvoid inPostFunc() {\\n    ConstructFromInPost* inPost;\\n\\n    vector<int> in1 = {4, 2, 5, 1, 6, 3, 7};\\n    vector<int> post1 = {4, 5, 2, 6, 7, 3, 1};\\n    inPost = new ConstructFromInPost();\\n    printTree(inPost->construct(in1, post1));\\n}\\n\\nvoid prePostFunc() {\\n    vector<int> pre1 = {1, 2, 4, 5, 3, 6, 7};\\n    vector<int> post1 = {4, 5, 2, 6, 7, 3, 1};\\n    printTree((new PrePost())->construct(pre1, post1));\\n\\n    vector<int> pre2 = {1, 2, 4, 5, 3, 6};\\n    vector<int> post2 = {4, 5, 2, 6, 3, 1};\\n    printTree((new PrePost())->construct(pre2, post2));\\n}\\n\\nint main() {\\n    preInFunc();\\n    inPostFunc();\\n    prePostFunc();\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 446833,
                "title": "java-1-ms-recursive-solution",
                "content": "Steps:\\n1. Create node from `pre[preIdx]` \\n2. Recurse left and repeat 1 until `pre[preIdx] == post[postIdx]`\\n3. Increment `postIdx` as we go back up the tree\\n4. Go right\\n5. Repeat\\n\\nBy the end, `preIdx` and `postIdx` will be the length of the arrays.\\n\\nTime: O(n) touches every node once\\nSpace: O(h) callstack is as the height of the tree\\n\\n```\\npublic class ConstructBinaryTreeFromPreorderAndPostorderTraversal {\\n    int preIdx = 0;\\n    int postIdx = 0;\\n\\n    // Time: O(n) every node\\n    // Space: O(h) height of tree\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if (preIdx >= pre.length) return null;\\n        \\n        TreeNode curr = new TreeNode(pre[preIdx]);\\n        if (pre[preIdx] == post[postIdx]) {\\n            preIdx++;\\n            postIdx++;\\n            return curr;\\n        }\\n\\n        preIdx++;\\n        curr.left = constructFromPrePost(pre, post);\\n        if (curr.val == post[postIdx]) {\\n            postIdx++;\\n            return curr;\\n        }\\n        \\n        curr.right = constructFromPrePost(pre, post);\\n        postIdx++;\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class ConstructBinaryTreeFromPreorderAndPostorderTraversal {\\n    int preIdx = 0;\\n    int postIdx = 0;\\n\\n    // Time: O(n) every node\\n    // Space: O(h) height of tree\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if (preIdx >= pre.length) return null;\\n        \\n        TreeNode curr = new TreeNode(pre[preIdx]);\\n        if (pre[preIdx] == post[postIdx]) {\\n            preIdx++;\\n            postIdx++;\\n            return curr;\\n        }\\n\\n        preIdx++;\\n        curr.left = constructFromPrePost(pre, post);\\n        if (curr.val == post[postIdx]) {\\n            postIdx++;\\n            return curr;\\n        }\\n        \\n        curr.right = constructFromPrePost(pre, post);\\n        postIdx++;\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393660,
                "title": "go-easy-to-understand-beat-83-for-speed-and-100-for-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    root := TreeNode{pre[0], nil, nil} //the parent node is the first node in pre\\n    if len(pre)==1 {return &root}\\n    pre = pre[1:] //clear the root from the list\\n    \\n    hold := pre[0] //pre[0] is the left child\\n\\n    leftChildren := []int{} \\n    for i, val := range post{\\n        if val == hold{\\n            leftChildren = post[:i+1] //iterate through post until you see the root. everything before that are left children\\n            post = post[i+1:] //everything to the right are the right children\\n            break\\n        }\\n    }\\n    if len(leftChildren) >0{root.Left = constructFromPrePost(pre[:len(leftChildren)], leftChildren)}\\n    \\n    pre = pre[len(leftChildren):] //cut all left children out of pre\\n    if len(pre)>0{root.Right = constructFromPrePost(pre, post)}\\n    \\n    return &root\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    root := TreeNode{pre[0], nil, nil} //the parent node is the first node in pre\\n    if len(pre)==1 {return &root}\\n    pre = pre[1:] //clear the root from the list\\n    \\n    hold := pre[0] //pre[0] is the left child\\n\\n    leftChildren := []int{} \\n    for i, val := range post{\\n        if val == hold{\\n            leftChildren = post[:i+1] //iterate through post until you see the root. everything before that are left children\\n            post = post[i+1:] //everything to the right are the right children\\n            break\\n        }\\n    }\\n    if len(leftChildren) >0{root.Left = constructFromPrePost(pre[:len(leftChildren)], leftChildren)}\\n    \\n    pre = pre[len(leftChildren):] //cut all left children out of pre\\n    if len(pre)>0{root.Right = constructFromPrePost(pre, post)}\\n    \\n    return &root\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365015,
                "title": "python-o-n-one-pass-iterative-solution",
                "content": "The idea behind this algorithm is that we traverse through the preorder array once, and add nodes to the tree as we go. The current node that we are at in the tree is determined by a stack of the latest nodes added to the tree. As we are iterating through the preorder array, we have a second pointer for the postorder array that helps us keep track of when we\\'ve reached the end of a branch. \\n\\nIf the current node we are examining (after adding to the tree) is equivalent to the value being pointed to by the posterorder pointer, then we enter the following loop until ```current_node != postorder_pointer_value```: (1) pop the stack, (2) peek at the top node in the stack, and (3) increment ```postorder_pointer``` by 1.\\n\\nBy doing so, this ensures that the preorder traversal still matches the postorder traversal.\\n\\n```\\ndef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\tif len(pre) == 0 or len(post) == 0:\\n\\t\\treturn None\\n\\n\\troot = TreeNode(pre[0])\\n\\tstack = [root]\\n\\tcurr = root\\n\\tpost_pointer = 0\\n\\tfor i in range(1, len(pre)):\\n\\t\\tif not curr.left:\\n\\t\\t\\tcurr.left = TreeNode(pre[i])\\n\\t\\t\\tstack.append(curr.left)\\n\\t\\telse:\\n\\t\\t\\tcurr.right = TreeNode(pre[i])\\n\\t\\t\\tstack.append(curr.right)\\n\\t\\tcurr = stack[-1]\\n\\t\\twhile curr.val == post[post_pointer]:\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tif not stack:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcurr = stack[-1]\\n\\t\\t\\tpost_pointer += 1\\n\\treturn root\\n```",
                "solutionTags": [],
                "code": "```current_node != postorder_pointer_value```\n```postorder_pointer```\n```\\ndef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\tif len(pre) == 0 or len(post) == 0:\\n\\t\\treturn None\\n\\n\\troot = TreeNode(pre[0])\\n\\tstack = [root]\\n\\tcurr = root\\n\\tpost_pointer = 0\\n\\tfor i in range(1, len(pre)):\\n\\t\\tif not curr.left:\\n\\t\\t\\tcurr.left = TreeNode(pre[i])\\n\\t\\t\\tstack.append(curr.left)\\n\\t\\telse:\\n\\t\\t\\tcurr.right = TreeNode(pre[i])\\n\\t\\t\\tstack.append(curr.right)\\n\\t\\tcurr = stack[-1]\\n\\t\\twhile curr.val == post[post_pointer]:\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tif not stack:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcurr = stack[-1]\\n\\t\\t\\tpost_pointer += 1\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 359298,
                "title": "python-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        # [1] [2 4 5] [3 6 7]\\n        # 4 5 [2] 6 7 3 [1]\\n        # the location of pre[1] in post decide how many left children there are\\n        if not pre or not post:\\n            return None\\n        mid = pre[0]\\n        node = TreeNode(mid)\\n        if len(pre) > 1:\\n            leftNum = post.index(pre[1])+1\\n            node.left = self.constructFromPrePost(pre[1:leftNum+1],post[:leftNum])\\n            node.right = self.constructFromPrePost(pre[leftNum+1:],post[leftNum:len(post)-1])\\n        return node\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        # [1] [2 4 5] [3 6 7]\\n        # 4 5 [2] 6 7 3 [1]\\n        # the location of pre[1] in post decide how many left children there are\\n        if not pre or not post:\\n            return None\\n        mid = pre[0]\\n        node = TreeNode(mid)\\n        if len(pre) > 1:\\n            leftNum = post.index(pre[1])+1\\n            node.left = self.constructFromPrePost(pre[1:leftNum+1],post[:leftNum])\\n            node.right = self.constructFromPrePost(pre[leftNum+1:],post[leftNum:len(post)-1])\\n        return node\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 334921,
                "title": "go-golang-0-ms-faster-than-100-00",
                "content": "```golang\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    if len(pre) == 0 || len(pre) != len(post) {\\n        return nil\\n    }\\n    \\n    root := &TreeNode{\\n        Val: pre[0],\\n    }\\n    \\n    size := len(post)\\n    if size == 1 {\\n\\t\\treturn root\\n\\t}\\n     \\n    for i:=0; i < size; i++ {\\n\\t\\tif post[i] == pre[1] {\\n\\t\\t\\troot.Left = constructFromPrePost(pre[1:i+2], post[:i+1])\\n\\t        root.Right = constructFromPrePost(pre[i+2:], post[i+1:size-1])\\n\\t\\t    break\\n        }\\n\\t}\\n    \\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    if len(pre) == 0 || len(pre) != len(post) {\\n        return nil\\n    }\\n    \\n    root := &TreeNode{\\n        Val: pre[0],\\n    }\\n    \\n    size := len(post)\\n    if size == 1 {\\n\\t\\treturn root\\n\\t}\\n     \\n    for i:=0; i < size; i++ {\\n\\t\\tif post[i] == pre[1] {\\n\\t\\t\\troot.Left = constructFromPrePost(pre[1:i+2], post[:i+1])\\n\\t        root.Right = constructFromPrePost(pre[i+2:], post[i+1:size-1])\\n\\t\\t    break\\n        }\\n\\t}\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329379,
                "title": "python3-recursive-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\t\\t\\tif not pre or not post:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\troot=TreeNode(pre[0])\\n\\t\\t\\tif len(pre)==1:           \\n\\t\\t\\t\\treturn root\\n\\t\\t\\tind=post.index(pre[1])\\n\\t\\t\\troot.left=self.constructFromPrePost(pre[1:ind+2],post[:ind+1])\\n\\t\\t\\troot.right=self.constructFromPrePost(pre[ind+2:],post[ind+1:-1])\\n\\t\\t\\treturn root",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\t\\t\\tif not pre or not post:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\troot=TreeNode(pre[0])\\n\\t\\t\\tif len(pre)==1:           \\n\\t\\t\\t\\treturn root\\n\\t\\t\\tind=post.index(pre[1])\\n\\t\\t\\troot.left=self.constructFromPrePost(pre[1:ind+2],post[:ind+1])\\n\\t\\t\\troot.right=self.constructFromPrePost(pre[ind+2:],post[ind+1:-1])\\n\\t\\t\\treturn root",
                "codeTag": "Java"
            },
            {
                "id": 326558,
                "title": "python-recursive",
                "content": "Run time O(n), space O(n)\\n\\n```\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if not post:\\n            return None\\n        elif len(post) == 1:\\n            return TreeNode(pre.pop(0))\\n        else:\\n            root = TreeNode(pre.pop(0))\\n            # print(root.val)\\n            pos = post.index(pre[0])\\n            root.left = self.constructFromPrePost(pre, post[:pos+1])\\n            root.right = self.constructFromPrePost(pre, post[pos+1:-1])\\n            return root\\n```",
                "solutionTags": [],
                "code": "```\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if not post:\\n            return None\\n        elif len(post) == 1:\\n            return TreeNode(pre.pop(0))\\n        else:\\n            root = TreeNode(pre.pop(0))\\n            # print(root.val)\\n            pos = post.index(pre[0])\\n            root.left = self.constructFromPrePost(pre, post[:pos+1])\\n            root.right = self.constructFromPrePost(pre, post[pos+1:-1])\\n            return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 326238,
                "title": "python-rescursion",
                "content": "This is similar to [my 105 solution](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/326205/Python-Recursion)\\n```python\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        if len(pre) == 0:\\n            return None\\n        head = TreeNode(pre[0])\\n        if len(pre) == 1:\\n            return head\\n        pre.pop(0)\\n        post.pop()\\n        ind = getInd(pre, post)\\n        lpre, rpre = leftAndRight(pre, ind)\\n        lpost, rpost = leftAndRight(post, ind)\\n        head.left = self.constructFromPrePost(lpre,lpost)\\n        head.right = self.constructFromPrePost (rpre,rpost)\\n        return head\\n        \\ndef getInd(preorder, inorder):\\n    i = 0\\n    lp, li, rp, ri = [], [], [], []\\n    while preorder[0] != inorder[i]:\\n        i += 1\\n    return i\\n\\ndef leftAndRight(order, i):\\n    if i == 0:\\n        return [order[0]], order[1:]\\n    if i == len(order):\\n        return order, []\\n    return order[:i+1], order[i+1:]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        if len(pre) == 0:\\n            return None\\n        head = TreeNode(pre[0])\\n        if len(pre) == 1:\\n            return head\\n        pre.pop(0)\\n        post.pop()\\n        ind = getInd(pre, post)\\n        lpre, rpre = leftAndRight(pre, ind)\\n        lpost, rpost = leftAndRight(post, ind)\\n        head.left = self.constructFromPrePost(lpre,lpost)\\n        head.right = self.constructFromPrePost (rpre,rpost)\\n        return head\\n        \\ndef getInd(preorder, inorder):\\n    i = 0\\n    lp, li, rp, ri = [], [], [], []\\n    while preorder[0] != inorder[i]:\\n        i += 1\\n    return i\\n\\ndef leftAndRight(order, i):\\n    if i == 0:\\n        return [order[0]], order[1:]\\n    if i == len(order):\\n        return order, []\\n    return order[:i+1], order[i+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326000,
                "title": "ruby-recursive-beat-100-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val)\\n#         @val = val\\n#         @left, @right = nil, nil\\n#     end\\n# end\\n\\n# @param {Integer[]} pre\\n# @param {Integer[]} post\\n# @return {TreeNode}\\ndef construct_from_pre_post(pre, post)\\n    return nil if pre.empty?\\n    root = TreeNode.new(pre.first)\\n    return root if pre.size == 1\\n    \\n    # case pre / post size >= 2\\n    idx_pre = 0\\n    \\n    # find left branch post\\n    left_val = pre[1]\\n    \\n    left_end_idx = post.find_index(left_val)\\n    post_left = post.slice(0..left_end_idx)\\n    \\n    # find right branch post\\n    post_right = post.slice(left_end_idx+1..-2)\\n    \\n    # find left branch pre\\n    right_val = post_right.last\\n    \\n    if right_val.nil?\\n        pre_left = pre.slice(1..-1) \\n        root.left = construct_from_pre_post(pre_left, post_left)\\n    else\\n        right_first_idx = pre.find_index(right_val)\\n        pre_left = pre.slice(1..right_first_idx-1) \\n        # find right branch post\\n        pre_right = pre.slice(right_first_idx..-1) \\n        root.left = construct_from_pre_post(pre_left, post_left)\\n        root.right = construct_from_pre_post(pre_right, post_right) \\n    end\\n    \\n    return root\\n    \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val)\\n#         @val = val\\n#         @left, @right = nil, nil\\n#     end\\n# end\\n\\n# @param {Integer[]} pre\\n# @param {Integer[]} post\\n# @return {TreeNode}\\ndef construct_from_pre_post(pre, post)\\n    return nil if pre.empty?\\n    root = TreeNode.new(pre.first)\\n    return root if pre.size == 1\\n    \\n    # case pre / post size >= 2\\n    idx_pre = 0\\n    \\n    # find left branch post\\n    left_val = pre[1]\\n    \\n    left_end_idx = post.find_index(left_val)\\n    post_left = post.slice(0..left_end_idx)\\n    \\n    # find right branch post\\n    post_right = post.slice(left_end_idx+1..-2)\\n    \\n    # find left branch pre\\n    right_val = post_right.last\\n    \\n    if right_val.nil?\\n        pre_left = pre.slice(1..-1) \\n        root.left = construct_from_pre_post(pre_left, post_left)\\n    else\\n        right_first_idx = pre.find_index(right_val)\\n        pre_left = pre.slice(1..right_first_idx-1) \\n        # find right branch post\\n        pre_right = pre.slice(right_first_idx..-1) \\n        root.left = construct_from_pre_post(pre_left, post_left)\\n        root.right = construct_from_pre_post(pre_right, post_right) \\n    end\\n    \\n    return root\\n    \\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312017,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nTreeNode* foo(vector<int>& pre,vector<int>& post,int preL,int preR,int postL,int postR)\\n{\\n    if (preL>preR) return NULL;\\n    \\n    TreeNode* root = new TreeNode(pre[preL]);\\n    \\n    if (preL==preR) return root;\\n    \\n    int l = pre[preL+1];\\n    int i = find(post.begin(),post.end(),l)-post.begin();\\n    \\n    int n = i-postL+1;\\n    \\n    root->left = foo(pre,post,preL+1,preL+n,postL,i);\\n    \\n    root->right = foo(pre,post,preL+n+1,preR,i+1,postR-1);\\n    \\n    return root;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        return foo(pre,post,0,pre.size()-1,0,post.size()-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nTreeNode* foo(vector<int>& pre,vector<int>& post,int preL,int preR,int postL,int postR)\\n{\\n    if (preL>preR) return NULL;\\n    \\n    TreeNode* root = new TreeNode(pre[preL]);\\n    \\n    if (preL==preR) return root;\\n    \\n    int l = pre[preL+1];\\n    int i = find(post.begin(),post.end(),l)-post.begin();\\n    \\n    int n = i-postL+1;\\n    \\n    root->left = foo(pre,post,preL+1,preL+n,postL,i);\\n    \\n    root->right = foo(pre,post,preL+n+1,preR,i+1,postR-1);\\n    \\n    return root;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        return foo(pre,post,0,pre.size()-1,0,post.size()-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297993,
                "title": "javascript-iterative-w-stack-beats-90",
                "content": "```\\nvar constructFromPrePost = function(pre, post) {\\n    let preIndex = 0;\\n    let postIndex = 0;\\n    let nodeStack = [];\\n    \\n    nodeStack.push(new TreeNode(0));\\n    \\n    while(postIndex < post.length) {\\n        if(nodeStack[nodeStack.length - 1].val == post[postIndex]) {\\n            let child = nodeStack.pop();\\n            let parent = nodeStack.pop();\\n            \\n            if(!parent.left)\\n                parent.left = child;\\n            else\\n                parent.right = child;\\n            \\n            nodeStack.push(parent);\\n            postIndex++;\\n        } else\\n            nodeStack.push(new TreeNode(pre[preIndex++]));\\n    }\\n    \\n    return nodeStack.pop().left;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar constructFromPrePost = function(pre, post) {\\n    let preIndex = 0;\\n    let postIndex = 0;\\n    let nodeStack = [];\\n    \\n    nodeStack.push(new TreeNode(0));\\n    \\n    while(postIndex < post.length) {\\n        if(nodeStack[nodeStack.length - 1].val == post[postIndex]) {\\n            let child = nodeStack.pop();\\n            let parent = nodeStack.pop();\\n            \\n            if(!parent.left)\\n                parent.left = child;\\n            else\\n                parent.right = child;\\n            \\n            nodeStack.push(parent);\\n            postIndex++;\\n        } else\\n            nodeStack.push(new TreeNode(pre[preIndex++]));\\n    }\\n    \\n    return nodeStack.pop().left;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570770,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1569902,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1804336,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1573886,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1938195,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1825069,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1745113,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            }
        ]
    },
    {
        "title": "Divide Array in Sets of K Consecutive Numbers",
        "question_content": "<p>Given an array of integers <code>nums</code> and a positive integer <code>k</code>, check whether it is possible to divide this array into sets of <code>k</code> consecutive numbers.</p>\n\n<p>Return <code>true</code> <em>if it is possible</em>.<strong> </strong>Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3,4,4,5,6], k = 4\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Array can be divided into [1,2,3,4] and [3,4,5,6].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], k = 3\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Each array should be divided in subarrays of size 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Note:</strong> This question is the same as&nbsp;846:&nbsp;<a href=\"https://leetcode.com/problems/hand-of-straights/\" target=\"_blank\">https://leetcode.com/problems/hand-of-straights/</a>",
        "solutions": [
            {
                "id": 457569,
                "title": "c-greedy",
                "content": "**Observation**\\n\\nWe can use a greedy approach and start with the smallest number and see if the numbers from that number + k exist and then keep removing them from the numbers we have, if there is a case where it\\'s not possible then we return false.\\n\\n**Solution**\\n```c++\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) \\n    {\\n        if(nums.size()%k!=0)\\n            return false;\\n        map<int,int> count;\\n        map<int,int>::iterator it;\\n        int freq;\\n        for(int &i:nums)\\t\\t\\t//Store the count of all numbers sorted.\\n            count[i]++;\\n        for(it=count.begin();it!=count.end();it++)\\t//Start with the smallest number.\\n            if(it->second)\\t\\t//If the count of smallest integer is non 0 check if next k numbers exist and have atleast same frequency.\\n            {\\n                freq=it->second;\\n                for(int i=0;i<k;i++)\\t\\t\\t\\t//Checks for the next k-1 numbers.\\n                    if(count[it->first+i]<freq) //We are unable to find ith consecutive number to the smallest(starting number) with atleast same frequency.\\n                        return false;\\n                    else\\n                        count[it->first+i]-=freq;       //Reduce the count of the numbers used.\\n            }\\n        return true;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(n)`. Since we store the count of all the numbers.\\nTime: `O(nlogn)`. Since we use map which is sorted and each lookup is `O(logn)`.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) \\n    {\\n        if(nums.size()%k!=0)\\n            return false;\\n        map<int,int> count;\\n        map<int,int>::iterator it;\\n        int freq;\\n        for(int &i:nums)\\t\\t\\t//Store the count of all numbers sorted.\\n            count[i]++;\\n        for(it=count.begin();it!=count.end();it++)\\t//Start with the smallest number.\\n            if(it->second)\\t\\t//If the count of smallest integer is non 0 check if next k numbers exist and have atleast same frequency.\\n            {\\n                freq=it->second;\\n                for(int i=0;i<k;i++)\\t\\t\\t\\t//Checks for the next k-1 numbers.\\n                    if(count[it->first+i]<freq) //We are unable to find ith consecutive number to the smallest(starting number) with atleast same frequency.\\n                        return false;\\n                    else\\n                        count[it->first+i]-=freq;       //Reduce the count of the numbers used.\\n            }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470238,
                "title": "java-c-python-exactly-same-as-846-hand-of-straights",
                "content": "# **Intuition**\\nExactly same as [846. Hand of Straights](https://leetcode.com/problems/hand-of-straights/discuss/135598/C++JavaPython-O(MlogM)-Complexity)\\n<br>\\n\\n# **Solution 1**\\n1. Count number of different cards to a map `c`\\n2. Loop from the smallest card number.\\n3. Everytime we meet a new card `i`, we cut off `i` - `i + k - 1` from the counter.\\n<br>\\n\\n# **Complexity**:\\nTime `O(MlogM + MK)`, where `M` is the number of different cards.\\nIn Cpp and Java it\\'s O(NlogM), which can also be improved.\\n<br>\\n\\n**Java:**\\n```java\\n    public boolean isPossibleDivide(int[] A, int k) {\\n        Map<Integer, Integer> c = new TreeMap<>();\\n        for (int i : A) c.put(i, c.getOrDefault(i, 0)+1);\\n        for (int it : c.keySet())\\n            if (c.get(it) > 0)\\n                for (int i = k - 1; i >= 0; --i) {\\n                    if (c.getOrDefault(it + i, 0) < c.get(it)) return false;\\n                    c.put(it + i, c.get(it + i) - c.get(it));\\n                }\\n        return true;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool isPossibleDivide(vector<int> A, int k) {\\n        map<int, int> c;\\n        for (int i : A) c[i]++;\\n        for (auto it : c)\\n            if (c[it.first] > 0)\\n                for (int i = k - 1; i >= 0; --i)\\n                    if ((c[it.first + i] -= c[it.first]) < 0)\\n                        return false;\\n        return true;\\n    }\\n```\\n**Python:**\\n```py\\n    def isPossibleDivide(self, A, k):\\n        c = collections.Counter(A)\\n        for i in sorted(c):\\n            if c[i] > 0:\\n                for j in range(k)[::-1]:\\n                    c[i + j] -= c[i]\\n                    if c[i + j] < 0:\\n                        return False\\n        return True\\n```\\n\\n# **Follow Up**\\nWe just got lucky AC solution. Because `k <= 10000`.\\nWhat if k is huge, should we cut off card on by one?\\n<br>\\n\\n# **Solution 2**\\n1. Count number of different cards to a map `c`\\n2. `Cur` represent current open straight groups.\\n3. In a deque `start`, we record the number of opened a straight group.\\n4. Loop from the smallest card number.\\n\\nFor example, A = [1,2,3,2,3,4], k = 3\\nWe meet one 1:\\n    opened = 0, we open a new straight groups starting at 1, push (1,1) to `start`.\\nWe meet two 2:\\n    opened = 1, we need open another straight groups starting at 1, push (2,1) to `start`.\\nWe meet two 3:\\n    opened = 2, it match current opened groups.\\n    We open one group at 1, now we close it. opened = opened - 1 = 1\\nWe meet one 4:\\n    opened = 1, it match current opened groups.\\n    We open one group at 2, now we close it. opened = opened - 1 = 0\\n\\n5. return if no more open groups.\\n<br>\\n\\n# **Complexity**\\n`O(N+MlogM)`, where `M` is the number of different cards.\\nBecause I count and sort cards.\\nIn Cpp and Java it\\'s O(NlogM), which can also be improved.\\n<br>\\n\\n**Java**\\n```java\\n    public boolean isPossibleDivide(int[] A, int k) {\\n        Map<Integer, Integer> c = new TreeMap<>();\\n        for (int i : A) c.put(i, c.getOrDefault(i, 0)+1);\\n        Queue<Integer> start = new LinkedList<>();\\n        int last_checked = -1, opened = 0;\\n        for (int i : c.keySet()) {\\n            if (opened > 0 && i > last_checked + 1 || opened > c.get(i)) return false;\\n            start.add(c.get(i) - opened);\\n            last_checked = i; opened = c.get(i);\\n            if (start.size() == k) opened -= start.remove();\\n        }\\n        return opened == 0;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool isPossibleDivide(vector<int> A, int k) {\\n        map<int, int> c;\\n        for (int i : A) c[i]++;\\n        queue<int> start;\\n        int last_checked = -1, opened = 0;\\n        for (auto it : c) {\\n            int i = it.first;\\n            if (opened > 0 && i > last_checked + 1 || opened > c[i]) return false;\\n            start.push(c[i] - opened);\\n            last_checked = i, opened = c[i];\\n            if (start.size() == k) {\\n                opened -= start.front();\\n                start.pop();\\n            }\\n        }\\n        return opened == 0;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def isPossibleDivide(self, A, k):\\n        c = collections.Counter(A)\\n        start = collections.deque()\\n        last_checked, opened = -1, 0\\n        for i in sorted(c):\\n            if opened > c[i] or opened > 0 and i > last_checked + 1: return False\\n            start.append(c[i] - opened)\\n            last_checked, opened = i, c[i]\\n            if len(start) == k: opened -= start.popleft()\\n        return opened == 0\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean isPossibleDivide(int[] A, int k) {\\n        Map<Integer, Integer> c = new TreeMap<>();\\n        for (int i : A) c.put(i, c.getOrDefault(i, 0)+1);\\n        for (int it : c.keySet())\\n            if (c.get(it) > 0)\\n                for (int i = k - 1; i >= 0; --i) {\\n                    if (c.getOrDefault(it + i, 0) < c.get(it)) return false;\\n                    c.put(it + i, c.get(it + i) - c.get(it));\\n                }\\n        return true;\\n    }\\n```\n```cpp\\n    bool isPossibleDivide(vector<int> A, int k) {\\n        map<int, int> c;\\n        for (int i : A) c[i]++;\\n        for (auto it : c)\\n            if (c[it.first] > 0)\\n                for (int i = k - 1; i >= 0; --i)\\n                    if ((c[it.first + i] -= c[it.first]) < 0)\\n                        return false;\\n        return true;\\n    }\\n```\n```py\\n    def isPossibleDivide(self, A, k):\\n        c = collections.Counter(A)\\n        for i in sorted(c):\\n            if c[i] > 0:\\n                for j in range(k)[::-1]:\\n                    c[i + j] -= c[i]\\n                    if c[i + j] < 0:\\n                        return False\\n        return True\\n```\n```java\\n    public boolean isPossibleDivide(int[] A, int k) {\\n        Map<Integer, Integer> c = new TreeMap<>();\\n        for (int i : A) c.put(i, c.getOrDefault(i, 0)+1);\\n        Queue<Integer> start = new LinkedList<>();\\n        int last_checked = -1, opened = 0;\\n        for (int i : c.keySet()) {\\n            if (opened > 0 && i > last_checked + 1 || opened > c.get(i)) return false;\\n            start.add(c.get(i) - opened);\\n            last_checked = i; opened = c.get(i);\\n            if (start.size() == k) opened -= start.remove();\\n        }\\n        return opened == 0;\\n    }\\n```\n```cpp\\n    bool isPossibleDivide(vector<int> A, int k) {\\n        map<int, int> c;\\n        for (int i : A) c[i]++;\\n        queue<int> start;\\n        int last_checked = -1, opened = 0;\\n        for (auto it : c) {\\n            int i = it.first;\\n            if (opened > 0 && i > last_checked + 1 || opened > c[i]) return false;\\n            start.push(c[i] - opened);\\n            last_checked = i, opened = c[i];\\n            if (start.size() == k) {\\n                opened -= start.front();\\n                start.pop();\\n            }\\n        }\\n        return opened == 0;\\n    }\\n```\n```py\\n    def isPossibleDivide(self, A, k):\\n        c = collections.Counter(A)\\n        start = collections.deque()\\n        last_checked, opened = -1, 0\\n        for i in sorted(c):\\n            if opened > c[i] or opened > 0 and i > last_checked + 1: return False\\n            start.append(c[i] - opened)\\n            last_checked, opened = i, c[i]\\n            if len(start) == k: opened -= start.popleft()\\n        return opened == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 457625,
                "title": "python-counter-solution",
                "content": "```python\\nfrom collections import Counter\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        count = Counter(nums)\\n        for n in sorted(count):\\n            if count[n] > 0:\\n                need = count[n]\\n                for i in range(n,n+k):\\n                    if count[i] < need:\\n                        return False\\n                    count[i] -= need\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        count = Counter(nums)\\n        for n in sorted(count):\\n            if count[n] > 0:\\n                need = count[n]\\n                for i in range(n,n+k):\\n                    if count[i] < need:\\n                        return False\\n                    count[i] -= need\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457728,
                "title": "o-n-python-and-c",
                "content": "Update: @khvalin wrote [&rarr;another O(n) solution](https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/discuss/459513/JS-O(n)-Time-Solution) (only the second I\\'ve seen so far) and it\\'s quite nice. I posted a Python version [&rarr;in its comments](https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/discuss/459513/JS-O(n)-Time-Solution/413076).\\n\\nMost (all?) other solutions always handle the smallest remaining number and the streak starting from it. For example when given `[3,2,1,5,6,7,7,8,9]` with `k=3`, they first somehow find `1` as the smallest number and remove `[1,2,3]`. Then they find `5` and remove `[5,6,7]`. Finally they find `7` and remove `[7,8,9]`.\\n\\nBut you could just as well remove `[5,6,7]` first. There\\'s no `4`, so you know `5` is the start of a streak, so it\\'s safe to remove `[5,6,7]` first.\\n\\nYou could remove `[7,8,9]` first, but how would you know that\\'s safe? For example it\\'s *not* safe to remove `[6,7,8]`, that would be a mistake. You could argue that `[7,8,9]` is safe because there\\'s no `10` so `9` must be the *end* of a streak. But then you\\'re looking for streak starts and ends, which needs more code than just looking for starts.\\n\\nHow to efficiently find the start of a streak? Simply grab *any* number and decrement it until you\\'re at a safe streak start. Let\\'s say in the above example you happen to grab the `8`. It\\'s not a safe start because there\\'s a `7`. That\\'s *also* not a safe start, because there\\'s a `6`. Not safe, either, because there\\'s a `5`. But that one\\'s safe, as there\\'s no `4`.\\n\\nThis might look expensive. If you happen to grab a long streak *end*, you\\'ll decrement all the way through the whole long streak. Just to find a single start. But... that\\'s very much worth it, as you can then go back *up* through the streak, deleting it all. So overall you might \"visit\" each number *twice*, once on a way down and once on a way up, but O(2n) = O(n).\\n\\n**Python:**\\n\\n```\\ndef isPossibleDivide(self, nums, k):\\n    ctr = collections.Counter(nums)\\n    for num in nums:\\n        start = num\\n        while ctr[start - 1]:\\n            start -= 1\\n        while start <= num:\\n            while ctr[start]:\\n                for victim in range(start, start + k):\\n                    if not ctr[victim]:\\n                        return False\\n                    ctr[victim] -= 1\\n            start += 1\\n    return True\\n```\\n\\n**Original explanation:**\\n\\nCount in a hashtable. Then go through the numbers. Go lower to find the start of the streak, then go higher along the streak, uncounting as needed.\\n\\nYou might think I go through all the numbers and for each `num` I might do a lot, so how is this O(n)? Isn\\'t it only O(n<sup>2</sup>)? Well, the amount of work I do for each `num` is proportional to how much I uncount. And overall I can\\'t uncount more than was originally there. Which is n. So overall I have O(n). For example, maybe the first `num` causes me to do \"n work\", uncounting everything. But then for all other `num` I do basically *nothing* (only O(1) each).\\n\\n**Somewhat improved version and maybe a little clearer(?):**\\n```\\ndef isPossibleDivide(self, nums, k):\\n    ctr = collections.Counter(nums)\\n    for num in nums:\\n        start = num\\n        while ctr[start - 1]:\\n            start -= 1\\n        while start <= num:\\n            times = ctr[start]\\n            if times:\\n                for victim in range(start, start + k):\\n                    if ctr[victim] < times:\\n                        return False\\n                    ctr[victim] -= times\\n            start += 1\\n    return True\\n```\\n**C++ version, accepted in 152 ms:**\\n```\\nbool isPossibleDivide(vector<int>& nums, int k) {\\n    unordered_map<int, int> ctr;\\n    for (int num : nums)\\n        ctr[num]++;\\n    for (int num : nums) {\\n        int start = num;\\n        while (ctr[start - 1])\\n            start--;\\n        for (; start <= num; start++) {\\n            int times = ctr[start];\\n            if (times) {\\n                for (int victim = start; victim < start + k; victim++) {\\n                    if (ctr[victim] < times)\\n                        return false;\\n                    ctr[victim] -= times;\\n                }\\n            }\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef isPossibleDivide(self, nums, k):\\n    ctr = collections.Counter(nums)\\n    for num in nums:\\n        start = num\\n        while ctr[start - 1]:\\n            start -= 1\\n        while start <= num:\\n            while ctr[start]:\\n                for victim in range(start, start + k):\\n                    if not ctr[victim]:\\n                        return False\\n                    ctr[victim] -= 1\\n            start += 1\\n    return True\\n```\n```\\ndef isPossibleDivide(self, nums, k):\\n    ctr = collections.Counter(nums)\\n    for num in nums:\\n        start = num\\n        while ctr[start - 1]:\\n            start -= 1\\n        while start <= num:\\n            times = ctr[start]\\n            if times:\\n                for victim in range(start, start + k):\\n                    if ctr[victim] < times:\\n                        return False\\n                    ctr[victim] -= times\\n            start += 1\\n    return True\\n```\n```\\nbool isPossibleDivide(vector<int>& nums, int k) {\\n    unordered_map<int, int> ctr;\\n    for (int num : nums)\\n        ctr[num]++;\\n    for (int num : nums) {\\n        int start = num;\\n        while (ctr[start - 1])\\n            start--;\\n        for (; start <= num; start++) {\\n            int times = ctr[start];\\n            if (times) {\\n                for (int victim = start; victim < start + k; victim++) {\\n                    if (ctr[victim] < times)\\n                        return false;\\n                    ctr[victim] -= times;\\n                }\\n            }\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 457687,
                "title": "java-map-priorityqueue-o-dlgd",
                "content": "We could sort the keys then add to queue, or simply use a heap.   Time: max(O(dlgd), O(n)), d is the number of distinct elements.\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int len = nums.length;\\n        if(len % k != 0) return false;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int n: nums)\\n            map.put(n, map.getOrDefault(n, 0) + 1);        \\n        for(int n: map.keySet()) \\n            pq.add(n);        \\n        while(!pq.isEmpty()){\\n            int cur = pq.poll();\\n            if(map.get(cur) == 0) continue;\\n            int times = map.get(cur);            \\n            for(int i = 0; i < k; i++){\\n                if(!map.containsKey(cur + i) || map.get(cur + i) < times)\\n                    return false;\\n                map.put(cur + i, map.get(cur + i) - times);\\n            }\\n            len -= k * times;                                 \\n        }\\n        return len == 0;        \\n    }\\n}\\n```\\nUpdate: Thanks for reminding, we don\\'t need len at all, just return true at the end:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int len = nums.length;\\n        if(len % k != 0) return false;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int n: nums)\\n            map.put(n, map.getOrDefault(n, 0) + 1);        \\n        for(int n: map.keySet()) \\n            pq.add(n);        \\n        while(!pq.isEmpty()){\\n            int cur = pq.poll();\\n            if(map.get(cur) == 0) continue;\\n            int times = map.get(cur);            \\n            for(int i = 0; i < k; i++){\\n                if(!map.containsKey(cur + i) || map.get(cur + i) < times)\\n                    return false;\\n                map.put(cur + i, map.get(cur + i) - times);\\n            }\\n            len -= k * times;                                 \\n        }\\n        return len == 0;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459513,
                "title": "js-o-n-time-solution",
                "content": "Consider the following input:\\nnums = [ 4, 5, 3, 3, 3, 2, 2, 1, 1 ];\\nk = 3;\\n\\nWe solve this problem in three simple steps:\\n\\n1. count each element\\'s occurences:\\n\\t`{ \\'1\\': 2, \\'2\\': 2, \\'3\\': 3, \\'4\\': 1, \\'5\\': 1 }`\\n1. identify initial \"roots\". By \"root\" I mean the very first number of any sequence. For now, we only care about the obvious \"roots\". \\n`[1, 1]`\\n2. iterate over \"roots\" and build sequences by decrementing number counts. if we\\'re short on numbers (`d[i] == 0`), return `false` . whenever we encounter a new root we add it to the top of our collection for further testing. \\nAt some point, we\\'ll save 3 as a root to find the final valid sequence `[3,4,5]` and return `true`.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar isPossibleDivide = function(nums, k) {\\n  const d = {};\\n\\n  // count occurances and store them into a map.\\n  for (const n of nums) {\\n    d[n] = d[n] || 0;\\n    d[n]++;\\n  }\\n\\n  // \"root\" is the starting number of a sequence.\\n  const roots = [];\\n  for (const n of nums) {\\n    if (!d[n - 1]) {\\n      roots.push(n);\\n    }\\n  }\\n\\n  // test each \"root\".\\n  while (roots.length > 0) {\\n    const r = roots.shift();\\n    if (d[r] <= 0) {\\n      continue;\\n    }\\n\\n    // visit every number in [r..r+k] range and attempt building sequence, note we test k + 1 consecutive numbers to make sure we check all potential \"roots\".\\n    for (let i = r; i <= r + k; i++) {\\n      if (i < r + k) {\\n        if (!d[i]) {\\n          return false;\\n        }\\n        d[i]--;\\n      }\\n\\n      // keeping track of new \"roots\".\\n      if (d[i] && !d[i - 1]) {\\n        roots.push(i);\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar isPossibleDivide = function(nums, k) {\\n  const d = {};\\n\\n  // count occurances and store them into a map.\\n  for (const n of nums) {\\n    d[n] = d[n] || 0;\\n    d[n]++;\\n  }\\n\\n  // \"root\" is the starting number of a sequence.\\n  const roots = [];\\n  for (const n of nums) {\\n    if (!d[n - 1]) {\\n      roots.push(n);\\n    }\\n  }\\n\\n  // test each \"root\".\\n  while (roots.length > 0) {\\n    const r = roots.shift();\\n    if (d[r] <= 0) {\\n      continue;\\n    }\\n\\n    // visit every number in [r..r+k] range and attempt building sequence, note we test k + 1 consecutive numbers to make sure we check all potential \"roots\".\\n    for (let i = r; i <= r + k; i++) {\\n      if (i < r + k) {\\n        if (!d[i]) {\\n          return false;\\n        }\\n        d[i]--;\\n      }\\n\\n      // keeping track of new \"roots\".\\n      if (d[i] && !d[i - 1]) {\\n        roots.push(i);\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492210,
                "title": "c-greedy-easy-to-read",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        std::map<int,int> m;\\n        for(auto num : nums)\\n            m[num]++;\\n        \\n        for(auto [key, value] : m)\\n        {\\n            while(m[key])\\n            {\\n                for(int i = key; i < key + k; ++i)\\n                {\\n                    m[i]--;\\n                    if(m[i] < 0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        std::map<int,int> m;\\n        for(auto num : nums)\\n            m[num]++;\\n        \\n        for(auto [key, value] : m)\\n        {\\n            while(m[key])\\n            {\\n                for(int i = key; i < key + k; ++i)\\n                {\\n                    m[i]--;\\n                    if(m[i] < 0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444403,
                "title": "c-java-python-javascript-fully-explained-map-2-approach",
                "content": "# Intuition:\\nBoth approaches are solving the same problem of determining whether a given array can be divided into groups of k consecutive elements or not. Approach 1 uses a map to keep track of the frequency of each element, and then iterates over the elements while maintaining the current group of k consecutive elements. If the current group cannot be formed, it returns false. Approach 2 also uses a map to keep track of the frequency of each element but sorts the array first and then iterates over it. For each element, it checks if it can form a group of k consecutive elements by checking the frequency of the next k-1 elements.\\n\\n# Approach 1:\\n\\n1. Initialize a map to keep track of the frequency of each element.\\n2. Iterate over the array and update the map with the frequency of each element.\\n3. While the map is not empty, get the first element of the map.\\n4. Iterate over the next k consecutive elements and check if they exist in the map and have a frequency greater than 0. If any element is missing or has a frequency of 0, return false.\\n5. Update the frequency of each element in the group and remove any element from the map whose frequency becomes 0.\\n6. Return true if all groups of k consecutive elements can be formed.\\n# Approach 2:\\n\\n1. Check if the length of the array is divisible by k. If not, return false.\\n2. Initialize an unordered map to keep track of the frequency of each element.\\n3. Iterate over the array and update the map with the frequency of each element.\\n4. Sort the array in ascending order.\\n5. For each element in the sorted array, check if its frequency is greater than 0.\\n6. If yes, iterate over the next k-1 elements and check if they exist in the map and have a frequency greater than 0. If any element is missing or has a frequency of 0, return false.\\n7. Update the frequency of each element in the group.\\n8. Repeat steps 5-7 until all groups of k consecutive elements have been formed.\\n9. Return true if all groups of k consecutive elements can be formed.\\n# Complexity:\\n\\n- Time complexity:\\n    - Approach 1: The time complexity of this approach is O(n log n) due to the use of a map and the worst-case scenario is when all elements are distinct, then it takes nlogn time for inserting into map, and n times we need to check for each group of k elements.\\n    - Approach 2: The time complexity of this approach is O(n log n) due to the use of sorting and iterating over the sorted array. Sorting takes O(n log n) time, and iterating over the array takes O(n) time.\\n\\n- Space complexity:\\n    - Approach 1: The space complexity of this approach is O(n) due to the use of a map to store the frequency of each element.\\n    - Approach 2: The space complexity of this approach is also O(n) due to the use of an unordered map to store the frequency of each element.\\n# C++\\n## Approach 1\\n```\\nclass Solution {\\npublic:\\n     bool isPossibleDivide(vector<int>& nums, int k) {\\n         map<int,int> map;\\n         for(int num : nums){\\n             map[num]++;\\n         }\\n         while(map.size()!=0){\\n             int first = map.begin()->first;\\n             for(int i=first; i<first+k; i++){\\n                 if(!map.count(i)){\\n                     return false;\\n                 }\\n                 map[i]--;\\n                 if(map[i]==0){\\n                     map.erase(i);\\n                 }\\n             }\\n         }\\n         return true;\\n     }\\n };\\n```\\n## Approach 2\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if (nums.size() % k != 0) {\\n            return false;\\n        }\\n        \\n        unordered_map<int,int> map;\\n        for (int num : nums) {\\n            map[num]++;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int num : nums) {\\n            if (map[num] > 0) {\\n                for (int i = num + 1; i < num + k; i++) {\\n                    if (map[i] == 0) {\\n                        return false;\\n                    }\\n                    map[i]--;\\n                }\\n                map[num]--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```\\n# Java\\n ## Approach 1\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        while (!map.isEmpty()) {\\n            int first = Collections.min(map.keySet());\\n            for (int i = first; i < first + k; i++) {\\n                if (!map.containsKey(i)) {\\n                    return false;\\n                }\\n                map.put(i, map.get(i) - 1);\\n                if (map.get(i) == 0) {\\n                    map.remove(i);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n## Approach 2\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums.length % k != 0) {\\n            return false;\\n        }\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        for (int num : nums) {\\n            if (map.get(num) > 0) {\\n                for (int i = num + 1; i < num + k; i++) {\\n                    if (map.getOrDefault(i, 0) == 0) {\\n                        return false;\\n                    }\\n                    map.put(i, map.get(i) - 1);\\n                }\\n                map.put(num, map.get(num) - 1);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n# Python\\n ## Approach 1\\n```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        num_map = {}\\n        for num in nums:\\n            num_map[num] = num_map.get(num, 0) + 1\\n        while num_map:\\n            first = min(num_map)\\n            for i in range(first, first+k):\\n                if i not in num_map:\\n                    return False\\n                num_map[i] -= 1\\n                if num_map[i] == 0:\\n                    del num_map[i]\\n        return True\\n\\n```\\n ## Approach 2\\n```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        if len(nums) % k != 0:\\n            return False\\n        \\n        map = {}\\n        for num in nums:\\n            map[num] = map.get(num, 0) + 1\\n        \\n        nums.sort()\\n        \\n        for num in nums:\\n            if map[num] > 0:\\n                for i in range(num+1, num+k):\\n                    if map.get(i, 0) == 0:\\n                        return False\\n                    map[i] -= 1\\n                map[num] -= 1\\n        \\n        return True\\n\\n```\\n# JavaScript\\n ## Approach 1\\n```\\nvar isPossibleDivide = function(nums, k) {\\n  const map = new Map();\\n  for (const num of nums) {\\n    map.set(num, (map.get(num) || 0) + 1);\\n  }\\n  while (map.size !== 0) {\\n    const first = Array.from(map.keys()).sort((a, b) => a - b)[0];\\n    for (let i = first; i < first + k; i++) {\\n      if (!map.has(i)) {\\n        return false;\\n      }\\n      map.set(i, map.get(i) - 1);\\n      if (map.get(i) === 0) {\\n        map.delete(i);\\n      }\\n    }\\n  }\\n  return true;\\n}\\n```\\n ## Approach 2\\n```\\nvar isPossibleDivide = function(nums, k) {\\n  if (nums.length % k !== 0) {\\n    return false;\\n  }\\n\\n  const map = new Map();\\n  for (const num of nums) {\\n    map.set(num, (map.get(num) || 0) + 1);\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n\\n  for (const num of nums) {\\n    if (map.get(num) > 0) {\\n      for (let i = num + 1; i < num + k; i++) {\\n        if (map.get(i) === 0) {\\n          return false;\\n        }\\n        map.set(i, map.get(i) - 1);\\n      }\\n      map.set(num, map.get(num) - 1);\\n    }\\n  }\\n\\n  return true;\\n}\\n\\n```\\n# Similar Question: \\nhttps://leetcode.com/problems/hand-of-straights/solutions/3444424/c-very-easy-fully-explained-using-map/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isPossibleDivide(vector<int>& nums, int k) {\\n         map<int,int> map;\\n         for(int num : nums){\\n             map[num]++;\\n         }\\n         while(map.size()!=0){\\n             int first = map.begin()->first;\\n             for(int i=first; i<first+k; i++){\\n                 if(!map.count(i)){\\n                     return false;\\n                 }\\n                 map[i]--;\\n                 if(map[i]==0){\\n                     map.erase(i);\\n                 }\\n             }\\n         }\\n         return true;\\n     }\\n };\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if (nums.size() % k != 0) {\\n            return false;\\n        }\\n        \\n        unordered_map<int,int> map;\\n        for (int num : nums) {\\n            map[num]++;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int num : nums) {\\n            if (map[num] > 0) {\\n                for (int i = num + 1; i < num + k; i++) {\\n                    if (map[i] == 0) {\\n                        return false;\\n                    }\\n                    map[i]--;\\n                }\\n                map[num]--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        while (!map.isEmpty()) {\\n            int first = Collections.min(map.keySet());\\n            for (int i = first; i < first + k; i++) {\\n                if (!map.containsKey(i)) {\\n                    return false;\\n                }\\n                map.put(i, map.get(i) - 1);\\n                if (map.get(i) == 0) {\\n                    map.remove(i);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums.length % k != 0) {\\n            return false;\\n        }\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        for (int num : nums) {\\n            if (map.get(num) > 0) {\\n                for (int i = num + 1; i < num + k; i++) {\\n                    if (map.getOrDefault(i, 0) == 0) {\\n                        return false;\\n                    }\\n                    map.put(i, map.get(i) - 1);\\n                }\\n                map.put(num, map.get(num) - 1);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        num_map = {}\\n        for num in nums:\\n            num_map[num] = num_map.get(num, 0) + 1\\n        while num_map:\\n            first = min(num_map)\\n            for i in range(first, first+k):\\n                if i not in num_map:\\n                    return False\\n                num_map[i] -= 1\\n                if num_map[i] == 0:\\n                    del num_map[i]\\n        return True\\n\\n```\n```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        if len(nums) % k != 0:\\n            return False\\n        \\n        map = {}\\n        for num in nums:\\n            map[num] = map.get(num, 0) + 1\\n        \\n        nums.sort()\\n        \\n        for num in nums:\\n            if map[num] > 0:\\n                for i in range(num+1, num+k):\\n                    if map.get(i, 0) == 0:\\n                        return False\\n                    map[i] -= 1\\n                map[num] -= 1\\n        \\n        return True\\n\\n```\n```\\nvar isPossibleDivide = function(nums, k) {\\n  const map = new Map();\\n  for (const num of nums) {\\n    map.set(num, (map.get(num) || 0) + 1);\\n  }\\n  while (map.size !== 0) {\\n    const first = Array.from(map.keys()).sort((a, b) => a - b)[0];\\n    for (let i = first; i < first + k; i++) {\\n      if (!map.has(i)) {\\n        return false;\\n      }\\n      map.set(i, map.get(i) - 1);\\n      if (map.get(i) === 0) {\\n        map.delete(i);\\n      }\\n    }\\n  }\\n  return true;\\n}\\n```\n```\\nvar isPossibleDivide = function(nums, k) {\\n  if (nums.length % k !== 0) {\\n    return false;\\n  }\\n\\n  const map = new Map();\\n  for (const num of nums) {\\n    map.set(num, (map.get(num) || 0) + 1);\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n\\n  for (const num of nums) {\\n    if (map.get(num) > 0) {\\n      for (let i = num + 1; i < num + k; i++) {\\n        if (map.get(i) === 0) {\\n          return false;\\n        }\\n        map.set(i, map.get(i) - 1);\\n      }\\n      map.set(num, map.get(num) - 1);\\n    }\\n  }\\n\\n  return true;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457586,
                "title": "java-map-short-and-concise",
                "content": "1. Check the length of nums\\n2. Count every distinct number in nums\\n3. Sort the array\\n4. Find every set\\'s smallest number and find all numbers in every set\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n % k != 0) {\\n            return false;\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int a : nums) {\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        }\\n        Arrays.sort(nums);\\n        for (int a : nums) {\\n            if (map.get(a) > 0) {\\n                for (int i = 0; i < k; i++) {\\n                    if (!map.containsKey(a + i) || map.get(a + i) == 0) {\\n                        return false;\\n                    } else {\\n                        map.put(a + i, map.get(a + i) - 1);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n % k != 0) {\\n            return false;\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int a : nums) {\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        }\\n        Arrays.sort(nums);\\n        for (int a : nums) {\\n            if (map.get(a) > 0) {\\n                for (int i = 0; i < k; i++) {\\n                    if (!map.containsKey(a + i) || map.get(a + i) == 0) {\\n                        return false;\\n                    } else {\\n                        map.put(a + i, map.get(a + i) - 1);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457617,
                "title": "easy-solution",
                "content": "```  \\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length % k != 0) return false;\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n\\n        for(int x: nums)\\n           map.put(x,map.getOrDefault(x,0)+1); \\n        \\n        for(int n: map.keySet()){\\n            int curr = map.get(n);\\n            \\n            if(curr == 0) continue;\\n            \\n            for(int i = n; i < k + n; i++){\\n                if(!map.containsKey(i) || map.get(i) <= 0)\\n                    return false;\\n                map.put(i,map.get(i) - curr);\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```  \\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length % k != 0) return false;\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n\\n        for(int x: nums)\\n           map.put(x,map.getOrDefault(x,0)+1); \\n        \\n        for(int n: map.keySet()){\\n            int curr = map.get(n);\\n            \\n            if(curr == 0) continue;\\n            \\n            for(int i = n; i < k + n; i++){\\n                if(!map.containsKey(i) || map.get(i) <= 0)\\n                    return false;\\n                map.put(i,map.get(i) - curr);\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 457668,
                "title": "java-python-3-greedy-algorithm-using-treemap-counter-w-explanation-and-analysis",
                "content": "1. Use a TreeMap/Counter to sort and count the elements in `nums`;\\n2. Start from the smallest key `key1` to `key1 + k`, decrease the count of them by 1 each; If any key is absent, return `false`; remove the entry if the count reaches `0`;\\n3. If never encounter the absence of any keys in 2, return `true`.\\n```java\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int n : nums)\\n            m.put(n, 1 + m.getOrDefault(n, 0));\\n        while (!m.isEmpty()) {\\n            Map.Entry<Integer, Integer> e = m.pollFirstEntry();\\n            int key = e.getKey(), val = e.getValue();\\n            while (val-- > 0) {\\n                for (int key1 = key + 1; key1 < key + k; ++key1) {\\n                    if (m.put(key1, m.getOrDefault(key1, 0) - 1) == null) // if key1 not in the TreeMap.\\n                        return false;\\n                    m.remove(key1, 0); // if the count of key1 decrease to 0, remove the entry.\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        c = collections.Counter(nums)                                      # count each of the distinct elements.\\n        # for key in sorted(c.keys()):                                     # Traverse the sorted keys.\\n        for key in sorted(c): # same as the above line but succincter. credit to @StefanPochmann\\n            while c[key]:                                                  # element key exhausted?\\n                for key1 in range(key, key + k):                           # Traverse [key, ..., key + k).\\n                    if not c[key1]:                                        # key1 exhausted?\\n                        return False                                       # impossible.\\n                    c[key1] -= 1                                           # decrease the count of key1 by 1.\\n        return True                                                        # never encounter the absence of the necessary keys.\\n```\\n\\n----\\n\\nUpdated codes - credit to **@HauserZ**.\\n```java\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int n : nums)\\n            m.put(n, 1 + m.getOrDefault(n, 0));\\n        while (!m.isEmpty()) {\\n            Map.Entry<Integer, Integer> e = m.pollFirstEntry();\\n            int key = e.getKey(), val = e.getValue();\\n            for (int key1 = key + 1; key1 < key + k; ++key1) {\\n                Integer oldVal = m.put(key1, m.getOrDefault(key1, 0) - val);\\n                if (oldVal == null || oldVal < val)\\n                    return false;\\n                m.remove(key1, 0);\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        c = collections.Counter(nums)                                      # count each of the distinct elements.\\n        # for key in sorted(c.keys()):                                     # Traverse the sorted keys.\\n        for key in sorted(c): # same as the above line but succincter. credit to @StefanPochmann\\n            if (val := c[key]) > 0:                                        # element key exhausted?\\n                for key1 in range(key, key + k):                           # Traverse [key, ..., key + k).\\n                    if c[key1] < val:                                      # key1 exhausted?\\n                        return False                                       # impossible.\\n                    c[key1] -= val                                         # decrease the count of key1 by the value of key.\\n        return True                                                        # never encounter the absence of the necessary keys.\\n```\\n**Analysis:**\\nTime: O(nlogn), space: O(n), where n = nums.length.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int n : nums)\\n            m.put(n, 1 + m.getOrDefault(n, 0));\\n        while (!m.isEmpty()) {\\n            Map.Entry<Integer, Integer> e = m.pollFirstEntry();\\n            int key = e.getKey(), val = e.getValue();\\n            while (val-- > 0) {\\n                for (int key1 = key + 1; key1 < key + k; ++key1) {\\n                    if (m.put(key1, m.getOrDefault(key1, 0) - 1) == null) // if key1 not in the TreeMap.\\n                        return false;\\n                    m.remove(key1, 0); // if the count of key1 decrease to 0, remove the entry.\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        c = collections.Counter(nums)                                      # count each of the distinct elements.\\n        # for key in sorted(c.keys()):                                     # Traverse the sorted keys.\\n        for key in sorted(c): # same as the above line but succincter. credit to @StefanPochmann\\n            while c[key]:                                                  # element key exhausted?\\n                for key1 in range(key, key + k):                           # Traverse [key, ..., key + k).\\n                    if not c[key1]:                                        # key1 exhausted?\\n                        return False                                       # impossible.\\n                    c[key1] -= 1                                           # decrease the count of key1 by 1.\\n        return True                                                        # never encounter the absence of the necessary keys.\\n```\n```java\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int n : nums)\\n            m.put(n, 1 + m.getOrDefault(n, 0));\\n        while (!m.isEmpty()) {\\n            Map.Entry<Integer, Integer> e = m.pollFirstEntry();\\n            int key = e.getKey(), val = e.getValue();\\n            for (int key1 = key + 1; key1 < key + k; ++key1) {\\n                Integer oldVal = m.put(key1, m.getOrDefault(key1, 0) - val);\\n                if (oldVal == null || oldVal < val)\\n                    return false;\\n                m.remove(key1, 0);\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        c = collections.Counter(nums)                                      # count each of the distinct elements.\\n        # for key in sorted(c.keys()):                                     # Traverse the sorted keys.\\n        for key in sorted(c): # same as the above line but succincter. credit to @StefanPochmann\\n            if (val := c[key]) > 0:                                        # element key exhausted?\\n                for key1 in range(key, key + k):                           # Traverse [key, ..., key + k).\\n                    if c[key1] < val:                                      # key1 exhausted?\\n                        return False                                       # impossible.\\n                    c[key1] -= val                                         # decrease the count of key1 by the value of key.\\n        return True                                                        # never encounter the absence of the necessary keys.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770938,
                "title": "c-solution-using-ordered-maps",
                "content": "A simple C++ solution using ordered maps with **keys as elements of the array** and **values as their respective counts**. \\n\\n1. Start from the first key of the map.(i.e. least element in the array which is not part of any sequence).\\n2. Check for the existence of other k-1 consecutive keys.\\n3. If any of the keys is not present, then return false.\\n4. Else,  decrement the count of that key as it is included in the current sequence. If the count is 0, then remove that key as well. \\n5. Repeat the above 4 steps (n/k) times where n is the number of elements in the array and k is the size of the sequence, so total number of sequences we can make is (n/k). \\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        if(n % k != 0)\\n        {\\n            return false;\\n        }\\n        \\n        map<int, int> mp;\\n        \\n        for(int& num: nums)\\n        {\\n            mp[num]++;\\n        }\\n        \\n        int l = n/k;\\n        \\n        \\n        for(int i = 1; i <= l; i++)\\n        {\\n            auto it = mp.begin();\\n            int tmp = it->first;\\n            \\n            for(int j = tmp; j < tmp + k; j++)\\n            {\\n                if(mp.find(j) == mp.end())\\n                {\\n                    return false;\\n                }\\n                \\n                mp[j]--;\\n                if(mp[j] == 0)\\n                {\\n                    mp.erase(j);\\n                }\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        if(n % k != 0)\\n        {\\n            return false;\\n        }\\n        \\n        map<int, int> mp;\\n        \\n        for(int& num: nums)\\n        {\\n            mp[num]++;\\n        }\\n        \\n        int l = n/k;\\n        \\n        \\n        for(int i = 1; i <= l; i++)\\n        {\\n            auto it = mp.begin();\\n            int tmp = it->first;\\n            \\n            for(int j = tmp; j < tmp + k; j++)\\n            {\\n                if(mp.find(j) == mp.end())\\n                {\\n                    return false;\\n                }\\n                \\n                mp[j]--;\\n                if(mp[j] == 0)\\n                {\\n                    mp.erase(j);\\n                }\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644577,
                "title": "python-straightforward-simple",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        d = Counter(nums)\\n        for x in sorted(nums):\\n            if x in d:\\n                for y in range(x, x + k):\\n                    if y in d:\\n                        d[y] -= 1\\n                        if d[y] == 0:\\n                            del d[y]\\n                    else:\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        d = Counter(nums)\\n        for x in sorted(nums):\\n            if x in d:\\n                for y in range(x, x + k):\\n                    if y in d:\\n                        d[y] -= 1\\n                        if d[y] == 0:\\n                            del d[y]\\n                    else:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457604,
                "title": "java-treemap-solution-clean",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int len = nums.length;\\n        if(len % k != 0) return false;\\n        int n = len/k;\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>(); \\n        for(int num: nums){\\n            treeMap.put(num, treeMap.getOrDefault(num, 0) +1);\\n        }\\n        for(int x = 0; x < n; x++){\\n            int first = treeMap.firstKey();\\n            for(int i = 0; i < k; i++){\\n                if(treeMap.containsKey(first)){\\n                    treeMap.put(first, treeMap.get(first) - 1);\\n                    if(treeMap.get(first) == 0)\\n                        treeMap.remove(first);\\n                    first += 1;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int len = nums.length;\\n        if(len % k != 0) return false;\\n        int n = len/k;\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>(); \\n        for(int num: nums){\\n            treeMap.put(num, treeMap.getOrDefault(num, 0) +1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1097975,
                "title": "c-solution-using-priority-queue-98-faster-than-other-can-be-extended-to-other-problems",
                "content": "Using minHeap and Greedy approach. The same template can be used for Problem: https://leetcode.com/problems/split-array-into-consecutive-subsequences/\\n\\nThe idea is here to keep a min heap (priority queue) of pair, where\\nfirst element of pair -> end element of series of consecutive integers\\nsecond element of pair -> size of series formed.\\ne.g. {5, 3} -> represents series { 3 4 5 }\\n\\nNow if we have a sorted sequence of integers, for any element x, the heap formed till now, will contain following entries in order:\\n1. series with end element < x - 1\\n2. series with end element == x - 1\\n3. series with end element == x  \\n\\nAll elements in scenario 1 can be discarded as the series has ended at element < x - 1, so with adding x, we cannot form consecutive series. \\n\\nIn this question we need to make sure all series formed have length == k, so we check for that condition  \\n```\\n while (!pq.empty() && pq.top().first < num - 1) {\\n\\tif (pq.top().second != k) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpq.pop();\\n}\\n```\\n\\nFor all elements in scenario 2, if the series is already of size k, we dont want to add x to those series as they are already complete, so we remove them.\\n```\\n while (!pq.empty() && pq.top().second == k) {\\n\\tif (pq.top().second != k) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpq.pop();\\n}\\n```\\nAlso, since the top element will have smallest size, we make sure that we are adding x to the series which is smallest.\\n\\nFor scenario 3, we will start new series of size 1.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        for (int num : nums) {\\n            while (!pq.empty() && (pq.top().first < num - 1 || pq.top().second == k)) {\\n                if (pq.top().second != k) {\\n                    return false;\\n                }\\n                \\n                pq.pop();\\n            }\\n            \\n            if (pq.empty() || pq.top().first == num) {\\n                pq.push(make_pair(num, 1));\\n                continue;\\n            }\\n            \\n            int size = pq.top().second + 1;\\n            pq.pop();\\n            pq.push(make_pair(num, size));\\n        }\\n        \\n        while (!pq.empty()) {\\n            if (pq.top().second != k) {\\n                return false;\\n            }\\n\\n            pq.pop();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n while (!pq.empty() && pq.top().first < num - 1) {\\n\\tif (pq.top().second != k) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpq.pop();\\n}\\n```\n```\\n while (!pq.empty() && pq.top().second == k) {\\n\\tif (pq.top().second != k) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tpq.pop();\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        for (int num : nums) {\\n            while (!pq.empty() && (pq.top().first < num - 1 || pq.top().second == k)) {\\n                if (pq.top().second != k) {\\n                    return false;\\n                }\\n                \\n                pq.pop();\\n            }\\n            \\n            if (pq.empty() || pq.top().first == num) {\\n                pq.push(make_pair(num, 1));\\n                continue;\\n            }\\n            \\n            int size = pq.top().second + 1;\\n            pq.pop();\\n            pq.push(make_pair(num, size));\\n        }\\n        \\n        while (!pq.empty()) {\\n            if (pq.top().second != k) {\\n                return false;\\n            }\\n\\n            pq.pop();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041998,
                "title": "using-only-priority-queue",
                "content": "* Add all the elements into the PQ.\\n* Then loop through the PQ and take the 1st smallest and find its k consicutive numbers. If at least one consicutive number is not present the return false.\\n* Last, if the PQ become empty the return true.\\n\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(Integer i : nums){\\n            pq.add(i);\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            int curr = pq.poll();\\n            for(int j=1; j<k; j++){\\n                if(!pq.remove(curr + j)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(Integer i : nums){\\n            pq.add(i);\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            int curr = pq.poll();\\n            for(int j=1; j<k; j++){\\n                if(!pq.remove(curr + j)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448806,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting && Hashmap***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // if n is not multiple of k, then we can\\'t divide the array\\n        \\n        if(n % k)\\n            return false;\\n        \\n        // sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // store the frequency of every elements into the count map\\n        \\n        unordered_map<int, int> count;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        \\n        // iterate over the array\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if all the occurance of curr element is include\\n            \\n            if(count[nums[i]] == 0)\\n                continue;\\n            \\n            // decrement the count of occurance of curr element\\n            \\n            count[nums[i]]--;\\n            \\n            // check can we make a set of k consecutive numbers\\n            \\n            for(int j = 1; j < k; j++)\\n            {\\n                // if nums[i] + j is not present in count map, then we can\\'t make a set of k consecutive numbers\\n                \\n                if(count[nums[i] + j] == 0)\\n                    return false;\\n                \\n                // decrement the count of occurance of nums[i] + j element \\n                \\n                count[nums[i] + j]--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // if n is not multiple of k, then we can\\'t divide the array\\n        \\n        if(n % k)\\n            return false;\\n        \\n        // sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // store the frequency of every elements into the count map\\n        \\n        unordered_map<int, int> count;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        \\n        // iterate over the array\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if all the occurance of curr element is include\\n            \\n            if(count[nums[i]] == 0)\\n                continue;\\n            \\n            // decrement the count of occurance of curr element\\n            \\n            count[nums[i]]--;\\n            \\n            // check can we make a set of k consecutive numbers\\n            \\n            for(int j = 1; j < k; j++)\\n            {\\n                // if nums[i] + j is not present in count map, then we can\\'t make a set of k consecutive numbers\\n                \\n                if(count[nums[i] + j] == 0)\\n                    return false;\\n                \\n                // decrement the count of occurance of nums[i] + j element \\n                \\n                count[nums[i] + j]--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323845,
                "title": "java-bucket-sorts-16ms-beats-99-62",
                "content": "**Explaination**\\n* We can see that for a array that is divisible into ```k``` consecutive numbers, we can distribute its elements into ```k``` buckets using the formular ```f(x, k) = x % k```. For example:\\n\\t* ```[1, 2, 3, 3, 4, 5, 1, 2, 3]``` with ```k = 3```\\n\\t* ```[1, 2, 0, 0, 1, 2, 1, 2, 0]``` when applying the formular.\\n\\t* ```buckets = [3, 3, 3]```\\n* So, the idea of the solution is to divide the elements of the array into ```k``` buckets, then we loop through the bucket to check whether each bucket contains the same element.\\n* However, we will have test case like ```[16, 21, 26, 31]``` with ```k = 4```, applying the formular we will receive ```[0, 1, 2, 3]```, hence,  ```buckets = [1, 1, 1, 1]```. \\n\\t* So, we have to sort the array first, then while we distribute the elements into bucket, we also check whether the different between two consecutive elements is larger than 1.\\n\\n**Code**\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] A, int k) {\\n        Arrays.sort(A);\\n        int[] buckets = new int[k];\\n        for (int i = 0; i < A.length; i++) {\\n            if (i % k != 0 && A[i] - A[i - 1] > 1) return false;\\n            buckets[A[i] % k]++;\\n        }\\n        \\n        for (int bucket: buckets) {\\n            if (bucket != buckets[0]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Complexity**\\n```O(NlogN)``` as we sort the array.",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```k```\n```k```\n```f(x, k) = x % k```\n```[1, 2, 3, 3, 4, 5, 1, 2, 3]```\n```k = 3```\n```[1, 2, 0, 0, 1, 2, 1, 2, 0]```\n```buckets = [3, 3, 3]```\n```k```\n```[16, 21, 26, 31]```\n```k = 4```\n```[0, 1, 2, 3]```\n```buckets = [1, 1, 1, 1]```\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] A, int k) {\\n        Arrays.sort(A);\\n        int[] buckets = new int[k];\\n        for (int i = 0; i < A.length; i++) {\\n            if (i % k != 0 && A[i] - A[i - 1] > 1) return false;\\n            buckets[A[i] % k]++;\\n        }\\n        \\n        for (int bucket: buckets) {\\n            if (bucket != buckets[0]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```O(NlogN)```",
                "codeTag": "Java"
            },
            {
                "id": 796529,
                "title": "python-simple-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums) % k != 0:\\n            return False\\n        \\n        my_dict = defaultdict(int)\\n        for num in nums:\\n            my_dict[num]+=1\\n        numbers_left = len(nums)\\n        \\n        while numbers_left > 0:\\n            mini = min(my_dict.keys())\\n            for i in range(k):\\n                if not my_dict.get(mini+i):\\n                    return False\\n                my_dict[mini+i]-=1\\n                numbers_left -= 1\\n                if my_dict[mini+i] == 0:\\n                    del my_dict[mini+i]\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums) % k != 0:\\n            return False\\n        \\n        my_dict = defaultdict(int)\\n        for num in nums:\\n            my_dict[num]+=1\\n        numbers_left = len(nums)\\n        \\n        while numbers_left > 0:\\n            mini = min(my_dict.keys())\\n            for i in range(k):\\n                if not my_dict.get(mini+i):\\n                    return False\\n                my_dict[mini+i]-=1\\n                numbers_left -= 1\\n                if my_dict[mini+i] == 0:\\n                    del my_dict[mini+i]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067661,
                "title": "c-easy-understanding-map-solution-same-as-846",
                "content": "**[//1296. Divide Array in Sets of K Consecutive Numbers ](https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/)**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool isPossibleDivide(vector<int>& nums, int k) \\n\\t\\t\\t{\\n\\t\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(auto p=mp.begin();p!=mp.end();)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(p->second>0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<k;i++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(mp[p->first+i]>0)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[p->first+i]--;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tp++;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\n**[SAME SOLUTION FOR 846. Hand of Straights](https://leetcode.com/problems/hand-of-straights/)**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool isNStraightHand(vector<int>& nums, int k) \\n\\t\\t\\t{\\n\\t\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(auto p=mp.begin();p!=mp.end();)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(p->second>0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<k;i++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(mp[p->first+i]>0)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[p->first+i]--;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tp++;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\t\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool isPossibleDivide(vector<int>& nums, int k) \\n\\t\\t\\t{\\n\\t\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmp[nums[i]]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 922050,
                "title": "clean-code-with-heavily-commented",
                "content": "**intuition**\\n1. Find the number of unique values and their count\\n2. For every unique values we need k consecutive values and their count should be >= current value\\'s count\\n3. If that\\'s not possible return false\\n\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int n=nums.length;\\n        // count every unique value frequencies present in this arr\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int count = map.getOrDefault(nums[i],0);\\n            map.put(nums[i],count+1);\\n        }\\n        \\n        // sort the keys in ascending order\\n        List<Integer> sortedKeys = new ArrayList<Integer>(map.keySet());\\n        Collections.sort(sortedKeys);\\n        \\n        // loop over the keys\\n        for(int key:sortedKeys){\\n            int val = map.get(key);\\n            \\n            // if this key occurance is 0 continue\\n            if(val == 0) continue;\\n            \\n            // find first k greater elements for this key(for eg: if key == 1 and k ==3 -> find(2,3) in map)\\n            \\n             for(int j=1;j<k;j++){\\n                int forward_key = key+j;\\n                \\n                //if we didn\\'t find an element in this map return false\\n                if(!map.containsKey(forward_key)) return false;\\n                \\n                int forward_val = map.get(forward_key);\\n                // if we can\\'t find enough elements to pair with this key return false\\n                if(forward_val < val) return false;\\n                \\n                // after pairing with this key update this element remaining count\\n                map.put(forward_key,forward_val- val);\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\\nIf u find it\\'s useful please upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int n=nums.length;\\n        // count every unique value frequencies present in this arr\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int count = map.getOrDefault(nums[i],0);\\n            map.put(nums[i],count+1);\\n        }\\n        \\n        // sort the keys in ascending order\\n        List<Integer> sortedKeys = new ArrayList<Integer>(map.keySet());\\n        Collections.sort(sortedKeys);\\n        \\n        // loop over the keys\\n        for(int key:sortedKeys){\\n            int val = map.get(key);\\n            \\n            // if this key occurance is 0 continue\\n            if(val == 0) continue;\\n            \\n            // find first k greater elements for this key(for eg: if key == 1 and k ==3 -> find(2,3) in map)\\n            \\n             for(int j=1;j<k;j++){\\n                int forward_key = key+j;\\n                \\n                //if we didn\\'t find an element in this map return false\\n                if(!map.containsKey(forward_key)) return false;\\n                \\n                int forward_val = map.get(forward_key);\\n                // if we can\\'t find enough elements to pair with this key return false\\n                if(forward_val < val) return false;\\n                \\n                // after pairing with this key update this element remaining count\\n                map.put(forward_key,forward_val- val);\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848790,
                "title": "c-using-frequency-count",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int size = nums.size();\\n         if(size % k != 0)\\n             return false;\\n        int count = 0;\\n        map<int,int> mp;\\n       \\n        for(int i = 0; i < size; i++)\\n        {\\n         mp[nums[i]]++;   \\n        }\\n        for(auto x: mp)\\n        {\\n            if(x.second)\\n            {\\n                int freq = x.second;\\n                int curr = x.first;\\n                while(count < k)\\n                {\\n                    if(mp[curr+count] >= freq)\\n                    {\\n                        mp[curr+count]-= freq;\\n                        count++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n                if(count == k)\\n                    count = 0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int size = nums.size();\\n         if(size % k != 0)\\n             return false;\\n        int count = 0;\\n        map<int,int> mp;\\n       \\n        for(int i = 0; i < size; i++)\\n        {\\n         mp[nums[i]]++;   \\n        }\\n        for(auto x: mp)\\n        {\\n            if(x.second)\\n            {\\n                int freq = x.second;\\n                int curr = x.first;\\n                while(count < k)\\n                {\\n                    if(mp[curr+count] >= freq)\\n                    {\\n                        mp[curr+count]-= freq;\\n                        count++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n                if(count == k)\\n                    count = 0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508681,
                "title": "python-o-n-log-n-sol-by-sorting-and-counter-75-with-explanation",
                "content": "Python O( n log n ) sol. by sorting and counter.\\n\\n---\\n\\nHint:\\n1. Maintain a data structure to keep the occurrence of each number.\\n\\n2. Make the consecutive sets from the smallest element.\\n\\n---\\n\\nAlgorithm:\\n\\nStep_#1:\\nBuild a **dictionary** with **number as key**, and **occurrence as value**.\\n\\nStep_#2:\\nSort the input array, making numbers **sorted with ascending order**.\\n\\nStep_#:\\nMake consecutive sets from the smallest element, **once** we meet a **shortage of number**, directly **reject and return False**.\\n\\nOtherwise, keep making sets till the end, accept and return True.\\n\\n---\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        \\n        if len(nums)%k != 0:\\n            # Quick response:\\n            # Reject because it is impossible to make sets\\n            return False\\n        \\n        if k == 1:\\n            # Quick response:\\n            # Accept with trivial solution by making set with each single element itself\\n            return True\\n        \\n        \\n        # Make number sorted in ascending order\\n        nums.sort()\\n        \\n        # dictionary:\\n        # key   : number\\n        # value : occurrence\\n        num_occ_dict = Counter( nums )\\n        \\n        \\n        # Make consecutive sets of size k from the smallest element\\n        for n in nums:\\n            \\n            occ_for_partition = num_occ_dict[n]\\n            \\n            if occ_for_partition == 0:\\n                continue\\n                \\n                \\n            for i in range(k):\\n                \\n                if num_occ_dict[n+i] < occ_for_partition:\\n                    # Reject:\\n                    # Either number (n+i) doesn\\'t exist, or\\n                    # occurrence of (n+i) is not enough to make consecutive sets with k\\n                    return False\\n                \\n                # after making sets, update occurrence\\n                num_occ_dict[n+i] -= occ_for_partition\\n                \\n        return True\\n```\\n\\n---\\n\\nReference:\\n[1] [Wiki offical docs about specialized dictionary: Counter()](https://docs.python.org/2/library/collections.html#collections.Counter)\\n\\n---\\n\\nRelative leetcode challenge:\\n[Leetcode #846 Hand of Straights](https://leetcode.com/problems/hand-of-straights/)",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        \\n        if len(nums)%k != 0:\\n            # Quick response:\\n            # Reject because it is impossible to make sets\\n            return False\\n        \\n        if k == 1:\\n            # Quick response:\\n            # Accept with trivial solution by making set with each single element itself\\n            return True\\n        \\n        \\n        # Make number sorted in ascending order\\n        nums.sort()\\n        \\n        # dictionary:\\n        # key   : number\\n        # value : occurrence\\n        num_occ_dict = Counter( nums )\\n        \\n        \\n        # Make consecutive sets of size k from the smallest element\\n        for n in nums:\\n            \\n            occ_for_partition = num_occ_dict[n]\\n            \\n            if occ_for_partition == 0:\\n                continue\\n                \\n                \\n            for i in range(k):\\n                \\n                if num_occ_dict[n+i] < occ_for_partition:\\n                    # Reject:\\n                    # Either number (n+i) doesn\\'t exist, or\\n                    # occurrence of (n+i) is not enough to make consecutive sets with k\\n                    return False\\n                \\n                # after making sets, update occurrence\\n                num_occ_dict[n+i] -= occ_for_partition\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452746,
                "title": "python-intuition-explained-brute-force-optimized",
                "content": "How to approach the problem?\\nLet\\'s start from the problem description:\\n\\n***Return true** if it is possible to **divide the array** into sets of **k consecutive** numbers.*\\n\\nAn example:  `[1,2,3,3,4,4,5,6], k = 4`\\n\\nSo what we see here? Let\\'s do a simulation of what we are asked to do: **divide** into **k consecutive** numbers.\\n\\n`[1,2,3,4],[3,4,5,6]` How did we do it? Our brain *did something* and ... **final** result?\\n\\nLet\\'s analyze how we got the result:\\n\\n`[1,2,3,3,4,4,5,6]`\\n\\n**Step 1]**\\nWe start from the smallest available number `1` and try to find the next **k - 1 consecutive** numbers (i.e. 2, 3, 4).\\n\\n```\\n[1,2,3,3,4,4,5,6]\\n x x x   x\\n 1 2 3   4\\n```\\nSuccess! We have found the first **k consecutive** numbers.\\n**Step 2]**\\nWe remove found/used numbers from the available numbers set.\\n```\\n[x,x,x,3,x,4,5,6]\\n```\\n\\nNext we search for the next set of **k consecutive** numbers.\\n\\nRepeat the 2-step process again:\\n\\n**Step 1]**\\nWe start from the smallest available number `3` and try to find the next **k - 1 consecutive** numbers (i.e. 4, 5, 6).\\n\\n```\\n[x,x,x,3,x,4,5,6]\\n       x   x x x\\n       3   4 5 6\\n```\\nSuccess! We have found the second set of **k consecutive** numbers.\\n**Step 2]**\\nWe remove found/used numbers from the available numbers set.\\n```\\n[x,x,x,x,x,x,x,x]\\n```\\n\\nWhy was it so easy to solve it? Because it\\'s easier to see that 1,2,3,4,5 is a consecutive sequence, then 5,1,3,2,4. In order to avoid finding the next smallest or the next consecutive number we can sort the input. This way we replace an extra loop with O(1) `nums[i] + 1 == nums[i + 1]` check.\\n\\nIn the code I use `0` instead of `x`, because `1 <= nums[i] <= 109`\\n\\nLet\\'s code it:\\n```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        \\n        nums.sort()\\n        \\n        sequences = 0\\n        for i in range(N):\\n            if nums[i] != 0:\\n                sequence = nums[i]\\n                nums[i] = 0\\n                found = 1\\n                for j in range(i + 1, N):\\n                    if sequence + 1 == nums[j]:\\n                        nums[j] = 0\\n                        sequence += 1\\n                        found += 1\\n                        if found == k:\\n                            found = 0\\n                            sequences += 1\\n                            break\\n        \\n        return N % k == 0 and sequences == N // k\\n```\\n\\nAs you can see it works the same way I explained in the text above. Except TLE. But .. that\\'s why it\\'s called dumb brute-force approach.\\n\\n**Optimizations:**\\nWe already optimized the approach above with sorting. My excuse here is that I am lazy to write 2 more loops. But sometimes it\\'s good to write them too to see the \"full picture\" of why it\\'s so sloooow.\\n\\nSo what do we see here that \"repeats and consumes time\"?\\n\\nThe first loop is `O(n)`:\\n```\\nfor i in range(N):\\n```\\n\\nThere is another loop `O(n)` inside the first loop.\\n```\\nfor j in range(i + 1, N):\\n```\\n\\nSo it\\'s `O(n^2)`. How can we get rid of the second loop and check in `O(1)` if an element exists in the array or not???\\n\\n---\\nLook up in `O(n)` and we need look up in `O(1)`???\\n---\\n\\nSomething is waving on the horizon!!! Oh, it\\'s **hashmap** data structure!\\n\\nWhy **hashmap** and not **hashset**?\\n**Hashset** looks good, but there\\'s 1 problem: we have the duplicates!!!\\n\\nSo we need to track their removal too, so we need a hashmap of (num, count)\\n\\nSo let\\'s replace our second loop with the hashmap.\\n\\nWe still need to check somehow sequence of **k consecutive** numbers. So we will need another loop to check k elements in the hashmap. Let\\'s code it.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        \\n        nums.sort()\\n        \\n        freq = Counter(nums)\\n        \\n        sequences = 0\\n        for i in range(N):\\n            if freq[nums[i]] != 0:\\n                sequence = nums[i]\\n                freq[sequence] -= 1\\n                found = 1\\n                if k > 1: # when we have sequence of 2+ elements\\n                    for _ in range(k):\\n                        if freq[sequence + 1] > 0:\\n                            freq[sequence + 1] -= 1\\n                            sequence += 1\\n                            found += 1\\n                            if found == k:\\n                                found = 0\\n                                sequences += 1\\n                                break\\n\\t\\t\\t\\telse: # k = 1, yeah, it\\'s a valid sequence\\n\\t\\t\\t\\t\\tif found == k:\\n\\t\\t\\t\\t\\t\\tfound = 0\\n\\t\\t\\t\\t\\t\\tsequences += 1\\n        \\n        return N % k == 0 and sequences == N // k\\n```\\n\\n**AC** But it\\'s still not optimized.\\n\\nWe remove 1 element at a time. What if we have [1,2,1,2,1,2,1,2,1,2,1,2,1,2... 500k elements later... 1,2,1,2,1,2,1,2,1,2,1,2,1,2] ?\\n\\nThis is where we can remove by \"count of dupe elements\".\\n\\nFor example: `1,2,3,1,2,3,1,2,3 k = 3`\\nWill be stored in our map as:\\n```\\n1:3\\n2:3\\n3:3\\n```\\n\\nIf for any reason when we remove the same count from all the k-sequence elements and get a negative value after removal, it means that we cannot form k consecutive sequences (not enought elements). So we can immediately return False.\\n\\nFor example: `1,2,3,1,2,3,1,2 k = 3`\\n```\\n1:3 -> remove 3 => 0\\n2:3 -> remove 3 => 0\\n3:2 -> remove 3 => -1 :/ FAIL\\n```\\n\\nLet\\'s code it:\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        nums.sort()\\n        freq = Counter(nums)\\n        sequences = 0\\n        for i in range(N):\\n            if freq[nums[i]] != 0:\\n                count = freq[nums[i]]\\n                sequence = nums[i]\\n                freq[sequence] -= count\\n                if freq[sequence] < 0:\\n                    return False\\n                found = 1\\n                if k > 1:\\n                    for _ in range(k):\\n                        if freq[sequence + 1] > 0:\\n                            freq[sequence + 1] -= count\\n                            if freq[sequence + 1] < 0:\\n                                return False\\n                            sequence += 1\\n                            found += 1\\n                            if found == k:\\n                                found = 0\\n                                sequences += count\\n                                break\\n                else:\\n                    if found == k:\\n                        found = 0\\n                        sequences += count\\n        \\n        return N % k == 0 and sequences == N // k\\n```\\n\\nThis looks optimized, but too long to write on a whiteboard.\\n\\nLet\\'s \"clean up the code a bit\":\\n\\n1. Replace `for _ in range(k):` with `for num in range(sequence, sequence + k):`\\n2. Remove `if k > 1:` and put `if found == k` right after `for num in range` loop\\n3. Remove `found` as not needed anymore (due to `for num` loop) and early exit when freq[x] < 0\\n4. Remove `freq[sequence] -= count` as it\\'s checked later anyways\\n5. Remove `sequences` as not needed anymore\\n6. ...\\n\\nHere\\'s how it looks after \"remove what is not needed anymore\":\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        nums.sort()\\n        freq = Counter(nums)\\n        # sequences = 0\\n        for i in range(N):\\n            if freq[nums[i]] != 0:\\n                count = freq[nums[i]]\\n                sequence = nums[i]\\n                # freq[sequence] -= count\\n                # if freq[sequence] < 0:\\n                    # return False\\n                # found = 1\\n                # if k > 1:\\n                    # for _ in range(k):\\n                for num in range(sequence, sequence + k):\\n                        # if freq[sequence + 1] > 0:\\n                    # if freq[num] > 0:\\n                            # freq[sequence + 1] -= count\\n                        freq[num] -= count\\n                            # if freq[sequence + 1] < 0:\\n                        if freq[num] < 0:\\n                            return False\\n                            # sequence += 1\\n                            # found += 1\\n                            # if found == k:\\n                                # found = 0\\n                                # sequences += count\\n                                # break\\n                # else:\\n                    # if found == k:\\n                        # found = 0\\n                # sequences += count\\n        \\n        return True # N % k == 0 and sequences == N // k\\n```\\n\\nAnd this is the final version after the cleanup:\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        nums.sort()\\n        freq = Counter(nums)\\n        for num in nums:\\n            if freq[num] != 0:\\n                count = freq[num]\\n                for current_num in range(num, num + k):\\n                    freq[current_num] -= count\\n                    if freq[current_num] < 0:\\n                        return False\\n        \\n        return True\\n```\\n\\nTC: max(O(nlogn) for sorting, O(n\\\\*k) for the algo)\\nSC: O(n)\\n\\nThat\\'s it! If you like the read, **upvote so the other people can see it.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n[1,2,3,3,4,4,5,6]\\n x x x   x\\n 1 2 3   4\\n```\n```\\n[x,x,x,3,x,4,5,6]\\n```\n```\\n[x,x,x,3,x,4,5,6]\\n       x   x x x\\n       3   4 5 6\\n```\n```\\n[x,x,x,x,x,x,x,x]\\n```\n```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        \\n        nums.sort()\\n        \\n        sequences = 0\\n        for i in range(N):\\n            if nums[i] != 0:\\n                sequence = nums[i]\\n                nums[i] = 0\\n                found = 1\\n                for j in range(i + 1, N):\\n                    if sequence + 1 == nums[j]:\\n                        nums[j] = 0\\n                        sequence += 1\\n                        found += 1\\n                        if found == k:\\n                            found = 0\\n                            sequences += 1\\n                            break\\n        \\n        return N % k == 0 and sequences == N // k\\n```\n```\\nfor i in range(N):\\n```\n```\\nfor j in range(i + 1, N):\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        \\n        nums.sort()\\n        \\n        freq = Counter(nums)\\n        \\n        sequences = 0\\n        for i in range(N):\\n            if freq[nums[i]] != 0:\\n                sequence = nums[i]\\n                freq[sequence] -= 1\\n                found = 1\\n                if k > 1: # when we have sequence of 2+ elements\\n                    for _ in range(k):\\n                        if freq[sequence + 1] > 0:\\n                            freq[sequence + 1] -= 1\\n                            sequence += 1\\n                            found += 1\\n                            if found == k:\\n                                found = 0\\n                                sequences += 1\\n                                break\\n\\t\\t\\t\\telse: # k = 1, yeah, it\\'s a valid sequence\\n\\t\\t\\t\\t\\tif found == k:\\n\\t\\t\\t\\t\\t\\tfound = 0\\n\\t\\t\\t\\t\\t\\tsequences += 1\\n        \\n        return N % k == 0 and sequences == N // k\\n```\n```\\n1:3\\n2:3\\n3:3\\n```\n```\\n1:3 -> remove 3 => 0\\n2:3 -> remove 3 => 0\\n3:2 -> remove 3 => -1 :/ FAIL\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        nums.sort()\\n        freq = Counter(nums)\\n        sequences = 0\\n        for i in range(N):\\n            if freq[nums[i]] != 0:\\n                count = freq[nums[i]]\\n                sequence = nums[i]\\n                freq[sequence] -= count\\n                if freq[sequence] < 0:\\n                    return False\\n                found = 1\\n                if k > 1:\\n                    for _ in range(k):\\n                        if freq[sequence + 1] > 0:\\n                            freq[sequence + 1] -= count\\n                            if freq[sequence + 1] < 0:\\n                                return False\\n                            sequence += 1\\n                            found += 1\\n                            if found == k:\\n                                found = 0\\n                                sequences += count\\n                                break\\n                else:\\n                    if found == k:\\n                        found = 0\\n                        sequences += count\\n        \\n        return N % k == 0 and sequences == N // k\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        nums.sort()\\n        freq = Counter(nums)\\n        # sequences = 0\\n        for i in range(N):\\n            if freq[nums[i]] != 0:\\n                count = freq[nums[i]]\\n                sequence = nums[i]\\n                # freq[sequence] -= count\\n                # if freq[sequence] < 0:\\n                    # return False\\n                # found = 1\\n                # if k > 1:\\n                    # for _ in range(k):\\n                for num in range(sequence, sequence + k):\\n                        # if freq[sequence + 1] > 0:\\n                    # if freq[num] > 0:\\n                            # freq[sequence + 1] -= count\\n                        freq[num] -= count\\n                            # if freq[sequence + 1] < 0:\\n                        if freq[num] < 0:\\n                            return False\\n                            # sequence += 1\\n                            # found += 1\\n                            # if found == k:\\n                                # found = 0\\n                                # sequences += count\\n                                # break\\n                # else:\\n                    # if found == k:\\n                        # found = 0\\n                # sequences += count\\n        \\n        return True # N % k == 0 and sequences == N // k\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        N = len(nums)\\n        nums.sort()\\n        freq = Counter(nums)\\n        for num in nums:\\n            if freq[num] != 0:\\n                count = freq[num]\\n                for current_num in range(num, num + k):\\n                    freq[current_num] -= count\\n                    if freq[current_num] < 0:\\n                        return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320829,
                "title": "java-sorting-hashmap-greedy-38ms-beats-95-t-c-o-nlogn-s-c-o-n",
                "content": "\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tif (len % k != 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\tArrays.sort(nums);\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\twhile (map.containsKey(nums[i])) {\\n\\n\\t\\t\\t\\tint min = nums[i];\\n\\t\\t\\t\\tfor (int j = 0; j < k - 1; j++) {\\n\\t\\t\\t\\t\\tif (!map.containsKey(min + 1)){\\n                        System.out.println(min);\\n\\t\\t\\t\\t\\t\\treturn false;\\n                    }\\n\\t\\t\\t\\t\\tint freq = map.get(min);\\n\\t\\t\\t\\t\\tmap.put(min, freq - 1);\\n\\t\\t\\t\\t\\tif (freq - 1 == 0)\\n\\t\\t\\t\\t\\t\\tmap.remove(min);\\n\\t\\t\\t\\t\\tmin++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint freq = map.get(min);\\n\\t\\t\\t\\tmap.put(min, freq - 1);\\n\\t\\t\\t\\tif (freq - 1 == 0)\\n\\t\\t\\t\\t\\tmap.remove(min);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tif (len % k != 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\tArrays.sort(nums);\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\twhile (map.containsKey(nums[i])) {\\n\\n\\t\\t\\t\\tint min = nums[i];\\n\\t\\t\\t\\tfor (int j = 0; j < k - 1; j++) {\\n\\t\\t\\t\\t\\tif (!map.containsKey(min + 1)){\\n                        System.out.println(min);\\n\\t\\t\\t\\t\\t\\treturn false;\\n                    }\\n\\t\\t\\t\\t\\tint freq = map.get(min);\\n\\t\\t\\t\\t\\tmap.put(min, freq - 1);\\n\\t\\t\\t\\t\\tif (freq - 1 == 0)\\n\\t\\t\\t\\t\\t\\tmap.remove(min);\\n\\t\\t\\t\\t\\tmin++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint freq = map.get(min);\\n\\t\\t\\t\\tmap.put(min, freq - 1);\\n\\t\\t\\t\\tif (freq - 1 == 0)\\n\\t\\t\\t\\t\\tmap.remove(min);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1235836,
                "title": "detailed-explanation-commented-clean-code-greedy-take-smallest-and-try-to-make-a-list-with-it",
                "content": "Intuition\\nI will first collect all the unique values `vals`\\nand a frequency: how many times they occur `fre`\\nNow that i have these two, let me keep trying to make a list of` k `consecutive elements starting from the smallest value in vals \\uD83E\\uDD14\\n\\nImplementation\\n(comments in code->if intermeddiate skip this)\\n\\nI put all the unique values in a heap\\n\\nnow for making a list of` k` elements, I just pop the min `start`\\n\\ncheck if all the values in `[start, start+1,start+2....start+k)` exist in `nums`\\n\\nany point i find a element that doesn\\'t exist i return `false`, since we cannot make a consecutive list ;)\\n\\n-at the end since we have used some elements and REDUCED their remaining frequency => we will delete those elements from the heap which have a `fre == 0` :D\\n\\nTime Complexity\\n\\\\mathcal{O}(n log n)O(nlogn) since each element is popped from the stack atmost once : why not O(K * N Log N) ? Because amortized, there are only N//K values of start so the for loop will run for a total of N//k * k = N ;)\\n\\nSpace Complexity\\n\\\\mathcal{O}(n)O(n) for the fre Counter and the vals heapq\\n```py\\nclass Solution:\\n    def solve(self, nums, k):\\n        fre = Counter(nums)\\n        # greedy solution, take the smallest then try\\n        vals = list(fre.keys())\\n        heapq.heapify(vals)\\n\\n        # every iteration i make a new list\\n        while len(vals):\\n            # let us start with the minimum element\\n            start = vals[0]\\n            # now create a list starting with \\'start\\'\\n            for i in range(k):\\n                if fre[start + i]:\\n                    fre[start + i] -= 1\\n                else:\\n                    return False\\n            # pop any elements which are not remaining\\n            while len(vals) and fre[vals[0]] == 0:\\n                heapq.heappop(vals)\\n\\n        return True\\n```\\n\\nif you know C++ then you can merge the priority queue and counter into a map ;)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k, map<int,int> vals = {}, int start = 0) {\\n        for (int&x:nums) vals[x]++;\\n        while (vals.size() and (start = vals.begin()->first)) \\n            for (int i = start ; i < start+k; i++) \\n                if (not vals[i]) return false;\\n                else if(not --vals[i]) vals.erase(i);\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```py\\nclass Solution:\\n    def solve(self, nums, k):\\n        fre = Counter(nums)\\n        # greedy solution, take the smallest then try\\n        vals = list(fre.keys())\\n        heapq.heapify(vals)\\n\\n        # every iteration i make a new list\\n        while len(vals):\\n            # let us start with the minimum element\\n            start = vals[0]\\n            # now create a list starting with \\'start\\'\\n            for i in range(k):\\n                if fre[start + i]:\\n                    fre[start + i] -= 1\\n                else:\\n                    return False\\n            # pop any elements which are not remaining\\n            while len(vals) and fre[vals[0]] == 0:\\n                heapq.heappop(vals)\\n\\n        return True\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k, map<int,int> vals = {}, int start = 0) {\\n        for (int&x:nums) vals[x]++;\\n        while (vals.size() and (start = vals.begin()->first)) \\n            for (int i = start ; i < start+k; i++) \\n                if (not vals[i]) return false;\\n                else if(not --vals[i]) vals.erase(i);\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177102,
                "title": "8-liner-c-nothing-fancy",
                "content": "```\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        map<int, int> mp;\\n        for(auto i : nums) mp[i]++;\\n        \\n        for(auto i : mp) \\n            if(i.second) \\n                for(int j = i.first ; j < k + i.first ; j++) {\\n                    if(mp[j] < i.second) return false;\\n                    mp[j] -= i.second;\\n                }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        map<int, int> mp;\\n        for(auto i : nums) mp[i]++;\\n        \\n        for(auto i : mp) \\n            if(i.second) \\n                for(int j = i.first ; j < k + i.first ; j++) {\\n                    if(mp[j] < i.second) return false;\\n                    mp[j] -= i.second;\\n                }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1080969,
                "title": "golang-solution-with-explanation-and-images",
                "content": "**Code On the Bottom, and If This Helps Please Up Vote**\\n**Divide array in sets of k consecutive numbers**\\n\\n\\tbetter space than 96.67%, O(1) without including input array\\n\\n\\nThe idea of this solution is to loop over the `nums` array until all the values are `-1`. The reason they all will become negative one is, whenever a item is used the value will become `-1` so the code knows to not use that number again.\\n\\n\\n**If you didn\\'t understand the explaination this can be shown using the code on the bottom, an example and some pictures:**\\n*By the way sorry if my handwriting is messy*\\n```\\ninput = [1, 2, 4, 3, 4, 5, 6, 3], k = 4\\nexpected output = true\\n```\\n\\nThis is for getting the first consecutive sequence:\\n![image](https://assets.leetcode.com/users/images/cfc0f0b7-8ffc-4ab0-8b83-143691f75526_1614179878.874795.png)\\n\\nAnd the second consecutive sequence:\\n![image](https://assets.leetcode.com/users/images/eb4d3251-f7a8-4fe4-a3d2-ee89a0cc4e42_1614180843.1899865.png)\\n\\nSince we found two consecutive sequences we can return `true`.\\n\\n* **\\n\\n```\\nfunc isPossibleDivide(nums []int, k int) bool {\\n\\tif len(nums)%k != 0 {\\n\\t\\treturn false\\n\\t}\\n\\tsort.Ints(nums)\\n\\tonlyNegetiveOnes := false\\n\\n\\tfor !onlyNegetiveOnes {\\n\\t\\tonlyNegetiveOnes = true\\n\\t\\tn := -1\\n\\t\\tcounter := 0\\n\\t\\tfor i := 0; i < len(nums); i++ {\\n\\t\\t\\tif nums[i] != -1 {\\n\\t\\t\\t\\tonlyNegetiveOnes = false\\n\\t\\t\\t\\tif (n == -1) || (counter != k && nums[i] == n+1) {\\n\\t\\t\\t\\t\\tn = nums[i]\\n\\t\\t\\t\\t\\tnums[i] = -1\\n\\t\\t\\t\\t\\tcounter++\\n\\t\\t\\t\\t} else if counter == k {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif counter != k && counter != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ninput = [1, 2, 4, 3, 4, 5, 6, 3], k = 4\\nexpected output = true\\n```\n```\\nfunc isPossibleDivide(nums []int, k int) bool {\\n\\tif len(nums)%k != 0 {\\n\\t\\treturn false\\n\\t}\\n\\tsort.Ints(nums)\\n\\tonlyNegetiveOnes := false\\n\\n\\tfor !onlyNegetiveOnes {\\n\\t\\tonlyNegetiveOnes = true\\n\\t\\tn := -1\\n\\t\\tcounter := 0\\n\\t\\tfor i := 0; i < len(nums); i++ {\\n\\t\\t\\tif nums[i] != -1 {\\n\\t\\t\\t\\tonlyNegetiveOnes = false\\n\\t\\t\\t\\tif (n == -1) || (counter != k && nums[i] == n+1) {\\n\\t\\t\\t\\t\\tn = nums[i]\\n\\t\\t\\t\\t\\tnums[i] = -1\\n\\t\\t\\t\\t\\tcounter++\\n\\t\\t\\t\\t} else if counter == k {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif counter != k && counter != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690898,
                "title": "java-simple-o-n-k-loop",
                "content": "1, find all number\\'s count, min, max;\\n2, loop from min, remove every k set from the pool, if we find any lack or extra, return false;\\nSame as: https://leetcode.com/problems/hand-of-straights/discuss/690900/Java-simple-O(n-*-W)-loop\\n```\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int m = nums.length, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        if (m % k != 0) return false;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            min = Math.min(min, n);\\n            max = Math.max(max, n);\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        for (int i = min; i <= max; i++) {\\n            if (map.getOrDefault(i, 0) < 0) return false;  // lacks\\n            if (map.getOrDefault(i, 0) == 0) continue;\\n            if (max - i + 1 < k) return false;  // extras, won\\'t make k subset;\\n            for (int j = i + k - 1; j >= i; j--) {\\n                map.put(j, map.getOrDefault(j, 0) - map.get(i));\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int m = nums.length, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        if (m % k != 0) return false;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            min = Math.min(min, n);\\n            max = Math.max(max, n);\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        for (int i = min; i <= max; i++) {\\n            if (map.getOrDefault(i, 0) < 0) return false;  // lacks\\n            if (map.getOrDefault(i, 0) == 0) continue;\\n            if (max - i + 1 < k) return false;  // extras, won\\'t make k subset;\\n            for (int j = i + k - 1; j >= i; j--) {\\n                map.put(j, map.getOrDefault(j, 0) - map.get(i));\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458270,
                "title": "java-treemap-solution-faster-than-100",
                "content": "The idea is simple. First, we put all the numbers in TreeMap. We get the first key (Let\\'s say c)  of the map. Then we traverse from the first key(c) to c + k - 1 and count minus 1, respectively; if any one of numbers from c to c + k - 1 is not in the map, we return false. Then we traverse from the (first key) to the (first key + k - 1) again and again until the map is empty.\\n```\\n    public boolean isPossibleDivide(int[] nums, int k) { \\n        int len = nums.length;\\n        if (len % k != 0) return false;\\n     \\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for(int i = 0; i < nums.length; i++) {\\n        \\tm.put(nums[i], m.getOrDefault(nums[i], 0) + 1);\\n        }\\n    \\n          while(m.size() > 0) {\\t        \\n\\t        int c = m.firstKey();\\t        \\n\\t\\t\\tfor(int i = c; i < c + k; i++) {\\n\\t        \\tif(!m.containsKey(i)) return false;\\n\\t        \\telse{\\n\\t        \\t\\tm.put(i, m.get(i) - 1);\\n        \\t\\t\\tif(m.get(i) ==0)\\n        \\t\\t\\t\\tm.remove(i);\\n\\t        \\t}\\n\\t        }\\n        }\\n        return true;        \\n    }",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "The idea is simple. First, we put all the numbers in TreeMap. We get the first key (Let\\'s say c)  of the map. Then we traverse from the first key(c) to c + k - 1 and count minus 1, respectively; if any one of numbers from c to c + k - 1 is not in the map, we return false. Then we traverse from the (first key) to the (first key + k - 1) again and again until the map is empty.\\n```\\n    public boolean isPossibleDivide(int[] nums, int k) { \\n        int len = nums.length;\\n        if (len % k != 0) return false;\\n     \\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for(int i = 0; i < nums.length; i++) {\\n        \\tm.put(nums[i], m.getOrDefault(nums[i], 0) + 1);\\n        }\\n    \\n          while(m.size() > 0) {\\t        \\n\\t        int c = m.firstKey();\\t        \\n\\t\\t\\tfor(int i = c; i < c + k; i++) {\\n\\t        \\tif(!m.containsKey(i)) return false;\\n\\t        \\telse{\\n\\t        \\t\\tm.put(i, m.get(i) - 1);\\n        \\t\\t\\tif(m.get(i) ==0)\\n        \\t\\t\\t\\tm.remove(i);\\n\\t        \\t}\\n\\t        }\\n        }\\n        return true;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 457589,
                "title": "c-17-solution",
                "content": "```cpp\\nbool isPossibleDivide(vector<int>& nums, int k) {\\n    if (nums.size() % k != 0) return false;\\n    multiset<int> s(nums.cbegin(), nums.cend());\\n    while(not s.empty()) {\\n        int a = *s.begin();\\n        for (int i = a; i < a + k; ++i) {\\n            if (auto it = s.find(i); it == s.end())\\n                return false;\\n            else s.erase(it);\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool isPossibleDivide(vector<int>& nums, int k) {\\n    if (nums.size() % k != 0) return false;\\n    multiset<int> s(nums.cbegin(), nums.cend());\\n    while(not s.empty()) {\\n        int a = *s.begin();\\n        for (int i = a; i < a + k; ++i) {\\n            if (auto it = s.find(i); it == s.end())\\n                return false;\\n            else s.erase(it);\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3309200,
                "title": "c-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo efficiently store and retrieve sorted numbers along with their frequencies, we can use a data structure like a TreeMap in Java or a std::map in C++. We can insert each number into the map and increment its frequency if it\\'s already present.\\n\\nTo check if there are k consecutive numbers starting from a given number, we can simply check if the map contains all the numbers in the range [num, num+k-1] and their frequencies are all greater than zero. If so, we can decrement their frequencies in the map to mark them as visited and continue to the loop.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor inserting n elements inside map, n*logn\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        map<int,int> freq;\\n        for(int num:nums){\\n            freq[num]++;\\n        }\\n\\n        while(!freq.empty()){\\n            int first = freq.begin()->first;\\n            for(int i=first; i<first+k; i++){\\n                if(!freq.count(i)){\\n                    return false;\\n                }\\n                freq[i]--;\\n                if(freq[i]==0){\\n                    freq.erase(i);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        map<int,int> freq;\\n        for(int num:nums){\\n            freq[num]++;\\n        }\\n\\n        while(!freq.empty()){\\n            int first = freq.begin()->first;\\n            for(int i=first; i<first+k; i++){\\n                if(!freq.count(i)){\\n                    return false;\\n                }\\n                freq[i]--;\\n                if(freq[i]==0){\\n                    freq.erase(i);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180204,
                "title": "super-easy-solution-faster-than-100-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        if(k==1) return true;\\n\\n        if(nums.size()%k!=0){\\n            return false;\\n        }\\n        else{\\n            int numgrp = nums.size()/k;\\n            map<int,int> m;\\n            for(auto it:nums){\\n                m[it]++;\\n            }\\n            for(auto it2:m){\\n                if(it2.second>numgrp) return false;\\n            }\\n\\n            while(m.size()!=0){\\n                int ptr = m.begin()->first;\\n                for(int i=0;i<k;i++){\\n                    if(m[ptr+i]==0) return false;\\n                    m[ptr+i]--;\\n                    if(m[ptr+i]==0) m.erase(ptr+i);\\n                }\\n            }\\n            \\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        if(k==1) return true;\\n\\n        if(nums.size()%k!=0){\\n            return false;\\n        }\\n        else{\\n            int numgrp = nums.size()/k;\\n            map<int,int> m;\\n            for(auto it:nums){\\n                m[it]++;\\n            }\\n            for(auto it2:m){\\n                if(it2.second>numgrp) return false;\\n            }\\n\\n            while(m.size()!=0){\\n                int ptr = m.begin()->first;\\n                for(int i=0;i<k;i++){\\n                    if(m[ptr+i]==0) return false;\\n                    m[ptr+i]--;\\n                    if(m[ptr+i]==0) m.erase(ptr+i);\\n                }\\n            }\\n            \\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850011,
                "title": "using-map-greedy-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool isPossibleDivide(vector<int> &nums, int k)\\n    {\\n        if (nums.size() % k != 0)\\n            return false;\\n        map<int, int> mp;\\n        int freq;\\n        for (int &i : nums)\\n            mp[i]++;\\n        for (auto &i: mp)\\n            if (i.second)\\n            {\\n                freq = i.second;\\n                for (int j = 0; j < k; j++)\\n                    if (mp[i.first + j] < freq)\\n                        return false;\\n                    else\\n                        mp[i.first + j] -= freq;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Tree",
                    "Counting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool isPossibleDivide(vector<int> &nums, int k)\\n    {\\n        if (nums.size() % k != 0)\\n            return false;\\n        map<int, int> mp;\\n        int freq;\\n        for (int &i : nums)\\n            mp[i]++;\\n        for (auto &i: mp)\\n            if (i.second)\\n            {\\n                freq = i.second;\\n                for (int j = 0; j < k; j++)\\n                    if (mp[i.first + j] < freq)\\n                        return false;\\n                    else\\n                        mp[i.first + j] -= freq;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158829,
                "title": "using-counter-speed-88",
                "content": "Runtime: 400 ms, faster than 88.09% of Python3 online submissions for Divide Array in Sets of K Consecutive Numbers.\\nMemory Usage: 28.7 MB, less than 82.31% of Python3 online submissions for Divide Array in Sets of K Consecutive Numbers.\\n```\\nclass Solution:\\n    def isPossibleDivide(self, nums, k: int) -> bool:\\n        cnt = Counter(nums)\\n        while cnt:\\n            start = min(cnt.keys())\\n            for i in range(start, start + k):\\n                if i in cnt:\\n                    cnt[i] -= 1\\n                    if cnt[i] == 0:\\n                        cnt.pop(i)\\n                else:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums, k: int) -> bool:\\n        cnt = Counter(nums)\\n        while cnt:\\n            start = min(cnt.keys())\\n            for i in range(start, start + k):\\n                if i in cnt:\\n                    cnt[i] -= 1\\n                    if cnt[i] == 0:\\n                        cnt.pop(i)\\n                else:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872280,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n\\t\\t\\tcnt = collections.Counter(nums)\\n\\t\\t\\twhile cnt:\\n\\t\\t\\t\\tm = min(cnt)\\n\\t\\t\\t\\tfor i in range(m, m + k):\\n\\t\\t\\t\\t\\tif i not in cnt:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telif cnt[i] == 1:\\n\\t\\t\\t\\t\\t\\tdel cnt[i]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcnt[i] -= 1\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n\\t\\t\\tcnt = collections.Counter(nums)\\n\\t\\t\\twhile cnt:\\n\\t\\t\\t\\tm = min(cnt)\\n\\t\\t\\t\\tfor i in range(m, m + k):\\n\\t\\t\\t\\t\\tif i not in cnt:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telif cnt[i] == 1:\\n\\t\\t\\t\\t\\t\\tdel cnt[i]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcnt[i] -= 1\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 632839,
                "title": "java-3ms-100-easy-to-understand-solution",
                "content": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums.length % k != 0) {\\n          return false;\\n        }\\n\\n        int[] map = new int[k];\\n        Set<Integer> set = new HashSet();\\n        for (int i = 0; i < nums.length; i++) {\\n          set.add(nums[i]);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n          int key = nums[i] % k;\\n          if (set.contains(nums[i] - 1) || set.contains(nums[i] + 1)) {\\n            map[key] += 1;\\n          } else {\\n            return false;\\n          }\\n        }\\n\\n        int val = map[0];\\n        for (int i = 1; i < map.length; i++) {\\n          if (val != map[i]) {\\n            return false;\\n          }\\n        }\\n        return true;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums.length % k != 0) {\\n          return false;\\n        }\\n\\n        int[] map = new int[k];\\n        Set<Integer> set = new HashSet();\\n        for (int i = 0; i < nums.length; i++) {\\n          set.add(nums[i]);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n          int key = nums[i] % k;\\n          if (set.contains(nums[i] - 1) || set.contains(nums[i] + 1)) {\\n            map[key] += 1;\\n          } else {\\n            return false;\\n          }\\n        }\\n\\n        int val = map[0];\\n        for (int i = 1; i < map.length; i++) {\\n          if (val != map[i]) {\\n            return false;\\n          }\\n        }\\n        return true;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 605897,
                "title": "java-true-o-n-little-explanation",
                "content": "Solution similar to 846. Hand of Straights, keeping track of new start of hand. Seems like multiple while loops, but the element is accesed only twice in the while loop.\\n\\n```\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        HashMap<Integer,Integer> remove=new HashMap<>();\\n        for(int n:nums) map.put(n,map.getOrDefault(n,0)+1);\\n        \\n        for(int n:nums){\\n\\t\\t   //if the number is already used before\\n            if(!map.containsKey(n)) continue;\\n\\t\\t   //finding the end node\\n            while(map.containsKey(n)) n++;\\n            n--;\\n\\t\\t\\t//current is the count of hands\\n            int current=map.get(n);\\n\\t\\t\\t//since the length of hand is k, after removing need to stop remove, adding negative value to stop remove after reaching here\\n            remove.put(n-k,-current);\\n            while(map.containsKey(n)){\\n                current=current+remove.getOrDefault(n,0);\\n                int available=map.get(n);\\n\\t\\t\\t\\t//number of elements avaible of this number must be more or equal to the hand size\\n                if(available<current) return false;\\n\\t\\t\\t\\t//start of new hand\\n                int start=available-current;\\n                if(start!=0){\\n                    remove.put(n-k,-start);\\n                    current=current+start;\\n                }\\n                map.put(n,map.get(n)-current);\\n                if(map.get(n)==0) map.remove(n);\\n                n--;\\n            }\\n            if(current!=-remove.getOrDefault(n,0)) return false;\\n        }\\n\\t\\t//after removing all nodes in the map needs to be empty\\n        return map.size()==0 ;\\n    }\\n\\t```\\n\\t\\n\\tPosting first solution, I am sure not explained well. comment if any doubt.",
                "solutionTags": [],
                "code": "```\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        HashMap<Integer,Integer> remove=new HashMap<>();\\n        for(int n:nums) map.put(n,map.getOrDefault(n,0)+1);\\n        \\n        for(int n:nums){\\n\\t\\t   //if the number is already used before\\n            if(!map.containsKey(n)) continue;\\n\\t\\t   //finding the end node\\n            while(map.containsKey(n)) n++;\\n            n--;\\n\\t\\t\\t//current is the count of hands\\n            int current=map.get(n);\\n\\t\\t\\t//since the length of hand is k, after removing need to stop remove, adding negative value to stop remove after reaching here\\n            remove.put(n-k,-current);\\n            while(map.containsKey(n)){\\n                current=current+remove.getOrDefault(n,0);\\n                int available=map.get(n);\\n\\t\\t\\t\\t//number of elements avaible of this number must be more or equal to the hand size\\n                if(available<current) return false;\\n\\t\\t\\t\\t//start of new hand\\n                int start=available-current;\\n                if(start!=0){\\n                    remove.put(n-k,-start);\\n                    current=current+start;\\n                }\\n                map.put(n,map.get(n)-current);\\n                if(map.get(n)==0) map.remove(n);\\n                n--;\\n            }\\n            if(current!=-remove.getOrDefault(n,0)) return false;\\n        }\\n\\t\\t//after removing all nodes in the map needs to be empty\\n        return map.size()==0 ;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 527946,
                "title": "java-greedy-single-hashmap",
                "content": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> freMap = new HashMap<>();\\n\\n        Arrays.sort(nums);\\n\\n\\n        for(int num : nums){\\n            freMap.put(num, freMap.getOrDefault(num, 0)+1);\\n            }\\n\\n\\n        for(int num : nums) {\\n\\n            if (freMap.get(num) == 0) continue;\\n\\n            for (int j = 0; j < k; j++) {\\n                if (freMap.getOrDefault(num + j, 0) <= 0) return false;\\n                freMap.put(num + j, freMap.get(num + j) - 1);\\n            }\\n\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n\\n        HashMap<Integer, Integer> freMap = new HashMap<>();\\n\\n        Arrays.sort(nums);\\n\\n\\n        for(int num : nums){\\n            freMap.put(num, freMap.getOrDefault(num, 0)+1);\\n            }\\n\\n\\n        for(int num : nums) {\\n\\n            if (freMap.get(num) == 0) continue;\\n\\n            for (int j = 0; j < k; j++) {\\n                if (freMap.getOrDefault(num + j, 0) <= 0) return false;\\n                freMap.put(num + j, freMap.get(num + j) - 1);\\n            }\\n\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457632,
                "title": "simple-java-solution-using-treemap",
                "content": "The idea is simple. I store the count of the numbers in a treeMap. I choose the lastKey as the end of a subarray of size K and start checking for the existence of the next consecutive smaller number. if it is present in the map then we are good, but if it is not we need to understand that there cannot be consecutive numbers in that block of size k.\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] arr, int k) {\\n        int n = arr.length;\\n        if(n == 0 && k == 0)\\n            return true;\\n        if(n%k != 0)\\n            return false;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < n; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n        }\\n        while(!map.isEmpty()) {\\n            int lastKey = map.lastKey();\\n            int count = 0;\\n            while (count < k) {\\n                if(!map.containsKey(lastKey))\\n                    return false;\\n                map.put(lastKey, map.getOrDefault(lastKey, 0) - 1);\\n                if(map.get(lastKey) <= 0)\\n                    map.remove(lastKey);\\n                count++;\\n                lastKey--;\\n            }\\n        }\\n        return map.isEmpty();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPossibleDivide(int[] arr, int k) {\\n        int n = arr.length;\\n        if(n == 0 && k == 0)\\n            return true;\\n        if(n%k != 0)\\n            return false;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < n; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3297932,
                "title": "easy-c-code-using-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> mpp;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()%k!=0){\\n            return false;\\n        }\\n\\n\\n        for(int i=0; i<nums.size(); i++){\\n            mpp[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(mpp[nums[i]]<=0){\\n                continue;\\n            }\\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\\n                if(mpp[j]<=0){\\n                    return false;\\n                }\\n                \\n                    mpp[j]--;\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> mpp;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()%k!=0){\\n            return false;\\n        }\\n\\n\\n        for(int i=0; i<nums.size(); i++){\\n            mpp[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(mpp[nums[i]]<=0){\\n                continue;\\n            }\\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\\n                if(mpp[j]<=0){\\n                    return false;\\n                }\\n                \\n                    mpp[j]--;\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022932,
                "title": "using-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int>freq;\\n        sort(nums.begin(),nums.end());\\n        for(auto i:nums)\\n            freq[i]++;\\n        for(auto i:nums)\\n        {\\n            if(freq[i]==0)\\n                continue;\\n            if(freq[i]>0)\\n            {\\n                int n=k;/*making the sequence of size k each time if it\\'s not possible then return false*/\\n                while(n>0)\\n                {\\n                    if(!freq[i+n-1])\\n                        return false;\\n                    freq[i+n-1]--;\\n                    n--;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int>freq;\\n        sort(nums.begin(),nums.end());\\n        for(auto i:nums)\\n            freq[i]++;\\n        for(auto i:nums)\\n        {\\n            if(freq[i]==0)\\n                continue;\\n            if(freq[i]>0)\\n            {\\n                int n=k;/*making the sequence of size k each time if it\\'s not possible then return false*/\\n                while(n>0)\\n                {\\n                    if(!freq[i+n-1])\\n                        return false;\\n                    freq[i+n-1]--;\\n                    n--;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722400,
                "title": "easy-to-understand-java-code",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/greedy/HandOfStraights.java",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1990598,
                "title": "python-dictionary-and-heap-solution-490ms",
                "content": "```\\nimport heapq;\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        \\n        #Make sure we have exactly enough values for sets of k consecutive numbers\\n        LENGTH = len( nums );\\n        EXPECTED = LENGTH // k;\\n        if EXPECTED * k != LENGTH:\\n            return False;\\n        \\n        #Count each digit\\n        counter = Counter( nums );\\n        \\n        #Find all the distinct digits that we counted\\n        distinct_keys = [];\\n        for key in counter:\\n            distinct_keys.append( key );\\n            \\n        #And put them into a min heap\\n        heapq.heapify( distinct_keys );\\n        \\n        #While we have values left in the min heap\\n        while len( distinct_keys ) > 0:\\n            \\n            #Take out the next min number\\n            min_num = heapq.heappop( distinct_keys );\\n            \\n            #This is important, as if we always take out the smallest number\\n            #We only have to search for numbers of higher value\\n\\n            #See how many of them there are\\n            min_count = counter[ min_num ];\\n            \\n            #If there are less than zero, we return False\\n            #As this would mean we are missing that value for a consecutive set\\n            if min_count < 0:\\n                return False;\\n            \\n            #If the count of the current min is greater than zero\\n            elif min_count > 0:\\n                \\n                #For each number that could come after it\\n                for i in range( 1, k ):\\n                    next_number = min_num + i;\\n                    \\n                    #See if the number is in the counter\\n                    valid_number = next_number in counter;\\n                    #If it isn\\'t, a consequtive set cannot be made \\n                    if not valid_number:\\n                        return False;\\n                    \\n                    #If it is in the dictionary counter, subtract the min_count\\n                    counter[ next_number ] -= min_count;\\n                    \\n                    #Note that, since we look at the minimum each time\\n                    #In order to satisfy the rule, there must be at least\\n                    #min_count in each subsequent valid_number\\n                    \\n                    #This allows us to process consecutive sets in batches\\n        \\n        #If we make it through each distinct key\\n        #We can return True\\n        return True;\\n\\n\\n#         Greedy Algorithm TLE\\n#         nums = sorted( nums );\\n#         LENGTH = len( nums );\\n#         EXPECTED = LENGTH // k;\\n        \\n#         if ( LENGTH % k ) != 0:\\n#             return False;\\n        \\n#         counter = [ 0 ];\\n        \\n#         while True:\\n#             if not self.find_k_group( nums, k, LENGTH, counter ):\\n#                 break;\\n#         return counter[ 0 ] == EXPECTED;\\n    \\n#     def find_k_group( self, nums, k, LENGTH, counter, sign = 1 ):\\n#         pointer = 0;\\n        \\n#         while nums[ pointer ] is None:\\n#             pointer += 1;\\n#             if pointer == LENGTH:\\n#                 return False;\\n            \\n#         prev = nums[ pointer ];\\n#         group = [ pointer ];\\n#         pointer += 1;\\n        \\n        \\n#         while pointer < LENGTH:\\n#             current = nums[ pointer ];\\n#             if current is not None and ( current - prev ) == ( 1 * sign ):\\n#                 group.append( pointer );\\n#                 if len( group ) == k:\\n#                     self.set_group_null( nums, group );    \\n#                     counter[ 0 ] += 1;\\n#                     return True;\\n                \\n#                 prev = current;\\n#             pointer += 1;\\n\\n            \\n#         return False;\\n    \\n#     def set_group_null( self, nums, group ):\\n#         for index in group:\\n#             nums[ index ] = None;\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq;\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        \\n        #Make sure we have exactly enough values for sets of k consecutive numbers\\n        LENGTH = len( nums );\\n        EXPECTED = LENGTH // k;\\n        if EXPECTED * k != LENGTH:\\n            return False;\\n        \\n        #Count each digit\\n        counter = Counter( nums );\\n        \\n        #Find all the distinct digits that we counted\\n        distinct_keys = [];\\n        for key in counter:\\n            distinct_keys.append( key );\\n            \\n        #And put them into a min heap\\n        heapq.heapify( distinct_keys );\\n        \\n        #While we have values left in the min heap\\n        while len( distinct_keys ) > 0:\\n            \\n            #Take out the next min number\\n            min_num = heapq.heappop( distinct_keys );\\n            \\n            #This is important, as if we always take out the smallest number\\n            #We only have to search for numbers of higher value\\n\\n            #See how many of them there are\\n            min_count = counter[ min_num ];\\n            \\n            #If there are less than zero, we return False\\n            #As this would mean we are missing that value for a consecutive set\\n            if min_count < 0:\\n                return False;\\n            \\n            #If the count of the current min is greater than zero\\n            elif min_count > 0:\\n                \\n                #For each number that could come after it\\n                for i in range( 1, k ):\\n                    next_number = min_num + i;\\n                    \\n                    #See if the number is in the counter\\n                    valid_number = next_number in counter;\\n                    #If it isn\\'t, a consequtive set cannot be made \\n                    if not valid_number:\\n                        return False;\\n                    \\n                    #If it is in the dictionary counter, subtract the min_count\\n                    counter[ next_number ] -= min_count;\\n                    \\n                    #Note that, since we look at the minimum each time\\n                    #In order to satisfy the rule, there must be at least\\n                    #min_count in each subsequent valid_number\\n                    \\n                    #This allows us to process consecutive sets in batches\\n        \\n        #If we make it through each distinct key\\n        #We can return True\\n        return True;\\n\\n\\n#         Greedy Algorithm TLE\\n#         nums = sorted( nums );\\n#         LENGTH = len( nums );\\n#         EXPECTED = LENGTH // k;\\n        \\n#         if ( LENGTH % k ) != 0:\\n#             return False;\\n        \\n#         counter = [ 0 ];\\n        \\n#         while True:\\n#             if not self.find_k_group( nums, k, LENGTH, counter ):\\n#                 break;\\n#         return counter[ 0 ] == EXPECTED;\\n    \\n#     def find_k_group( self, nums, k, LENGTH, counter, sign = 1 ):\\n#         pointer = 0;\\n        \\n#         while nums[ pointer ] is None:\\n#             pointer += 1;\\n#             if pointer == LENGTH:\\n#                 return False;\\n            \\n#         prev = nums[ pointer ];\\n#         group = [ pointer ];\\n#         pointer += 1;\\n        \\n        \\n#         while pointer < LENGTH:\\n#             current = nums[ pointer ];\\n#             if current is not None and ( current - prev ) == ( 1 * sign ):\\n#                 group.append( pointer );\\n#                 if len( group ) == k:\\n#                     self.set_group_null( nums, group );    \\n#                     counter[ 0 ] += 1;\\n#                     return True;\\n                \\n#                 prev = current;\\n#             pointer += 1;\\n\\n            \\n#         return False;\\n    \\n#     def set_group_null( self, nums, group ):\\n#         for index in group:\\n#             nums[ index ] = None;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846892,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        \\n        if len(nums) % k : return False  \\n        counter = Counter(nums) \\n        tmp = [] \\n        while len(tmp)<k and counter:\\n            if len(tmp) == 0 : \\n                min_ = min(counter.keys())\\n                tmp.append(min_)\\n                counter[min_] -= 1 \\n                if counter[min_] <= 0 : \\n                    del counter[min_]\\n            else:\\n                if counter[tmp[-1]+1] <1 : \\n                    return False \\n                counter[tmp[-1]+1] -= 1 \\n                # print(counter)\\n                if counter[tmp[-1]+1] <= 0: \\n                    del counter[tmp[-1]+1] \\n                tmp.append(tmp[-1]+1)\\n            if len(tmp) == k :  \\n                tmp = [] \\n        return True \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        \\n        if len(nums) % k : return False  \\n        counter = Counter(nums) \\n        tmp = [] \\n        while len(tmp)<k and counter:\\n            if len(tmp) == 0 : \\n                min_ = min(counter.keys())\\n                tmp.append(min_)\\n                counter[min_] -= 1 \\n                if counter[min_] <= 0 : \\n                    del counter[min_]\\n            else:\\n                if counter[tmp[-1]+1] <1 : \\n                    return False \\n                counter[tmp[-1]+1] -= 1 \\n                # print(counter)\\n                if counter[tmp[-1]+1] <= 0: \\n                    del counter[tmp[-1]+1] \\n                tmp.append(tmp[-1]+1)\\n            if len(tmp) == k :  \\n                tmp = [] \\n        return True \\n",
                "codeTag": "Java"
            },
            {
                "id": 1830788,
                "title": "divide-array-in-sets-of-k-consecutive-numbers",
                "content": "\\n\\nUsemap count frequency \\ntraverse to the map by taking first value of map \\nif next k element exist means that you are going good(check it by counter)\\nif any element reduces to the freq =0 , you will erase the element.\\n\\n\\ncode is here\\n\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) \\n    {\\n        map<int, int> mp;\\n        //count frequency of elements\\n\\t    for (int n : nums)\\n\\t\\t   mp[n]++;\\n\\n\\t    int count = 0;\\n\\t    while (mp.size() >= 1) \\n        {\\n\\t\\t  int cur = mp.begin()->first;\\n\\t\\t  while(count++ < k) \\n          {\\n             // If cur element is not present then you have to return directly because its impossible to split completely\\n\\t\\t    \\tif (mp.find(cur) == mp.end())\\n\\t\\t\\t    \\treturn false;\\n                //after using cur we will reduce cur freq by 1 \\n\\t\\t\\t    mp[cur]--;\\n                // after accepting cur if freq become zero erase element\\n\\t\\t\\t    if (mp[cur] == 0)\\n\\t\\t\\t\\t     mp.erase(cur);\\n\\t\\t\\t    cur++;\\n\\t\\t   }\\n\\t\\t   count=0;\\n\\t     }\\n\\t   return mp.size() == 0;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) \\n    {\\n        map<int, int> mp;\\n        //count frequency of elements\\n\\t    for (int n : nums)\\n\\t\\t   mp[n]++;\\n\\n\\t    int count = 0;\\n\\t    while (mp.size() >= 1) \\n        {\\n\\t\\t  int cur = mp.begin()->first;\\n\\t\\t  while(count++ < k) \\n          {\\n             // If cur element is not present then you have to return directly because its impossible to split completely\\n\\t\\t    \\tif (mp.find(cur) == mp.end())\\n\\t\\t\\t    \\treturn false;\\n                //after using cur we will reduce cur freq by 1 \\n\\t\\t\\t    mp[cur]--;\\n                // after accepting cur if freq become zero erase element\\n\\t\\t\\t    if (mp[cur] == 0)\\n\\t\\t\\t\\t     mp.erase(cur);\\n\\t\\t\\t    cur++;\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1340276,
                "title": "python3-linearithmic-time-solution-with-explanation",
                "content": "This is a very good problem indeed. Intuition says that if duplicates were not allowed in the given list of numbers, it would have been a cake walk. The challenge lies in choosing the correct element from the list to begin our new set with. Explanation lies in the form of comments in the code.\\n\\nOverall Time Complexity of the problem is `O(nlogn) + O(n*k)`, making it `O(nlogn)` asymptotically.\\n\\n```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n\\t\\t\\n\\t\\t# if \\'k\\' is not a multiple of the length of the array, it cannot be divided into sets\\n        if n % k != 0: return False\\n        \\n        nums = sorted(nums)\\n        container, index = collections.Counter(nums), 0\\n        \\n        while index < n:\\n            curr = nums[index] # starting off with the element at <index>th index\\n\\t\\t\\t\\n\\t\\t\\t# checking if consecutive elements occur in the array\\n            for i in range(k):\\n\\t\\t\\t\\n\\t\\t\\t\\t# if a consecutive is not present, we simply return False meaning division is not possible\\n                if not container.get(curr+i, 0):\\n                    return False\\n                container[curr+i] -= 1 # we reduce the count by 1\\n                if container[curr+i] == 0: # also if the count becomes zero, we simply remove the key, which is an O(1) operation\\n                    del container[curr+i]\\n             \\n\\t\\t\\t# this loop determines the index of the element with which we start our next set\\n\\t\\t\\t# this piece of code is self explanatory\\n            index += 1\\n            while index < n and (not container.get(nums[index], 0)):\\n                index += 1\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        n = len(nums)\\n\\t\\t\\n\\t\\t# if \\'k\\' is not a multiple of the length of the array, it cannot be divided into sets\\n        if n % k != 0: return False\\n        \\n        nums = sorted(nums)\\n        container, index = collections.Counter(nums), 0\\n        \\n        while index < n:\\n            curr = nums[index] # starting off with the element at <index>th index\\n\\t\\t\\t\\n\\t\\t\\t# checking if consecutive elements occur in the array\\n            for i in range(k):\\n\\t\\t\\t\\n\\t\\t\\t\\t# if a consecutive is not present, we simply return False meaning division is not possible\\n                if not container.get(curr+i, 0):\\n                    return False\\n                container[curr+i] -= 1 # we reduce the count by 1\\n                if container[curr+i] == 0: # also if the count becomes zero, we simply remove the key, which is an O(1) operation\\n                    del container[curr+i]\\n             \\n\\t\\t\\t# this loop determines the index of the element with which we start our next set\\n\\t\\t\\t# this piece of code is self explanatory\\n            index += 1\\n            while index < n and (not container.get(nums[index], 0)):\\n                index += 1\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151694,
                "title": "treemap-java",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] hand, int W) {\\n         \\n        if(hand.length%W!=0)\\n            return false;\\n        \\n        \\n        //A treemap is always sorted based on the order of the keys.\\n        \\n        TreeMap<Integer,Integer> treemap = new TreeMap<>();\\n        \\n        for(int i=0;i<hand.length;i++)\\n        {\\n            if(treemap.containsKey(hand[i]))\\n                treemap.put(hand[i],treemap.get(hand[i])+1);\\n            else\\n                treemap.put(hand[i],1);\\n        }\\n    \\n        while(treemap.size()>0)\\n        {\\n            int lowest_key = treemap.firstKey();\\n            treemap.replace(lowest_key,treemap.get(lowest_key)-1);\\n            if(treemap.get(lowest_key) == 0)\\n                treemap.remove(lowest_key);\\n\\n            int num = 1;\\n            while(num<W)\\n            {\\n                if(treemap.containsKey(lowest_key+num))\\n                {\\n                    treemap.replace(lowest_key+num,treemap.get(lowest_key+num)-1);\\n                    if(treemap.get(lowest_key+num) == 0)\\n                        treemap.remove(lowest_key+num);\\n                }\\n                else\\n                    return false;\\n                num++;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] hand, int W) {\\n         \\n        if(hand.length%W!=0)\\n            return false;\\n        \\n        \\n        //A treemap is always sorted based on the order of the keys.\\n        \\n        TreeMap<Integer,Integer> treemap = new TreeMap<>();\\n        \\n        for(int i=0;i<hand.length;i++)\\n        {\\n            if(treemap.containsKey(hand[i]))\\n                treemap.put(hand[i],treemap.get(hand[i])+1);\\n            else\\n                treemap.put(hand[i],1);\\n        }\\n    \\n        while(treemap.size()>0)\\n        {\\n            int lowest_key = treemap.firstKey();\\n            treemap.replace(lowest_key,treemap.get(lowest_key)-1);\\n            if(treemap.get(lowest_key) == 0)\\n                treemap.remove(lowest_key);\\n\\n            int num = 1;\\n            while(num<W)\\n            {\\n                if(treemap.containsKey(lowest_key+num))\\n                {\\n                    treemap.replace(lowest_key+num,treemap.get(lowest_key+num)-1);\\n                    if(treemap.get(lowest_key+num) == 0)\\n                        treemap.remove(lowest_key+num);\\n                }\\n                else\\n                    return false;\\n                num++;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099639,
                "title": "python-solution-with-comments",
                "content": "from collections import Counter\\nclass Solution:\\n\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums)%k !=0:\\n            return False\\n\\n        count = Counter(nums)\\n        unique_list = sorted(count.keys()) # get all unique values \\n        for n in unique_list: #n is the current minimum number \\n            avaiable_n = count[n] # check avaiable numbers\\n            if avaiable_n == 0:\\n                continue\\n            for i in range(k): \\n                if count.get(n+i,0) >= avaiable_n:\\n                    count[n+i]-=avaiable_n\\n                else:\\n                    return False\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "from collections import Counter\\nclass Solution:\\n\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums)%k !=0:\\n            return False\\n\\n        count = Counter(nums)\\n        unique_list = sorted(count.keys()) # get all unique values \\n        for n in unique_list: #n is the current minimum number \\n            avaiable_n = count[n] # check avaiable numbers\\n            if avaiable_n == 0:\\n                continue\\n            for i in range(k): \\n                if count.get(n+i,0) >= avaiable_n:\\n                    count[n+i]-=avaiable_n\\n                else:\\n                    return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 958459,
                "title": "simple-c-pq-ht-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n=nums.size(), count=n/k;\\n        if(n%k != 0) return false;\\n\\n        unordered_map<int,int> ht;\\n        \\n        for(int i=0; i<n; i++)\\n            ht[nums[i]]++;\\n        \\n        priority_queue<int, vector<int>, greater<>> pq;\\n        for(auto val : ht)\\n            pq.push(val.first);\\n        \\n        for(int i=0; i<count; i++){\\n            int val = pq.top();\\n            while(ht.find(val) == ht.end()){\\n                val = pq.top();\\n                if(ht.find(val) == ht.end())\\n                    pq.pop();\\n            }\\n            \\n            for(int i=val; i<val+k; i++){\\n                if(ht.find(i) == ht.end()) return false;\\n                ht[i]--;\\n                if(ht[i]==0)\\n                    ht.erase(i);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n/*\\n\\n1. check if possible, count = n/k\\n2. store in ht\\n3. for every iteration of size count\\n4. if from first point in map, k values ahead exist in map, continue and decrement them.\\n5. if doesn\\'t exist, return false\\n\\n*/\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n=nums.size(), count=n/k;\\n        if(n%k != 0) return false;\\n\\n        unordered_map<int,int> ht;\\n        \\n        for(int i=0; i<n; i++)\\n            ht[nums[i]]++;\\n        \\n        priority_queue<int, vector<int>, greater<>> pq;\\n        for(auto val : ht)\\n            pq.push(val.first);\\n        \\n        for(int i=0; i<count; i++){\\n            int val = pq.top();\\n            while(ht.find(val) == ht.end()){\\n                val = pq.top();\\n                if(ht.find(val) == ht.end())\\n                    pq.pop();\\n            }\\n            \\n            for(int i=val; i<val+k; i++){\\n                if(ht.find(i) == ht.end()) return false;\\n                ht[i]--;\\n                if(ht[i]==0)\\n                    ht.erase(i);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n/*\\n\\n1. check if possible, count = n/k\\n2. store in ht\\n3. for every iteration of size count\\n4. if from first point in map, k values ahead exist in map, continue and decrement them.\\n5. if doesn\\'t exist, return false\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935545,
                "title": "python3-commented-and-faster-than-97-19",
                "content": "*Runtime: 384 ms, faster than 97.19% of Python3 online submissions for Divide Array in Sets of K Consecutive Numbers.\\nMemory Usage: 29.9 MB, less than 15.27% of Python3 online submissions for Divide Array in Sets of K Consecutive Numbers.*\\n\\n```python\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums)%k != 0:\\n            return False\\n        # move list -> multiset\\n        counter = {}\\n        for num in sorted(nums):\\n            if num in counter:\\n                counter[num] = counter[num] + 1\\n            else:\\n                counter[num] = 1\\n        # group numbers into groups of k\\n        while counter:\\n            # get next min\\n            next_num = next(iter(counter))\\n            for next_num in range(next_num, next_num + k):\\n                # consecutive number not present\\n                if next_num not in counter:\\n                    return False\\n                counter[next_num] = counter[next_num] - 1\\n                # remove depleted numbers\\n                if not counter[next_num]:\\n                    del(counter[next_num])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums)%k != 0:\\n            return False\\n        # move list -> multiset\\n        counter = {}\\n        for num in sorted(nums):\\n            if num in counter:\\n                counter[num] = counter[num] + 1\\n            else:\\n                counter[num] = 1\\n        # group numbers into groups of k\\n        while counter:\\n            # get next min\\n            next_num = next(iter(counter))\\n            for next_num in range(next_num, next_num + k):\\n                # consecutive number not present\\n                if next_num not in counter:\\n                    return False\\n                counter[next_num] = counter[next_num] - 1\\n                # remove depleted numbers\\n                if not counter[next_num]:\\n                    del(counter[next_num])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818875,
                "title": "java-map-priorityqueue",
                "content": "Step 1) Add all nums into a map. Key is num. Value is count.\\nStep 2) Add all nums (i.e. map.keySet()) into a priority queue, because we want to build the k consecutive numbers from the smallest number first.\\nStep 3) Iterate the priority queue. Remove the top element, which is the smallest number, (call it \"m\"). Look for \\nm, m+1, ..., m + k-1 in the map. If the value exists, we update the map and look for next value. If the value doens\\'t exist, we know is can\\'t be divided into k consecutive numbers.\\n\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int num : nums) {\\n            if (!map.containsKey(num)) {\\n                map.put(num, 0);\\n            }\\n            map.put(num, map.get(num) + 1);\\n        }\\n                \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for (int key : map.keySet()) {\\n            pq.add(key);\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            int candidate = pq.peek();\\n            if (!map.containsKey(candidate)) {\\n                pq.remove();\\n            } else {\\n                for (int i = candidate; i < candidate + k; i++) {\\n                    if (!map.containsKey(i)) {\\n                        return false;\\n                    }\\n                    int count = map.get(i);\\n                    if (count - 1 == 0) {\\n                        map.remove(i);\\n                    } else {\\n                        map.put(i, count - 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int num : nums) {\\n            if (!map.containsKey(num)) {\\n                map.put(num, 0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 751621,
                "title": "java-simple-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums == null || nums.length == 0 || nums.length % k != 0) return false;\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0)+1);\\n        }\\n        \\n        for (int num : map.keySet()) {\\n            if (map.get(num) <= 0) continue;\\n            for (int i = k-1; i>= 0; i--) {\\n                if (map.getOrDefault(num + i, 0) < map.get(num)) return false;\\n                map.put(num+i, map.getOrDefault(num + i, 0) - map.get(num));\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums == null || nums.length == 0 || nums.length % k != 0) return false;\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 629157,
                "title": "fast-javascript-solution",
                "content": "```\\nconst isPossibleDivide = (nums, k) => {\\n    if(nums.length % k)return false\\n    let map = {}, set = new Set(nums)\\n    nums.forEach(x => map[x] ? map[x]++ : map[x] = 1)\\n    let count = nums.length / k\\n    while(count--){\\n        let min = Math.min(...set)\\n        for(let i = min; i < min + k; i++){\\n            if(!map[i])return false\\n            if(--map[i] == 0)set.delete(i)\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPossibleDivide = (nums, k) => {\\n    if(nums.length % k)return false\\n    let map = {}, set = new Set(nums)\\n    nums.forEach(x => map[x] ? map[x]++ : map[x] = 1)\\n    let count = nums.length / k\\n    while(count--){\\n        let min = Math.min(...set)\\n        for(let i = min; i < min + k; i++){\\n            if(!map[i])return false\\n            if(--map[i] == 0)set.delete(i)\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 580246,
                "title": "o-n-python-solution-with-explanations",
                "content": "**Explanation**:\\n1. Build a map and count different the show up time in of each number in `nums`\\n2. Use a queue to record the starting number (`starts`) of each valid sequence. \\n3. For each starting number (`start`), we iterate nxt_number from `start + k - 1` back to `start`. `counts[nxt_number]` can only build valid sequence iff `counts[nxt_number] >= counts[start]`. If  `counts[nxt_number] == 0`, we need to remove nxt_number from counts. MOREOVER, to deal with overlap sequences, we need to check `counts[nxt_number+ 1]`, if `counts[nxt_number+ 1] > 0`, nxt_number is the starting number of an overlap sequence.\\n\\n**Complexity**: Time O(N), N is `len(nums)`\\n``` \\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        counts = collections.Counter(nums)\\n        starts = collections.deque([])\\n        for num in counts:\\n\\t\\t    # if num - 1 isn\\'t in counts, num must be the starting number of a sequence\\n            if num - 1 not in counts:\\n                starts.append(num)\\n        while starts:\\n            start = starts.popleft()\\n            for j in range(k - 1, -1, -1):\\n                if counts[start + j] < counts[start]: return False\\n                counts[start + j] -= counts[start]\\n                if counts[start + j] == 0:\\n                    counts.pop(start + j)\\n                    if counts[start + j + 1] > 0:\\n                        starts.append(start + j + 1)\\n        return True\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Queue"
                ],
                "code": "``` \\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        counts = collections.Counter(nums)\\n        starts = collections.deque([])\\n        for num in counts:\\n\\t\\t    # if num - 1 isn\\'t in counts, num must be the starting number of a sequence\\n            if num - 1 not in counts:\\n                starts.append(num)\\n        while starts:\\n            start = starts.popleft()\\n            for j in range(k - 1, -1, -1):\\n                if counts[start + j] < counts[start]: return False\\n                counts[start + j] -= counts[start]\\n                if counts[start + j] == 0:\\n                    counts.pop(start + j)\\n                    if counts[start + j + 1] > 0:\\n                        starts.append(start + j + 1)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543092,
                "title": "o-n-100-fast-100-memory-efficient-no-sort-easy-to-understand-python",
                "content": "We can fit all numbers between 0 to k-1, if we do modulo by k.\\nthan all we need to check is that in our map, all keys from 0 to k-1 have same value or not.\\n\\n```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        # first check if array contains enough elements to be multiple of k\\n        if len(nums) % k != 0:\\n            return False\\n\\n        # Now lets reduce number and try to fit it between 0 to k-1\\n        numMap = {x: 0 for x in range(k)}\\n        for num in nums:\\n            numMap[num % k] += 1\\n\\n        # see if all values in map for each key is not same\\n        return (len(set(numMap.values())) == 1)        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        # first check if array contains enough elements to be multiple of k\\n        if len(nums) % k != 0:\\n            return False\\n\\n        # Now lets reduce number and try to fit it between 0 to k-1\\n        numMap = {x: 0 for x in range(k)}\\n        for num in nums:\\n            numMap[num % k] += 1\\n\\n        # see if all values in map for each key is not same\\n        return (len(set(numMap.values())) == 1)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 498326,
                "title": "java-greedy-treemap-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int len = nums.length;\\n        if(len % k != 0){\\n            return false;\\n        }\\n        \\n        TreeMap<Integer,Integer> num_times = new TreeMap<Integer,Integer>();\\n        for(int i:nums){\\n            num_times.put(i,num_times.getOrDefault(i,0) + 1);\\n        }\\n        \\n        while(num_times.size() != 0){\\n            int smallestKey = num_times.firstKey();\\n            for(int i=0;i<k;i++){\\n                int findKey = smallestKey + i;\\n                if(!num_times.containsKey(findKey)){\\n                    return false;\\n                }else{\\n                    num_times.put(findKey,num_times.get(findKey) - 1);\\n                    if(num_times.get(findKey) == 0){\\n                        num_times.remove(findKey);\\n                    }\\n                }\\n                \\n            }    \\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nTime complexity: O(nlogn), for putting all elements into treemap",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int len = nums.length;\\n        if(len % k != 0){\\n            return false;\\n        }\\n        \\n        TreeMap<Integer,Integer> num_times = new TreeMap<Integer,Integer>();\\n        for(int i:nums){\\n            num_times.put(i,num_times.getOrDefault(i,0) + 1);\\n        }\\n        \\n        while(num_times.size() != 0){\\n            int smallestKey = num_times.firstKey();\\n            for(int i=0;i<k;i++){\\n                int findKey = smallestKey + i;\\n                if(!num_times.containsKey(findKey)){\\n                    return false;\\n                }else{\\n                    num_times.put(findKey,num_times.get(findKey) - 1);\\n                    if(num_times.get(findKey) == 0){\\n                        num_times.remove(findKey);\\n                    }\\n                }\\n                \\n            }    \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458643,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea** \\nIt is easy to see every set must start with smallest number possible and then grow from there.\\n`TreeMap` keeps things in sorted way and can find an element in `O(lgn)` time. So we keep picking the smallest and keep taking out every next number we require to form the set of size `k`.\\n\\n```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for(int n : nums)\\n            m.put(n, m.getOrDefault(n,0)+1);\\n        \\n        for(int n : m.keySet()){\\n            while(m.get(n) > 0){\\n                for(int i=n; i < n+k; i++){\\n                    if(!m.containsKey(i) || m.get(i) == 0)\\n                        return false;\\n                    else{\\n                        m.put(i, m.get(i)-1);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for(int n : nums)\\n            m.put(n, m.getOrDefault(n,0)+1);\\n        \\n        for(int n : m.keySet()){\\n            while(m.get(n) > 0){\\n                for(int i=n; i < n+k; i++){\\n                    if(!m.containsKey(i) || m.get(i) == 0)\\n                        return false;\\n                    else{\\n                        m.put(i, m.get(i)-1);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458533,
                "title": "javascript-easy-to-understand-greedy",
                "content": "After reading the description, we could find out a condition for early break easily is that the length of `nums` must be an integer multiple of `k`.\\n\\nThen, the main strategy is to remove the sub consecutive set from original `nums`. We need to make sure to remove it from the edge. Finally, we get the result until the original `nums` is empty or we can\\'t find such a sub consecutive set.\\n\\nThere are two common deletion methods -- real delete or counting. Here I choose counting for performance reason. And since the range of numbers is too large `[1, 10^9]`, so I choose  to using map instead of array to store the count.\\n\\nAnd to make sure to remove from the edge, I sort the `nums` first. Finally, we get the result.\\n\\n```js\\nconst isPossibleDivide = (nums, k) => {\\n  if (nums.length % k !== 0) return false;\\n  const map = new Map();\\n  nums.sort((a, b) => a - b);\\n  for (const val of nums) {\\n    map.set(val, map.has(val) ? map.get(val) + 1 : 1);\\n  }\\n  for (let i = 0; i < nums.length; ++i) {\\n    const start = nums[i];\\n    const count = map.get(start);\\n    if (count === 0) continue;\\n    for (let i = 1; i < k; ++i) {\\n      const c = map.get(start + i)\\n      if (c === undefined || c < count) return false;\\n      map.set(start + i, c - count);\\n    }\\n    map.set(start, 0);\\n  }\\n  return true;\\n};\\n```\\n\\nThe code above will get accepted with 152ms. But that sort is very noticeable since it raises the base time complexity to `nlogn`. Could we remove the sort?\\n\\nWe use sorting here is just to ensure that we delete from the edge. If we can do it in another way, then we don\\'t need to sort the whole array.\\n\\nSo, here\\'s the code without sorting which has better performance, 92ms.\\n\\n```js\\nconst isPossibleDivide = (nums, k) => {\\n  if (nums.length % k !== 0) return false;\\n  const map = new Map();\\n  for (const val of nums) {\\n    map.set(val, map.has(val) ? map.get(val) + 1 : 1);\\n  }\\n  for (let start of nums) {\\n    if (map.get(start) === 0) continue;\\n    while (map.get(--start) > 0);\\n    ++start;\\n    const count = map.get(start);\\n    for (let i = 1; i < k; ++i) {\\n      const c = map.get(start + i)\\n      if (c === undefined || c < count) return false;\\n      map.set(start + i, c - count);\\n    }\\n    map.set(start, 0);\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst isPossibleDivide = (nums, k) => {\\n  if (nums.length % k !== 0) return false;\\n  const map = new Map();\\n  nums.sort((a, b) => a - b);\\n  for (const val of nums) {\\n    map.set(val, map.has(val) ? map.get(val) + 1 : 1);\\n  }\\n  for (let i = 0; i < nums.length; ++i) {\\n    const start = nums[i];\\n    const count = map.get(start);\\n    if (count === 0) continue;\\n    for (let i = 1; i < k; ++i) {\\n      const c = map.get(start + i)\\n      if (c === undefined || c < count) return false;\\n      map.set(start + i, c - count);\\n    }\\n    map.set(start, 0);\\n  }\\n  return true;\\n};\\n```\n```js\\nconst isPossibleDivide = (nums, k) => {\\n  if (nums.length % k !== 0) return false;\\n  const map = new Map();\\n  for (const val of nums) {\\n    map.set(val, map.has(val) ? map.get(val) + 1 : 1);\\n  }\\n  for (let start of nums) {\\n    if (map.get(start) === 0) continue;\\n    while (map.get(--start) > 0);\\n    ++start;\\n    const count = map.get(start);\\n    for (let i = 1; i < k; ++i) {\\n      const c = map.get(start + i)\\n      if (c === undefined || c < count) return false;\\n      map.set(start + i, c - count);\\n    }\\n    map.set(start, 0);\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458313,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func isPossibleDivide(_ nums: [Int], _ k: Int) -> Bool {\\n        if nums.count % k != 0 { return false }\\n        var dict = [Int: Int]()\\n        for num in nums {\\n            dict[num, default: 0] += 1\\n        }\\n        \\n        while dict.count > 0 {\\n            let smallest = Array(dict.keys).min()!\\n            for i in 0..<k {\\n                let val = smallest + i\\n                if dict[val] == nil { return false }\\n                dict[val] = dict[val]! - 1\\n                if dict[val]! == 0 { dict[val] = nil }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isPossibleDivide(_ nums: [Int], _ k: Int) -> Bool {\\n        if nums.count % k != 0 { return false }\\n        var dict = [Int: Int]()\\n        for num in nums {\\n            dict[num, default: 0] += 1\\n        }\\n        \\n        while dict.count > 0 {\\n            let smallest = Array(dict.keys).min()!\\n            for i in 0..<k {\\n                let val = smallest + i\\n                if dict[val] == nil { return false }\\n                dict[val] = dict[val]! - 1\\n                if dict[val]! == 0 { dict[val] = nil }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457570,
                "title": "java-sort-map",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int n = nums.length;\\n\\t\\tif(k == 1) return true;\\n        if(n % k != 0) return false;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            int count = 1;\\n            if(map.containsKey(nums[i])) count += map.get(nums[i]);\\n            if(!map.containsKey(nums[i])) list.add(nums[i]);\\n            map.put(nums[i], count);\\n        }\\n        \\n        Collections.sort(list);\\n        \\n        for(int i = 0; i < list.size();){\\n            int curr = list.get(i);\\n            int currLength = 0;\\n            while(currLength < k && map.containsKey(curr) && map.get(curr) > 0){\\n                int c = map.get(curr);\\n                currLength++;\\n                c--;\\n                map.put(curr, c);\\n                curr++;\\n            }\\n            if(currLength < k) return false;\\n            while(i < list.size() && map.get(list.get(i)) == 0) i++;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int n = nums.length;\\n\\t\\tif(k == 1) return true;\\n        if(n % k != 0) return false;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            int count = 1;\\n            if(map.containsKey(nums[i])) count += map.get(nums[i]);\\n            if(!map.containsKey(nums[i])) list.add(nums[i]);\\n            map.put(nums[i], count);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4103961,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] arr, int k) {\\n        \\n        int n = arr.length;\\n\\n        if(n%k!=0) return false;\\n        Arrays.sort(arr);\\n\\n        ArrayList<Integer> a = new ArrayList<>();\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            a.add(arr[i]);\\n            hp.put(arr[i],hp.getOrDefault(arr[i],0)+1);\\n        }\\n\\n        while(a.size()!=0){\\n            if(a.size()<k){\\n                return false;\\n            }\\n\\n            int y = Integer.valueOf(a.get(0));\\n\\n            for(int i=1; i<=k; i++){\\n                if(hp.containsKey(y)){\\n                    hp.put(y,hp.get(y)-1);\\n                    if(hp.get(y)==0) hp.remove(y);\\n\\n                    int x = a.indexOf(y);\\n                    a.remove(x);\\n                }else{\\n                    return false;\\n                }\\n                y=y+1;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] arr, int k) {\\n        \\n        int n = arr.length;\\n\\n        if(n%k!=0) return false;\\n        Arrays.sort(arr);\\n\\n        ArrayList<Integer> a = new ArrayList<>();\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            a.add(arr[i]);\\n            hp.put(arr[i],hp.getOrDefault(arr[i],0)+1);\\n        }\\n\\n        while(a.size()!=0){\\n            if(a.size()<k){\\n                return false;\\n            }\\n\\n            int y = Integer.valueOf(a.get(0));\\n\\n            for(int i=1; i<=k; i++){\\n                if(hp.containsKey(y)){\\n                    hp.put(y,hp.get(y)-1);\\n                    if(hp.get(y)==0) hp.remove(y);\\n\\n                    int x = a.indexOf(y);\\n                    a.remove(x);\\n                }else{\\n                    return false;\\n                }\\n                y=y+1;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809978,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        map<int,int>mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            if(mp.size()==k){\\n                \\n                for(int j=nums[i];j>nums[i]-k;j--)\\n                {\\n                    mp[j]--;\\n                    if(mp[j]==0)\\n                    mp.erase(j);\\n                }\\n                   cout<<mp.size()<<endl;\\n                \\n        }\\n        }\\n        if(mp.size())\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        map<int,int>mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            if(mp.size()==k){\\n                \\n                for(int j=nums[i];j>nums[i]-k;j--)\\n                {\\n                    mp[j]--;\\n                    if(mp[j]==0)\\n                    mp.erase(j);\\n                }\\n                   cout<<mp.size()<<endl;\\n                \\n        }\\n        }\\n        if(mp.size())\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2924608,
                "title": "java-100-fastest-solution-only-use-18ms",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/1c154d9a-0551-4e9f-a776-fbf04db72925_1671351243.7660797.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int[] arr = new int[k];//count mod k\\n        int previous = nums[0];\\n        Arrays.sort(nums);\\n        for(int x : nums){\\n            //if countinue previous mod can\\'t bigger than current mod\\n            if(x == previous + 1 && arr[(previous - 1) % k] > arr[previous % k]) return false; \\n            //if not countinue previous mod should equal current mod   \\n            if(x > previous + 1 && arr[(previous - 1) % k] != arr[previous % k]) return false;\\n            arr[x % k]++;//current mod++\\n            previous = x;//previous = current\\n        }\\n        return arr[(previous - 1) % k] == arr[previous % k];//previous mod should equal current mod\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int[] arr = new int[k];//count mod k\\n        int previous = nums[0];\\n        Arrays.sort(nums);\\n        for(int x : nums){\\n            //if countinue previous mod can\\'t bigger than current mod\\n            if(x == previous + 1 && arr[(previous - 1) % k] > arr[previous % k]) return false; \\n            //if not countinue previous mod should equal current mod   \\n            if(x > previous + 1 && arr[(previous - 1) % k] != arr[previous % k]) return false;\\n            arr[x % k]++;//current mod++\\n            previous = x;//previous = current\\n        }\\n        return arr[(previous - 1) % k] == arr[previous % k];//previous mod should equal current mod\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870808,
                "title": "easy-java-code-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] hand, int groupSize) {\\n        if(hand.length % groupSize != 0){\\n            return false;\\n        }\\n        \\n        int totalgroup = hand.length / groupSize;\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int i=0; i < hand.length; i++){\\n            pq.add(hand[i]);\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            int start = pq.poll();\\n            start++;\\n            \\n            int j = 0;\\n            while(j++ < groupSize - 1){\\n                if(pq.contains(start)){\\n                    pq.remove(start++);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n                \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] hand, int groupSize) {\\n        if(hand.length % groupSize != 0){\\n            return false;\\n        }\\n        \\n        int totalgroup = hand.length / groupSize;\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int i=0; i < hand.length; i++){\\n            pq.add(hand[i]);\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            int start = pq.poll();\\n            start++;\\n            \\n            int j = 0;\\n            while(j++ < groupSize - 1){\\n                if(pq.contains(start)){\\n                    pq.remove(start++);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n                \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734823,
                "title": "java-priorityqueue-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int p : nums){\\n            pq.offer(p);\\n        }\\n        while(!pq.isEmpty()){\\n            int first = pq.peek();\\n            for(int i = 0;i<k;i++){\\n                if(!pq.remove(first+i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int p : nums){\\n            pq.offer(p);\\n        }\\n        while(!pq.isEmpty()){\\n            int first = pq.peek();\\n            for(int i = 0;i<k;i++){\\n                if(!pq.remove(first+i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544795,
                "title": "sort-the-array-and-check-the-frequency-via-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& a, int k) {\\n        \\n        int n = a.size();\\n        if(n<k || n%k!=0)\\n            return false;\\n       map<int,int> mp;\\n        vector<int> v;\\n        \\n        for(auto i: a)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        \\n        sort(a.begin(),a.end());\\n        for(auto i: a)\\n        {\\n            int val = i;\\n            int freq = mp[val];\\n            if(freq>0){\\n                for(int j=0;j<k;j++)\\n                {\\n                    int test = val+j;\\n                    if(mp.count(test)>0 && mp[test]>0){\\n                        mp[test]--;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n            else{\\n                mp.erase(val);\\n            }\\n            \\n        }\\n        \\n         for(auto i: mp)\\n        {\\n            \\n             if(i.second == 0)\\n             {\\n                 mp.erase(i.first);\\n             }\\n         }\\n       \\n        return mp.empty();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& a, int k) {\\n        \\n        int n = a.size();\\n        if(n<k || n%k!=0)\\n            return false;\\n       map<int,int> mp;\\n        vector<int> v;\\n        \\n        for(auto i: a)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        \\n        sort(a.begin(),a.end());\\n        for(auto i: a)\\n        {\\n            int val = i;\\n            int freq = mp[val];\\n            if(freq>0){\\n                for(int j=0;j<k;j++)\\n                {\\n                    int test = val+j;\\n                    if(mp.count(test)>0 && mp[test]>0){\\n                        mp[test]--;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n            else{\\n                mp.erase(val);\\n            }\\n            \\n        }\\n        \\n         for(auto i: mp)\\n        {\\n            \\n             if(i.second == 0)\\n             {\\n                 mp.erase(i.first);\\n             }\\n         }\\n       \\n        return mp.empty();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453155,
                "title": "c-98-faster-and-99-less-space-detailed-explanation",
                "content": "Similar problem: https://leetcode.com/problems/split-array-into-consecutive-subsequences/\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// Custom comparator for min heap\\n    struct comp{\\n        bool operator()(pair<int,int> &a, pair<int,int> &b){\\n            if(a.first == b.first){\\n                return a.second > b.second;\\n            }\\n            return a.first > b.first;\\n        }\\n    };\\n    \\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n\\t\\t// Sort the numbers\\n        sort(nums.begin(), nums.end());\\n        \\n        // Min heap storing {last num of the seq, len of the seq}\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, comp> heap;\\n        \\n        int i=0;\\n        while(i < nums.size()){\\n            if(heap.empty()){\\n                heap.push({nums[i], 1});\\n                i++;\\n            }\\n            else{\\n                int curr = nums[i];\\n                int prev = heap.top().first;\\n                int len = heap.top().second;\\n                heap.pop();\\n                \\n                // Same num cannot be in the same subsequence\\n                if(prev == curr){\\n                    heap.push({curr, 1});\\n                    heap.push({prev, len});\\n                    i++;\\n                }\\n\\t\\t\\t\\t// Found the next consecutive number\\n                else if(prev+1 == curr){\\n\\t\\t\\t\\t\\t// Seq length is alreay \\'K\\', hence create a new sequence starting with curr\\n                    if(len == k){\\n                        heap.push({curr, 1});\\n                    }\\n\\t\\t\\t\\t\\t// Seq length is not \\'K\\'\\n                    else{\\n                        heap.push({curr, len+1});\\n                    }\\n                    i++;\\n                }\\n\\t\\t\\t\\t// Not the next consecutive number\\n                else{\\n\\t\\t\\t\\t\\t// Previous subsequence is not of length K\\n                    if(len < k){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(!heap.empty()){\\n            if(heap.top().second < k){\\n                return false;\\n            }\\n            heap.pop();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Custom comparator for min heap\\n    struct comp{\\n        bool operator()(pair<int,int> &a, pair<int,int> &b){\\n            if(a.first == b.first){\\n                return a.second > b.second;\\n            }\\n            return a.first > b.first;\\n        }\\n    };\\n    \\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n\\t\\t// Sort the numbers\\n        sort(nums.begin(), nums.end());\\n        \\n        // Min heap storing {last num of the seq, len of the seq}\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, comp> heap;\\n        \\n        int i=0;\\n        while(i < nums.size()){\\n            if(heap.empty()){\\n                heap.push({nums[i], 1});\\n                i++;\\n            }\\n            else{\\n                int curr = nums[i];\\n                int prev = heap.top().first;\\n                int len = heap.top().second;\\n                heap.pop();\\n                \\n                // Same num cannot be in the same subsequence\\n                if(prev == curr){\\n                    heap.push({curr, 1});\\n                    heap.push({prev, len});\\n                    i++;\\n                }\\n\\t\\t\\t\\t// Found the next consecutive number\\n                else if(prev+1 == curr){\\n\\t\\t\\t\\t\\t// Seq length is alreay \\'K\\', hence create a new sequence starting with curr\\n                    if(len == k){\\n                        heap.push({curr, 1});\\n                    }\\n\\t\\t\\t\\t\\t// Seq length is not \\'K\\'\\n                    else{\\n                        heap.push({curr, len+1});\\n                    }\\n                    i++;\\n                }\\n\\t\\t\\t\\t// Not the next consecutive number\\n                else{\\n\\t\\t\\t\\t\\t// Previous subsequence is not of length K\\n                    if(len < k){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(!heap.empty()){\\n            if(heap.top().second < k){\\n                return false;\\n            }\\n            heap.pop();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2448876,
                "title": "cpp-solution-o-nlogn",
                "content": "class Solution {\\npublic:\\n \\n    \\n\\t#define p pair<int,int >\\n    bool isPossibleDivide(vector<int>& nums,int k) {\\n        \\n        if(k==1)return true;\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n\\n      priority_queue<p , vector<p> , greater<p> > pq;  // <need,size_curr>\\n        \\n     for(int i=0;i<n;i++)\\n     {\\n         int curr=nums[i];\\n         \\n         if(pq.size()==0)\\n         {\\n             pq.push({curr+1,1});\\n         }\\n         else\\n         {\\n             int need= pq.top().first;\\n             int sz= pq.top().second;\\n             \\n             if(curr>need)return false;\\n             \\n             if(curr<need)\\n             {\\n                 pq.push({curr+1,1});\\n             }\\n             else if(curr==need)\\n             {\\n                 pq.pop();\\n                 if(sz+1 == k)\\n                 {\\n                     continue;\\n                 }\\n                 pq.push({curr+1,sz+1});\\n             }\\n         }\\n     }\\n       // cout<<n<<\" \"<<pq.size()<<endl;\\n        if(pq.size()==0)return true;\\n \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n \\n    \\n\\t#define p pair<int,int >\\n    bool isPossibleDivide(vector<int>& nums,int k) {\\n        \\n        if(k==1)return true;\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n\\n      priority_queue<p , vector<p> , greater<p> > pq;  // <need,size_curr>\\n        \\n     for(int i=0;i<n;i++)\\n     {\\n         int curr=nums[i];\\n         \\n         if(pq.size()==0)\\n         {\\n             pq.push({curr+1,1}",
                "codeTag": "Java"
            },
            {
                "id": 2448550,
                "title": "c-o-nlogn-solution-using-hashmap",
                "content": "**C++ Code:**\\n**Time Complexity: O(nlogn) \\nSpace Complexity: O(n)**\\n```\\nbool isPossibleDivide(vector<int>& nums, int k) {\\n        if(nums.size()%k!=0) return false;\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++) m[nums[i]]++;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n           if(m[it->first]==0) continue;\\n            int count = m[it->first];\\n            m[it->first]-= count;\\n            int x=1;\\n            while(x<k && m.find(it->first+x)!=m.end())\\n            {\\n                if(m[it->first+x]<count) return false;\\n                m[it->first+x]-=count;\\n                x++;\\n            }\\n            if(x!=k) return false;\\n        }\\n     return true;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nbool isPossibleDivide(vector<int>& nums, int k) {\\n        if(nums.size()%k!=0) return false;\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++) m[nums[i]]++;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n           if(m[it->first]==0) continue;\\n            int count = m[it->first];\\n            m[it->first]-= count;\\n            int x=1;\\n            while(x<k && m.find(it->first+x)!=m.end())\\n            {\\n                if(m[it->first+x]<count) return false;\\n                m[it->first+x]-=count;\\n                x++;\\n            }\\n            if(x!=k) return false;\\n        }\\n     return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2448179,
                "title": "100-fastest-hashmap-and-sorting-o-n-logn",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n % k != 0) return false;\\n        \\n        unordered_map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int& num : nums) {\\n            mp[num]++;\\n        }        \\n        \\n        for(int& num : nums) {\\n            if(mp[num] <= 0) continue;\\n\\n            for(int start = num ; start<num+k ; start++) {\\n                if(mp[start] <= 0) return false;\\n                mp[start]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n % k != 0) return false;\\n        \\n        unordered_map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int& num : nums) {\\n            mp[num]++;\\n        }        \\n        \\n        for(int& num : nums) {\\n            if(mp[num] <= 0) continue;\\n\\n            for(int start = num ; start<num+k ; start++) {\\n                if(mp[start] <= 0) return false;\\n                mp[start]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440754,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tbool isPossibleDivide(vector<int>& nums, int k) {\\n\\t\\tmap<int, int> m;\\n\\t\\tfor (auto &e : nums) m[e]++;\\n\\t\\tfor (auto &e : m) {\\n\\t\\t\\tif (e.second) {\\n\\t\\t\\t\\tint freq = e.second;\\n\\t\\t\\t\\tfor (int i = 0; i < k; ++i) {\\n\\t\\t\\t\\t\\tif (m[e.first + i] < freq) return false;\\n\\t\\t\\t\\t\\telse m[e.first + i] -= freq;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool isPossibleDivide(vector<int>& nums, int k) {\\n\\t\\tmap<int, int> m;\\n\\t\\tfor (auto &e : nums) m[e]++;\\n\\t\\tfor (auto &e : m) {\\n\\t\\t\\tif (e.second) {\\n\\t\\t\\t\\tint freq = e.second;\\n\\t\\t\\t\\tfor (int i = 0; i < k; ++i) {\\n\\t\\t\\t\\t\\tif (m[e.first + i] < freq) return false;\\n\\t\\t\\t\\t\\telse m[e.first + i] -= freq;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413566,
                "title": "c-best-hashing-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n         map<int,int> m;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto x:m)\\n        {\\n            int key=x.first;\\n            while(m[key]>0)\\n            {\\n                for(int i = key; i < key + k; ++i)\\n                {\\n                    m[i]--;\\n                    if(m[i] < 0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408342,
                "title": "c-short-and-easy-solution-using-multiset",
                "content": "Time Complexity: O(nlog(n))\\nSpace Complexity: O(n)\\n ```\\nbool isPossibleDivide(vector<int>& a, int k) {\\n        multiset<int> m;\\n        for(auto x:a) m.insert(x);\\n        while(!m.empty()){\\n\\t\\t\\n\\t\\t// the first element of the multiset will always be the smallest element \\n            int cnt=*m.begin();\\n\\t\\t\\t\\n\\t\\t// maintaining pointer to satisfy condition of k consecutive elements \\n            int temp=cnt;\\n\\t\\t\\n            while(cnt-temp<k){\\n                auto x=m.find(cnt);\\n\\t\\t\\t\\t// if the element is present in the multiset then erase its one occurence\\n                if(x!=m.end()) m.erase(x);\\n\\t\\t\\t\\t// else if it is not present then return false\\n                else return false;\\n                cnt++;\\n              }\\n        }\\n        return m.empty();\\n    }\\n```\\nIf you have liked the solution then please do upvote the solution \\uD83D\\uDE42.\\nHappy Coding!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nbool isPossibleDivide(vector<int>& a, int k) {\\n        multiset<int> m;\\n        for(auto x:a) m.insert(x);\\n        while(!m.empty()){\\n\\t\\t\\n\\t\\t// the first element of the multiset will always be the smallest element \\n            int cnt=*m.begin();\\n\\t\\t\\t\\n\\t\\t// maintaining pointer to satisfy condition of k consecutive elements \\n            int temp=cnt;\\n\\t\\t\\n            while(cnt-temp<k){\\n                auto x=m.find(cnt);\\n\\t\\t\\t\\t// if the element is present in the multiset then erase its one occurence\\n                if(x!=m.end()) m.erase(x);\\n\\t\\t\\t\\t// else if it is not present then return false\\n                else return false;\\n                cnt++;\\n              }\\n        }\\n        return m.empty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379839,
                "title": "c-using-dictionary-67-faster",
                "content": "public class Solution {\\n    public bool IsPossibleDivide(int[] nums, int k) {\\n        var dic = new Dictionary<int,int>(); // We are going to pass all the nums contain to the dictionary\\n        \\n        foreach(var num in nums)\\n        {\\n            if(!dic.ContainsKey(num)) dic[num] =0; // if Key does not exists we create it\\n            dic[num] +=1; // if exists we add 1 in the value\\n        }\\n        \\n        return Checker(dic,k); // we send the dictionary to the recursive function\\n    \\n    }\\n    \\n    private bool Checker(Dictionary<int,int>dic ,int k)\\n    {\\n        int count = dic.Values.Sum(); // this is the total Length of the dictionary if it was an array\\n        if(count % k !=0) return false; // if this statement is true, there is no way to divide it, so this is false\\n        int min = dic.Keys.Min(); //we create a min integer to check the minimum key for the start of the for loop\\n\\n        \\n        for(int i =min;i< min + k;i++) // it must iterate from the minimum to the max length of the array division\\n        {\\n            if(!dic.ContainsKey(i)) return false; // just a check, it the key does not existe, something is wrong\\n            dic[i]--; // if exists we decrease a value from that key to take out the repetition\\n            if(dic[i] ==0) // if the value is 0, we remove the key\\n                dic.Remove(i);\\n                \\n        }\\n        \\n        return count == k ? true: Checker(dic,k); // using the ternary operator we check if the count is equal to k, if is not, we need to go through the function again\\n    }\\n}",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public bool IsPossibleDivide(int[] nums, int k) {\\n        var dic = new Dictionary<int,int>(); // We are going to pass all the nums contain to the dictionary\\n        \\n        foreach(var num in nums)\\n        {\\n            if(!dic.ContainsKey(num)) dic[num] =0; // if Key does not exists we create it\\n            dic[num] +=1; // if exists we add 1 in the value\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2246464,
                "title": "java-ez-2-understand",
                "content": "```\\nclass Solution {\\n\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        //initial check\\n        if ((nums.length % k) != 0) return false;\\n        //sosrting the array\\n        Arrays.sort(nums);\\n        //taking a map for mapping the occurrence of each digit\\n        Map<Integer, Integer> hm = new HashMap<>();\\n        for (int i : nums) hm.put(i, hm.getOrDefault(i, 0) + 1);\\n        int next = nums[0], curr = 1, nStart = -1;\\n        while (curr <= nums.length) {\\n            //if the nect element is not present return false\\n            if (hm.getOrDefault(next, -1) <= 0) return false;\\n            //if it is present decrement the occurrence by 1\\n            hm.put(next, hm.get(next) - 1);\\n            //if the digit possesses higher than 1 then it can be used in upcoming subsequence\\n            if (hm.get(next) > 0 && nStart == -1) nStart = next;\\n            next++;\\n            if ((curr) % k == 0) {\\n                if (curr == nums.length) break;\\n                if (nStart == -1) next = nums[curr]; else {\\n                    next = nStart;\\n                    nStart = -1;\\n                }\\n            }\\n            curr++;\\n        }\\n        return true;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        //initial check\\n        if ((nums.length % k) != 0) return false;\\n        //sosrting the array\\n        Arrays.sort(nums);\\n        //taking a map for mapping the occurrence of each digit\\n        Map<Integer, Integer> hm = new HashMap<>();\\n        for (int i : nums) hm.put(i, hm.getOrDefault(i, 0) + 1);\\n        int next = nums[0], curr = 1, nStart = -1;\\n        while (curr <= nums.length) {\\n            //if the nect element is not present return false\\n            if (hm.getOrDefault(next, -1) <= 0) return false;\\n            //if it is present decrement the occurrence by 1\\n            hm.put(next, hm.get(next) - 1);\\n            //if the digit possesses higher than 1 then it can be used in upcoming subsequence\\n            if (hm.get(next) > 0 && nStart == -1) nStart = next;\\n            next++;\\n            if ((curr) % k == 0) {\\n                if (curr == nums.length) break;\\n                if (nStart == -1) next = nums[curr]; else {\\n                    next = nStart;\\n                    nStart = -1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2212446,
                "title": "python3",
                "content": "```class Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums) % k:\\n            return False\\n        \\n        c = defaultdict(int)\\n        for i in nums:\\n            c[i] += 1\\n        \\n        freq = 0\\n        \\n        for key in sorted(c.keys()):\\n            freq = c[key]\\n            if freq:\\n                for i in range(1,k):\\n                    if c[key+i] and c[key+i] >= freq:\\n                        c[key+i] -= freq\\n                    else:\\n                        return False\\n        return True",
                "solutionTags": [],
                "code": "```class Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums) % k:\\n            return False\\n        \\n        c = defaultdict(int)\\n        for i in nums:\\n            c[i] += 1\\n        \\n        freq = 0\\n        \\n        for key in sorted(c.keys()):\\n            freq = c[key]\\n            if freq:\\n                for i in range(1,k):\\n                    if c[key+i] and c[key+i] >= freq:\\n                        c[key+i] -= freq\\n                    else:\\n                        return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2181319,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int &num : nums)\\n        {\\n            mp[num]++;\\n        }\\n        //vector<int> srt;\\n        for(auto &[fst, snd] : mp)\\n        {\\n            if(snd == 0) continue;\\n            int xp2 = snd;\\n            mp[fst] = 0;\\n            int xp1 = fst;\\n            int h = k;\\n            while(--h)\\n            {\\n                if(mp.count(xp1+1) && mp[xp1+1] >= xp2)\\n                {\\n                    mp[xp1+1] -= xp2;\\n                }\\n                else\\n                    return false;\\n                xp1 = xp1+1;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(int &num : nums)\\n        {\\n            mp[num]++;\\n        }\\n        //vector<int> srt;\\n        for(auto &[fst, snd] : mp)\\n        {\\n            if(snd == 0) continue;\\n            int xp2 = snd;\\n            mp[fst] = 0;\\n            int xp1 = fst;\\n            int h = k;\\n            while(--h)\\n            {\\n                if(mp.count(xp1+1) && mp[xp1+1] >= xp2)\\n                {\\n                    mp[xp1+1] -= xp2;\\n                }\\n                else\\n                    return false;\\n                xp1 = xp1+1;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036108,
                "title": "python-greedy-better-than100-memory",
                "content": "\\n```python\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums) % k != 0:\\n            return False\\n        nums.sort()\\n        resArrs = [[] for _ in range(int(len(nums)/k))]\\n        arrIndex = 0    # Which resulting array to insert into\\n        for num in nums:\\n            if len(resArrs[arrIndex]) == 0 or num != resArrs[arrIndex][-1]:     # Is the number distinct or a duplicate\\n                if len(resArrs[arrIndex]) > 0 and num != resArrs[arrIndex][-1] + 1: # Is it not consecutive\\n                    return False\\n                resArrs[arrIndex].append(num)\\n                dupeIndex = arrIndex + 1\\n                # print(f\"Inserted distinct {num} at {numArrs}\")\\n            else:\\n                if dupeIndex >= len(resArrs) or len(resArrs[dupeIndex]) >= k or (len(resArrs[dupeIndex]) > 0 and resArrs[dupeIndex][-1] + 1 != num):\\n                    return False\\n                resArrs[dupeIndex].append(num)\\n                dupeIndex += 1\\n            if len(resArrs[arrIndex]) == k:\\n                arrIndex += 1\\n                if arrIndex > len(resArrs):\\n                    return False\\n        return arrIndex == int(len(nums)/k)\\n\\t\\t```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums) % k != 0:\\n            return False\\n        nums.sort()\\n        resArrs = [[] for _ in range(int(len(nums)/k))]\\n        arrIndex = 0    # Which resulting array to insert into\\n        for num in nums:\\n            if len(resArrs[arrIndex]) == 0 or num != resArrs[arrIndex][-1]:     # Is the number distinct or a duplicate\\n                if len(resArrs[arrIndex]) > 0 and num != resArrs[arrIndex][-1] + 1: # Is it not consecutive\\n                    return False\\n                resArrs[arrIndex].append(num)\\n                dupeIndex = arrIndex + 1\\n                # print(f\"Inserted distinct {num} at {numArrs}\")\\n            else:\\n                if dupeIndex >= len(resArrs) or len(resArrs[dupeIndex]) >= k or (len(resArrs[dupeIndex]) > 0 and resArrs[dupeIndex][-1] + 1 != num):\\n                    return False\\n                resArrs[dupeIndex].append(num)\\n                dupeIndex += 1\\n            if len(resArrs[arrIndex]) == k:\\n                arrIndex += 1\\n                if arrIndex > len(resArrs):\\n                    return False\\n        return arrIndex == int(len(nums)/k)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2013519,
                "title": "100-c-explaination-picture-clear-codeo-nlog-n",
                "content": "\\nclass Solution {\\npublic:\\n\\n    bool isPossibleDivide(vector<int>& v, int k) {\\n\\t\\n        unordered_map<int,int> m;\\n        //stored the frequencies of the elements.\\n        int i=0;\\n        while(i<v.size()){\\n            m[v[i]]++;\\n            i++;\\n        }\\n        \\n        //sort the vector.\\n        sort(v.begin(),v.end());\\n        \\n        //traverse the vector,\\n        //go through each element,if that element is not in the map\\n        //that implies that element is already gotten used, and i++;\\n        //if that element is in the map.\\n        //then run for the k next numbers ,delete them, \\n        //if not found ,return false,because its suposed to be found.\\n        i=0;\\n        while(i<v.size()){\\n            if(!(m.find(v[i])==m.end())){\\n                int count=0;\\n                int x=v[i];\\n                while(count<k){\\n                    if(!(m.find(x)==m.end())){\\n                        count++;\\n                        m[x]--;\\n                        if(m[x]==0){\\n                            m.erase(x);\\n                        }\\n                        x++;\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n                \\n                i++;\\n                \\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n};\\n\\n![image](https://assets.leetcode.com/users/images/693082e3-7a26-4d6e-ad1e-ac47a1561568_1651900480.6858733.jpeg)\\n\\n//upvote it if you understood the approch , it motivates me to post.\\n//do comment if you want to discuss,",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isPossibleDivide(vector<int>& v, int k) {\\n\\t\\n        unordered_map<int,int> m;\\n        //stored the frequencies of the elements.\\n        int i=0;\\n        while(i<v.size()){\\n            m[v[i]]++;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2000414,
                "title": "java-topological-sort-o-n-solution",
                "content": "The idea is simple. If a number x exist but x - 1 doesn\\'t exist in the array, then there is no dependency for x, x should be a start number. We caculate the x, x+1, ..., x+k-1. If any number doesn\\'t have depedency, we can make it a start number. \\n\\nFor example,\\n[1,2,2,3,3,3,4,4,5,9,10,11], k = 3\\nFor 1, there is no 0, so 1 should be a start number.\\nFor 9, there is no 8, so 9 should be a start number.\\n\\nThen, based on start number 1, we could remove 1,2,3. And the array item become [2,3,3,4,4,5,9,10,11]\\nAnd we noticed that after remove 1, the only 2 doesn\\'t have dependency, so this 2 can be a start number again.\\n\\nThis result in a topological sort.\\n\\n```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        for (Integer key : map.keySet()) {\\n            if (!map.containsKey(key - 1)) {\\n                q.offer(key);\\n            }\\n        }\\n        \\n        int count = 0;\\n        while (!q.isEmpty()) {\\n            int start = q.poll();\\n            for (int i = start; i < start + k; i++) {\\n                int rest = map.getOrDefault(i, 0);\\n                if (rest == 0) {\\n                    return false;\\n                }\\n                count++;\\n                map.put(i, rest - 1);\\n                if (map.get(i) == 0) {\\n                    map.remove(i);\\n                }\\n                else {\\n                    if (!map.containsKey(i - 1)) {\\n                        q.offer(i);\\n                    }    \\n                }\\n            }\\n            if (map.containsKey(start + k) && !map.containsKey(start + k - 1)) {\\n                q.offer(start + k);\\n            }\\n        }\\n        return count == nums.length;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        for (Integer key : map.keySet()) {\\n            if (!map.containsKey(key - 1)) {\\n                q.offer(key);\\n            }\\n        }\\n        \\n        int count = 0;\\n        while (!q.isEmpty()) {\\n            int start = q.poll();\\n            for (int i = start; i < start + k; i++) {\\n                int rest = map.getOrDefault(i, 0);\\n                if (rest == 0) {\\n                    return false;\\n                }\\n                count++;\\n                map.put(i, rest - 1);\\n                if (map.get(i) == 0) {\\n                    map.remove(i);\\n                }\\n                else {\\n                    if (!map.containsKey(i - 1)) {\\n                        q.offer(i);\\n                    }    \\n                }\\n            }\\n            if (map.containsKey(start + k) && !map.containsKey(start + k - 1)) {\\n                q.offer(start + k);\\n            }\\n        }\\n        return count == nums.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975681,
                "title": "leetcode-test-cases-is-so-stupid",
                "content": "Many Of the Problems in leetCode is not hard but the l**eetcode owners** **add** so many frustrating **stupid test cases**, not to mention many **leetcoders** **add** many  **stupid test cases** just **to** **EARN COIN**. And it is so frustrating because you already know how to solve it, but these stupid test cases and the stupid debug machenism just get in the way. If you think leetcode should remove these stupid test case because someone add them just to earn coin, please up vote this post. Thank you.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1973749,
                "title": "c-easy-map-solution",
                "content": "\\'\\'\\'\\n\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!mp[nums[i]])\\n            {\\n                continue;\\n            }\\n                \\n            for(int j=0;j<k;j++)\\n            {\\n                if(mp[nums[i]+j])\\n                {\\n                    mp[nums[i]+j]--;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!mp[nums[i]])\\n            {\\n                continue;\\n            }\\n                \\n            for(int j=0;j<k;j++)\\n            {\\n                if(mp[nums[i]+j])\\n                {\\n                    mp[nums[i]+j]--;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1936137,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting && Unordered map***\\n\\n* ***Time Complexity : O(NlogN)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp[nums[i]] == 0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                int prev = nums[i];\\n                \\n                mp[prev]--;\\n                \\n                int count = k;\\n                \\n                count--;\\n                \\n                while(count--)\\n                {\\n                    int curr = prev + 1;\\n                    \\n                    if(mp[curr] == 0)\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    else\\n                    {\\n                        mp[curr]--;\\n                        \\n                        prev = curr;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp[nums[i]] == 0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                int prev = nums[i];\\n                \\n                mp[prev]--;\\n                \\n                int count = k;\\n                \\n                count--;\\n                \\n                while(count--)\\n                {\\n                    int curr = prev + 1;\\n                    \\n                    if(mp[curr] == 0)\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    else\\n                    {\\n                        mp[curr]--;\\n                        \\n                        prev = curr;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836927,
                "title": "java-hashmap-sort",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length%k!=0){\\n            return false;\\n        }\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        for(int ele:nums){\\n            if(map.get(ele)>0){\\n                map.put(ele,map.get(ele)-1);\\n                for(int i=1;i<k;i++){\\n                    if(map.getOrDefault(ele+i,0)>0){\\n                        map.put(ele+i,map.get(ele+i)-1);\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length%k!=0){\\n            return false;\\n        }\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        for(int ele:nums){\\n            if(map.get(ele)>0){\\n                map.put(ele,map.get(ele)-1);\\n                for(int i=1;i<k;i++){\\n                    if(map.getOrDefault(ele+i,0)>0){\\n                        map.put(ele+i,map.get(ele+i)-1);\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708568,
                "title": "c-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        //array should get divided\\n        \\n        //use ordered hashmap  O(NlogN)\\n        map<int,int> mp;\\n        for(auto it: nums) mp[it]++;\\n        \\n        while(mp.size())  //O(N) -> as n elements are there\\n        {\\n            vector<int> temp;\\n            for(auto it=mp.begin(); it!=mp.end() && temp.size()<k; it++)\\n            {\\n                if(temp.size() && it->first!=temp.back()+1) return false; //not consecutive\\n                \\n                temp.push_back(it->first);\\n                mp[it->first]--;\\n                if(mp[it->first]==0) mp.erase(it->first);\\n            }\\n            if(temp.size()<k) return false;  //when set of size k is not completed \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        //array should get divided\\n        \\n        //use ordered hashmap  O(NlogN)\\n        map<int,int> mp;\\n        for(auto it: nums) mp[it]++;\\n        \\n        while(mp.size())  //O(N) -> as n elements are there\\n        {\\n            vector<int> temp;\\n            for(auto it=mp.begin(); it!=mp.end() && temp.size()<k; it++)\\n            {\\n                if(temp.size() && it->first!=temp.back()+1) return false; //not consecutive\\n                \\n                temp.push_back(it->first);\\n                mp[it->first]--;\\n                if(mp[it->first]==0) mp.erase(it->first);\\n            }\\n            if(temp.size()<k) return false;  //when set of size k is not completed \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680293,
                "title": "easy-to-understand-java-treemap-53-with-comments",
                "content": "1. We dont really need to create space to store the lists or arrays, we only need to check if the consequtive element is present or not until k times.\\n2. We get the first entry from the treemap and then check for consequtive element keys in the treemap, reducing their values by 1 in the process and removing them if their value becomes 0.\\n3. the outer loop only needs to run for ( nums.length / k ) times, while the inner loop only runs for k - 1 times.\\n4. the inner loop checks for the consequtive entries after we have taken out the initial element key.\\n\\nP.S. Can someone please help me out with the time complexity? I think it should be O(logN) + O(N/K + (K-1) * LogN) ~= O(NLogN). Is that correct?\\n\\nSpace Complexity: O(N) for the TreeMap\\n\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length % k != 0) return false; // if the length of nums is not perfectly divisible by k then straightup return false\\n      \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i: nums) map.put(i, map.getOrDefault(i, 0)+1); //map the elements and their frequencies\\n        \\n        for(int i = 0; i < nums.length/k; i++) {\\n            Map.Entry<Integer, Integer> first = map.pollFirstEntry(); //get the first entry from the map\\n    \\n            map.put(first.getKey(), first.getValue()-1); // reduce value by 1 and put it back in the map\\n            int temp = first.getKey(); // store the key in a temp variable as we will need it later\\n            \\n            if(map.get(temp) == 0) map.remove(temp); // remove the key pair from the map\\n \\n            for(int j = 1; j < k; j++) { // since we already took one entry out, run the loop till k-1\\n                temp += 1; // this value is to check for consequtives after we have gotten the first key\\n                if(!map.containsKey(temp))\\n                    return false; // if the consecutive value is not in the map then return false\\n                else {\\n                    int con_key = temp;\\n                    map.put(con_key, map.get(con_key)-1); // reduce the value of the consequtive number and put it back in the map\\n                    if(map.get(con_key) == 0) map.remove(con_key); // remove the consequtive key pair if value if 0\\n                }\\n            }\\n        }\\n        return true; //if everything passes then return true\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length % k != 0) return false; // if the length of nums is not perfectly divisible by k then straightup return false\\n      \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i: nums) map.put(i, map.getOrDefault(i, 0)+1); //map the elements and their frequencies\\n        \\n        for(int i = 0; i < nums.length/k; i++) {\\n            Map.Entry<Integer, Integer> first = map.pollFirstEntry(); //get the first entry from the map\\n    \\n            map.put(first.getKey(), first.getValue()-1); // reduce value by 1 and put it back in the map\\n            int temp = first.getKey(); // store the key in a temp variable as we will need it later\\n            \\n            if(map.get(temp) == 0) map.remove(temp); // remove the key pair from the map\\n \\n            for(int j = 1; j < k; j++) { // since we already took one entry out, run the loop till k-1\\n                temp += 1; // this value is to check for consequtives after we have gotten the first key\\n                if(!map.containsKey(temp))\\n                    return false; // if the consecutive value is not in the map then return false\\n                else {\\n                    int con_key = temp;\\n                    map.put(con_key, map.get(con_key)-1); // reduce the value of the consequtive number and put it back in the map\\n                    if(map.get(con_key) == 0) map.remove(con_key); // remove the consequtive key pair if value if 0\\n                }\\n            }\\n        }\\n        return true; //if everything passes then return true\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678832,
                "title": "easy-to-understand-very-simple-and-straightforward-solution-o-n-logn-java",
                "content": "In the hashmap we record existing incomplete result with the length. \\nWhen we meet a number i in A, we check if there is incomplete result for i-1 in the map.\\nIf so, we get the first length (it will be the longest), we add 1 to the length to see if length == k.\\n-->If so, it\\'s complete and we can eliminate this result.\\n-->Else, we add (length + 1) to i in the map.\\n*For example, [1 2 3 3 4]\\nThe map will be:\\n1 {1: [1]}\\n2 {2: [2]}\\n3 {3: [3]}\\n3 {3: [3, 1]}\\n4 {3: [1]}*\\nIf the array can be divided into groups of k, the map will contain nothing after we loop through the array.\\n\\n\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] A, int k) {\\n        Arrays.sort(A);\\n        HashMap<Integer, List<Integer>> map = new HashMap();\\n        for (int i : A){\\n            if (map.containsKey(i-1)){\\n                int currLen = map.get(i-1).get(0);\\n                map.get(i-1).remove(0);\\n                if (map.get(i-1).size()==0) map.remove(i-1);\\n                if (currLen == k - 1) continue;\\n                map.putIfAbsent(i, new ArrayList());\\n                map.get(i).add(currLen + 1);\\n            } else {\\n                map.putIfAbsent(i, new ArrayList());\\n                map.get(i).add(1);\\n            }\\n        }\\n        return map.size()==0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] A, int k) {\\n        Arrays.sort(A);\\n        HashMap<Integer, List<Integer>> map = new HashMap();\\n        for (int i : A){\\n            if (map.containsKey(i-1)){\\n                int currLen = map.get(i-1).get(0);\\n                map.get(i-1).remove(0);\\n                if (map.get(i-1).size()==0) map.remove(i-1);\\n                if (currLen == k - 1) continue;\\n                map.putIfAbsent(i, new ArrayList());\\n                map.get(i).add(currLen + 1);\\n            } else {\\n                map.putIfAbsent(i, new ArrayList());\\n                map.get(i).add(1);\\n            }\\n        }\\n        return map.size()==0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662078,
                "title": "java-39ms-91-41",
                "content": "```\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        \\n        if(k == 1 || nums.length % k != 0) {\\n            return k == 1;\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        LinkedList<int[]> queue = new LinkedList<>();\\n        for(int n : nums) {\\n            \\n            if(queue.isEmpty() || queue.getFirst()[1] == n){\\n                queue.add(new int[] {n, n});\\n                continue;\\n            }\\n            \\n            if(queue.getFirst()[1] != n - 1) {\\n                return false;\\n            }\\n            \\n            int[] arr = queue.getFirst();\\n            queue.removeFirst();\\n                \\n            arr[1] = n;\\n            if(arr[1] - arr[0] + 1 < k) {\\n                queue.add(arr);\\n            }\\n        }\\n        \\n        return queue.isEmpty();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        \\n        if(k == 1 || nums.length % k != 0) {\\n            return k == 1;\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        LinkedList<int[]> queue = new LinkedList<>();\\n        for(int n : nums) {\\n            \\n            if(queue.isEmpty() || queue.getFirst()[1] == n){\\n                queue.add(new int[] {n, n});\\n                continue;\\n            }\\n            \\n            if(queue.getFirst()[1] != n - 1) {\\n                return false;\\n            }\\n            \\n            int[] arr = queue.getFirst();\\n            queue.removeFirst();\\n                \\n            arr[1] = n;\\n            if(arr[1] - arr[0] + 1 < k) {\\n                queue.add(arr);\\n            }\\n        }\\n        \\n        return queue.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598302,
                "title": "c-using-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if(nums.size()%k != 0)return false;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]]>0){\\n                int temp = 1;\\n                mp[nums[i]]--;\\n                while(temp!=k){\\n                    int val = nums[i]+temp;\\n                    if(mp[val]>0){\\n                        mp[val]--;\\n                    }else{\\n                        return false;\\n                    }\\n                    temp++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if(nums.size()%k != 0)return false;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1409214,
                "title": "c-straightforward",
                "content": "We have two observations:\\n* if `nums.size() % k != 0`, we can return `false` directly\\n* otherwise, the smallest number must be the starting number of the first the k-tuple. \\n\\nThus, if the smallest number is `a`, we know the first k-tuple to remove is `(a, a+1, ..., a+k-1)`. Remove it and we are left with `nums.size()-k` numbers. We can repeat this process until `nums` is empty.\\n\\nIn the implementation, we leverage a `freq` map to record the frequency of numbers. With C++\\'s default `map` implementation (tree), we can get the smallest number by `freq.begin()`.\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n\\t\\t// time O(N), space O(N)\\n        if (nums.size() % k != 0) {\\n            return false;\\n        }\\n        // generate freq map\\n        map<int, int> freq;\\n        for (int x : nums) {\\n            auto it = freq.find(x);\\n            if (it == freq.end()) {\\n                freq[x] = 1;\\n            }\\n            else {\\n                it->second += 1;\\n            }\\n        }\\n        // remove k-tuple of consecutive numbers everytime, until freq is empty\\n        while (not freq.empty()) {\\n            int startNum = freq.begin()->first;\\n            for (int i = 0; i < k; ++i) {\\n                auto it = freq.find(startNum + i);\\n                if (it == freq.end() or it->second == 0) {\\n                    return false;\\n                }\\n                else if (it->second == 1) {\\n                    freq.erase(it);\\n                }\\n                else {\\n                    it->second -= 1;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n\\t\\t// time O(N), space O(N)\\n        if (nums.size() % k != 0) {\\n            return false;\\n        }\\n        // generate freq map\\n        map<int, int> freq;\\n        for (int x : nums) {\\n            auto it = freq.find(x);\\n            if (it == freq.end()) {\\n                freq[x] = 1;\\n            }\\n            else {\\n                it->second += 1;\\n            }\\n        }\\n        // remove k-tuple of consecutive numbers everytime, until freq is empty\\n        while (not freq.empty()) {\\n            int startNum = freq.begin()->first;\\n            for (int i = 0; i < k; ++i) {\\n                auto it = freq.find(startNum + i);\\n                if (it == freq.end() or it->second == 0) {\\n                    return false;\\n                }\\n                else if (it->second == 1) {\\n                    freq.erase(it);\\n                }\\n                else {\\n                    it->second -= 1;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391790,
                "title": "c-hashmap-faster-than-95-40",
                "content": "```\\n sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int count=0,p=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]]>0){\\n                mp[nums[i]]--;\\n                count++;\\n                while(mp.find(nums[i]+1)!=mp.end()&&count<k&&mp[nums[i]+1]>0){\\n                    count++;\\n                    mp[nums[i]+1]--;\\n                    nums[i]=nums[i]+1;\\n                }\\n                if(count==k){\\n                    p++;\\n                    count=0;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return nums.size()%p==0;\\n        \\n        \\n       \\n    }\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int count=0,p=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]]>0){\\n                mp[nums[i]]--;\\n                count++;\\n                while(mp.find(nums[i]+1)!=mp.end()&&count<k&&mp[nums[i]+1]>0){\\n                    count++;\\n                    mp[nums[i]+1]--;\\n                    nums[i]=nums[i]+1;\\n                }\\n                if(count==k){\\n                    p++;\\n                    count=0;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return nums.size()%p==0;\\n        \\n        \\n       \\n    }\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382942,
                "title": "js-easy",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar isPossibleDivide = function(nums, k) {\\n    const numsCount = nums.length\\n    \\n    if((numsCount % k) !== 0) {  \\n        return false\\n    }\\n\\n    if(numsCount === k) { \\n        for(let i = 0; i < numsCount; i++) {        \\n            if(nums[i]+1 !== nums[i+1]) {\\n                return false\\n            }           \\n        }\\n\\n        return true\\n    }\\n  \\n    nums = nums.sort((a,b ) => a -b)         \\n    \\n    for(let j = 0; j < numsCount / k; j++) {        \\n        let pre = [-1]\\n        for(let i = 0, counter = k; i < counter; i++) {   \\n        \\t\\n          \\n        \\twhile(nums[i] === -1 || nums[i] === pre[0]) {\\n          \\tcounter++\\n            i++\\n          }          \\n          let rem = nums.splice(i,1,-1)\\n          \\n          if(pre[0] !== -1 && pre[0]+1 !== rem[0]) {\\n          \\treturn false\\n          }\\n          \\n          pre = rem\\n        }\\n    }\\n \\n   \\n  return true\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar isPossibleDivide = function(nums, k) {\\n    const numsCount = nums.length\\n    \\n    if((numsCount % k) !== 0) {  \\n        return false\\n    }\\n\\n    if(numsCount === k) { \\n        for(let i = 0; i < numsCount; i++) {        \\n            if(nums[i]+1 !== nums[i+1]) {\\n                return false\\n            }           \\n        }\\n\\n        return true\\n    }\\n  \\n    nums = nums.sort((a,b ) => a -b)         \\n    \\n    for(let j = 0; j < numsCount / k; j++) {        \\n        let pre = [-1]\\n        for(let i = 0, counter = k; i < counter; i++) {   \\n        \\t\\n          \\n        \\twhile(nums[i] === -1 || nums[i] === pre[0]) {\\n          \\tcounter++\\n            i++\\n          }          \\n          let rem = nums.splice(i,1,-1)\\n          \\n          if(pre[0] !== -1 && pre[0]+1 !== rem[0]) {\\n          \\treturn false\\n          }\\n          \\n          pre = rem\\n        }\\n    }\\n \\n   \\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1320783,
                "title": "java-treemap-greedy-t-c-o-nlogn-s-c-o-n",
                "content": "\\n\\t// TreeMap + Greedy\\n\\t// O(NlogN) O(N)\\n\\tpublic boolean isPossibleDivide1(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tif (len % k != 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n\\t\\twhile (!map.isEmpty()) {\\n\\n\\t\\t\\tint min = map.firstKey();\\n\\t\\t\\tfor (int i = 0; i < k - 1; i++) {\\n\\t\\t\\t\\tif (!map.containsKey(min + 1))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tint freq = map.get(min);\\n\\t\\t\\t\\tmap.put(min, freq - 1);\\n\\t\\t\\t\\tif (freq - 1 == 0)\\n\\t\\t\\t\\t\\tmap.remove(min);\\n\\t\\t\\t\\tmin++;\\n\\t\\t\\t}\\n\\t\\t\\tint freq = map.get(min);\\n\\t\\t\\tmap.put(min, freq - 1);\\n\\t\\t\\tif (freq - 1 == 0)\\n\\t\\t\\t\\tmap.remove(min);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// TreeMap + Greedy\\n\\t// O(NlogN) O(N)\\n\\tpublic boolean isPossibleDivide1(int[] nums, int k) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tif (len % k != 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n\\t\\twhile (!map.isEmpty()) {\\n\\n\\t\\t\\tint min = map.firstKey();\\n\\t\\t\\tfor (int i = 0; i < k - 1; i++) {\\n\\t\\t\\t\\tif (!map.containsKey(min + 1))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tint freq = map.get(min);\\n\\t\\t\\t\\tmap.put(min, freq - 1);\\n\\t\\t\\t\\tif (freq - 1 == 0)\\n\\t\\t\\t\\t\\tmap.remove(min);\\n\\t\\t\\t\\tmin++;\\n\\t\\t\\t}\\n\\t\\t\\tint freq = map.get(min);\\n\\t\\t\\tmap.put(min, freq - 1);\\n\\t\\t\\tif (freq - 1 == 0)\\n\\t\\t\\t\\tmap.remove(min);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1246676,
                "title": "c-solution-using-set-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k)\\n    {\\n        if(nums.size()%k!=0)\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n         set<int,greater<int> >st;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            st.insert(nums[i]);\\n            mp[nums[i]]++;\\n        }\\n     \\n        int count=nums.size()/k;\\n        \\n        for(auto x: st)\\n        {\\n           \\n            if(count==0)\\n            {\\n                break;\\n            }\\n            int req=mp[x];\\n            if(req==0)\\n            {\\n                continue;\\n            }\\n            int ele=x;\\n            for(int i=ele;i>ele-k;i--)\\n            {\\n                if(mp[i]<req)\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    mp[i]=mp[i]-req;\\n                }\\n            }\\n            count--;\\n           // mp.erase(ele);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k)\\n    {\\n        if(nums.size()%k!=0)\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n         set<int,greater<int> >st;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            st.insert(nums[i]);\\n            mp[nums[i]]++;\\n        }\\n     \\n        int count=nums.size()/k;\\n        \\n        for(auto x: st)\\n        {\\n           \\n            if(count==0)\\n            {\\n                break;\\n            }\\n            int req=mp[x];\\n            if(req==0)\\n            {\\n                continue;\\n            }\\n            int ele=x;\\n            for(int i=ele;i>ele-k;i--)\\n            {\\n                if(mp[i]<req)\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    mp[i]=mp[i]-req;\\n                }\\n            }\\n            count--;\\n           // mp.erase(ele);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204380,
                "title": "c-map-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        map<int,int>pq;\\n        if(nums.size() %k != 0)\\n            return false;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            pq[nums[i]]++;\\n        }\\n        int number = nums.size()/k;\\n        for(int i = 1;i<=number;i++)\\n        {\\n           auto it = pq.begin();\\n           int val = it->first;\\n           for(int j = val;j<val+k;j++)\\n           {\\n               if(pq.find(j) == pq.end())\\n                   return false;\\n               pq[j]--;\\n               if(pq[j] == 0)\\n                   pq.erase(j);\\n           }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        map<int,int>pq;\\n        if(nums.size() %k != 0)\\n            return false;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            pq[nums[i]]++;\\n        }\\n        int number = nums.size()/k;\\n        for(int i = 1;i<=number;i++)\\n        {\\n           auto it = pq.begin();\\n           int val = it->first;\\n           for(int j = val;j<val+k;j++)\\n           {\\n               if(pq.find(j) == pq.end())\\n                   return false;\\n               pq[j]--;\\n               if(pq[j] == 0)\\n                   pq.erase(j);\\n           }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069948,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if(len(nums)%k):\\n            return False\\n        import collections\\n        oc = collections.OrderedDict()\\n        oc.update(collections.Counter(sorted(nums)))\\n        while(oc):\\n            s,t = oc.popitem(False)\\n            if(0>t):\\n                return False\\n            elif(0==t):\\n                continue\\n            else:\\n                for i in range(1,k):\\n                    oc[s+i] = oc.get(s+i,0) - t\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if(len(nums)%k):\\n            return False\\n        import collections\\n        oc = collections.OrderedDict()\\n        oc.update(collections.Counter(sorted(nums)))\\n        while(oc):\\n            s,t = oc.popitem(False)\\n            if(0>t):\\n                return False\\n            elif(0==t):\\n                continue\\n            else:\\n                for i in range(1,k):\\n                    oc[s+i] = oc.get(s+i,0) - t\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991348,
                "title": "straight-forward-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n = nums.size(); if (n % k) return false;\\n        \\n        if (k == 1) return true;\\n        \\n        map<int, int> count;\\n        \\n        for (const auto& num : nums)  count[num]++;\\n\\n        while (!count.empty()) {\\n            int first = count.begin()->first;\\n            \\n            for (int i = 0; i < k; i++) {\\n                if (count.find(first) == count.end()) return false;\\n                \\n                count[first]--; if (count[first] == 0) count.erase(first);\\n                \\n                first++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n = nums.size(); if (n % k) return false;\\n        \\n        if (k == 1) return true;\\n        \\n        map<int, int> count;\\n        \\n        for (const auto& num : nums)  count[num]++;\\n\\n        while (!count.empty()) {\\n            int first = count.begin()->first;\\n            \\n            for (int i = 0; i < k; i++) {\\n                if (count.find(first) == count.end()) return false;\\n                \\n                count[first]--; if (count[first] == 0) count.erase(first);\\n                \\n                first++;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960974,
                "title": "python-easy-counter-solution",
                "content": "We maintain a counter that counts the items in the nums list. \\n\\nWhile the counter is not empty, \\nwe iteratively decrease the number of the minimum value item m in the counter,\\nthen the m + 1, ..., m + k - 1.\\nIf we can not do so (some item is not in the counter), we return False, \\nif we can do so, we return True.\\n\\n```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        dict_a = Counter(nums)\\n        while dict_a:\\n\\t\\t    \"\"\"\\n\\t\\t\\tm is the minimum value in the counter.\\n\\t\\t\\t\"\"\"\\n            m = min(dict_a)\\n            for i in range(k):\\n                if m in dict_a:\\n\\t\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\t\\tif we can decrease the number of m in the counter, we decrease it. \\n\\t\\t\\t\\t\\t\"\"\"\\n                    dict_a[m] -= 1\\n                    if dict_a[m] == 0:\\n                        del dict_a[m]\\n                else:\\n                    return False\\n                m = m + 1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        dict_a = Counter(nums)\\n        while dict_a:\\n\\t\\t    \"\"\"\\n\\t\\t\\tm is the minimum value in the counter.\\n\\t\\t\\t\"\"\"\\n            m = min(dict_a)\\n            for i in range(k):\\n                if m in dict_a:\\n\\t\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\t\\tif we can decrease the number of m in the counter, we decrease it. \\n\\t\\t\\t\\t\\t\"\"\"\\n                    dict_a[m] -= 1\\n                    if dict_a[m] == 0:\\n                        del dict_a[m]\\n                else:\\n                    return False\\n                m = m + 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917758,
                "title": "java-solution-using-map-and-priorityqueue-approach-similar-to-task-scheduler",
                "content": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums.length == 0 || nums.length % k != 0) {\\n            return false;\\n        }\\n        \\n        Map<Integer, Integer> digitToCount = new HashMap<>();\\n        for (int n : nums) {\\n            int count = digitToCount.getOrDefault(n, 0);\\n            digitToCount.put(n, count + 1);\\n        }\\n        \\n        List<List<Integer>> sets = new ArrayList<>();\\n        for (int j = 0; j < nums.length / k; j++) {\\n            sets.add(new ArrayList<>());\\n        }\\n        \\n        PriorityQueue<Integer> queue = new PriorityQueue<>((n1, n2) -> {\\n            return n1 - n2;\\n        });\\n        queue.addAll(digitToCount.keySet());\\n        \\n        for (List<Integer> s : sets) {\\n            Set<Integer> usedDigits = new HashSet<>();\\n            \\n            while (s.size() != k && !queue.isEmpty()) {                \\n                int digit = queue.poll();\\n                \\n                if (s.isEmpty() || s.get(s.size() - 1) == digit - 1) {\\n                    s.add(digit);\\n                    int count = digitToCount.get(digit);\\n                    digitToCount.put(digit, count - 1);\\n                }\\n                \\n                if (digitToCount.get(digit) > 0) {\\n                    usedDigits.add(digit);\\n                }\\n            }\\n            \\n            if (s.size() != k) {\\n                return false;\\n            }\\n            \\n            queue.addAll(usedDigits);\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums.length == 0 || nums.length % k != 0) {\\n            return false;\\n        }\\n        \\n        Map<Integer, Integer> digitToCount = new HashMap<>();\\n        for (int n : nums) {\\n            int count = digitToCount.getOrDefault(n, 0);\\n            digitToCount.put(n, count + 1);\\n        }\\n        \\n        List<List<Integer>> sets = new ArrayList<>();\\n        for (int j = 0; j < nums.length / k; j++) {\\n            sets.add(new ArrayList<>());\\n        }\\n        \\n        PriorityQueue<Integer> queue = new PriorityQueue<>((n1, n2) -> {\\n            return n1 - n2;\\n        });\\n        queue.addAll(digitToCount.keySet());\\n        \\n        for (List<Integer> s : sets) {\\n            Set<Integer> usedDigits = new HashSet<>();\\n            \\n            while (s.size() != k && !queue.isEmpty()) {                \\n                int digit = queue.poll();\\n                \\n                if (s.isEmpty() || s.get(s.size() - 1) == digit - 1) {\\n                    s.add(digit);\\n                    int count = digitToCount.get(digit);\\n                    digitToCount.put(digit, count - 1);\\n                }\\n                \\n                if (digitToCount.get(digit) > 0) {\\n                    usedDigits.add(digit);\\n                }\\n            }\\n            \\n            if (s.size() != k) {\\n                return false;\\n            }\\n            \\n            queue.addAll(usedDigits);\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 914247,
                "title": "python-o-n-log-n",
                "content": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n\\t    if k==1: return True\\n        nums=sorted(nums)\\n        map={}\\n        # key : value\\n        # largest consecutive number found: list of count of total consecutive numbers\\n        # e.g. [1 2 2 3 3 4, 4]\\n        # map = {1:[1]} # found 1\\n        # map = {2: [2]} # found 1,2\\n        # map = {2: [2, 1]} # found 1,2 and 2\\n        # map = {2: [2], 3:[2]} # found 1,2 and 2,3\\n        # map = {3: [2, 3]} # found 2, 3 and 1,2,3\\n        # map = {3: [2], 4:[4]} # found 2, 3 and 1,2,3,4\\n        # map = {4:[4, 3]} # found 2,3,4 and 1,2,3,4\\n        for n in nums:\\n            if n-1 in map and map[n-1]:\\n                # previous number found in map\\n                if n not in map: map[n] = []\\n                map[n] += [map[n-1][-1]+1]\\n                del map[n-1][-1]\\n                if map[n][-1]==k: del map[n][-1]\\n            else:\\n                # previous number not found in map\\n                if n not in map : map[n] = []\\n                map[n] += [1]\\n\\n        return True if all([len(v)==0 for v in map.values()]) else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n\\t    if k==1: return True\\n        nums=sorted(nums)\\n        map={}\\n        # key : value\\n        # largest consecutive number found: list of count of total consecutive numbers\\n        # e.g. [1 2 2 3 3 4, 4]\\n        # map = {1:[1]} # found 1\\n        # map = {2: [2]} # found 1,2\\n        # map = {2: [2, 1]} # found 1,2 and 2\\n        # map = {2: [2], 3:[2]} # found 1,2 and 2,3\\n        # map = {3: [2, 3]} # found 2, 3 and 1,2,3\\n        # map = {3: [2], 4:[4]} # found 2, 3 and 1,2,3,4\\n        # map = {4:[4, 3]} # found 2,3,4 and 1,2,3,4\\n        for n in nums:\\n            if n-1 in map and map[n-1]:\\n                # previous number found in map\\n                if n not in map: map[n] = []\\n                map[n] += [map[n-1][-1]+1]\\n                del map[n-1][-1]\\n                if map[n][-1]==k: del map[n][-1]\\n            else:\\n                # previous number not found in map\\n                if n not in map : map[n] = []\\n                map[n] += [1]\\n\\n        return True if all([len(v)==0 for v in map.values()]) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856103,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if(nums.size()%k!=0)\\n            return false;\\n        int i,j;\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(i=0;i<n;i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        vector<int> adj[n/k];\\n        for(auto it:m)\\n        {\\n            int a=it.first;\\n            int b=it.second;\\n            for(i=0;i<n/k;i++)\\n            {\\n                if(adj[i].size()==0 || (adj[i].size()<k && adj[i][adj[i].size()-1]==a-1))\\n                    break;\\n            }\\n            int size=n/k-i;\\n            if(size<b)\\n                return false;\\n            while(b>0)\\n            {\\n                if(adj[i].size()>0 && adj[i][adj[i].size()-1]!=a-1)\\n                    return false;\\n                adj[i].push_back(a);\\n                b--;\\n                i++;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if(nums.size()%k!=0)\\n            return false;\\n        int i,j;\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(i=0;i<n;i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        vector<int> adj[n/k];\\n        for(auto it:m)\\n        {\\n            int a=it.first;\\n            int b=it.second;\\n            for(i=0;i<n/k;i++)\\n            {\\n                if(adj[i].size()==0 || (adj[i].size()<k && adj[i][adj[i].size()-1]==a-1))\\n                    break;\\n            }\\n            int size=n/k-i;\\n            if(size<b)\\n                return false;\\n            while(b>0)\\n            {\\n                if(adj[i].size()>0 && adj[i][adj[i].size()-1]!=a-1)\\n                    return false;\\n                adj[i].push_back(a);\\n                b--;\\n                i++;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853216,
                "title": "c-o-n-solution",
                "content": "Here is my idea:\\n1. Iterate through collection and store numer and occuerence in Sorted Dictionary. (Add - O(logn))\\n2. Iterate through collection till the count is Zero. Get First() element and see if all numbers from First to \\'First+k\\' exist. If exist reduce the occurence. Remove from collection, when occurence is 1 or going to be zero. (Remove - O(logn))\\n\\n```\\npublic class Solution {\\n    public bool IsPossibleDivide(int[] nums, int k) {\\n        int L = nums == null? 0 : nums.Length;\\n        \\n        if(L % k != 0) return false;\\n        \\n        SortedDictionary<int, int> map = new SortedDictionary<int, int>();\\n        foreach(var num in nums){\\n            if(!map.ContainsKey(num)){\\n                map.Add(num,0);\\n            }\\n            map[num]++;\\n        }\\n\\n        while(map.Count > 0){\\n            var val = map.First();\\n            for(int start = val.Key; start < val.Key+k; start++){\\n                if(!map.ContainsKey(start)) return false;\\n                if(map[start] == 1){\\n                    map.Remove(start);\\n                }else{\\n                    map[start]--;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPossibleDivide(int[] nums, int k) {\\n        int L = nums == null? 0 : nums.Length;\\n        \\n        if(L % k != 0) return false;\\n        \\n        SortedDictionary<int, int> map = new SortedDictionary<int, int>();\\n        foreach(var num in nums){\\n            if(!map.ContainsKey(num)){\\n                map.Add(num,0);\\n            }\\n            map[num]++;\\n        }\\n\\n        while(map.Count > 0){\\n            var val = map.First();\\n            for(int start = val.Key; start < val.Key+k; start++){\\n                if(!map.ContainsKey(start)) return false;\\n                if(map[start] == 1){\\n                    map.Remove(start);\\n                }else{\\n                    map[start]--;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832730,
                "title": "java-simple-solution-array-sorting-hashmap-time-o-nlogn-space-o-n-beats-94-time",
                "content": "**Algorithm used:**\\n1. Sort the given Array -> nums\\n2. Put all numbers from the nums array as the key and their respective frequency/count as the value in a HashMap\\n3. Iterate over the array once starting from the first element (smallest, as we have sorted). For each element (let\\'s say, curr), find (curr+1), (curr+2), .........., (curr+k-1). \\n4. Whenever you find any element, decrease it\\'s count in the hashmap by 1.\\n5. If you are not able to find any element as any point, just return false. If all goes well, return true. \\n\\n**Code with properly explained comments:**\\n\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        // If total elements in nums is not a multiple of k, we can\\'t create equal partitions, so we return false\\n        if(nums.length%k!=0){\\n            return false;\\n        }\\n        // if k==1, we can create partitions of length=1, so we return true\\n        if(k==1){\\n            return true;\\n        }\\n        \\n        // First, we sort the array elements in ascending order to access elements sequence wise as we need to check for consecutive numbers.\\n        Arrays.sort(nums);\\n        \\n        // We will store the count of all numbers in a hashmap.\\n        HashMap<Integer,Integer> numCountMap = new HashMap<>();\\n        \\n        // updating count of every numbers in nums array\\n        for(int i : nums){\\n            numCountMap.put(i,numCountMap.getOrDefault(i,0)+1);\\n        }\\n        \\n        // Now, let\\'s iterate over nums array once and find all partitions with consecutive numbers\\n        for(int i=0;i<nums.length;i++){\\n            \\n            // we take the current number in curr variable and then we try to lookup (curr+1), (curr+2), (curr+2), ...... (curr+k-1). \\n            \\n            int curr = nums[i];\\n            \\n            //While looking up in hashmap, if we get count of curr as 0, we need not do anything as the curr has already been processed and it\\'s count has been exhausted. So, we proceed to next number in num.\\n            if(numCountMap.get(curr)<=0){\\n                continue;\\n            }\\n            else{\\n                // else we have a positive count for curr, so we just decrease the curr\\'s count and proceed on to find (curr+1), (curr+2), (curr+2), ...... (curr+k-1)\\n                numCountMap.put(curr,numCountMap.get(curr)-1);\\n                \\n                // starting this loop from 1 as we already got one valid number, that is, curr\\n\\t\\t\\t\\t// We will run this loop k times as our partition length which we need to make is k\\n                for(int j=1;j<k;j++){\\n                    // similarly if we found (curr+j) in our hashmap and it has a valid count, we will decrease it\\'s count and move to next iteration to find(curr+j+1)\\n                    if(numCountMap.containsKey(curr+j) && numCountMap.get(curr+j)>0){\\n                        numCountMap.put(curr+j,numCountMap.get(curr+j)-1);\\n                    }\\n                    \\n                    // else we will just return false\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // all is good till here so we return true\\n        return true;\\n    }\\n}\\n```\\n\\nLet me know if anything remains unclear, I will try to clear your doubts. Thanks!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        // If total elements in nums is not a multiple of k, we can\\'t create equal partitions, so we return false\\n        if(nums.length%k!=0){\\n            return false;\\n        }\\n        // if k==1, we can create partitions of length=1, so we return true\\n        if(k==1){\\n            return true;\\n        }\\n        \\n        // First, we sort the array elements in ascending order to access elements sequence wise as we need to check for consecutive numbers.\\n        Arrays.sort(nums);\\n        \\n        // We will store the count of all numbers in a hashmap.\\n        HashMap<Integer,Integer> numCountMap = new HashMap<>();\\n        \\n        // updating count of every numbers in nums array\\n        for(int i : nums){\\n            numCountMap.put(i,numCountMap.getOrDefault(i,0)+1);\\n        }\\n        \\n        // Now, let\\'s iterate over nums array once and find all partitions with consecutive numbers\\n        for(int i=0;i<nums.length;i++){\\n            \\n            // we take the current number in curr variable and then we try to lookup (curr+1), (curr+2), (curr+2), ...... (curr+k-1). \\n            \\n            int curr = nums[i];\\n            \\n            //While looking up in hashmap, if we get count of curr as 0, we need not do anything as the curr has already been processed and it\\'s count has been exhausted. So, we proceed to next number in num.\\n            if(numCountMap.get(curr)<=0){\\n                continue;\\n            }\\n            else{\\n                // else we have a positive count for curr, so we just decrease the curr\\'s count and proceed on to find (curr+1), (curr+2), (curr+2), ...... (curr+k-1)\\n                numCountMap.put(curr,numCountMap.get(curr)-1);\\n                \\n                // starting this loop from 1 as we already got one valid number, that is, curr\\n\\t\\t\\t\\t// We will run this loop k times as our partition length which we need to make is k\\n                for(int j=1;j<k;j++){\\n                    // similarly if we found (curr+j) in our hashmap and it has a valid count, we will decrease it\\'s count and move to next iteration to find(curr+j+1)\\n                    if(numCountMap.containsKey(curr+j) && numCountMap.get(curr+j)>0){\\n                        numCountMap.put(curr+j,numCountMap.get(curr+j)-1);\\n                    }\\n                    \\n                    // else we will just return false\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // all is good till here so we return true\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831846,
                "title": "python-using-dict-o-nlogn-n-beats-98",
                "content": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        count = collections.defaultdict(int)\\n        nums.sort()\\n        for n in nums:\\n            if count[n] == 0:\\n                for i in range(1,k):\\n                    count[n+i] += 1\\n            else:\\n                count[n] -= 1\\n        for c in count.values():\\n            if c>0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        count = collections.defaultdict(int)\\n        nums.sort()\\n        for n in nums:\\n            if count[n] == 0:\\n                for i in range(1,k):\\n                    count[n+i] += 1\\n            else:\\n                count[n] -= 1\\n        for c in count.values():\\n            if c>0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823828,
                "title": "c-91-solution",
                "content": "class Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        ios_base::sync_with_stdio(false); \\n    cin.tie(NULL);\\n        if(nums.size()%k!=0)\\n            return false;\\n        map<int,int> m;\\n        map<int,int> :: iterator ptr;\\n        map<int,int > ::  iterator  ptr1;\\n        int i,j;\\n        for(j=0;j<nums.size();j++)\\n        {\\n            m[nums[j]]++;\\n        }\\n        for(ptr=m.begin();ptr!=m.end();++ptr)\\n        {\\n            \\n            \\n            ptr1=ptr;\\n            int a=ptr->first;\\n            int b=ptr->second;\\n            int l=0;\\n            if(b!=0)\\n            while(l!=k && ptr1!=m.end())\\n            {\\n                ptr1->second=ptr1->second-b;\\n               \\n                if(ptr1->second<0)\\n                    return false;\\n                if(ptr1->first!=a+l)\\n                    return false;\\n                l++;\\n                ptr1++;\\n                if(ptr1==m.end() && l!=k)\\n                    return false;\\n                    \\n                \\n            }\\n           \\n            \\n      \\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        ios_base::sync_with_stdio(false); \\n    cin.tie(NULL);\\n        if(nums.size()%k!=0)\\n            return false;\\n        map<int,int> m;\\n        map<int,int> :: iterator ptr;\\n        map<int,int > ::  iterator  ptr1;\\n        int i,j;\\n        for(j=0;j<nums.size();j++)\\n        {\\n            m[nums[j]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 796083,
                "title": "java-runtime-94-memory-usage-96",
                "content": "``` \\npublic boolean isPossibleDivide(int[] nums, int k){\\n        if(nums.length % k != 0){\\n            return false;\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            map.put(nums[i], map.getOrDefault(nums[i], 0)+1);\\n        }\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < n; i++){\\n            int num = nums[i];\\n            if(map.size() == 0){\\n                break;\\n            }\\n            if(map.containsKey(num)){\\n                for(int j = 0; j < k; j++){\\n                    Integer freq = map.get(num);\\n                    if(freq == null){\\n                        return false;\\n                    }\\n                    if(freq == 1){\\n                        map.remove(num);\\n                    }else{\\n                        map.put(num, freq-1);\\n                    }\\n                    num++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "``` \\npublic boolean isPossibleDivide(int[] nums, int k){\\n        if(nums.length % k != 0){\\n            return false;\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            map.put(nums[i], map.getOrDefault(nums[i], 0)+1);\\n        }\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < n; i++){\\n            int num = nums[i];\\n            if(map.size() == 0){\\n                break;\\n            }\\n            if(map.containsKey(num)){\\n                for(int j = 0; j < k; j++){\\n                    Integer freq = map.get(num);\\n                    if(freq == null){\\n                        return false;\\n                    }\\n                    if(freq == 1){\\n                        map.remove(num);\\n                    }else{\\n                        map.put(num, freq-1);\\n                    }\\n                    num++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 788882,
                "title": "how-about-this-solution-no-iterator-no-queue",
                "content": "I think this is ```O(nlogn + n)``` time complexity solution. Could anyone confirm this?\\n\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        \\n        if (k < 0) return false;\\n        \\n        if (k <= 1) return true;\\n        \\n        if (nums.length % k != 0) return false;\\n        \\n        // O(nlogn)\\n        Arrays.sort(nums);\\n\\n        Map<Integer,Integer> map = new HashMap();\\n        // O(n)\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if (!map.containsKey(nums[i]))\\n                map.put(nums[i], 0);\\n            map.put(nums[i], map.get(nums[i])+1);\\n        }\\n        \\n        int prev = -1;\\n        \\n        // O(n) : In every iteration we consume k nums. This should\\n\\t\\t// stop when total numbers consumed are n.\\n        for (int i = 0; i < (nums.length - k + 1); i++)\\n        {\\n            if (nums[i] == prev || map.get(nums[i]) <= 0)\\n                continue;\\n            int cnt = map.get(nums[i]);\\n            int j = 0;\\n            int next = nums[i];\\n            while (j < k)\\n            {\\n                if (!map.containsKey(next) || map.get(next) < cnt)\\n                    return false;\\n                map.put(next, map.get(next) - cnt);\\n                j++;\\n                next++;\\n            }            \\n            prev = nums[i];\\n        }\\n        \\n        // unconsumed\\n        for (int i = nums.length - k + 1; i < (nums.length); i++)\\n        {\\n            if (map.get(nums[i]) > 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```O(nlogn + n)```\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        \\n        if (k < 0) return false;\\n        \\n        if (k <= 1) return true;\\n        \\n        if (nums.length % k != 0) return false;\\n        \\n        // O(nlogn)\\n        Arrays.sort(nums);\\n\\n        Map<Integer,Integer> map = new HashMap();\\n        // O(n)\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if (!map.containsKey(nums[i]))\\n                map.put(nums[i], 0);\\n            map.put(nums[i], map.get(nums[i])+1);\\n        }\\n        \\n        int prev = -1;\\n        \\n        // O(n) : In every iteration we consume k nums. This should\\n\\t\\t// stop when total numbers consumed are n.\\n        for (int i = 0; i < (nums.length - k + 1); i++)\\n        {\\n            if (nums[i] == prev || map.get(nums[i]) <= 0)\\n                continue;\\n            int cnt = map.get(nums[i]);\\n            int j = 0;\\n            int next = nums[i];\\n            while (j < k)\\n            {\\n                if (!map.containsKey(next) || map.get(next) < cnt)\\n                    return false;\\n                map.put(next, map.get(next) - cnt);\\n                j++;\\n                next++;\\n            }            \\n            prev = nums[i];\\n        }\\n        \\n        // unconsumed\\n        for (int i = nums.length - k + 1; i < (nums.length); i++)\\n        {\\n            if (map.get(nums[i]) > 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785364,
                "title": "o-n-log-n-time-and-o-n-space-python3-using-hashmap-and-lists",
                "content": "The intuition is to maintain an expectation map which stores the expected value as key to a list of hands that are expecting this value as the next consecutive number.\\n```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        hand = nums\\n        W = k\\n        if not hand and W > 0:\\n            return False\\n        if W > len(hand):\\n            return False\\n        if W == 0 or W == 1: \\n            return True\\n        expectation_map = {}\\n        # self.count keep track of the numbers of cards that have been successfully counted as a straight,\\n        # when self.count == len(hand) => All cards are part of a valid straight \\n        self.count = 0\\n        handLength = len(hand)\\n\\n        #Sort the hand.\\n        sortedHand = sorted(hand)\\n\\n        \\n        \"\"\"\\n        This method updates the expectation map in the following way:\\n            a) If the len(l) == W\\n                    => We\\'ve completed a straight of length W, add it towards the final count\\n            b) if the next expected number (num+1) is already in the map \\n                    => add the list to a queue of hands waiting to make a straight\\n            c) if expected number (num+1) not in the map \\n                    => Add a new expectation key with value as a new queue with this list \\n        \"\"\"\\n        def update_expectation_with_list(expectation_map, num, l, W):\\n            # If we have W consecutive numbers, we\\'re done with this set, count towards final count\\n            if len(l) == W:\\n                self.count += W\\n            # we need more numbers to make this straight, add back with next expected num \\n            else:\\n                exp = num + 1\\n                # Some other list is already expecting this number, add to the queue\\n                if exp in expectation_map:\\n                    expectation_map[exp].append(l)\\n\\n                # New expected number, create new key and set [l] as value\\n                else:\\n                    expectation_map[exp] = [l]\\n        \\n        \"\"\"\\n        Very similar to update_expectation_with_list. The difference here is we have the first card of the straight and thus we need to handle it correctly (set the value as a list of lists)\\n        \"\"\"\\n        def update_expectation_with_integer(expectation_map, num):\\n            exp = num + 1\\n            # Some other list is already expecting this number, add to the queue\\n            if exp in expectation_map:\\n                expectation_map[exp].append([num])\\n            # New expected number, create new key and set [num] as value\\n            else:\\n                expectation_map[exp] = [[num]]\\n        \\n        for idx,num in enumerate(sortedHand):\\n            # A possible straight can be formed with this number\\n            if num in expectation_map:\\n                # there are multiple hands waiting for this number\\n                if len(expectation_map[num]) > 1:\\n                    # pop the first hand\\n                    l = expectation_map[num].pop(0)\\n                    # add num to this hand\\n                    l.append(num)\\n                    # Update the expectation map\\n                    update_expectation_with_list(expectation_map, num, l, W)\\n                \\n                # there\\'s only one hand expecting this number\\n                else:\\n                    # pop the first hand\\n                    l = expectation_map[num].pop(0)\\n                    l.append(num)\\n\\n                    # Important : del the key! There\\'s no other hand expecting this number\\n                    expectation_map.pop(num) \\n                    update_expectation_with_list(expectation_map, num, l, W)\\n                    \\n            # Nothing is expecting this number, add new expectation to the map\\n            else:\\n                update_expectation_with_integer(expectation_map, num)\\n                \\n        return self.count == handLength\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        hand = nums\\n        W = k\\n        if not hand and W > 0:\\n            return False\\n        if W > len(hand):\\n            return False\\n        if W == 0 or W == 1: \\n            return True\\n        expectation_map = {}\\n        # self.count keep track of the numbers of cards that have been successfully counted as a straight,\\n        # when self.count == len(hand) => All cards are part of a valid straight \\n        self.count = 0\\n        handLength = len(hand)\\n\\n        #Sort the hand.\\n        sortedHand = sorted(hand)\\n\\n        \\n        \"\"\"\\n        This method updates the expectation map in the following way:\\n            a) If the len(l) == W\\n                    => We\\'ve completed a straight of length W, add it towards the final count\\n            b) if the next expected number (num+1) is already in the map \\n                    => add the list to a queue of hands waiting to make a straight\\n            c) if expected number (num+1) not in the map \\n                    => Add a new expectation key with value as a new queue with this list \\n        \"\"\"\\n        def update_expectation_with_list(expectation_map, num, l, W):\\n            # If we have W consecutive numbers, we\\'re done with this set, count towards final count\\n            if len(l) == W:\\n                self.count += W\\n            # we need more numbers to make this straight, add back with next expected num \\n            else:\\n                exp = num + 1\\n                # Some other list is already expecting this number, add to the queue\\n                if exp in expectation_map:\\n                    expectation_map[exp].append(l)\\n\\n                # New expected number, create new key and set [l] as value\\n                else:\\n                    expectation_map[exp] = [l]\\n        \\n        \"\"\"\\n        Very similar to update_expectation_with_list. The difference here is we have the first card of the straight and thus we need to handle it correctly (set the value as a list of lists)\\n        \"\"\"\\n        def update_expectation_with_integer(expectation_map, num):\\n            exp = num + 1\\n            # Some other list is already expecting this number, add to the queue\\n            if exp in expectation_map:\\n                expectation_map[exp].append([num])\\n            # New expected number, create new key and set [num] as value\\n            else:\\n                expectation_map[exp] = [[num]]\\n        \\n        for idx,num in enumerate(sortedHand):\\n            # A possible straight can be formed with this number\\n            if num in expectation_map:\\n                # there are multiple hands waiting for this number\\n                if len(expectation_map[num]) > 1:\\n                    # pop the first hand\\n                    l = expectation_map[num].pop(0)\\n                    # add num to this hand\\n                    l.append(num)\\n                    # Update the expectation map\\n                    update_expectation_with_list(expectation_map, num, l, W)\\n                \\n                # there\\'s only one hand expecting this number\\n                else:\\n                    # pop the first hand\\n                    l = expectation_map[num].pop(0)\\n                    l.append(num)\\n\\n                    # Important : del the key! There\\'s no other hand expecting this number\\n                    expectation_map.pop(num) \\n                    update_expectation_with_list(expectation_map, num, l, W)\\n                    \\n            # Nothing is expecting this number, add new expectation to the map\\n            else:\\n                update_expectation_with_integer(expectation_map, num)\\n                \\n        return self.count == handLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778233,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>&v,int k){\\n        if(v.size()%k!=0) return false;\\n        sort(v.begin(),v.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<v.size();i++) mp[v[i]]++;\\n        for(int i=0;i<v.size();i++){\\n            int val=v[i];\\n            if(mp[val]==0) continue;\\n            mp[val]--;\\n            for(int j=1;j<k;j++){\\n                val++;\\n                if(mp[val]==0) return false;\\n                mp[val]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>&v,int k){\\n        if(v.size()%k!=0) return false;\\n        sort(v.begin(),v.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<v.size();i++) mp[v[i]]++;\\n        for(int i=0;i<v.size();i++){\\n            int val=v[i];\\n            if(mp[val]==0) continue;\\n            mp[val]--;\\n            for(int j=1;j<k;j++){\\n                val++;\\n                if(mp[val]==0) return false;\\n                mp[val]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765117,
                "title": "very-easy-with-a-dictionary",
                "content": "```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def get_min_key(d):\\n            min_key = float(\"inf\")\\n            for key in d.keys():\\n                if d[key] > 0 and key < min_key:\\n                    min_key = key\\n            return min_key\\n\\n        if len(nums) % k != 0 or max(nums)-min(nums) < k-1:\\n            return False\\n        \\n        d = {}\\n        \\n        for num in nums:\\n            try:\\n                d[num] += 1\\n            except:\\n                d[num] = 1\\n            \\n        while get_min_key(d) < float(\"inf\"):\\n            min_so_far = get_min_key(d)\\n            for i in range(k):\\n                try:\\n                    if d[min_so_far] == 0:\\n                        return False\\n                    else:\\n                        d[min_so_far] -= 1\\n                        min_so_far += 1\\n                except:\\n                    return False\\n        return get_min_key(d) == float(\"inf\")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def get_min_key(d):\\n            min_key = float(\"inf\")\\n            for key in d.keys():\\n                if d[key] > 0 and key < min_key:\\n                    min_key = key\\n            return min_key\\n\\n        if len(nums) % k != 0 or max(nums)-min(nums) < k-1:\\n            return False\\n        \\n        d = {}\\n        \\n        for num in nums:\\n            try:\\n                d[num] += 1\\n            except:\\n                d[num] = 1\\n            \\n        while get_min_key(d) < float(\"inf\"):\\n            min_so_far = get_min_key(d)\\n            for i in range(k):\\n                try:\\n                    if d[min_so_far] == 0:\\n                        return False\\n                    else:\\n                        d[min_so_far] -= 1\\n                        min_so_far += 1\\n                except:\\n                    return False\\n        return get_min_key(d) == float(\"inf\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745621,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if(nums.size()%k!=0)return false;\\n        map<int,int> freq_map;\\n        int tot_ele = nums.size();\\n        for(auto & n : nums){\\n            freq_map[n]++;\\n        }\\n        \\n        vector<int> check;\\n        while(tot_ele>0){\\n            std::map<int,int>::iterator it = freq_map.begin();\\n            for(int i=0; i<k; ++i , ++it ){\\n                if(it->second>0){\\n                    check.push_back(it->first);\\n                    it->second--;\\n                    --tot_ele;\\n                }else if (it->second==0){\\n                    freq_map.erase(it->first);\\n                    --i;\\n                }\\n            }\\n        }\\n        \\n        int j;\\n        for(int i=0; i<check.size(); i=j)\\n            for(j =i+1; j<i+k; ++j)\\n                if(check[j]-check[j-1]!=1)\\n                    return false;\\n                \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if(nums.size()%k!=0)return false;\\n        map<int,int> freq_map;\\n        int tot_ele = nums.size();\\n        for(auto & n : nums){\\n            freq_map[n]++;\\n        }\\n        \\n        vector<int> check;\\n        while(tot_ele>0){\\n            std::map<int,int>::iterator it = freq_map.begin();\\n            for(int i=0; i<k; ++i , ++it ){\\n                if(it->second>0){\\n                    check.push_back(it->first);\\n                    it->second--;\\n                    --tot_ele;\\n                }else if (it->second==0){\\n                    freq_map.erase(it->first);\\n                    --i;\\n                }\\n            }\\n        }\\n        \\n        int j;\\n        for(int i=0; i<check.size(); i=j)\\n            for(j =i+1; j<i+k; ++j)\\n                if(check[j]-check[j-1]!=1)\\n                    return false;\\n                \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740631,
                "title": "very-simple-accepted-python-solution-using-greedy-approach",
                "content": "Idea : Firstly create a Hashmap which contains the frequency of every element then,\\n* iterate that Hashmap until it has atleast K elements inorder to break the array in a set of K length.\\n* start variable has the minimum element of the remaining array elements to start from.\\n* lastly, check that all elements from start to start +k are present or not in the remaining availabale elements, if not return False.\\n```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        nums_dic = collections.defaultdict(int)\\n        for num in nums:\\n            nums_dic[num] += 1\\n        count = len(nums)\\n        while len(nums_dic) > 0:\\n            if count < k:return False\\n            start = min(nums_dic.keys())\\n            for i in range(k):\\n                if start in nums_dic:\\n                    count -= 1\\n                    nums_dic[start] -= 1\\n                    if nums_dic[start] == 0: del nums_dic[start]\\n                else:\\n                    return False\\n                start += 1\\n        return True if len(nums_dic) == 0 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        nums_dic = collections.defaultdict(int)\\n        for num in nums:\\n            nums_dic[num] += 1\\n        count = len(nums)\\n        while len(nums_dic) > 0:\\n            if count < k:return False\\n            start = min(nums_dic.keys())\\n            for i in range(k):\\n                if start in nums_dic:\\n                    count -= 1\\n                    nums_dic[start] -= 1\\n                    if nums_dic[start] == 0: del nums_dic[start]\\n                else:\\n                    return False\\n                start += 1\\n        return True if len(nums_dic) == 0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666816,
                "title": "c-inspired-from-659",
                "content": "Basically, we keep the counts for each number. If we have to start a new group, count the all the k numbers at once. The numbers have to be sorted so we know if we have to start a new group or not.\\n```\\nbool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        if(nums.size()%k!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        for(auto n:nums) freq[n]++;\\n        for(auto n:nums){\\n            if(freq[n]>0){\\n                int c = freq[n];\\n                for(int j=n+k-1;j>=n;--j) {\\n                    freq[j]-=c;\\n                    if(freq[j]<0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\\ntime O(nlogn)\\nspace O(n)",
                "solutionTags": [],
                "code": "```\\nbool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        if(nums.size()%k!=0) return false;\\n        sort(nums.begin(),nums.end());\\n        for(auto n:nums) freq[n]++;\\n        for(auto n:nums){\\n            if(freq[n]>0){\\n                int c = freq[n];\\n                for(int j=n+k-1;j>=n;--j) {\\n                    freq[j]-=c;\\n                    if(freq[j]<0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 650680,
                "title": "java-o-nlogn-greedy-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length%k!=0) return false;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int num : nums){\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        }\\n        \\n        while(map.size()>0){\\n            int smallest = map.firstKey();\\n            for(int i=0;i<k;i++){\\n                int temp = smallest+i;\\n                if(!map.containsKey(temp)) return false;\\n                map.put(temp,map.get(temp)-1);\\n                if(map.get(temp)==0) map.remove(temp);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length%k!=0) return false;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int num : nums){\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        }\\n        \\n        while(map.size()>0){\\n            int smallest = map.firstKey();\\n            for(int i=0;i<k;i++){\\n                int temp = smallest+i;\\n                if(!map.containsKey(temp)) return false;\\n                map.put(temp,map.get(temp)-1);\\n                if(map.get(temp)==0) map.remove(temp);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644998,
                "title": "c-ordered-map-same-as-846",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if (n % k != 0) return false;\\n        \\n        int ssize = n/k;\\n        map<int, int>hm;\\n        for (int i = 0; i < n; i++)\\n            hm[nums[i]]++;\\n        \\n        for (auto it = hm.begin(); it != hm.end(); it++) {\\n            if (hm[it->first] > 0) {\\n                for (int i = k-1; i >= 0; i--) {\\n                    hm[it->first+i] -= hm[it->first];\\n                    if (hm[it->first+i] < 0)\\n                        return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if (n % k != 0) return false;\\n        \\n        int ssize = n/k;\\n        map<int, int>hm;\\n        for (int i = 0; i < n; i++)\\n            hm[nums[i]]++;\\n        \\n        for (auto it = hm.begin(); it != hm.end(); it++) {\\n            if (hm[it->first] > 0) {\\n                for (int i = k-1; i >= 0; i--) {\\n                    hm[it->first+i] -= hm[it->first];\\n                    if (hm[it->first+i] < 0)\\n                        return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635804,
                "title": "add-a-test-case-that-fails-a-lot-of-solutions",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n       if(nums.length % k != 0)\\n           return false;\\n        int[] mod = new int[k];\\n        for(int i=0;i<nums.length;i++) {\\n            mod[nums[i]%k]++;\\n        }\\n        System.out.println(Arrays.toString(mod));\\n        int temp = mod[0];\\n        for(int i=1;i<mod.length;i++) {\\n            if(mod[i]!=temp)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nThis is the fastest non explicilty cheating java solution (the fastest one uses divisibility on sums, which obviously doesn\\'t work but is annoying to construct a failure for and also appears to be a fairly rare solution)\\n\\nThe above code fails for ``nums = [1, 6, 11, 16] k=4``. Please add this test case.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n       if(nums.length % k != 0)\\n           return false;\\n        int[] mod = new int[k];\\n        for(int i=0;i<nums.length;i++) {\\n            mod[nums[i]%k]++;\\n        }\\n        System.out.println(Arrays.toString(mod));\\n        int temp = mod[0];\\n        for(int i=1;i<mod.length;i++) {\\n            if(mod[i]!=temp)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623932,
                "title": "simple-o-n-solution-using-modulo",
                "content": "class Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int i, n = nums.length;\\n        int[] count = new int[k];\\n        \\n        if (n%k!=0)\\n            return false;\\n        \\n        for(i=0;i<nums.length;i++) {\\n            nums[i]%=k;\\n            count[nums[i]]++;\\n        }\\n        \\n        int temp = count[0];\\n        for(i=1;i<k;i++) {\\n            if (temp != count[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int i, n = nums.length;\\n        int[] count = new int[k];\\n        \\n        if (n%k!=0)\\n            return false;\\n        \\n        for(i=0;i<nums.length;i++) {\\n            nums[i]%=k;\\n            count[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 589234,
                "title": "c-o-log-n-n-sorting-o-amount-of-unique-numbers-k",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end()); //O(log(n) * n)\\n        unordered_map<int, int> counter;\\n        set<int> non_rept;\\n        //build hash\\n        \\n        for(int i = 0; i < (int)nums.size(); i++){\\n            counter[nums[i]]++; //O(log(n) * n)\\n            non_rept.insert(nums[i]); //O(log(n) * n)\\n        }\\n        for(auto cur : non_rept){ //O(x non repeated elem) *\\n            if(counter[cur] > 0){\\n                for(int i = 1; i < k; i++){ //O(k) \\n                    if(counter.find(cur + i) != counter.end() and counter[cur + i] >= counter[cur]){\\n                        counter[cur + i]-= counter[cur];\\n                    }else return false;\\n                }\\n                counter[cur] = 0;\\n            }\\n        }\\n        return true;\\n                \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end()); //O(log(n) * n)\\n        unordered_map<int, int> counter;\\n        set<int> non_rept;\\n        //build hash\\n        \\n        for(int i = 0; i < (int)nums.size(); i++){\\n            counter[nums[i]]++; //O(log(n) * n)\\n            non_rept.insert(nums[i]); //O(log(n) * n)\\n        }\\n        for(auto cur : non_rept){ //O(x non repeated elem) *\\n            if(counter[cur] > 0){\\n                for(int i = 1; i < k; i++){ //O(k) \\n                    if(counter.find(cur + i) != counter.end() and counter[cur + i] >= counter[cur]){\\n                        counter[cur + i]-= counter[cur];\\n                    }else return false;\\n                }\\n                counter[cur] = 0;\\n            }\\n        }\\n        return true;\\n                \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560362,
                "title": "c-solution-easy-to-understand-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        if(n%k!=0)\\n            return false;\\n        map<int, int> m;\\n        for(int i=0; i<n; i++)\\n            m[nums[i]]++;\\n        for(auto itr=m.begin(); itr!=m.end(); itr++)\\n            while(itr->second)\\n                for(int i = itr->first; i < itr->first + k; i++)\\n                {\\n                    m[i]--;\\n                    if(m[i] < 0)\\n                        return false;\\n                }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        if(n%k!=0)\\n            return false;\\n        map<int, int> m;\\n        for(int i=0; i<n; i++)\\n            m[nums[i]]++;\\n        for(auto itr=m.begin(); itr!=m.end(); itr++)\\n            while(itr->second)\\n                for(int i = itr->first; i < itr->first + k; i++)\\n                {\\n                    m[i]--;\\n                    if(m[i] < 0)\\n                        return false;\\n                }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554109,
                "title": "easy-java-treemap-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> set = new TreeMap();\\n        \\n        for(int a : nums){\\n            set.put(a, set.getOrDefault(a, 0) + 1);\\n        }\\n        \\n        while(!set.isEmpty()){\\n            Map.Entry firstEntry = set.firstEntry();\\n            int first = (Integer)firstEntry.getKey();\\n            int freq = (Integer)firstEntry.getValue();\\n            set.remove(first);\\n            int count = 1;\\n            for(int i = 1; i < k; i++){\\n                if(!set.containsKey(first+i) || set.get(first+i) < freq){\\n                    return false;\\n                }\\n                if(set.get(first+i) - freq == 0){\\n                    set.remove(first+i);\\n                }else\\n                    set.put(first + i, set.get(first+i) - freq);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> set = new TreeMap();\\n        \\n        for(int a : nums){\\n            set.put(a, set.getOrDefault(a, 0) + 1);\\n        }\\n        \\n        while(!set.isEmpty()){\\n            Map.Entry firstEntry = set.firstEntry();\\n            int first = (Integer)firstEntry.getKey();\\n            int freq = (Integer)firstEntry.getValue();\\n            set.remove(first);\\n            int count = 1;\\n            for(int i = 1; i < k; i++){\\n                if(!set.containsKey(first+i) || set.get(first+i) < freq){\\n                    return false;\\n                }\\n                if(set.get(first+i) - freq == 0){\\n                    set.remove(first+i);\\n                }else\\n                    set.put(first + i, set.get(first+i) - freq);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552700,
                "title": "c-dictionary-solution",
                "content": "```\\npublic class Solution \\n{\\n    public bool IsPossibleDivide(int[] nums, int k)\\n    {\\n        var numMap = new Dictionary<int,int>();\\n        if(nums.Length % k != 0) return false;\\n        \\n        foreach(int num in nums)\\n        {\\n            if(!numMap.ContainsKey(num)) numMap.Add(num , 0);\\n            numMap[num] += 1;\\n        }\\n        \\n        while(numMap.Count() > 0)\\n        {\\n            int key = numMap.Keys.Min();\\n            \\n            for(int i = key; i < key + k; i++)\\n            {                \\n                if(!numMap.ContainsKey(i))\\n                {\\n                    return false;\\n                }\\n                else\\n                {                    \\n                    numMap[i] -= 1;\\n                    if(numMap[i] == 0) numMap.Remove(i);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsPossibleDivide(int[] nums, int k)\\n    {\\n        var numMap = new Dictionary<int,int>();\\n        if(nums.Length % k != 0) return false;\\n        \\n        foreach(int num in nums)\\n        {\\n            if(!numMap.ContainsKey(num)) numMap.Add(num , 0);\\n            numMap[num] += 1;\\n        }\\n        \\n        while(numMap.Count() > 0)\\n        {\\n            int key = numMap.Keys.Min();\\n            \\n            for(int i = key; i < key + k; i++)\\n            {                \\n                if(!numMap.ContainsKey(i))\\n                {\\n                    return false;\\n                }\\n                else\\n                {                    \\n                    numMap[i] -= 1;\\n                    if(numMap[i] == 0) numMap.Remove(i);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552597,
                "title": "swift-hashmap-greedy-solution-beats-100",
                "content": "```\\nclass Solution {\\n    func isPossibleDivide(_ nums: [Int], _ k: Int) -> Bool {\\n        let n = nums.count\\n        guard n % k == 0 else { return false }\\n\\n        var map = [Int:Int]()\\n        for num in nums {\\n            map[num, default: 0] += 1\\n        }\\n        \\n        let keys = map.keys.sorted(by: <)\\n        \\n        for num in keys {\\n            if let count = map[num], count > 0 {\\n                for i in 1..<k {\\n                    guard let val = map[num + i] else { return false }\\n                    map[num + i] = val - count\\n                }\\n            }\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    func isPossibleDivide(_ nums: [Int], _ k: Int) -> Bool {\\n        let n = nums.count\\n        guard n % k == 0 else { return false }\\n\\n        var map = [Int:Int]()\\n        for num in nums {\\n            map[num, default: 0] += 1\\n        }\\n        \\n        let keys = map.keys.sorted(by: <)\\n        \\n        for num in keys {\\n            if let count = map[num], count > 0 {\\n                for i in 1..<k {\\n                    guard let val = map[num + i] else { return false }\\n                    map[num + i] = val - count\\n                }\\n            }\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520744,
                "title": "c-map-solution",
                "content": "```\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n      \\n        std::map<int, int> numsMap; // first is number, second is count\\n        for( const auto& num : nums) \\n            numsMap[num]++;\\n        \\n        while( !numsMap.empty() )\\n        {\\n            auto it = numsMap.begin(); // first element in the map sorted by number\\n            int num = it->first;\\n            it->second--;\\n            if ( it->second == 0 )\\n                numsMap.erase( it );\\n            int n = k-1;\\n            while( n > 0 )\\n            {\\n                auto it = numsMap.find( num + 1);\\n                if ( it == numsMap.end() )\\n                    return false;\\n\\n                it->second--;\\n                if ( it->second == 0 )\\n                      numsMap.erase( it );\\n                --n;\\n                ++num;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        \\n      \\n        std::map<int, int> numsMap; // first is number, second is count\\n        for( const auto& num : nums) \\n            numsMap[num]++;\\n        \\n        while( !numsMap.empty() )\\n        {\\n            auto it = numsMap.begin(); // first element in the map sorted by number\\n            int num = it->first;\\n            it->second--;\\n            if ( it->second == 0 )\\n                numsMap.erase( it );\\n            int n = k-1;\\n            while( n > 0 )\\n            {\\n                auto it = numsMap.find( num + 1);\\n                if ( it == numsMap.end() )\\n                    return false;\\n\\n                it->second--;\\n                if ( it->second == 0 )\\n                      numsMap.erase( it );\\n                --n;\\n                ++num;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515102,
                "title": "interval-data-structure-and-pq-explained-java",
                "content": "This problem has many solutions, but I wanted to present an alternative take.\\n\\nThe general idea is to create the concept of an \"Interval\", which is a class that holds two values: it\\'s length, and the end number. We sort the array, to ensure that we can detect consecutive orders and this will also help us easily find edge cases.\\n\\nTime complexity is O(N) * O(log N), as we loop through the nums N times, and then offer up intervals. I believe a Java PQ is O(log N) but could be wrong.\\n\\nSpace complexity is O(N) at worse, assuming every number gets its own interval in the PQ. eg: 1, 3, 5, 7, 9, k -> 3. \\n\\nThe flow goes as such:\\n\\n1. Sort the input array, as this will help us with later logic\\n2. Create a custom class, Interval, which contains its length and end number from nums.\\n3. Create a custom PQ, which sorts intervals based on end number.\\n4. Loop through the sorted nums array\\n5. For each number, check whether we should create a new interval, or add to the existing one. This is mainly based on a few checks. 1) have we reached a duplicate? If so, we need to start a new interval, as we are no longer seeing consecutive numbers. 2) Are we seeing a new number, but is it not what we expect? For a consecutive interval, we need n == n + 1.  eg: 2, 3, 5 -> not conescutive. This is where our sort comes in, this ensures that this check will give us what we want. \\n6. Otherwise, we are in a valid interval, and we should increment the len and assign a new end number.\\n7. As this happens, we will continously check the pq and poll off any matching candidates. If we know we have a valid interval, and we have already seen these numbers based on our sort guarantee, we can safely eliminate those numbers.\\n8. After all of this is done, we have one final check to see if we have any remaing intervals left which do not match k.\\n9. If all these checks pass, we can return true.\\n\\n        public boolean isPossibleDivide(int[] nums, int k) {\\n            if (nums == null || nums.length == 0) {\\n                return false;\\n            }\\n\\n            Arrays.sort(nums);\\n\\n            // priority queue sorted by end\\n            PriorityQueue<Interval> pq = new PriorityQueue<>((a, b) -> a.end - b.end);\\n\\n            for (int n : nums) {\\n                while (!pq.isEmpty() && pq.peek().len == k) {\\n                   pq.poll();\\n                }\\n\\n                if (pq.isEmpty() || (pq.peek().end == n) || pq.peek().end + 1 != n) {\\n                    pq.offer(new Interval(n, 1));\\n                } else {\\n                    Interval interval = pq.poll();\\n\\n                    interval.end = n;\\n                    interval.len += 1;\\n\\n                    pq.offer(interval);\\n                }\\n\\n            }\\n\\n            while (!pq.isEmpty()) {\\n                if (pq.poll().len != k) {\\n                    return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n\\n        class Interval {\\n            int end;\\n            int len;\\n\\n            Interval(int end, int len) {\\n                this.end = end;\\n                this.len = len;\\n            }\\n        }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "This problem has many solutions, but I wanted to present an alternative take.\\n\\nThe general idea is to create the concept of an \"Interval\", which is a class that holds two values: it\\'s length, and the end number. We sort the array, to ensure that we can detect consecutive orders and this will also help us easily find edge cases.\\n\\nTime complexity is O(N) * O(log N), as we loop through the nums N times, and then offer up intervals. I believe a Java PQ is O(log N) but could be wrong.\\n\\nSpace complexity is O(N) at worse, assuming every number gets its own interval in the PQ. eg: 1, 3, 5, 7, 9, k -> 3. \\n\\nThe flow goes as such:\\n\\n1. Sort the input array, as this will help us with later logic\\n2. Create a custom class, Interval, which contains its length and end number from nums.\\n3. Create a custom PQ, which sorts intervals based on end number.\\n4. Loop through the sorted nums array\\n5. For each number, check whether we should create a new interval, or add to the existing one. This is mainly based on a few checks. 1) have we reached a duplicate? If so, we need to start a new interval, as we are no longer seeing consecutive numbers. 2) Are we seeing a new number, but is it not what we expect? For a consecutive interval, we need n == n + 1.  eg: 2, 3, 5 -> not conescutive. This is where our sort comes in, this ensures that this check will give us what we want. \\n6. Otherwise, we are in a valid interval, and we should increment the len and assign a new end number.\\n7. As this happens, we will continously check the pq and poll off any matching candidates. If we know we have a valid interval, and we have already seen these numbers based on our sort guarantee, we can safely eliminate those numbers.\\n8. After all of this is done, we have one final check to see if we have any remaing intervals left which do not match k.\\n9. If all these checks pass, we can return true.\\n\\n        public boolean isPossibleDivide(int[] nums, int k) {\\n            if (nums == null || nums.length == 0) {\\n                return false;\\n            }\\n\\n            Arrays.sort(nums);\\n\\n            // priority queue sorted by end\\n            PriorityQueue<Interval> pq = new PriorityQueue<>((a, b) -> a.end - b.end);\\n\\n            for (int n : nums) {\\n                while (!pq.isEmpty() && pq.peek().len == k) {\\n                   pq.poll();\\n                }\\n\\n                if (pq.isEmpty() || (pq.peek().end == n) || pq.peek().end + 1 != n) {\\n                    pq.offer(new Interval(n, 1));\\n                } else {\\n                    Interval interval = pq.poll();\\n\\n                    interval.end = n;\\n                    interval.len += 1;\\n\\n                    pq.offer(interval);\\n                }\\n\\n            }\\n\\n            while (!pq.isEmpty()) {\\n                if (pq.poll().len != k) {\\n                    return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n\\n        class Interval {\\n            int end;\\n            int len;\\n\\n            Interval(int end, int len) {\\n                this.end = end;\\n                this.len = len;\\n            }\\n        }\\n",
                "codeTag": "Java"
            },
            {
                "id": 507193,
                "title": "c-solution-beats-99",
                "content": "each sequence can be represented as b+1 ,b+2 ,....b+k for some value of b>=0 .firstly size of array has to be a multiple of k . total no of sequences will be d = l / k,so sum of all the sequences ignoring the base (b) will be s = k*(k+1)/2  * d .now for this array to contain valid sequences there has to be a valid b for all sequences . so sum of all elements (sum) - s has to be a multiple of  k;\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        long long int l = nums.size(), k1=k , sum=0;\\n        for(int i:nums) sum+=i;\\n        long long int d = l/k1 , s = (k1*(k1+1))/2 ;\\n        sum -=s*d;\\n        return (sum % k == 0  &&  l % k == 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        long long int l = nums.size(), k1=k , sum=0;\\n        for(int i:nums) sum+=i;\\n        long long int d = l/k1 , s = (k1*(k1+1))/2 ;\\n        sum -=s*d;\\n        return (sum % k == 0  &&  l % k == 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506664,
                "title": "java-o-n-math-solution",
                "content": "**[This is copied from other\\'s idea.]**\\n**[upate] this will failed case `k = 7, [1, 9, 17, 25, 33, 41, 49]`.  There should be more test cases.**\\nIt\\'s quite simple and I try to explain it here.\\nLogic back this solution is that if we have a K consecutive set, it must be like `[x, x + 1, x + 2,..., x + k - 1]`. That make all number\\'s mod with K will fit into one position in `0, .... , k-1`, which will work in all other K consecutive sets no matter what exact number starting with. In single set, there would be any duplicate number of same mod value. So what we need to do is to loop through `nums` compute mod of K and count. Then check every mod to find whether its value same as `len(nums) / k`. \\n\\nHope this help.\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n % k != 0) return false;\\n        int s = n / k;\\n        int[] c = new int[k];\\n        for(int j : nums) {\\n            c[j % k] ++;\\n        }\\n        \\n        for(int i : c) {\\n            if(i != s) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n % k != 0) return false;\\n        int s = n / k;\\n        int[] c = new int[k];\\n        for(int j : nums) {\\n            c[j % k] ++;\\n        }\\n        \\n        for(int i : c) {\\n            if(i != s) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494580,
                "title": "python-counter-beats-97",
                "content": "```class Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i] = 1\\n        z = sorted(dic)\\n        for i in z:\\n            x = dic[i]\\n            if x > 0:\\n                dic[i] = 0\\n                for j in range(1,k):\\n                    try:\\n                        dic[i+j]-=x\\n                        pass\\n                    except KeyError:\\n                        return False\\n                    if dic[i+j] < 0:\\n                        return False\\n        return True\\n```\\n\\t\\t\\nFirst post, would really like feedback :)",
                "solutionTags": [],
                "code": "```class Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i] = 1\\n        z = sorted(dic)\\n        for i in z:\\n            x = dic[i]\\n            if x > 0:\\n                dic[i] = 0\\n                for j in range(1,k):\\n                    try:\\n                        dic[i+j]-=x\\n                        pass\\n                    except KeyError:\\n                        return False\\n                    if dic[i+j] < 0:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482600,
                "title": "java-arrange-into-2d-matrix-simple-clean-easy-to-understand",
                "content": "**Ideas**\\nIf you can arrange the given numbers into a matrix where rows = N / k and columns = k, then return true\\nUse TreeMap to store the number and occurance by natural ordering\\n\\n**Algorithm**\\n1. Start with the first counter by calling ```map.firstKey()``` \\n2. Update the map by decrementing the occurance or remove entry if occurance is 0\\n3. Until the end of column, if next number is not found, return false\\n4. Update the map by decrementing the occurance or remove entry if occurance is 0\\n5. Repeat #1 through #4 for all next rows\\n6. Return ```true```\\n\\n```\\nprivate TreeMap<Integer, Integer> map;\\n    \\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        final int N = nums.length;\\n        if (N % k > 0) return false;\\n        map = new TreeMap<>();\\n        for(int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);\\n        int rows = N / k, cols = k;\\n        for(int row = 0; row < rows; row++){\\n            int counter = getFirstKeyAndReduceCountOrRemove();\\n            for(int col = 1; col < cols; col++){\\n                counter++;\\n                if (map.get(counter) == null) return false;\\n                reduceCountOrRemove(counter);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private int getFirstKeyAndReduceCountOrRemove(){\\n        int firstKey = map.firstKey();\\n        map.put(firstKey, map.get(firstKey)-1);\\n        if (map.get(firstKey) <= 0) map.remove(firstKey);\\n        return firstKey;\\n    }\\n    \\n    private void reduceCountOrRemove(int key){\\n        map.put(key, map.get(key)-1);\\n        if (map.get(key) <= 0) map.remove(key);\\n    }",
                "solutionTags": [],
                "code": "```map.firstKey()```\n```true```",
                "codeTag": "Unknown"
            },
            {
                "id": 480635,
                "title": "treemap-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n          if(nums.length%k!=0){\\n              return false;\\n          }\\n          TreeMap<Integer,Integer> map = new TreeMap<>();\\n          int res = 0;\\n          for(int ele: nums){\\n              map.put(ele, map.getOrDefault(ele, 0)+1);\\n          }\\n         \\n          while(map.size()!=0){\\n               Integer first = map.firstKey();\\n              \\n               for(int i=0;i<k;i++){\\n                   int ele = first + i;\\n                   if(map.containsKey(ele)==false){\\n                       return false;\\n                   }\\n                   map.put(ele, map.get(ele)-1);\\n                   if(map.get(ele)==0){\\n                       map.remove(ele);\\n                   }\\n               }\\n          }\\n        \\n          return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n          if(nums.length%k!=0){\\n              return false;\\n          }\\n          TreeMap<Integer,Integer> map = new TreeMap<>();\\n          int res = 0;\\n          for(int ele: nums){\\n              map.put(ele, map.getOrDefault(ele, 0)+1);\\n          }\\n         \\n          while(map.size()!=0){\\n               Integer first = map.firstKey();\\n              \\n               for(int i=0;i<k;i++){\\n                   int ele = first + i;\\n                   if(map.containsKey(ele)==false){\\n                       return false;\\n                   }\\n                   map.put(ele, map.get(ele)-1);\\n                   if(map.get(ele)==0){\\n                       map.remove(ele);\\n                   }\\n               }\\n          }\\n        \\n          return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475425,
                "title": "map-priorityqueue",
                "content": "```\\nclass Solution {\\n    // TC -> O(n log n)\\n    // SC -> O(n + n) = O(n)\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        // Number -> Occurence Cnt\\n        Map<Integer, Integer> nMap = new HashMap<>();\\n        \\n        for (int num: nums)\\n            nMap.put(num, nMap.getOrDefault(num, 0) + 1);\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(nMap.keySet());\\n        \\n        while (!pq.isEmpty()) {\\n            int ele = pq.poll();\\n            \\n            int cnt = nMap.get(ele);\\n            if (cnt == 0)\\n                continue;\\n            \\n            for (int i = 0; i < k; i++) {\\n                Integer nextCnt = nMap.get(ele + i);\\n                // Need a minimum of cnt occurence\\n                if (nextCnt == null || nextCnt < cnt) {\\n                    return false;\\n                }\\n                \\n                // Reduce (ele + i) cnt\\n                nMap.put(ele + i, nextCnt - cnt);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    // TC -> O(n log n)\\n    // SC -> O(n + n) = O(n)\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        // Number -> Occurence Cnt\\n        Map<Integer, Integer> nMap = new HashMap<>();\\n        \\n        for (int num: nums)\\n            nMap.put(num, nMap.getOrDefault(num, 0) + 1);\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(nMap.keySet());\\n        \\n        while (!pq.isEmpty()) {\\n            int ele = pq.poll();\\n            \\n            int cnt = nMap.get(ele);\\n            if (cnt == 0)\\n                continue;\\n            \\n            for (int i = 0; i < k; i++) {\\n                Integer nextCnt = nMap.get(ele + i);\\n                // Need a minimum of cnt occurence\\n                if (nextCnt == null || nextCnt < cnt) {\\n                    return false;\\n                }\\n                \\n                // Reduce (ele + i) cnt\\n                nMap.put(ele + i, nextCnt - cnt);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465594,
                "title": "simple-c-code-use-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        multiset<int> a(nums.begin(),nums.end());\\n        while(!a.empty()) {\\n            int top = *a.begin();\\n            for (int i = 0; i < k; ++i) {\\n                auto iter = a.find(top + i);\\n                if (iter == a.end()) return false;\\n                a.erase(iter);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        multiset<int> a(nums.begin(),nums.end());\\n        while(!a.empty()) {\\n            int top = *a.begin();\\n            for (int i = 0; i < k; ++i) {\\n                auto iter = a.find(top + i);\\n                if (iter == a.end()) return false;\\n                a.erase(iter);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462936,
                "title": "c-concise-map-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        map<int, int> nmap;\\n        for(auto i: nums) nmap[i]++;\\n        \\n        for(auto &cur: nmap){\\n            while(true){\\n                int res = del(nmap, cur.first, k);\\n                if(res == 2) return false;\\n                if(res == 1) break;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int del(map<int, int> &nmap, int entry, int len){\\n        for(int i=0; i<len; i++) {\\n            if(nmap[entry+i] == 0 && i==0) return 1;\\n            else if(nmap[entry+i] == 0) return 2;\\n            nmap[entry+i]--;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        map<int, int> nmap;\\n        for(auto i: nums) nmap[i]++;\\n        \\n        for(auto &cur: nmap){\\n            while(true){\\n                int res = del(nmap, cur.first, k);\\n                if(res == 2) return false;\\n                if(res == 1) break;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int del(map<int, int> &nmap, int entry, int len){\\n        for(int i=0; i<len; i++) {\\n            if(nmap[entry+i] == 0 && i==0) return 1;\\n            else if(nmap[entry+i] == 0) return 2;\\n            nmap[entry+i]--;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459381,
                "title": "simple-and-explained-java-solution-using-treemap",
                "content": "I have copied this solution, but put the coments after understanding.\\nIt might help some one like me who is searching for logic of this solution\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        /* if size of array itself is not divisible by k\\n         then it can not be devided so return false */\\n        if(nums.length % k != 0) return false;\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        \\n        /* keep count of each no. */\\n        for(int x: nums)\\n           map.put(x,map.getOrDefault(x,0)+1); \\n        \\n        /* iterate over each key(1,2,3) in map ex : [1 : 2, 2 : 2, 3 : 2] */\\n        for(int n: map.keySet()){\\n            //get count of each key\\n            int curr = map.get(n);\\n            //if count is 0 continue for next number\\n            if(curr == 0) continue;\\n            /* else for the number(n) start from n and go till k+n ie\\n             if no. is 1 and k = 3 then consecutive no. will be 1,2,3\\n             other ex : n = 3 k = 5 : 3,4,5,6,7 */\\n            for(int i = n; i < k + n; i++){\\n                /* if any element of sequence is not in the list or its count is 0\\n                  then return false as this set can not be completed ie array is \\n                 not divisible */\\n                if(!map.containsKey(i) || map.get(i) <= 0)\\n                    return false;\\n                /* else subtract the count of this number as this is included\\n                in the set */\\n                map.put(i,map.get(i) - curr);\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        /* if size of array itself is not divisible by k\\n         then it can not be devided so return false */\\n        if(nums.length % k != 0) return false;\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        \\n        /* keep count of each no. */\\n        for(int x: nums)\\n           map.put(x,map.getOrDefault(x,0)+1); \\n        \\n        /* iterate over each key(1,2,3) in map ex : [1 : 2, 2 : 2, 3 : 2] */\\n        for(int n: map.keySet()){\\n            //get count of each key\\n            int curr = map.get(n);\\n            //if count is 0 continue for next number\\n            if(curr == 0) continue;\\n            /* else for the number(n) start from n and go till k+n ie\\n             if no. is 1 and k = 3 then consecutive no. will be 1,2,3\\n             other ex : n = 3 k = 5 : 3,4,5,6,7 */\\n            for(int i = n; i < k + n; i++){\\n                /* if any element of sequence is not in the list or its count is 0\\n                  then return false as this set can not be completed ie array is \\n                 not divisible */\\n                if(!map.containsKey(i) || map.get(i) <= 0)\\n                    return false;\\n                /* else subtract the count of this number as this is included\\n                in the set */\\n                map.put(i,map.get(i) - curr);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 458887,
                "title": "a-treemap-solution",
                "content": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int n: nums) {\\n            //count map\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        return check(map, k);\\n    }\\n    \\n    boolean check(TreeMap<Integer, Integer> map, int k) {\\n        //System.out.println(map);\\n        if(map.isEmpty()) {\\n            return true;\\n        }\\n        int i=0;\\n        int min = map.firstKey();\\n        for(i=min; i < min+k; i++) {\\n            int count = map.getOrDefault(i, 0);\\n            if(count == 0) {\\n                return false;\\n            } else {\\n                if(count == 1){\\n                    map.remove(i);\\n                } else {\\n                    map.put(i, count-1);\\n                }\\n            }\\n        }\\n        return check(map, k);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int n: nums) {\\n            //count map\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        return check(map, k);\\n    }\\n    \\n    boolean check(TreeMap<Integer, Integer> map, int k) {\\n        //System.out.println(map);\\n        if(map.isEmpty()) {\\n            return true;\\n        }\\n        int i=0;\\n        int min = map.firstKey();\\n        for(i=min; i < min+k; i++) {\\n            int count = map.getOrDefault(i, 0);\\n            if(count == 0) {\\n                return false;\\n            } else {\\n                if(count == 1){\\n                    map.remove(i);\\n                } else {\\n                    map.put(i, count-1);\\n                }\\n            }\\n        }\\n        return check(map, k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458194,
                "title": "100-treemap-time-o-nlogn-and-space-o-n",
                "content": "```\\n   public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length % k !=0) return false;\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for(int i: nums) treeMap.put(i, treeMap.getOrDefault(i, 0) +1);\\n        \\n        while(!treeMap.isEmpty()){\\n            int size = k;\\n            Integer traverse = treeMap.firstKey();\\n            while(size-- > 0){\\n                if(treeMap.get(traverse) == null) return false;\\n                treeMap.put(traverse, treeMap.get(traverse) -1);\\n                if(treeMap.get(traverse) ==0 ) treeMap.remove(traverse);\\n                traverse++;\\n            }\\n        }        \\n        return treeMap.isEmpty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length % k !=0) return false;\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for(int i: nums) treeMap.put(i, treeMap.getOrDefault(i, 0) +1);\\n        \\n        while(!treeMap.isEmpty()){\\n            int size = k;\\n            Integer traverse = treeMap.firstKey();\\n            while(size-- > 0){\\n                if(treeMap.get(traverse) == null) return false;\\n                treeMap.put(traverse, treeMap.get(traverse) -1);\\n                if(treeMap.get(traverse) ==0 ) treeMap.remove(traverse);\\n                traverse++;\\n            }\\n        }        \\n        return treeMap.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457817,
                "title": "javascript-hashmap-solution",
                "content": "```\\nvar isPossibleDivide = function(nums, k) {\\n  let n = nums.length;\\n  if (n % k) {\\n    return false;\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n  \\n  var hs = new Map();\\n  nums.forEach(num => {\\n    let val = hs.get(num) || 0;\\n    hs.set(num, val + 1);\\n  });\\n\\n  for (key of hs.keys()) {\\n    if (hs.get(key)) {\\n      let keyVal = hs.get(key);\\n\\n      for (let i = 0; i < k; i++) {\\n        let next = key + i;\\n        let nextVal = hs.get(next);\\n        if (!hs.has(next) || nextVal < keyVal) {\\n          return false;\\n        }\\n        hs.set(next, nextVal - keyVal)\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPossibleDivide = function(nums, k) {\\n  let n = nums.length;\\n  if (n % k) {\\n    return false;\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n  \\n  var hs = new Map();\\n  nums.forEach(num => {\\n    let val = hs.get(num) || 0;\\n    hs.set(num, val + 1);\\n  });\\n\\n  for (key of hs.keys()) {\\n    if (hs.get(key)) {\\n      let keyVal = hs.get(key);\\n\\n      for (let i = 0; i < k; i++) {\\n        let next = key + i;\\n        let nextVal = hs.get(next);\\n        if (!hs.has(next) || nextVal < keyVal) {\\n          return false;\\n        }\\n        hs.set(next, nextVal - keyVal)\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457659,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> hm = new TreeMap<Integer, Integer>();\\n        if(nums.length % k != 0) return false;\\n        for(int i = 0; i < nums.length; i++){\\n            int count = hm.getOrDefault(nums[i], 0) + 1;\\n            hm.put(nums[i], count);\\n        }\\n        for(int i = 0; i < nums.length / k; i++){\\n            int key = hm.firstKey();\\n            for(int j = 0; j < k; j++){\\n                if(!hm.containsKey(key + j)) return false;\\n                int value = hm.get(key + j);\\n                if(value - 1 == 0) hm.remove(key + j);\\n                else hm.put(key + j, value - 1);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        TreeMap<Integer, Integer> hm = new TreeMap<Integer, Integer>();\\n        if(nums.length % k != 0) return false;\\n        for(int i = 0; i < nums.length; i++){\\n            int count = hm.getOrDefault(nums[i], 0) + 1;\\n            hm.put(nums[i], count);\\n        }\\n        for(int i = 0; i < nums.length / k; i++){\\n            int key = hm.firstKey();\\n            for(int j = 0; j < k; j++){\\n                if(!hm.containsKey(key + j)) return false;\\n                int value = hm.get(key + j);\\n                if(value - 1 == 0) hm.remove(key + j);\\n                else hm.put(key + j, value - 1);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457595,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public bool IsPossibleDivide(int[] nums, int k)\\n    {\\n        var dict = new Dictionary<int, int>();\\n        foreach(var num in nums)\\n        {\\n            if(!dict.ContainsKey(num)) dict[num] = 0;\\n            dict[num]++;\\n        }\\n        \\n        return IsPossibleDivide(dict, k);\\n    }\\n    \\n    public bool IsPossibleDivide(Dictionary<int, int> dict, int k)\\n    {\\n        var count = dict.Values.Sum();\\n        if(count % k != 0) return false;\\n        int min = dict.Keys.Min();\\n        for(int i = min; i < min + k; i++)\\n        {\\n            if(!dict.ContainsKey(i))\\n                return false;\\n            dict[i]--;\\n            if(dict[i] == 0)\\n                dict.Remove(i);\\n        }\\n        \\n        return count == k ? true : IsPossibleDivide(dict, k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsPossibleDivide(int[] nums, int k)\\n    {\\n        var dict = new Dictionary<int, int>();\\n        foreach(var num in nums)\\n        {\\n            if(!dict.ContainsKey(num)) dict[num] = 0;\\n            dict[num]++;\\n        }\\n        \\n        return IsPossibleDivide(dict, k);\\n    }\\n    \\n    public bool IsPossibleDivide(Dictionary<int, int> dict, int k)\\n    {\\n        var count = dict.Values.Sum();\\n        if(count % k != 0) return false;\\n        int min = dict.Keys.Min();\\n        for(int i = min; i < min + k; i++)\\n        {\\n            if(!dict.ContainsKey(i))\\n                return false;\\n            dict[i]--;\\n            if(dict[i] == 0)\\n                dict.Remove(i);\\n        }\\n        \\n        return count == k ? true : IsPossibleDivide(dict, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457584,
                "title": "c-greedy-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& A, int k) {\\n        unordered_map<int, int> mp;\\n        sort(A.begin(), A.end());\\n        for(int i = 0; i < A.size(); i++) {\\n            mp[A[i]]++;\\n        }\\n        for(int i = 0; i < A.size(); i++) {\\n            int v = A[i];\\n            if(mp.find(v) == mp.end())\\n                continue;\\n            for(int j = v; j < v + k; j++) {\\n                if(mp[j] == 0)\\n                    return false;\\n                mp[j]--;\\n                if(mp[j] == 0) {\\n                    mp.erase(j);\\n                }\\n            }\\n        }\\n        return mp.size() == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& A, int k) {\\n        unordered_map<int, int> mp;\\n        sort(A.begin(), A.end());\\n        for(int i = 0; i < A.size(); i++) {\\n            mp[A[i]]++;\\n        }\\n        for(int i = 0; i < A.size(); i++) {\\n            int v = A[i];\\n            if(mp.find(v) == mp.end())\\n                continue;\\n            for(int j = v; j < v + k; j++) {\\n                if(mp[j] == 0)\\n                    return false;\\n                mp[j]--;\\n                if(mp[j] == 0) {\\n                    mp.erase(j);\\n                }\\n            }\\n        }\\n        return mp.size() == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091089,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if (nums.size() % k != 0) return false;\\n        if (k == 1) return true;\\n        sort(nums.begin(), nums.end());\\n        // each lower number must attach to a consectutive higher number\\n        // for each number we can look at if there is a lower one to attach to\\n        // otherwise it can start a new chain\\n        unordered_map<int, vector<int>> m;\\n        for (auto& n : nums){\\n            int prev = n - 1;\\n            if (m.find(prev) != m.end()){\\n                int r = m[prev].back();\\n                m[prev].pop_back();\\n                if (m[prev].empty()) m.erase(n-1);\\n                if (++r != k){\\n                    m[n].push_back(r);\\n                }\\n            }\\n            else m[n].push_back(1);\\n        }\\n        return m.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if (nums.size() % k != 0) return false;\\n        if (k == 1) return true;\\n        sort(nums.begin(), nums.end());\\n        // each lower number must attach to a consectutive higher number\\n        // for each number we can look at if there is a lower one to attach to\\n        // otherwise it can start a new chain\\n        unordered_map<int, vector<int>> m;\\n        for (auto& n : nums){\\n            int prev = n - 1;\\n            if (m.find(prev) != m.end()){\\n                int r = m[prev].back();\\n                m[prev].pop_back();\\n                if (m[prev].empty()) m.erase(n-1);\\n                if (++r != k){\\n                    m[n].push_back(r);\\n                }\\n            }\\n            else m[n].push_back(1);\\n        }\\n        return m.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079929,
                "title": "unordered-map-and-sorting-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        for(int i=0;i<size(nums);i++){\\n            map[nums[i]]++;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<size(nums);i++){\\n            if(map[nums[i]]<=0)\\n            continue;\\n            int y=nums[i];\\n            map[y]--;\\n            for (int j=0;j<k-1;j++){\\n                y++;\\n                if(map[y]<=0)\\n                return 0;\\n                map[y]--;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        for(int i=0;i<size(nums);i++){\\n            map[nums[i]]++;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<size(nums);i++){\\n            if(map[nums[i]]<=0)\\n            continue;\\n            int y=nums[i];\\n            map[y]--;\\n            for (int j=0;j<k-1;j++){\\n                y++;\\n                if(map[y]<=0)\\n                return 0;\\n                map[y]--;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066318,
                "title": "o-n-log-n-solution-not-iterating-over-k-only-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince I could not find a solution that does not iterate over k, I thought I would try it myself, and it was possible with only iterating over the counter.\\n\\nWhile numbers and their counts are iterated, there are three failure cases.\\n\\n1. There are not enough occurences of a number in sequence.\\n   - For example, in `[1, 1, 2, 3, 3]` and `k = 3`, there is only one 2.\\n2. There is a gap in a sequence, like `[1, 2, 4, 5]` and `k = 5`.\\n3. Some sequences do not finish at the end, like `[1, 2, 3, 3, 4]` and `k = 3`. A sequence starting from 3 is not finished.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Create a counter of numbers, and iterate over the counter\\n2. Keep track of how many occurrences are required to proceed in variable `minNeeded`\\n3. To check for a gap, also keep track of what number we saw in the previous iteration, in variable `prevNum`. If we are in the middle of a sequence and `prevNum` is not `currentNum - 1`, then we have a gap.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n log n) to sort the counter, O(n) to iterate it.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) to store counters and number of new sequences\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums) % k != 0:\\n            return False\\n\\n        counter = collections.Counter(nums)\\n        minNeeded = 0  # Minimum number of elements needed at the current key\\n        prevNum = None  # Previous number to check if sequences are consecutive.\\n\\n        for num, count in sorted(counter.items()):\\n            # Fail 1: If a number in the middle of sequence does not have enough counts\\n            if minNeeded > count:\\n                return False\\n\\n            # Fail 2. If there is a hole in consecutive sequence\\n            if minNeeded > 0 and prevNum != num - 1:\\n                return False\\n\\n            # Start of new sequence of k consecutive numbers from num\\n            counter[num] = count - minNeeded\\n\\n            # End of previous sequences\\n            minNeeded = count - counter.get(num - k + 1, 0)\\n            prevNum = num\\n\\n        # Fail 3: if some sequences didn\\'t end\\n        return minNeeded == 0\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n\\nclass Solution:\\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\\n        if len(nums) % k != 0:\\n            return False\\n\\n        counter = collections.Counter(nums)\\n        minNeeded = 0  # Minimum number of elements needed at the current key\\n        prevNum = None  # Previous number to check if sequences are consecutive.\\n\\n        for num, count in sorted(counter.items()):\\n            # Fail 1: If a number in the middle of sequence does not have enough counts\\n            if minNeeded > count:\\n                return False\\n\\n            # Fail 2. If there is a hole in consecutive sequence\\n            if minNeeded > 0 and prevNum != num - 1:\\n                return False\\n\\n            # Start of new sequence of k consecutive numbers from num\\n            counter[num] = count - minNeeded\\n\\n            # End of previous sequences\\n            minNeeded = count - counter.get(num - k + 1, 0)\\n            prevNum = num\\n\\n        # Fail 3: if some sequences didn\\'t end\\n        return minNeeded == 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034760,
                "title": "java-treemap-solution-easy-to-read",
                "content": "\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int N = nums.length;\\n        if(N % k != 0)\\n            return false;\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>(); // val -> freq\\n        for(int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for(int key : map.keySet()) {\\n            while(map.get(key) != 0) {\\n                for(int i = 0; i < k; i++) {\\n                    if(!map.containsKey(key + i) || map.get(key + i) == 0)\\n                        return false;\\n                    map.put(key+i, map.get(key+i) - 1);\\n                }\\n            }  \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        int N = nums.length;\\n        if(N % k != 0)\\n            return false;\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>(); // val -> freq\\n        for(int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for(int key : map.keySet()) {\\n            while(map.get(key) != 0) {\\n                for(int i = 0; i < k; i++) {\\n                    if(!map.containsKey(key + i) || map.get(key + i) == 0)\\n                        return false;\\n                    map.put(key+i, map.get(key+i) - 1);\\n                }\\n            }  \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028452,
                "title": "c-beats-85-94-ordered-map",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*k)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if (nums.size() % k != 0) return false;\\n        map<int,int> mp;\\n        for (int i : nums) ++ mp[i];\\n        int mark = mp.size() - k;\\n        auto it = mp.begin();\\n        for (; it != mp.end() && mark; ++ it) {\\n            -- mark;\\n            if (it->second == 0) continue;\\n            int cnt = 1;\\n            for (auto it1 = next(it), it2 = it; it1 != mp.end() && cnt < k; ++ it1, ++ it2) {\\n                if (it1->first != it2->first + 1 || it1->second < it->second) return false;\\n                it1->second -= it->second;\\n                ++ cnt;\\n            }\\n        }\\n        for (auto it1 = next(it); it1 != mp.end(); ++ it, ++ it1) {\\n            if (it1->first != it->first + 1 || it1->second != it->second) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if (nums.size() % k != 0) return false;\\n        map<int,int> mp;\\n        for (int i : nums) ++ mp[i];\\n        int mark = mp.size() - k;\\n        auto it = mp.begin();\\n        for (; it != mp.end() && mark; ++ it) {\\n            -- mark;\\n            if (it->second == 0) continue;\\n            int cnt = 1;\\n            for (auto it1 = next(it), it2 = it; it1 != mp.end() && cnt < k; ++ it1, ++ it2) {\\n                if (it1->first != it2->first + 1 || it1->second < it->second) return false;\\n                it1->second -= it->second;\\n                ++ cnt;\\n            }\\n        }\\n        for (auto it1 = next(it); it1 != mp.end(); ++ it, ++ it1) {\\n            if (it1->first != it->first + 1 || it1->second != it->second) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027896,
                "title": "divide-array-in-sets-of-k-consecutive-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        map<int, int>mpp;\\n        for(int i=0; i<n; i++){\\n            mpp[nums[i]]++;\\n        }\\n\\n        for(auto it:mpp){\\n            if(mpp[it.first]>0){\\n                for(int i=1; i<k; i++){\\n                    mpp[it.first+i]-=mpp[it.first];\\n                    if(mpp[it.first+i]<0) return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        map<int, int>mpp;\\n        for(int i=0; i<n; i++){\\n            mpp[nums[i]]++;\\n        }\\n\\n        for(auto it:mpp){\\n            if(mpp[it.first]>0){\\n                for(int i=1; i<k; i++){\\n                    mpp[it.first+i]-=mpp[it.first];\\n                    if(mpp[it.first+i]<0) return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003802,
                "title": "swift-expected-solution-queue",
                "content": "# Solution\\n```\\nclass Solution {\\n    class Queue {\\n        private var location = 0\\n        private(set) var length = 0\\n        private var array: [Int]\\n        init(_ size: Int) {\\n            self.array = Array(repeating: 0, count: size)\\n        }\\n        func enqueue(_ value: Int) {\\n            array[(location + length) % array.count] = value\\n            length += 1\\n        }\\n        func dequeue() -> Int {\\n            let result = array[location]\\n            location = (location + 1) % array.count\\n            length -= 1\\n            return result\\n        }\\n    }\\n    func isPossibleDivide(_ nums: [Int], _ k: Int) -> Bool {\\n        guard nums.count >= k else { return false }\\n        guard nums.count % k == 0 else { return false }\\n\\n        // Convert hand to unique nums and their counts.\\n        var countMap: [Int: Int] = [:]\\n        nums.forEach {\\n            countMap[$0, default: 0] += 1\\n        }\\n        let uniqueNums = countMap.keys.sorted()\\n\\n        let queue = Queue(k)\\n        var expectedCount = 0\\n        var i = 0\\n    \\n        for (index, num) in uniqueNums.enumerated() {\\n            let count = countMap[num] ?? 0\\n            let diff = count - expectedCount\\n\\n            // There aren\\'t enough nums to build groups using all the previous nums.\\n            guard diff >= 0 else {\\n                return false\\n            }\\n            \\n            // Missing consecutive num.\\n            guard expectedCount == 0 || uniqueNums[index - 1] + 1 == num else {\\n                return false\\n            }\\n\\n            // Increase expectations when new groups start.\\n            if diff > 0 {\\n                expectedCount += diff\\n            }\\n            queue.enqueue(diff)\\n\\n            // Reduce expectations when groups end.\\n            if queue.length == k {\\n                expectedCount -= queue.dequeue()\\n            }\\n        }\\n\\n        // Verify that the queue is empty.\\n        while queue.length > 0 {\\n            if queue.dequeue() != 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time: $$O(m \\\\cdot logm + n)$$ where $$m$$ is the number of unique nums.\\n- Space: $$O(m)$$",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    class Queue {\\n        private var location = 0\\n        private(set) var length = 0\\n        private var array: [Int]\\n        init(_ size: Int) {\\n            self.array = Array(repeating: 0, count: size)\\n        }\\n        func enqueue(_ value: Int) {\\n            array[(location + length) % array.count] = value\\n            length += 1\\n        }\\n        func dequeue() -> Int {\\n            let result = array[location]\\n            location = (location + 1) % array.count\\n            length -= 1\\n            return result\\n        }\\n    }\\n    func isPossibleDivide(_ nums: [Int], _ k: Int) -> Bool {\\n        guard nums.count >= k else { return false }\\n        guard nums.count % k == 0 else { return false }\\n\\n        // Convert hand to unique nums and their counts.\\n        var countMap: [Int: Int] = [:]\\n        nums.forEach {\\n            countMap[$0, default: 0] += 1\\n        }\\n        let uniqueNums = countMap.keys.sorted()\\n\\n        let queue = Queue(k)\\n        var expectedCount = 0\\n        var i = 0\\n    \\n        for (index, num) in uniqueNums.enumerated() {\\n            let count = countMap[num] ?? 0\\n            let diff = count - expectedCount\\n\\n            // There aren\\'t enough nums to build groups using all the previous nums.\\n            guard diff >= 0 else {\\n                return false\\n            }\\n            \\n            // Missing consecutive num.\\n            guard expectedCount == 0 || uniqueNums[index - 1] + 1 == num else {\\n                return false\\n            }\\n\\n            // Increase expectations when new groups start.\\n            if diff > 0 {\\n                expectedCount += diff\\n            }\\n            queue.enqueue(diff)\\n\\n            // Reduce expectations when groups end.\\n            if queue.length == k {\\n                expectedCount -= queue.dequeue()\\n            }\\n        }\\n\\n        // Verify that the queue is empty.\\n        while queue.length > 0 {\\n            if queue.dequeue() != 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001761,
                "title": "easy-solution-map-c-simple-short-code",
                "content": "![\\u2014Pngtree\\u2014janmashtami brush stroke frame with_8504820.png](https://assets.leetcode.com/users/images/15e144ca-5906-4805-b319-3cc503113981_1693840091.7538166.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& hand, int k) {\\n\\n        if(hand.size()%k!=0)return false;\\n        map<int,int>mp;\\n        for(auto i:hand)mp[i]++;\\n\\n        int x=hand.size()/k;\\n        for(int i=0;i<x;i++){\\n\\n            auto it=mp.begin();\\n            int y=it->first;\\n            int count=1;\\n\\n            while(count<=k&&mp.find(y)!=mp.end()){\\n\\n                mp[y]--;\\n                if(!mp[y])mp.erase(y);\\n                y++;\\n                count++;\\n\\n            }\\n\\n            count--;\\n            if(count!=k)return false;\\n\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& hand, int k) {\\n\\n        if(hand.size()%k!=0)return false;\\n        map<int,int>mp;\\n        for(auto i:hand)mp[i]++;\\n\\n        int x=hand.size()/k;\\n        for(int i=0;i<x;i++){\\n\\n            auto it=mp.begin();\\n            int y=it->first;\\n            int count=1;\\n\\n            while(count<=k&&mp.find(y)!=mp.end()){\\n\\n                mp[y]--;\\n                if(!mp[y])mp.erase(y);\\n                y++;\\n                count++;\\n\\n            }\\n\\n            count--;\\n            if(count!=k)return false;\\n\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997721,
                "title": "c-multiset",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        //\\n        if (nums.size()%k>0) return false;\\n        //\\n        multiset<int> set(nums.begin(), nums.end());\\n        //\\n        while(!set.empty()) {\\n            int curr=*set.begin(); // = minimum element\\n            //try to find curr+0, curr+1..curr+groupSize-1\\n            for(int i=0; i<k;++i) {\\n                auto it=set.find(curr+i); \\n                if (it!=set.end()) {\\n                    set.erase(it); //found - remove it from multiset\\n                }\\n                else {\\n                    return false;//not found\\n                }\\n            }\\n        }\\n        return true;\\n        //                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        //\\n        if (nums.size()%k>0) return false;\\n        //\\n        multiset<int> set(nums.begin(), nums.end());\\n        //\\n        while(!set.empty()) {\\n            int curr=*set.begin(); // = minimum element\\n            //try to find curr+0, curr+1..curr+groupSize-1\\n            for(int i=0; i<k;++i) {\\n                auto it=set.find(curr+i); \\n                if (it!=set.end()) {\\n                    set.erase(it); //found - remove it from multiset\\n                }\\n                else {\\n                    return false;//not found\\n                }\\n            }\\n        }\\n        return true;\\n        //                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982424,
                "title": "java-hashmap-counting-priorityqueue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length%k!=0)\\n            return false;\\n\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((n1,n2)->n1[0]-n2[0]);\\n        PriorityQueue<int[]> temp = new PriorityQueue<>((n1,n2)->n2[0]-n1[0]);\\n\\n        for(int h:nums){\\n            hm.put(h,hm.getOrDefault(h,0)+1);\\n        }\\n        for(int key:hm.keySet()){\\n            heap.offer(new int[]{key,hm.get(key)});\\n        }\\n        \\n        int count =0;\\n        while(!heap.isEmpty()){\\n\\n            while(count<k){\\n                if(temp.isEmpty()){\\n                    temp.offer(heap.poll());\\n                    count++;\\n                }\\n                else{\\n                    if(heap.isEmpty())//need more elements but heap is empty\\n                        return false;\\n                    if(heap.peek()[0]-1==temp.peek()[0]){//satisfy consecutive \\n                        temp.offer(heap.poll());\\n                        count++;\\n                    }\\n                    else//not satisfy consecutive\\n                        return false;\\n                }\\n            }\\n            while(!temp.isEmpty()){\\n                int [] curr = temp.poll();\\n                if(curr[1]>1)\\n                    heap.offer(new int[]{curr[0],curr[1]-1});//put back to heap\\n            }\\n            count=0;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if(nums.length%k!=0)\\n            return false;\\n\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((n1,n2)->n1[0]-n2[0]);\\n        PriorityQueue<int[]> temp = new PriorityQueue<>((n1,n2)->n2[0]-n1[0]);\\n\\n        for(int h:nums){\\n            hm.put(h,hm.getOrDefault(h,0)+1);\\n        }\\n        for(int key:hm.keySet()){\\n            heap.offer(new int[]{key,hm.get(key)});\\n        }\\n        \\n        int count =0;\\n        while(!heap.isEmpty()){\\n\\n            while(count<k){\\n                if(temp.isEmpty()){\\n                    temp.offer(heap.poll());\\n                    count++;\\n                }\\n                else{\\n                    if(heap.isEmpty())//need more elements but heap is empty\\n                        return false;\\n                    if(heap.peek()[0]-1==temp.peek()[0]){//satisfy consecutive \\n                        temp.offer(heap.poll());\\n                        count++;\\n                    }\\n                    else//not satisfy consecutive\\n                        return false;\\n                }\\n            }\\n            while(!temp.isEmpty()){\\n                int [] curr = temp.poll();\\n                if(curr[1]>1)\\n                    heap.offer(new int[]{curr[0],curr[1]-1});//put back to heap\\n            }\\n            count=0;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566342,
                "content": [
                    {
                        "username": "aliaamohamedali",
                        "content": "I\\'ve ran some of the codes that utilize the modulos (ensure they are equally distributed) that were \"accepted\" against this example and they all fail ?\\n\\n[1, 9, 17, 25, 33, 41, 49]\\n7"
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "nums = [2,5,6,8,9,10]\\nk = 3\\n\\nhow is this expected to be false when we can make a set of 3\\n[2,5,6] and [8,9,10] "
                    },
                    {
                        "username": "Indominous1",
                        "content": "It says that you have to divide the array and make sets of consecutive numbers, the first set doesn\\'t contain consecutive elements if the set have [2,3,4] [8,9,10] than that would be considered and as 3,4 are not present in the array answer is false"
                    },
                    {
                        "username": "GR1985",
                        "content": "[16,5,15,15,20,16,20,14,21,20,19,20,12,17,13,15,11,17,18,18,11,13,13,14,14,9,20,18,10,4,4,6,15,19,8,15,7,17,15,9,24,2,23,22,26,8,21,22,14,13,16,2,25,23,17,19,17,3,22,23,19,12,21,12,16,27,28,10,13,8,24,3,22,6,10,9,14,7,11,22,11,5,16,19,21,2,8,24,16,21,7,29,18,9,10,18,6,17,21,20]\\n10\\n\\nwhy is this supposed to be false ?  \\n\\nI can divide into consecutive numbers of 10 each. \\n\\n 0 => int 2\\n  1 => int 2\\n  2 => int 2\\n  3 => int 3\\n  4 => int 3\\n  5 => int 4\\n  6 => int 4\\n  7 => int 5\\n  8 => int 5\\n  9 => int 6\\n  \\n  10 => int 6\\n  11 => int 6\\n  12 => int 7\\n  13 => int 7\\n  14 => int 7\\n  15 => int 8\\n  16 => int 8\\n  17 => int 8\\n  18 => int 8\\n  19 => int 9\\n  \\n  20 => int 9\\n  21 => int 9\\n  22 => int 9\\n  23 => int 10\\n  24 => int 10\\n  25 => int 10\\n  26 => int 10\\n  27 => int 11\\n  28 => int 11\\n  29 => int 11\\n  \\n  30 => int 11\\n  31 => int 12\\n  32 => int 12\\n  33 => int 12\\n  34 => int 13\\n  35 => int 13\\n  36 => int 13\\n  37 => int 13\\n  38 => int 13\\n  39 => int 14\\n  \\n  40 => int 14\\n  41 => int 14\\n  42 => int 14\\n  43 => int 14\\n  44 => int 15\\n  45 => int 15\\n  46 => int 15\\n  47 => int 15\\n  48 => int 15\\n  49 => int 15\\n  \\n  50 => int 16\\n  51 => int 16\\n  52 => int 16\\n  53 => int 16\\n  54 => int 16\\n  55 => int 16\\n  56 => int 17\\n  57 => int 17\\n  58 => int 17\\n  59 => int 17\\n  \\n  60 => int 17\\n  61 => int 17\\n  62 => int 18\\n  63 => int 18\\n  64 => int 18\\n  65 => int 18\\n  66 => int 18\\n  67 => int 19\\n  68 => int 19\\n  69 => int 19\\n  \\n  70 => int 19\\n  71 => int 19\\n  72 => int 20\\n  73 => int 20\\n  74 => int 20\\n  75 => int 20\\n  76 => int 20\\n  77 => int 20\\n  78 => int 21\\n  79 => int 21\\n  \\n  80 => int 21\\n  81 => int 21\\n  82 => int 21\\n  83 => int 21\\n  84 => int 22\\n  85 => int 22\\n  86 => int 22\\n  87 => int 22\\n  88 => int 22\\n  89 => int 23\\n  \\n  90 => int 23\\n  91 => int 23\\n  92 => int 24\\n  93 => int 24\\n  94 => int 24\\n  95 => int 25\\n  96 => int 26\\n  97 => int 27\\n  98 => int 28\\n  99 => int 29\\n  \\n  wrong test case ?"
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "Your sets do not contain k(=10) consecutive numbers.\\nThe below set is wrong\\n0 => int 2\\n1 => int 2\\n2 => int 2\\n3 => int 3\\n4 => int 3\\n5 => int 4\\n6 => int 4\\n7 => int 5\\n8 => int 5\\n9 => int 6\\n\\nThe correct one will be:\\n0 => int 2\\n1 => int 3\\n2 => int 4\\n3 => int 5\\n4 => int 6\\n5 => int 7\\n6 => int 8\\n7 => int 9\\n8 => int 10\\n9 => int 11"
                    },
                    {
                        "username": "raysterest",
                        "content": "why [2,5,6,8,9,10] and k = 3 expected as false"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\n* Don' t confuse urself  with group size with no  of groups in an array\ni.e [2,3,4,5,6,7,8,9] groupsize=8,Here we need to check only whether we can divide the array into group of 8 irrespective of how many groups we can form.\nElement in group should be  **consecutive** No duplicate element in same group allowed"
                    }
                ]
            },
            {
                "id": 1855828,
                "content": [
                    {
                        "username": "aliaamohamedali",
                        "content": "I\\'ve ran some of the codes that utilize the modulos (ensure they are equally distributed) that were \"accepted\" against this example and they all fail ?\\n\\n[1, 9, 17, 25, 33, 41, 49]\\n7"
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "nums = [2,5,6,8,9,10]\\nk = 3\\n\\nhow is this expected to be false when we can make a set of 3\\n[2,5,6] and [8,9,10] "
                    },
                    {
                        "username": "Indominous1",
                        "content": "It says that you have to divide the array and make sets of consecutive numbers, the first set doesn\\'t contain consecutive elements if the set have [2,3,4] [8,9,10] than that would be considered and as 3,4 are not present in the array answer is false"
                    },
                    {
                        "username": "GR1985",
                        "content": "[16,5,15,15,20,16,20,14,21,20,19,20,12,17,13,15,11,17,18,18,11,13,13,14,14,9,20,18,10,4,4,6,15,19,8,15,7,17,15,9,24,2,23,22,26,8,21,22,14,13,16,2,25,23,17,19,17,3,22,23,19,12,21,12,16,27,28,10,13,8,24,3,22,6,10,9,14,7,11,22,11,5,16,19,21,2,8,24,16,21,7,29,18,9,10,18,6,17,21,20]\\n10\\n\\nwhy is this supposed to be false ?  \\n\\nI can divide into consecutive numbers of 10 each. \\n\\n 0 => int 2\\n  1 => int 2\\n  2 => int 2\\n  3 => int 3\\n  4 => int 3\\n  5 => int 4\\n  6 => int 4\\n  7 => int 5\\n  8 => int 5\\n  9 => int 6\\n  \\n  10 => int 6\\n  11 => int 6\\n  12 => int 7\\n  13 => int 7\\n  14 => int 7\\n  15 => int 8\\n  16 => int 8\\n  17 => int 8\\n  18 => int 8\\n  19 => int 9\\n  \\n  20 => int 9\\n  21 => int 9\\n  22 => int 9\\n  23 => int 10\\n  24 => int 10\\n  25 => int 10\\n  26 => int 10\\n  27 => int 11\\n  28 => int 11\\n  29 => int 11\\n  \\n  30 => int 11\\n  31 => int 12\\n  32 => int 12\\n  33 => int 12\\n  34 => int 13\\n  35 => int 13\\n  36 => int 13\\n  37 => int 13\\n  38 => int 13\\n  39 => int 14\\n  \\n  40 => int 14\\n  41 => int 14\\n  42 => int 14\\n  43 => int 14\\n  44 => int 15\\n  45 => int 15\\n  46 => int 15\\n  47 => int 15\\n  48 => int 15\\n  49 => int 15\\n  \\n  50 => int 16\\n  51 => int 16\\n  52 => int 16\\n  53 => int 16\\n  54 => int 16\\n  55 => int 16\\n  56 => int 17\\n  57 => int 17\\n  58 => int 17\\n  59 => int 17\\n  \\n  60 => int 17\\n  61 => int 17\\n  62 => int 18\\n  63 => int 18\\n  64 => int 18\\n  65 => int 18\\n  66 => int 18\\n  67 => int 19\\n  68 => int 19\\n  69 => int 19\\n  \\n  70 => int 19\\n  71 => int 19\\n  72 => int 20\\n  73 => int 20\\n  74 => int 20\\n  75 => int 20\\n  76 => int 20\\n  77 => int 20\\n  78 => int 21\\n  79 => int 21\\n  \\n  80 => int 21\\n  81 => int 21\\n  82 => int 21\\n  83 => int 21\\n  84 => int 22\\n  85 => int 22\\n  86 => int 22\\n  87 => int 22\\n  88 => int 22\\n  89 => int 23\\n  \\n  90 => int 23\\n  91 => int 23\\n  92 => int 24\\n  93 => int 24\\n  94 => int 24\\n  95 => int 25\\n  96 => int 26\\n  97 => int 27\\n  98 => int 28\\n  99 => int 29\\n  \\n  wrong test case ?"
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "Your sets do not contain k(=10) consecutive numbers.\\nThe below set is wrong\\n0 => int 2\\n1 => int 2\\n2 => int 2\\n3 => int 3\\n4 => int 3\\n5 => int 4\\n6 => int 4\\n7 => int 5\\n8 => int 5\\n9 => int 6\\n\\nThe correct one will be:\\n0 => int 2\\n1 => int 3\\n2 => int 4\\n3 => int 5\\n4 => int 6\\n5 => int 7\\n6 => int 8\\n7 => int 9\\n8 => int 10\\n9 => int 11"
                    },
                    {
                        "username": "raysterest",
                        "content": "why [2,5,6,8,9,10] and k = 3 expected as false"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\n* Don' t confuse urself  with group size with no  of groups in an array\ni.e [2,3,4,5,6,7,8,9] groupsize=8,Here we need to check only whether we can divide the array into group of 8 irrespective of how many groups we can form.\nElement in group should be  **consecutive** No duplicate element in same group allowed"
                    }
                ]
            },
            {
                "id": 1573288,
                "content": [
                    {
                        "username": "aliaamohamedali",
                        "content": "I\\'ve ran some of the codes that utilize the modulos (ensure they are equally distributed) that were \"accepted\" against this example and they all fail ?\\n\\n[1, 9, 17, 25, 33, 41, 49]\\n7"
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "nums = [2,5,6,8,9,10]\\nk = 3\\n\\nhow is this expected to be false when we can make a set of 3\\n[2,5,6] and [8,9,10] "
                    },
                    {
                        "username": "Indominous1",
                        "content": "It says that you have to divide the array and make sets of consecutive numbers, the first set doesn\\'t contain consecutive elements if the set have [2,3,4] [8,9,10] than that would be considered and as 3,4 are not present in the array answer is false"
                    },
                    {
                        "username": "GR1985",
                        "content": "[16,5,15,15,20,16,20,14,21,20,19,20,12,17,13,15,11,17,18,18,11,13,13,14,14,9,20,18,10,4,4,6,15,19,8,15,7,17,15,9,24,2,23,22,26,8,21,22,14,13,16,2,25,23,17,19,17,3,22,23,19,12,21,12,16,27,28,10,13,8,24,3,22,6,10,9,14,7,11,22,11,5,16,19,21,2,8,24,16,21,7,29,18,9,10,18,6,17,21,20]\\n10\\n\\nwhy is this supposed to be false ?  \\n\\nI can divide into consecutive numbers of 10 each. \\n\\n 0 => int 2\\n  1 => int 2\\n  2 => int 2\\n  3 => int 3\\n  4 => int 3\\n  5 => int 4\\n  6 => int 4\\n  7 => int 5\\n  8 => int 5\\n  9 => int 6\\n  \\n  10 => int 6\\n  11 => int 6\\n  12 => int 7\\n  13 => int 7\\n  14 => int 7\\n  15 => int 8\\n  16 => int 8\\n  17 => int 8\\n  18 => int 8\\n  19 => int 9\\n  \\n  20 => int 9\\n  21 => int 9\\n  22 => int 9\\n  23 => int 10\\n  24 => int 10\\n  25 => int 10\\n  26 => int 10\\n  27 => int 11\\n  28 => int 11\\n  29 => int 11\\n  \\n  30 => int 11\\n  31 => int 12\\n  32 => int 12\\n  33 => int 12\\n  34 => int 13\\n  35 => int 13\\n  36 => int 13\\n  37 => int 13\\n  38 => int 13\\n  39 => int 14\\n  \\n  40 => int 14\\n  41 => int 14\\n  42 => int 14\\n  43 => int 14\\n  44 => int 15\\n  45 => int 15\\n  46 => int 15\\n  47 => int 15\\n  48 => int 15\\n  49 => int 15\\n  \\n  50 => int 16\\n  51 => int 16\\n  52 => int 16\\n  53 => int 16\\n  54 => int 16\\n  55 => int 16\\n  56 => int 17\\n  57 => int 17\\n  58 => int 17\\n  59 => int 17\\n  \\n  60 => int 17\\n  61 => int 17\\n  62 => int 18\\n  63 => int 18\\n  64 => int 18\\n  65 => int 18\\n  66 => int 18\\n  67 => int 19\\n  68 => int 19\\n  69 => int 19\\n  \\n  70 => int 19\\n  71 => int 19\\n  72 => int 20\\n  73 => int 20\\n  74 => int 20\\n  75 => int 20\\n  76 => int 20\\n  77 => int 20\\n  78 => int 21\\n  79 => int 21\\n  \\n  80 => int 21\\n  81 => int 21\\n  82 => int 21\\n  83 => int 21\\n  84 => int 22\\n  85 => int 22\\n  86 => int 22\\n  87 => int 22\\n  88 => int 22\\n  89 => int 23\\n  \\n  90 => int 23\\n  91 => int 23\\n  92 => int 24\\n  93 => int 24\\n  94 => int 24\\n  95 => int 25\\n  96 => int 26\\n  97 => int 27\\n  98 => int 28\\n  99 => int 29\\n  \\n  wrong test case ?"
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "Your sets do not contain k(=10) consecutive numbers.\\nThe below set is wrong\\n0 => int 2\\n1 => int 2\\n2 => int 2\\n3 => int 3\\n4 => int 3\\n5 => int 4\\n6 => int 4\\n7 => int 5\\n8 => int 5\\n9 => int 6\\n\\nThe correct one will be:\\n0 => int 2\\n1 => int 3\\n2 => int 4\\n3 => int 5\\n4 => int 6\\n5 => int 7\\n6 => int 8\\n7 => int 9\\n8 => int 10\\n9 => int 11"
                    },
                    {
                        "username": "raysterest",
                        "content": "why [2,5,6,8,9,10] and k = 3 expected as false"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\n* Don' t confuse urself  with group size with no  of groups in an array\ni.e [2,3,4,5,6,7,8,9] groupsize=8,Here we need to check only whether we can divide the array into group of 8 irrespective of how many groups we can form.\nElement in group should be  **consecutive** No duplicate element in same group allowed"
                    }
                ]
            },
            {
                "id": 2060657,
                "content": [
                    {
                        "username": "aliaamohamedali",
                        "content": "I\\'ve ran some of the codes that utilize the modulos (ensure they are equally distributed) that were \"accepted\" against this example and they all fail ?\\n\\n[1, 9, 17, 25, 33, 41, 49]\\n7"
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "nums = [2,5,6,8,9,10]\\nk = 3\\n\\nhow is this expected to be false when we can make a set of 3\\n[2,5,6] and [8,9,10] "
                    },
                    {
                        "username": "Indominous1",
                        "content": "It says that you have to divide the array and make sets of consecutive numbers, the first set doesn\\'t contain consecutive elements if the set have [2,3,4] [8,9,10] than that would be considered and as 3,4 are not present in the array answer is false"
                    },
                    {
                        "username": "GR1985",
                        "content": "[16,5,15,15,20,16,20,14,21,20,19,20,12,17,13,15,11,17,18,18,11,13,13,14,14,9,20,18,10,4,4,6,15,19,8,15,7,17,15,9,24,2,23,22,26,8,21,22,14,13,16,2,25,23,17,19,17,3,22,23,19,12,21,12,16,27,28,10,13,8,24,3,22,6,10,9,14,7,11,22,11,5,16,19,21,2,8,24,16,21,7,29,18,9,10,18,6,17,21,20]\\n10\\n\\nwhy is this supposed to be false ?  \\n\\nI can divide into consecutive numbers of 10 each. \\n\\n 0 => int 2\\n  1 => int 2\\n  2 => int 2\\n  3 => int 3\\n  4 => int 3\\n  5 => int 4\\n  6 => int 4\\n  7 => int 5\\n  8 => int 5\\n  9 => int 6\\n  \\n  10 => int 6\\n  11 => int 6\\n  12 => int 7\\n  13 => int 7\\n  14 => int 7\\n  15 => int 8\\n  16 => int 8\\n  17 => int 8\\n  18 => int 8\\n  19 => int 9\\n  \\n  20 => int 9\\n  21 => int 9\\n  22 => int 9\\n  23 => int 10\\n  24 => int 10\\n  25 => int 10\\n  26 => int 10\\n  27 => int 11\\n  28 => int 11\\n  29 => int 11\\n  \\n  30 => int 11\\n  31 => int 12\\n  32 => int 12\\n  33 => int 12\\n  34 => int 13\\n  35 => int 13\\n  36 => int 13\\n  37 => int 13\\n  38 => int 13\\n  39 => int 14\\n  \\n  40 => int 14\\n  41 => int 14\\n  42 => int 14\\n  43 => int 14\\n  44 => int 15\\n  45 => int 15\\n  46 => int 15\\n  47 => int 15\\n  48 => int 15\\n  49 => int 15\\n  \\n  50 => int 16\\n  51 => int 16\\n  52 => int 16\\n  53 => int 16\\n  54 => int 16\\n  55 => int 16\\n  56 => int 17\\n  57 => int 17\\n  58 => int 17\\n  59 => int 17\\n  \\n  60 => int 17\\n  61 => int 17\\n  62 => int 18\\n  63 => int 18\\n  64 => int 18\\n  65 => int 18\\n  66 => int 18\\n  67 => int 19\\n  68 => int 19\\n  69 => int 19\\n  \\n  70 => int 19\\n  71 => int 19\\n  72 => int 20\\n  73 => int 20\\n  74 => int 20\\n  75 => int 20\\n  76 => int 20\\n  77 => int 20\\n  78 => int 21\\n  79 => int 21\\n  \\n  80 => int 21\\n  81 => int 21\\n  82 => int 21\\n  83 => int 21\\n  84 => int 22\\n  85 => int 22\\n  86 => int 22\\n  87 => int 22\\n  88 => int 22\\n  89 => int 23\\n  \\n  90 => int 23\\n  91 => int 23\\n  92 => int 24\\n  93 => int 24\\n  94 => int 24\\n  95 => int 25\\n  96 => int 26\\n  97 => int 27\\n  98 => int 28\\n  99 => int 29\\n  \\n  wrong test case ?"
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "Your sets do not contain k(=10) consecutive numbers.\\nThe below set is wrong\\n0 => int 2\\n1 => int 2\\n2 => int 2\\n3 => int 3\\n4 => int 3\\n5 => int 4\\n6 => int 4\\n7 => int 5\\n8 => int 5\\n9 => int 6\\n\\nThe correct one will be:\\n0 => int 2\\n1 => int 3\\n2 => int 4\\n3 => int 5\\n4 => int 6\\n5 => int 7\\n6 => int 8\\n7 => int 9\\n8 => int 10\\n9 => int 11"
                    },
                    {
                        "username": "raysterest",
                        "content": "why [2,5,6,8,9,10] and k = 3 expected as false"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\n* Don' t confuse urself  with group size with no  of groups in an array\ni.e [2,3,4,5,6,7,8,9] groupsize=8,Here we need to check only whether we can divide the array into group of 8 irrespective of how many groups we can form.\nElement in group should be  **consecutive** No duplicate element in same group allowed"
                    }
                ]
            },
            {
                "id": 1937514,
                "content": [
                    {
                        "username": "aliaamohamedali",
                        "content": "I\\'ve ran some of the codes that utilize the modulos (ensure they are equally distributed) that were \"accepted\" against this example and they all fail ?\\n\\n[1, 9, 17, 25, 33, 41, 49]\\n7"
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "nums = [2,5,6,8,9,10]\\nk = 3\\n\\nhow is this expected to be false when we can make a set of 3\\n[2,5,6] and [8,9,10] "
                    },
                    {
                        "username": "Indominous1",
                        "content": "It says that you have to divide the array and make sets of consecutive numbers, the first set doesn\\'t contain consecutive elements if the set have [2,3,4] [8,9,10] than that would be considered and as 3,4 are not present in the array answer is false"
                    },
                    {
                        "username": "GR1985",
                        "content": "[16,5,15,15,20,16,20,14,21,20,19,20,12,17,13,15,11,17,18,18,11,13,13,14,14,9,20,18,10,4,4,6,15,19,8,15,7,17,15,9,24,2,23,22,26,8,21,22,14,13,16,2,25,23,17,19,17,3,22,23,19,12,21,12,16,27,28,10,13,8,24,3,22,6,10,9,14,7,11,22,11,5,16,19,21,2,8,24,16,21,7,29,18,9,10,18,6,17,21,20]\\n10\\n\\nwhy is this supposed to be false ?  \\n\\nI can divide into consecutive numbers of 10 each. \\n\\n 0 => int 2\\n  1 => int 2\\n  2 => int 2\\n  3 => int 3\\n  4 => int 3\\n  5 => int 4\\n  6 => int 4\\n  7 => int 5\\n  8 => int 5\\n  9 => int 6\\n  \\n  10 => int 6\\n  11 => int 6\\n  12 => int 7\\n  13 => int 7\\n  14 => int 7\\n  15 => int 8\\n  16 => int 8\\n  17 => int 8\\n  18 => int 8\\n  19 => int 9\\n  \\n  20 => int 9\\n  21 => int 9\\n  22 => int 9\\n  23 => int 10\\n  24 => int 10\\n  25 => int 10\\n  26 => int 10\\n  27 => int 11\\n  28 => int 11\\n  29 => int 11\\n  \\n  30 => int 11\\n  31 => int 12\\n  32 => int 12\\n  33 => int 12\\n  34 => int 13\\n  35 => int 13\\n  36 => int 13\\n  37 => int 13\\n  38 => int 13\\n  39 => int 14\\n  \\n  40 => int 14\\n  41 => int 14\\n  42 => int 14\\n  43 => int 14\\n  44 => int 15\\n  45 => int 15\\n  46 => int 15\\n  47 => int 15\\n  48 => int 15\\n  49 => int 15\\n  \\n  50 => int 16\\n  51 => int 16\\n  52 => int 16\\n  53 => int 16\\n  54 => int 16\\n  55 => int 16\\n  56 => int 17\\n  57 => int 17\\n  58 => int 17\\n  59 => int 17\\n  \\n  60 => int 17\\n  61 => int 17\\n  62 => int 18\\n  63 => int 18\\n  64 => int 18\\n  65 => int 18\\n  66 => int 18\\n  67 => int 19\\n  68 => int 19\\n  69 => int 19\\n  \\n  70 => int 19\\n  71 => int 19\\n  72 => int 20\\n  73 => int 20\\n  74 => int 20\\n  75 => int 20\\n  76 => int 20\\n  77 => int 20\\n  78 => int 21\\n  79 => int 21\\n  \\n  80 => int 21\\n  81 => int 21\\n  82 => int 21\\n  83 => int 21\\n  84 => int 22\\n  85 => int 22\\n  86 => int 22\\n  87 => int 22\\n  88 => int 22\\n  89 => int 23\\n  \\n  90 => int 23\\n  91 => int 23\\n  92 => int 24\\n  93 => int 24\\n  94 => int 24\\n  95 => int 25\\n  96 => int 26\\n  97 => int 27\\n  98 => int 28\\n  99 => int 29\\n  \\n  wrong test case ?"
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "Your sets do not contain k(=10) consecutive numbers.\\nThe below set is wrong\\n0 => int 2\\n1 => int 2\\n2 => int 2\\n3 => int 3\\n4 => int 3\\n5 => int 4\\n6 => int 4\\n7 => int 5\\n8 => int 5\\n9 => int 6\\n\\nThe correct one will be:\\n0 => int 2\\n1 => int 3\\n2 => int 4\\n3 => int 5\\n4 => int 6\\n5 => int 7\\n6 => int 8\\n7 => int 9\\n8 => int 10\\n9 => int 11"
                    },
                    {
                        "username": "raysterest",
                        "content": "why [2,5,6,8,9,10] and k = 3 expected as false"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "```HINT```\n* Don' t confuse urself  with group size with no  of groups in an array\ni.e [2,3,4,5,6,7,8,9] groupsize=8,Here we need to check only whether we can divide the array into group of 8 irrespective of how many groups we can form.\nElement in group should be  **consecutive** No duplicate element in same group allowed"
                    }
                ]
            }
        ]
    }
]