[
    {
        "title": "Find the Pivot Integer",
        "question_content": "Given a positive integer n, find the pivot integer x such that:\n\n\tThe sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.\n\nReturn the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.\n&nbsp;\nExample 1:\n\nInput: n = 8\nOutput: 6\nExplanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\nExplanation: 1 is the pivot integer since: 1 = 1.\n\nExample 3:\n\nInput: n = 4\nOutput: -1\nExplanation: It can be proved that no such integer exist.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000",
        "solutions": [
            {
                "id": 2851991,
                "title": "sqrt-binary-search-dp",
                "content": "O(n) is easy, but where is the fun in that.\\n\\n## SQRT\\nWhy `x * x == sum`? For `n`, the sum of `[1..n]` is `sum = n * (n + 1) / 2`.\\n\\nThe sum of `[1..x]` is `x * (x + 1) / 2`. The sum of `[x..n]` is `n * (n + 1) / 2 - x * (x + 1) / 2 + x`. So: \\n- `x * (x + 1) / 2 ==  n * (n + 1) / 2 - x * (x + 1) / 2 + x`,\\n- `x * (x + 1) / 2 + x * (x + 1) / 2 - x == n * (n + 1) / 2`,\\n- `x * (x + 1) - x == sum`,\\n- `x * x == sum`.\\n\\nThus, we can just use SQRT to find `x`.\\n\\n**C++**\\n```cpp\\nint pivotInteger(int n) {\\n    int sum = n * (n + 1) / 2, x = sqrt(sum);\\n    return x * x == sum ? x : -1;\\n}\\n```\\n\\n## Binary Search\\nWe can binary-search for a pivot for a O(log n) solution.\\n**C++**\\n```cpp\\nint pivotInteger(int n) {\\n    int l = 1, r = n, sum = n * (n + 1) / 2;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (m * m - sum < 0)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l * l - sum == 0 ? l : -1;\\n}\\n```\\n\\n## DP\\nSince pivot increases with `n`, we can compute pivot for the entire range in O(n).\\n\\nThen, a query will take O(1). The overal complexity will be amortized O(1).\\n\\n**C++**\\nNote that `dp` is global so it\\'s populated once then reused between test cases.\\n```cpp\\nint dp[1001] = { 0, 0 };\\nclass Solution {\\npublic:\\nint pivotInteger(int n) {\\n    if (dp[1] == 0)\\n       for (int i = 1, j = 1; i <= 1000; ++i) {\\n           int sum = i * (i + 1) / 2;\\n           while (j * j < sum)\\n               ++j;\\n           dp[i] = j * j == sum ? j : -1;\\n       }\\n    return dp[n];\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint pivotInteger(int n) {\\n    int sum = n * (n + 1) / 2, x = sqrt(sum);\\n    return x * x == sum ? x : -1;\\n}\\n```\n```cpp\\nint pivotInteger(int n) {\\n    int l = 1, r = n, sum = n * (n + 1) / 2;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (m * m - sum < 0)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l * l - sum == 0 ? l : -1;\\n}\\n```\n```cpp\\nint dp[1001] = { 0, 0 };\\nclass Solution {\\npublic:\\nint pivotInteger(int n) {\\n    if (dp[1] == 0)\\n       for (int i = 1, j = 1; i <= 1000; ++i) {\\n           int sum = i * (i + 1) / 2;\\n           while (j * j < sum)\\n               ++j;\\n           dp[i] = j * j == sum ? j : -1;\\n       }\\n    return dp[n];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851954,
                "title": "simple-maths-proof-with-picture",
                "content": "##### Please upvote if you like the post \\uD83D\\uDE0A\\n\\nThe value of x is going to sqrt((n2 + n) / 2 )\\n\\n**Q] Why is that so ?**\\n\\nAns] Proof :\\n\\n![image](https://assets.leetcode.com/users/images/930fc949-eae3-493f-be64-fea236b4119f_1669520731.6008582.png)\\n****\\n\\n**Note** The sum of a AP series given first and last term is **n / 2 [first term + last term ]**\\n\\nHence the code would be :-\\n1. c++\\n```c++\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int ans = (n * n + n ) /2;\\n        int sq = sqrt(ans);\\n        if(sq * sq == ans)return sq;\\n        else return -1;\\n    }\\n};\\n```\\n **** \\n2. java\\n```Java\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int ans = (n * n + n ) /2;\\n        int sq = (int)Math.sqrt(ans);\\n        if(sq * sq == ans)return sq;\\n        else return -1;\\n    }\\n}\\n```\\n*****\\n3. python\\n```python\\nclass Solution(object):\\n    def pivotInteger(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        temp = (n * n + n) // 2\\n        sq = int(sqrt(temp))\\n        if sq * sq == temp:\\n            return sq\\n        return -1\\n        \\n```\\n\\nTime Complexity O(log n)\\nSpace Complexity :- O(1)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int ans = (n * n + n ) /2;\\n        int sq = sqrt(ans);\\n        if(sq * sq == ans)return sq;\\n        else return -1;\\n    }\\n};\\n```\n```Java\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int ans = (n * n + n ) /2;\\n        int sq = (int)Math.sqrt(ans);\\n        if(sq * sq == ans)return sq;\\n        else return -1;\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def pivotInteger(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        temp = (n * n + n) // 2\\n        sq = int(sqrt(temp))\\n        if sq * sq == temp:\\n            return sq\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851967,
                "title": "python-o-n-vs-binary-search-vs-math-one-liner-proof-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Comment.**\\n\\nTotal sum of all `n` numbers is `A=n*(n+1)/2`.\\nThe same for first `x-1` of them `B=(x-1)*x/2`.\\nThe same for first `x` of them `C=x*(x+1)/2`.\\n\\nNow solve `A-B=C`. There exist several approaches, e.g.:\\n1. Brute force by checking this equality for each `x` from `1` to `n`.\\n2. Brute force by applying binary search (`x**2` is a monotonic function, thus, has sorted range).\\n3. Rearrange it to be `A = B + C`, then cancel terms with opposite signs. You\\'ll get `x**2 = n*(n+1)//2`\\nThus, the solution is the integer square root (if exists), i.e., `isqrt(n*(n+1)//2)`. \\n\\n**Python #1.** Linear-time brute force.\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        A = n*(n+1)//2\\n        for x in range(n+1):\\n            B, C = x*(x-1)//2, x*(x+1)//2\\n            if A - B == C: return x\\n        return -1\\n```\\n\\n**Python #2.** Logarithmic time brute force (using binary search).\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        \\n        x = bisect_right(range(n+1), 0, key=lambda x: (x+1)**2 - n*(n+1)//2)\\n        return x if x**2 == n*(n+1)//2 else -1\\n```\\n\\n**Python #3.** Math one-liner.\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        return x if (x:=isqrt(x2:=n*(n+1)//2))**2 == x2 else -1 \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        A = n*(n+1)//2\\n        for x in range(n+1):\\n            B, C = x*(x-1)//2, x*(x+1)//2\\n            if A - B == C: return x\\n        return -1\\n```\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        \\n        x = bisect_right(range(n+1), 0, key=lambda x: (x+1)**2 - n*(n+1)//2)\\n        return x if x**2 == n*(n+1)//2 else -1\\n```\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        return x if (x:=isqrt(x2:=n*(n+1)//2))**2 == x2 else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851964,
                "title": "c-use-prefix-sum-efficient-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int pivotInteger(int n) \\n    {\\n        \\n        int totsum=0;\\n        for(int i=1; i<=n; i++) //calculate total sum\\n            totsum += i;\\n        \\n        int presum=0;\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            presum += i; //calculate prefix sum\\n            if((totsum - presum + i) == presum) //apply condition mentioned in the problem\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int pivotInteger(int n) \\n    {\\n        \\n        int totsum=0;\\n        for(int i=1; i<=n; i++) //calculate total sum\\n            totsum += i;\\n        \\n        int presum=0;\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            presum += i; //calculate prefix sum\\n            if((totsum - presum + i) == presum) //apply condition mentioned in the problem\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852044,
                "title": "java-python-3-from-o-n-to-o-logn-compare-left-and-right-sum",
                "content": "**Method 1: Linear Search**\\n\\n```java\\n    public int pivotInteger(int n) {\\n        int rightSum = n * (n + 1) / 2;\\n        for (int i = 1, leftSum = 0; i <= n; ++i) {\\n            rightSum -= i;\\n            if (leftSum == rightSum) {\\n                return i;\\n            }else if (leftSum > rightSum) {\\n                return -1;\\n            }\\n            leftSum += i;\\n        }\\n        return -1;\\n    }\\n```\\n```python\\n    def pivotInteger(self, n: int) -> int:\\n        right_sum = n * (n + 1) // 2\\n        left_sum = 0\\n        for i in range(1, n + 1):\\n            right_sum -= i\\n            if left_sum == right_sum:\\n                return i\\n            left_sum += i\\n        return -1\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`.\\n\\n----\\n\\n**Method 2: Binary Search**\\n\\n```java\\n    public int pivotInteger(int n) {\\n        int sum = n * (n + 1) / 2;\\n        int lo = 1, hi = n + 1;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int leftSum = (mid - 1) * mid / 2;\\n            int rightSum = sum - (mid + 1) * mid / 2;\\n            if (leftSum < rightSum) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            }\\n        }\\n        return (lo - 1) * lo / 2 == sum - lo * (lo + 1) / 2 ? lo : -1;\\n    }\\n```\\n```python\\n    def pivotInteger(self, n: int) -> int:\\n        total_sum = n * (n + 1) // 2\\n        lo, hi = 1, n + 1\\n        while lo < hi:\\n            mid = (lo + hi) // 2 \\n            left_sum = (mid - 1) * mid // 2\\n            right_sum = total_sum - left_sum - mid\\n            if left_sum < right_sum:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo if lo * (lo - 1) // 2 == total_sum - (lo + 1) * lo // 2 else -1\\n```\\n**Analysis:**\\n\\nTime: `O(logn)`, space: `O(1)`.\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int pivotInteger(int n) {\\n        int rightSum = n * (n + 1) / 2;\\n        for (int i = 1, leftSum = 0; i <= n; ++i) {\\n            rightSum -= i;\\n            if (leftSum == rightSum) {\\n                return i;\\n            }else if (leftSum > rightSum) {\\n                return -1;\\n            }\\n            leftSum += i;\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def pivotInteger(self, n: int) -> int:\\n        right_sum = n * (n + 1) // 2\\n        left_sum = 0\\n        for i in range(1, n + 1):\\n            right_sum -= i\\n            if left_sum == right_sum:\\n                return i\\n            left_sum += i\\n        return -1\\n```\n```java\\n    public int pivotInteger(int n) {\\n        int sum = n * (n + 1) / 2;\\n        int lo = 1, hi = n + 1;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int leftSum = (mid - 1) * mid / 2;\\n            int rightSum = sum - (mid + 1) * mid / 2;\\n            if (leftSum < rightSum) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            }\\n        }\\n        return (lo - 1) * lo / 2 == sum - lo * (lo + 1) / 2 ? lo : -1;\\n    }\\n```\n```python\\n    def pivotInteger(self, n: int) -> int:\\n        total_sum = n * (n + 1) // 2\\n        lo, hi = 1, n + 1\\n        while lo < hi:\\n            mid = (lo + hi) // 2 \\n            left_sum = (mid - 1) * mid // 2\\n            right_sum = total_sum - left_sum - mid\\n            if left_sum < right_sum:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo if lo * (lo - 1) // 2 == total_sum - (lo + 1) * lo // 2 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2852423,
                "title": "java-c-python-2-line-math-solution-o-1",
                "content": "# **Explanation**\\n`1 + 2... + x = x + (x + 1)... + n`\\n`(1 + 2... + x) * 2 = 1 + 2 + ... + n + x`\\n`x * (x + 1)` = `n (n + 1) / 2 + x`\\n`x^2 + x = n (n + 1) / 2 + x`\\n`x^2 = n (n + 1) / 2`\\n`x = n (n + 1) / 2`\\n\\nSo we only need to check if `x` is integer,\\notehrwise return -1.\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`,\\nSpace `O(1)`.\\n(Actually is O(sqrt))\\n<br>\\n\\n**Java**\\n```java\\n    public int pivotInteger(int n) {\\n        double x = Math.sqrt(n * (n + 1) / 2);\\n        return x % 1 == 0 ? (int)x : -1;\\n    }\\n```\\n**C++**\\n```cpp\\n    int pivotInteger(int n) {\\n        double x = sqrt(n * (n + 1) / 2);\\n        return round(x) == x ? int(x) : -1;\\n    }\\n```\\n**Python**\\n```py\\n    def pivotInteger(self, n):\\n        x = sqrt(n * (n + 1) // 2)\\n        return -1 if x % 1 else int(x)\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int pivotInteger(int n) {\\n        double x = Math.sqrt(n * (n + 1) / 2);\\n        return x % 1 == 0 ? (int)x : -1;\\n    }\\n```\n```cpp\\n    int pivotInteger(int n) {\\n        double x = sqrt(n * (n + 1) / 2);\\n        return round(x) == x ? int(x) : -1;\\n    }\\n```\n```py\\n    def pivotInteger(self, n):\\n        x = sqrt(n * (n + 1) // 2)\\n        return -1 if x % 1 else int(x)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2852273,
                "title": "store-prefix-in-variable",
                "content": "There is a similar problem [724. Find Pivot Index](https://leetcode.com/problems/find-pivot-index/)\\n# C++    \\n\\tint pivotInteger(int n) {\\n        int total = n * (n + 1) / 2;\\n        int left = 0;\\n        for(int k = 1;k <= n;++k){\\n            left += k;\\n            int right = total - left + k;\\n            if(left == right) return k;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "There is a similar problem [724. Find Pivot Index](https://leetcode.com/problems/find-pivot-index/)\\n# C++    \\n\\tint pivotInteger(int n) {\\n        int total = n * (n + 1) / 2;\\n        int left = 0;\\n        for(int k = 1;k <= n;++k){\\n            left += k;\\n            int right = total - left + k;\\n            if(left == right) return k;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2852310,
                "title": "java-4-solutions",
                "content": "### **Please Upvote** :D\\n##### 1. Using prefix and suffix sum arrays:\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int[] left = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            left[i] = i + 1;\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            left[i] += left[i - 1];\\n        }\\n\\n        int[] right = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            right[i] = i + 1;\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            right[i] += right[i + 1];\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (left[i] == right[i]) {\\n                return i + 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n// TC: O(5 * n) => O(n)\\n// SC: O(2 * n) => O(n)\\n```\\n##### 2. Using prefix and suffix sum arrays (reduced looping):\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int[] left = new int[n];\\n        left[0] = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            left[i] = left[i - 1] + i + 1;\\n        }\\n\\n        int[] right = new int[n];\\n        right[n - 1] = n;\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            right[i] += right[i + 1] + i + 1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (left[i] == right[i]) {\\n                return i + 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n// TC: O(3 * n) => O(n)\\n// SC: O(2 * n) => O(n)\\n```\\n##### 3. Using only prefix sum (no extra space) + Math:\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int leftSum = 0;\\n        int sum = n * (n + 1) / 2;\\n\\n        for (int i = 1; i <= n; i++) {\\n            leftSum += i;\\n            int rightSum = sum - leftSum + i;\\n            if (leftSum == rightSum) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n##### 4. Only math:\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int k = n * (n + 1) / 2;\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (i * i == k) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int[] left = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            left[i] = i + 1;\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            left[i] += left[i - 1];\\n        }\\n\\n        int[] right = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            right[i] = i + 1;\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            right[i] += right[i + 1];\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (left[i] == right[i]) {\\n                return i + 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n// TC: O(5 * n) => O(n)\\n// SC: O(2 * n) => O(n)\\n```\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int[] left = new int[n];\\n        left[0] = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            left[i] = left[i - 1] + i + 1;\\n        }\\n\\n        int[] right = new int[n];\\n        right[n - 1] = n;\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            right[i] += right[i + 1] + i + 1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (left[i] == right[i]) {\\n                return i + 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n// TC: O(3 * n) => O(n)\\n// SC: O(2 * n) => O(n)\\n```\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int leftSum = 0;\\n        int sum = n * (n + 1) / 2;\\n\\n        for (int i = 1; i <= n; i++) {\\n            leftSum += i;\\n            int rightSum = sum - leftSum + i;\\n            if (leftSum == rightSum) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int k = n * (n + 1) / 2;\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (i * i == k) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852121,
                "title": "c-using-prefix-sum-easy-solution",
                "content": "**Similar to [724. Find Pivot Index](htthttps://leetcode.com/problems/find-pivot-index/p://)**\\n```\\nclass Solution {\\npublic:\\n    int pivotIndex(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int> pref(n);\\n       vector<int> suffix(n);\\n        \\n        int suma=0;\\n        for(int i=0;i<n;i++){\\n            pref[i]=suma;\\n            suma=suma+nums[i];\\n        }\\n       \\n        int sumb=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suffix[i]=sumb;\\n            sumb=sumb+nums[i];\\n        }\\n      \\n        \\n        int pos=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            if(pref[i]==suffix[i])\\n            {\\n                pos=i;\\n                break;\\n            }\\n        }\\n        return pos;\\n    }\\n    int pivotInteger(int n) {\\n        vector<int> ans(n+1);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            ans[i] = i;\\n        }\\n        \\n        int res  = pivotIndex(ans);\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotIndex(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int> pref(n);\\n       vector<int> suffix(n);\\n        \\n        int suma=0;\\n        for(int i=0;i<n;i++){\\n            pref[i]=suma;\\n            suma=suma+nums[i];\\n        }\\n       \\n        int sumb=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suffix[i]=sumb;\\n            sumb=sumb+nums[i];\\n        }\\n      \\n        \\n        int pos=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            if(pref[i]==suffix[i])\\n            {\\n                pos=i;\\n                break;\\n            }\\n        }\\n        return pos;\\n    }\\n    int pivotInteger(int n) {\\n        vector<int> ans(n+1);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            ans[i] = i;\\n        }\\n        \\n        int res  = pivotIndex(ans);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852111,
                "title": "c-super-easy-prefix-sum",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        if( n == 1 ) return 1 ;\\n        \\n        vector<int> preSum(n+1) ;\\n        int tmpSum = 0 ;\\n        \\n        for( int i=1 ; i<=n ; i++ ){\\n            tmpSum += i ;\\n            preSum[i] = tmpSum ;\\n        }\\n        \\n        int sum = 0 ;\\n        \\n        for( int i=n ; i>0 ; i-- ){\\n            sum += i ;\\n            if( sum == preSum[i] ) \\n                return i ;\\n        }\\n        \\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        if( n == 1 ) return 1 ;\\n        \\n        vector<int> preSum(n+1) ;\\n        int tmpSum = 0 ;\\n        \\n        for( int i=1 ; i<=n ; i++ ){\\n            tmpSum += i ;\\n            preSum[i] = tmpSum ;\\n        }\\n        \\n        int sum = 0 ;\\n        \\n        for( int i=n ; i>0 ; i-- ){\\n            sum += i ;\\n            if( sum == preSum[i] ) \\n                return i ;\\n        }\\n        \\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852084,
                "title": "c-2-lines",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        float x = sqrt((n*n+n)/2);\\n        return ( x == (int)x )?x:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        float x = sqrt((n*n+n)/2);\\n        return ( x == (int)x )?x:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852083,
                "title": "c-simple-clean-o-logn-solution-using-binary-search",
                "content": "```\\nint pivotInteger(int n) {\\n        int l=1,r=n,mid;\\n        while(l<=r)\\n        {\\n            mid=(l+r)/2;\\n            int a=(mid*(mid+1))/2;\\n            int b=((n*(n+1))/2)-a+mid;\\n            if(a==b)return mid;\\n            if(a<b)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\npls upvote if u like the sol",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint pivotInteger(int n) {\\n        int l=1,r=n,mid;\\n        while(l<=r)\\n        {\\n            mid=(l+r)/2;\\n            int a=(mid*(mid+1))/2;\\n            int b=((n*(n+1))/2)-a+mid;\\n            if(a==b)return mid;\\n            if(a<b)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852010,
                "title": "c-java-python3-2-line-math",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e728a9f475e5742bea7cf67ac2d1a98ab99fb206) for solutions of weekly 321. \\n\\n**Intuition**\\nHere, we are solving an equation `x*(x+1)/2 == n*(n+1)/2 - (x-1)*x/2` for which the solution is `sqrt(n*(n+1)/2)`. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sm = n * (n+1)/2, val = sqrt(sm); \\n        return val*val == sm ? val : -1; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sm = n*(n+1)/2, val = (int) Math.sqrt(sm); \\n        return val*val == sm ? val : -1; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        val = n*(n+1)//2\\n        return isqrt(val) if isqrt(val)**2 == val else -1 \\n```\\n**Complexity**\\nTime O(1)\\nSpace O(1) \\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sm = n * (n+1)/2, val = sqrt(sm); \\n        return val*val == sm ? val : -1; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sm = n*(n+1)/2, val = (int) Math.sqrt(sm); \\n        return val*val == sm ? val : -1; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        val = n*(n+1)//2\\n        return isqrt(val) if isqrt(val)**2 == val else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628985,
                "title": "no-loops-just-2-line-simple-and-fast-code-for-any-language",
                "content": "\\nNote: If you like this solution or find it useful, please upvote this post.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe want to find a number such that the sum of all numbers from 1 to that number is equal to the sum of all numbers from that number to a given number n.\\n\\nFor example, if n = 8, then the output is 6 because 1+2+3+4+5+6 = 6+7+8.\\n\\nGenerally, we want to find x such that:\\n1+2+3+...+x = x+(x+1)+(x+2)+...+n\\n\\nWe can rewrite this equation by subtracting (1+2+3+...+x) from both sides:\\n1+2+3+...+x = (1+2+3+...+x) - (1+2+3+...+x) + (x+(x+1)+(x+2)+...+n)\\n\\nNow let\\'s do some rearrangement:\\n1+2+3+...+x = (1+2+3+...+x) + (x+(x+1)+(x+2)+...+n) - (1+2+3+...+x)\\n\\nSimplifying further, we get:\\n1+2+3+...+x + x+(x+1)+(x+2)+...+n\\n\\nSince there are 2 occurrences of x in the equation, we can simplify it as follows:\\n1+2+3+...+x = (1+2+3+...) + (x+(x+1)+(x+2)+...+n) - (1+2+3+...+x) + x\\n\\nNow, consider (1+2+3+...) multiplied by (x+(x+1)+(x+2)+...+n). It is the sum of the first n numbers. Let\\'s open the brackets:\\n(-1-2-3-...-(x-1)-x) + x\\n\\nThe -x and +x cancel out, so we have:\\n1+2+3+...+x = (1+2+3+...)(x+(x+1)+(x+2)+...+n) - (1+2+3+...+(x-1))\\n\\nThe term (1+2+3+...+(x-1)) is nothing but the sum of the first x-1 numbers. The left part is the sum of the first n numbers. We know that the equation to find the sum of the first n numbers is n*(n+1)/2. So let\\'s rewrite this:\\n\\nSum of the first x numbers = Sum of the first n numbers - Sum of the first x-1 numbers\\n$$x*(x+1)/2 = n*(n+1)/2 - (x-1)*x/2$$\\n\\nSimplifying further, we get:\\nx*(x+1)/2 + (x-1)x/2 = n(n+1)/2\\n\\nx*(x+1) + (x-1)x = n(n+1)\\n\\n2x^2 = n*(n+1)\\n\\nDividing both sides by 2:\\nx^2 = n*(n+1)/2\\n\\nTaking the square root of both sides:\\nx = Sqrt(n*(n+1)/2)\\n\\nThis formula gives us the value of x such that the sum of all numbers from 1 to x is equal to the sum of all numbers from x to n.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(1), which means it has constant time complexity. Regardless of the value of the input integer n, the code performs a fixed number of arithmetic operations and comparisons. The execution time does not depend on the size of the input.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(1) because the code does not use any additional data structures that grow in size with the input. It only requires a few variables to store the intermediate results and the final result, which occupy a constant amount of space.\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        x=(n*(n+1)/2)**0.5\\n        return int(x) if int(x)==x else -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        x=(n*(n+1)/2)**0.5\\n        return int(x) if int(x)==x else -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099304,
                "title": "beats-100-ms-97-memory",
                "content": "# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum=n*(n+1)/2;      //sum from 1 to n;\\n        for(int i=n/2;i<=n;i++)\\n        {   \\n            int sum_to_i=i*(i+1)/2;\\n            if(sum_to_i==(sum-sum_to_i+i))return i; //there is +i because we want sum from i to n \\n                                                    //not from i-1 to n;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nDont forget to upvote :)\\n![upvote.png](https://assets.leetcode.com/users/images/db6f72fe-3fb9-409c-aca8-d4873062fdd0_1674675330.2776644.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum=n*(n+1)/2;      //sum from 1 to n;\\n        for(int i=n/2;i<=n;i++)\\n        {   \\n            int sum_to_i=i*(i+1)/2;\\n            if(sum_to_i==(sum-sum_to_i+i))return i; //there is +i because we want sum from i to n \\n                                                    //not from i-1 to n;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882576,
                "title": "c-one-line-solution-using-math",
                "content": "# Solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind x, that sum(1, x) = sum(x, n)\\n\\n$$\\\\sum_{l}^{r} = \\\\frac{(r - l + 1)(l + r)}{2}$$\\n\\nWith given n, solve the equation with one unknown variable. Try it yourself!\\n\\n$$x = \\\\frac{\\\\sqrt{n^2 + n}}{2} $$\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int m = (n + n * n) / 2;\\n        if (int q = sqrt(m); q * q == m)\\n            return q;\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int m = (n + n * n) / 2;\\n        if (int q = sqrt(m); q * q == m)\\n            return q;\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859253,
                "title": "python-math-solution-sum-of-an-arithmetic-sequence",
                "content": "https://leetcode.com/submissions/detail/851656878/\\n```\\nRuntime: 98 ms, faster than 64.20% of Python3 online submissions for Find the Pivot Integer.\\nMemory Usage: 31.9 MB, less than 15.80% of Python3 online submissions for Find the Pivot Integer.\\n```\\n```\\nfrom numpy import ceil, floor\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        ## (1+x)*x/2 = (x+n)*(n-x+1)/2\\n        ## x^2 = n*(n+1)/2\\n        pivot = (n*(n+1)/2)**0.5\\n        if ceil(pivot)==floor(pivot):\\n            return int(pivot)\\n        return -1\\n```\\n![image](https://assets.leetcode.com/users/images/14114d05-0504-469c-abf8-1b30de50020b_1669713353.691913.webp)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nRuntime: 98 ms, faster than 64.20% of Python3 online submissions for Find the Pivot Integer.\\nMemory Usage: 31.9 MB, less than 15.80% of Python3 online submissions for Find the Pivot Integer.\\n```\n```\\nfrom numpy import ceil, floor\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        ## (1+x)*x/2 = (x+n)*(n-x+1)/2\\n        ## x^2 = n*(n+1)/2\\n        pivot = (n*(n+1)/2)**0.5\\n        if ceil(pivot)==floor(pivot):\\n            return int(pivot)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854006,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n```rs\\nimpl Solution {\\n    pub fn pivot_integer(n: i32) -> i32 {\\n        // total sum: 1 + 2 + ... + n - 1 + n\\n        let mut s1 = n * (n + 1) / 2;\\n        // running sum\\n        let mut s2 = 0;\\n        for i in 1 .. n + 1 {\\n            // add i to s2 (prefix sum)\\n            s2 += i;\\n            // if both sum is same, then i is the pivot integer\\n            if s1 == s2 {\\n                return i;\\n            }\\n            // substract i from s1 (suffix sum)\\n            s1 -= i;\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nimpl Solution {\\n    pub fn pivot_integer(n: i32) -> i32 {\\n        // total sum: 1 + 2 + ... + n - 1 + n\\n        let mut s1 = n * (n + 1) / 2;\\n        // running sum\\n        let mut s2 = 0;\\n        for i in 1 .. n + 1 {\\n            // add i to s2 (prefix sum)\\n            s2 += i;\\n            // if both sum is same, then i is the pivot integer\\n            if s1 == s2 {\\n                return i;\\n            }\\n            // substract i from s1 (suffix sum)\\n            s1 -= i;\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852743,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlet that number be x;\\nx*(x+1)/2=n*(n+1)/2-x*(x+1)/2+x;\\nso after transposing we get\\nequation as\\nx^2=n*(n+1)/2;\\nif(n*(n+1)/2) is perfect square then answer exist and ans is square root of the (n*(n+1))/2 else ans doesn\\'t exist and ans is -1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool checkperfectsquare(int n)\\n{\\n     \\n    \\n    if (ceil((double)sqrt(n)) == floor((double)sqrt(n))) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    int pivotInteger(int n) {\\n        int x=((n)*(n+1))/2;\\n        if( checkperfectsquare(x)){\\n            int ans=sqrt(x);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool checkperfectsquare(int n)\\n{\\n     \\n    \\n    if (ceil((double)sqrt(n)) == floor((double)sqrt(n))) {\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n}\\n    int pivotInteger(int n) {\\n        int x=((n)*(n+1))/2;\\n        if( checkperfectsquare(x)){\\n            int ans=sqrt(x);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851998,
                "title": "c-using-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) \\n    {\\n        \\n        vector<int> left(n+1);\\n        vector<int> right(n+1);\\n        \\n        int total = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            total += i;\\n        }\\n        \\n        left[0] = 0;\\n        right[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            left[i] = i + left[i-1];\\n            right[i] = total - left[i-1];\\n            \\n            if(left[i]==right[i]) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) \\n    {\\n        \\n        vector<int> left(n+1);\\n        vector<int> right(n+1);\\n        \\n        int total = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            total += i;\\n        }\\n        \\n        left[0] = 0;\\n        right[0] = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            left[i] = i + left[i-1];\\n            right[i] = total - left[i-1];\\n            \\n            if(left[i]==right[i]) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851937,
                "title": "sum-of-n-terms",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int m = (n*(n+1))/2 , ans = -1;\\n        for(int i=1; i<=n; i++){\\n            int k = (i*(i+1))/2;\\n            if(k==m){\\n                ans = i;\\n                break;\\n            }\\n            m -= i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int m = (n*(n+1))/2 , ans = -1;\\n        for(int i=1; i<=n; i++){\\n            int k = (i*(i+1))/2;\\n            if(k==m){\\n                ans = i;\\n                break;\\n            }\\n            m -= i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030054,
                "title": "java-1000-beats-0-log-n-2-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Using Binary seach..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst solution solved using Binary search and second solution using linear search.\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum = n*(n+1)/2;\\n        int low = 1, high = n+1;\\n        while (low<high) {\\n            int mid = low+(high-low)/2;\\n            int leftSum = (mid-1)*mid/2 , rightSum = sum-(mid+1)*mid/2;\\n            if (leftSum < rightSum) low = mid+1;\\n            else high = mid;  \\n        }\\n        if((low-1)*low/2 == sum-low*(low+1)/2) return low;\\n        return -1;\\n\\n//       Another solution(0(N))--> (try this one)\\n\\n        // if(n==1) return n;\\n        // int temp = n , val = n;\\n        // int sum = n*(n+1)/2;\\n        // while(temp!=0){\\n        //     if(sum!=val){\\n        //         sum=sum-temp;\\n        //         temp--;\\n        //         val+=temp;\\n        //     }else return temp;\\n        // }\\n        // return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum = n*(n+1)/2;\\n        int low = 1, high = n+1;\\n        while (low<high) {\\n            int mid = low+(high-low)/2;\\n            int leftSum = (mid-1)*mid/2 , rightSum = sum-(mid+1)*mid/2;\\n            if (leftSum < rightSum) low = mid+1;\\n            else high = mid;  \\n        }\\n        if((low-1)*low/2 == sum-low*(low+1)/2) return low;\\n        return -1;\\n\\n//       Another solution(0(N))--> (try this one)\\n\\n        // if(n==1) return n;\\n        // int temp = n , val = n;\\n        // int sum = n*(n+1)/2;\\n        // while(temp!=0){\\n        //     if(sum!=val){\\n        //         sum=sum-temp;\\n        //         temp--;\\n        //         val+=temp;\\n        //     }else return temp;\\n        // }\\n        // return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419901,
                "title": "c-and-c-very-easy-solution-with-explanation",
                "content": "![photo_2023-04-15_20-28-27.jpg](https://assets.leetcode.com/users/images/60297274-1260-4187-be77-fce341c27939_1681572742.843554.jpeg)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n       double x=sqrt((n*n+n)/2);\\n       if((int)x==x)\\n       return x;\\n       return -1;\\n    }\\n};\\n// 1+2+..+x==x+x+1..n\\n// x*(1+x)/2=(n-x+1)*(x+n)/2\\n//x+x*x=n*n-x*x+n+x\\n//2*x*x==n*n+n\\n//x=ildiz(n*n+n)/2 \\n```\\n```C# []\\npublic class Solution {\\n    public int PivotInteger(int n) {\\n        double x=Math.Sqrt((n*n+n)/2);\\n        int y=(int)x;\\n       if(y==x)\\n       return y;\\n       return -1; \\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n       double x=sqrt((n*n+n)/2);\\n       if((int)x==x)\\n       return x;\\n       return -1;\\n    }\\n};\\n// 1+2+..+x==x+x+1..n\\n// x*(1+x)/2=(n-x+1)*(x+n)/2\\n//x+x*x=n*n-x*x+n+x\\n//2*x*x==n*n+n\\n//x=ildiz(n*n+n)/2 \\n```\n```C# []\\npublic class Solution {\\n    public int PivotInteger(int n) {\\n        double x=Math.Sqrt((n*n+n)/2);\\n        int y=(int)x;\\n       if(y==x)\\n       return y;\\n       return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324176,
                "title": "use-sum-of-natural-formula-n-n-1-2",
                "content": "\\n\\n# Sum of Natural Number Approach\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        for i in range(1,n+1):\\n            left=((i+1)*i)//2\\n            right=(n*(n+1))//2-(i*(i-1))//2\\n            if right==left:\\n                return i\\n        return -1\\n\\n    //please upvote me it would encourage me alot\\n\\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        for i in range(1,n+1):\\n            left=((i+1)*i)//2\\n            right=(n*(n+1))//2-(i*(i-1))//2\\n            if right==left:\\n                return i\\n        return -1\\n\\n    //please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142467,
                "title": "100-fastest-and-easy-to-understand-c-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum = (n*(n+1))/2;\\n        int temp = 0;\\n        int ans = -1;\\n        for(int i=1; i<=n; i++)\\n        {\\n            sum = sum -i;\\n            if(sum==temp)\\n            {\\n                ans=i;\\n                break;\\n            }\\n            temp = temp + i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum = (n*(n+1))/2;\\n        int temp = 0;\\n        int ans = -1;\\n        for(int i=1; i<=n; i++)\\n        {\\n            sum = sum -i;\\n            if(sum==temp)\\n            {\\n                ans=i;\\n                break;\\n            }\\n            temp = temp + i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940552,
                "title": "easy-and-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        sm=0\\n        rm=0\\n        if n==1:\\n            return 1\\n        for i in range(n+1):\\n            sm+=i\\n        for j in range(1,n):\\n            sm=sm-j+1\\n            rm=rm+j\\n            if sm==rm:\\n                return j\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        sm=0\\n        rm=0\\n        if n==1:\\n            return 1\\n        for i in range(n+1):\\n            sm+=i\\n        for j in range(1,n):\\n            sm=sm-j+1\\n            rm=rm+j\\n            if sm==rm:\\n                return j\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883348,
                "title": "math-with-explanation",
                "content": "# Intuition & Explanation\\nLet pivot integer be `x`.\\n1, 2, 3, 4, 5, ... x, ... , n - 1, n.\\n\\n`left` 1 to x = `(x + 1) * x / 2`\\n`right` x to n = `(n + 1) * n / 2 - (x - 1) * x / 2`\\n\\n`left` = `right`\\n`(x * x + x) / 2 = (n * n + n - x * x + x) / 2`\\n`2 * x * x = n * n + n`\\n`x^2 = (n^2 + n) / 2`\\n\\ntherefor\\n`x = sqrt((n^2 + n) / 2)`\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf the `x` comes as an integer using the formula we derived then we return `x`.\\nelse it\\'s not possible therefore return `-1`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(1)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int x2 = (n * n + n) / 2;\\n        int x = (int)Math.sqrt(x2);\\n        if(x * x == x2)\\n            return x;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int x2 = (n * n + n) / 2;\\n        int x = (int)Math.sqrt(x2);\\n        if(x * x == x2)\\n            return x;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871104,
                "title": "o-1-time-and-o-1-space-simple-and-explained-solution-in-3-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a Math problem where we look for second degree equation solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to look for x where the sum of 1 to x equal to the sum of x to n. We know that the sum of 1 to n is n * ( n + 1) / 2, so the sum from 1 to x is x * ( x + 1) / 2. So we need to solve \\n```\\nx * ( x + 1) / 2 = n * ( n + 1) / 2 - x * ( x + 1) / 2 + x\\n```\\nthe sum from 1 to x equal to the some from 1 to n minus the sum from 1 to x plus x.\\nWhich simplify to\\n```\\nx * x = n\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nMath.Sqrt() is O(1) // from google\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) two variables\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PivotInteger(int n) {\\n        var t = Math.Sqrt(n * (n + 1) / 2); \\n        int r = (int)t;\\n        return t == r ? r : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nx * ( x + 1) / 2 = n * ( n + 1) / 2 - x * ( x + 1) / 2 + x\\n```\n```\\nx * x = n\\n```\n```\\npublic class Solution {\\n    public int PivotInteger(int n) {\\n        var t = Math.Sqrt(n * (n + 1) / 2); \\n        int r = (int)t;\\n        return t == r ? r : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852971,
                "title": "python-3-2-versions-1-3-lines-w-some-explanation-t-m-100-92",
                "content": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:  # algebra tells us that if the pivot index  \\n                                            # k exists, then k = sqrt(n*(n+1)//2) \\n\\n        N = n*(n+1)//2                      # <-- Sum of the integers 1, 2..., n\\n\\n        k = isqrt(N)                        # <-- compute the candidate\\n\\n        return k if N == k*k else -1        # <-- check and return answer\\n\\n```\\n[https://leetcode.com/submissions/detail/850533907/](http://)\\n\\n\\n```\\n# Number theory tells us that, within the given constraint  1 <= n <= 1000, \\n# only four integers of the form n(n+1)//2 are perfect squares. This set \\n# becomes even more sparse as the upper bound for n increases. (Yeah, it\\'s \\n# kind of a cheat...)\\n\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n\\n        return isqrt(n*(n+1)//2) if n in {1, 8, 49, 288} else -1   \\n\\n```\\n\\n\\n\\n\\nI could be wrong, but I think it\\'s T: *O*(1) and S: *O*(1).\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:  # algebra tells us that if the pivot index  \\n                                            # k exists, then k = sqrt(n*(n+1)//2) \\n\\n        N = n*(n+1)//2                      # <-- Sum of the integers 1, 2..., n\\n\\n        k = isqrt(N)                        # <-- compute the candidate\\n\\n        return k if N == k*k else -1        # <-- check and return answer\\n\\n```\n```\\n# Number theory tells us that, within the given constraint  1 <= n <= 1000, \\n# only four integers of the form n(n+1)//2 are perfect squares. This set \\n# becomes even more sparse as the upper bound for n increases. (Yeah, it\\'s \\n# kind of a cheat...)\\n\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n\\n        return isqrt(n*(n+1)//2) if n in {1, 8, 49, 288} else -1   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852346,
                "title": "c-one-pass-easy-to-understand",
                "content": "# Approach\\nTook two pointers and maintained the sum from both side.\\nwhen sum are equal check in both pointers are adjacent.\\n\\n# Complexity\\n- Time complexity: O(N/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int t) {\\n        int s=1,n=t,sums=1,sumb=n;\\n        if(n==s)return n;\\n        while(s<n){\\n            if(sums<sumb)\\n                sums+=++s;\\n            else\\n                sumb+=--n;\\n            if(sums==sumb && n!=t && s+1==n-1)return s+1;\\n        }\\n    \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int t) {\\n        int s=1,n=t,sums=1,sumb=n;\\n        if(n==s)return n;\\n        while(s<n){\\n            if(sums<sumb)\\n                sums+=++s;\\n            else\\n                sumb+=--n;\\n            if(sums==sumb && n!=t && s+1==n-1)return s+1;\\n        }\\n    \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852190,
                "title": "c-binary-search-o-log-n-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n\\n        int start=0;\\n        if(n==1)return 1;\\n        int end=n;\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;\\n            // cout<<mid<<\" \";\\n            int sum1=(mid)*(mid+1)/2;\\n            int sum2=(n*(n+1))/2-sum1+mid;\\n            // if(mid==6)\\n            // {\\n                // cout<<sum1<<\" \"<<sum2;\\n            // }\\n            if(sum1==sum2)\\n            {\\n                return mid;\\n            }\\n            else if(sum1<sum2)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n\\n        int start=0;\\n        if(n==1)return 1;\\n        int end=n;\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;\\n            // cout<<mid<<\" \";\\n            int sum1=(mid)*(mid+1)/2;\\n            int sum2=(n*(n+1))/2-sum1+mid;\\n            // if(mid==6)\\n            // {\\n                // cout<<sum1<<\" \"<<sum2;\\n            // }\\n            if(sum1==sum2)\\n            {\\n                return mid;\\n            }\\n            else if(sum1<sum2)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3548100,
                "title": "python-very-easy-4-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        s1 = 0\\n        s2 = 0\\n        for i in range(1,n+1):\\n            s1 = sum(range(1, i+1))\\n            s2 = sum(range(i, n+1))\\n            if(s1==s2):\\n                return i\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        s1 = 0\\n        s2 = 0\\n        for i in range(1,n+1):\\n            s1 = sum(range(1, i+1))\\n            s2 = sum(range(i, n+1))\\n            if(s1==s2):\\n                return i\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369188,
                "title": "c-prefix-sum-faster-easy-to-understand",
                "content": "* ***Prefix Sum***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        // find the prefix sum \\n        \\n        vector<int> prefix(n + 1, 0);\\n        \\n        prefix[1] = 1;\\n        \\n        for(int i = 2; i <= n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + i;\\n        }\\n        \\n        // traverse over the prefix array and find pivot\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            int left = prefix[i];\\n            \\n            int right = prefix[n] - prefix[i - 1];\\n            \\n            if(left == right)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        // find the prefix sum \\n        \\n        vector<int> prefix(n + 1, 0);\\n        \\n        prefix[1] = 1;\\n        \\n        for(int i = 2; i <= n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + i;\\n        }\\n        \\n        // traverse over the prefix array and find pivot\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            int left = prefix[i];\\n            \\n            int right = prefix[n] - prefix[i - 1];\\n            \\n            if(left == right)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882569,
                "title": "left-and-right",
                "content": "# Intuition\\nIterate from n to 1 to find the pivot integer.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing prefix sum find the sum of elements after `i` and find the pivot where `left == right`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int left, right;\\n        left = right = 0;\\n        for(int i = 1; i <= n; i++)\\n            left += i;\\n        for(int i = n; i > 0; i--) {\\n            right += i;\\n            if(left == right)\\n                return i;\\n            left -= i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int left, right;\\n        left = right = 0;\\n        for(int i = 1; i <= n; i++)\\n            left += i;\\n        for(int i = n; i > 0; i--) {\\n            right += i;\\n            if(left == right)\\n                return i;\\n            left -= i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874442,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        l=[]\\n        for i in range(1,n+1):\\n            l.append(i)\\n        for i in range(n):\\n            if sum(l[:i+1])==sum(l[i:]):\\n                return i+1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        l=[]\\n        for i in range(1,n+1):\\n            l.append(i)\\n        for i in range(n):\\n            if sum(l[:i+1])==sum(l[i:]):\\n                return i+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853860,
                "title": "easy-understanding-c-single-iteration",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum=0,rsum=0; \\n        for(int i=1;i<=n;i++) sum+=i;\\n       for(int i=n;i>0;i--)\\n       {\\n           rsum+=i;\\n           if(rsum==sum) return i;\\n          sum-=i;\\n       }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum=0,rsum=0; \\n        for(int i=1;i<=n;i++) sum+=i;\\n       for(int i=n;i>0;i--)\\n       {\\n           rsum+=i;\\n           if(rsum==sum) return i;\\n          sum-=i;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2852967,
                "title": "simple-ap-maths-proof-with-picture",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![IMG_1427 (1).jpg](https://assets.leetcode.com/users/images/860d606b-4fd6-4f47-abc9-dc4842bf438b_1669534430.6968548.jpeg)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(Sqrt (N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        \\n        double ans =  Math.sqrt(n * (n+1) / 2);\\n        if(ans % 1 == 0) return (int) ans; // Checking if Sqrt is Integer or not\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        \\n        double ans =  Math.sqrt(n * (n+1) / 2);\\n        if(ans % 1 == 0) return (int) ans; // Checking if Sqrt is Integer or not\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852532,
                "title": "c-solution-basic-maths-approach",
                "content": "class Solution {\\npublic:\\n    int pivotInteger(int n) {\\n         long long i,sum=0,sum1=0;\\n        if(n==1)  return 1;\\n         for(i=1;i<n;i++){\\n             sum=(i*(i+1))/2;    //sum of first n integers\\n             sum1=(n*(n+1))/2-sum+i;   //sum of remaining integers + number(because it includees in both)\\n             if(sum1==sum) return i;    //return answer when both are eqaul\\n         }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int pivotInteger(int n) {\\n         long long i,sum=0,sum1=0;\\n        if(n==1)  return 1;\\n         for(i=1;i<n;i++){\\n             sum=(i*(i+1))/2;    //sum of first n integers\\n             sum1=(n*(n+1))/2-sum+i;   //sum of remaining integers + number(because it includees in both)\\n             if(sum1==sum) return i;    //return answer when both are eqaul\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2852384,
                "title": "c-python3-2-lines-o-1-easy-solution",
                "content": "**C++ 2lines O(1) solution, using basic formula**\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int p = n*(n+1)/2, q = sqrt(p);\\n        return q*q == p ? q : -1;\\n    }\\n};\\n```\\n\\n**Python3**\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        p= n*(n+1)//2\\n        q = int(sqrt(p))\\n        if(q*q==p): return q\\n        else: return -1\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int p = n*(n+1)/2, q = sqrt(p);\\n        return q*q == p ? q : -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        p= n*(n+1)//2\\n        q = int(sqrt(p))\\n        if(q*q==p): return q\\n        else: return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825060,
                "title": "simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe numbers are in arithmetic progression,so we can take advantage of that fact.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s assume the answeer as \\'x\\'.now the arithmetic sum from 1 to x and x to n should be same.lets name the sum from 1 to x as sum1 and x to n as sum2.here,for sum1 the first term is 1 and last term is x and for  sum2 the first term is x and last term is n. \\nwe know that sum of ap for given last term is - s = (n/2)*(a1 + an)\\nfor sum1 - n = x,an =x and a1 =1.\\nfor sum2 - n = (n-x+1),a1 = x and an = n.\\nequating both sum1 and sum2 and solving the equation we get the relation x*x = (n*n + n)/2.from now we just have to find square root of x and verify it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nimport java.lang.*;\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int a = (int)Math.sqrt((n*n + n)/2);\\n        if(2*a*a==n*n+n)\\n        return a;\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nimport java.lang.*;\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int a = (int)Math.sqrt((n*n + n)/2);\\n        if(2*a*a==n*n+n)\\n        return a;\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736435,
                "title": "c-best-easiest-beats-100-0ms-solution",
                "content": "\\n# Approach\\nDivide the sum into 2 parts sum1 and sum2. If both of these are equal return the last number that was added. This is your pivot number.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum=0;\\n        for(int i=1;i<n+1;i++){\\n            sum=sum+i;\\n        }\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=1;i<=n;i++){\\n            sum1=sum1+i;\\n            sum2=i+sum-sum1;\\n            if(sum1==sum2){\\n                return i;\\n            }\\n            else{\\n                sum2=0;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum=0;\\n        for(int i=1;i<n+1;i++){\\n            sum=sum+i;\\n        }\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=1;i<=n;i++){\\n            sum1=sum1+i;\\n            sum2=i+sum-sum1;\\n            if(sum1==sum2){\\n                return i;\\n            }\\n            else{\\n                sum2=0;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703958,
                "title": "maths-soution-with-proof",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nx must be a perfect Square\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WhatsApp Image 2023-07-01 at 16.34.12.jpg](https://assets.leetcode.com/users/images/3fd10e6f-3df3-4716-9ec5-0ea7ac289ce7_1688209591.5050952.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n         int ans= ((n*n)+n)/2;\\n        int sq=(int)Math.sqrt(ans);\\n        if(ans==sq*sq) return sq;\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n         int ans= ((n*n)+n)/2;\\n        int sq=(int)Math.sqrt(ans);\\n        if(ans==sq*sq) return sq;\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610449,
                "title": "clean-code-with-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem requires finding the pivot integer in the range of 1 to n, where the pivot integer is defined as the number at the index where the sum of all numbers to the left is equal to the sum of all numbers to the right.\\n\\n# Approach\\n1. We start by creating two arrays: arr and prefix. These arrays will help us store and calculate the required values.\\n1. We initialize the first element of both arrays as 1 because the first number in the range is always 1.\\n1. If the given range n is 1 (i.e., there is only one number in the range), we return 1 as the pivot integer.\\n1. Next, we fill the arr array with numbers incrementing from the previous number by 1. For example, if the previous number is 1, the next number will be 2, then 3, and so on.\\n1. We calculate the prefix sum in the prefix array. This means each element in the prefix array is the sum of all the elements before it in the arr array. For example, if the arr array is [1, 2, 3, 4], the prefix array will be [1, 3, 6, 10] (1, 1+2, 1+2+3, 1+2+3+4).\\n1. We iterate through the prefix array and check if the sum of elements on the left side of each index is equal to the sum of elements on the right side.\\n1. If we find an index where the left sum is equal to the right sum, we have found the pivot index. We return the corresponding index plus 1.\\n1. If no pivot index is found after iterating through the array, we return -1 to indicate that there is no pivot integer.\\n\\n# Complexity\\n- Time complexity:\\n1. Creating the arr array takes $$O(n)$$ time.\\n1. Calculating the prefix sum in the prefix array takes $$O(n)$$ time.\\n1. Checking for the pivot index by iterating through the prefix array takes $$O(n)$$ time.\\n1. Therefore, the overall time complexity is $$O(n)$$.\\n\\n- Space complexity:\\nThe arr and prefix arrays both have a size of n, so the space complexity is $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        \\n        // Create an array to store the numbers in the range\\n        int[] arr = new int[n];\\n        \\n        // Create an array to store the prefix sum of the numbers\\n        int[] prefix = new int[n];\\n        \\n        // Initialize the first element of both arrays as 1\\n        arr[0] = 1;\\n        prefix[0] = arr[0];\\n        \\n        // If the range is 1, return 1 as the pivot integer\\n        if (n == 1)\\n            return 1;\\n\\n        // Fill the arr array with numbers incrementing from the previous number by 1\\n        for (int i = 1; i < n; i++) {\\n            arr[i] = arr[i-1] + 1;\\n        }\\n        \\n        // Calculate the prefix sum in the prefix array\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i-1] + arr[i];\\n        }\\n        \\n        // Iterate through the prefix array to find the pivot integer\\n        for (int i = 1; i < n; i++) {\\n            int left = prefix[i-1];\\n            int right = prefix[n-1] - prefix[i];\\n            \\n            // If the left sum is equal to the right sum, return the pivot integer (index + 1)\\n            if (left == right) {\\n                return i+1;\\n            }\\n        }\\n        \\n        // If no pivot integer is found, return -1\\n        return -1;\\n    }\\n}\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/b397e4c7-b7e7-41fe-ad05-2a956f38ce3f_1686162839.1015584.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        \\n        // Create an array to store the numbers in the range\\n        int[] arr = new int[n];\\n        \\n        // Create an array to store the prefix sum of the numbers\\n        int[] prefix = new int[n];\\n        \\n        // Initialize the first element of both arrays as 1\\n        arr[0] = 1;\\n        prefix[0] = arr[0];\\n        \\n        // If the range is 1, return 1 as the pivot integer\\n        if (n == 1)\\n            return 1;\\n\\n        // Fill the arr array with numbers incrementing from the previous number by 1\\n        for (int i = 1; i < n; i++) {\\n            arr[i] = arr[i-1] + 1;\\n        }\\n        \\n        // Calculate the prefix sum in the prefix array\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i-1] + arr[i];\\n        }\\n        \\n        // Iterate through the prefix array to find the pivot integer\\n        for (int i = 1; i < n; i++) {\\n            int left = prefix[i-1];\\n            int right = prefix[n-1] - prefix[i];\\n            \\n            // If the left sum is equal to the right sum, return the pivot integer (index + 1)\\n            if (left == right) {\\n                return i+1;\\n            }\\n        }\\n        \\n        // If no pivot integer is found, return -1\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501671,
                "title": "swift-binary-search-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    func pivotInteger(_ n: Int) -> Int {\\n        let arr = Array(1...n)\\n        var left = 0\\n        var right = n\\n\\n        while left <= right {\\n            let mid = (left + right) / 2\\n            let sumLeft = arr[0...mid].reduce(0, +)\\n            let sumRight = arr[mid..<arr.count].reduce(0, +)\\n\\n            if sumLeft == sumRight {\\n                return arr[mid]\\n            } else if sumLeft < sumRight {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    func pivotInteger(_ n: Int) -> Int {\\n        let arr = Array(1...n)\\n        var left = 0\\n        var right = n\\n\\n        while left <= right {\\n            let mid = (left + right) / 2\\n            let sumLeft = arr[0...mid].reduce(0, +)\\n            let sumRight = arr[mid..<arr.count].reduce(0, +)\\n\\n            if sumLeft == sumRight {\\n                return arr[mid]\\n            } else if sumLeft < sumRight {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375788,
                "title": "c-beats-100-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the first half of the sum up to the pivot is smaller than the second half, it means the pivot must be higher up in the list of number. Similarly, if the second half is smaller, then the pivot must be lower in the number list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can try and use a binary search apporach due to the observation made above. The sum of the first half is jsut using the math priciple to calculate sum given first and last arithematic sequence. \\n\\nn*(a + l)/2 \\n\\nWhere:\\n\"n\" is the height\\n\"a\" is the first in the series\\n\"l\" is the last in sereis\\n\\nThe first half and second half are then calculate each iteration, and the end points move based on that outcome. Converging on the pivot point (if it exist) after log(n) iteration. If not, will exit loop after log(n) iterations to return -1. \\n\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int start = 1; \\n        int end = n;\\n        int i = 0;\\n\\n        while(start <= end && i < log(n) + 1){\\n            int mid = floor((end - start)/2.0 + start);\\n            int firstHalf = (mid)* (mid + 1)/2;\\n            int secondHalf = (n - mid +1 ) * (n + mid)/2;\\n            if(firstHalf == secondHalf){\\n                return mid;\\n            }else if(firstHalf > secondHalf){\\n                end = mid;\\n            }else if(firstHalf < secondHalf){\\n                start = mid;\\n            }\\n\\n            i ++;\\n        }\\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int start = 1; \\n        int end = n;\\n        int i = 0;\\n\\n        while(start <= end && i < log(n) + 1){\\n            int mid = floor((end - start)/2.0 + start);\\n            int firstHalf = (mid)* (mid + 1)/2;\\n            int secondHalf = (n - mid +1 ) * (n + mid)/2;\\n            if(firstHalf == secondHalf){\\n                return mid;\\n            }else if(firstHalf > secondHalf){\\n                end = mid;\\n            }else if(firstHalf < secondHalf){\\n                start = mid;\\n            }\\n\\n            i ++;\\n        }\\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297196,
                "title": "python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        lst=[]\\n        for i in range(1,n+1):\\n            lst.append(i)\\n        for i in range(len(lst)):\\n            if sum(lst[:i])==sum(lst[i+1:]):\\n                return lst[i]\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        lst=[]\\n        for i in range(1,n+1):\\n            lst.append(i)\\n        for i in range(len(lst)):\\n            if sum(lst[:i])==sum(lst[i+1:]):\\n                return lst[i]\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269149,
                "title": "java-solution-easy-to-understand",
                "content": "# Java\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        \\n        int l = 0, r = 0;\\n\\n        if (n == 1) return 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n\\n            for (int j = i; j > 0; j--) l += j;\\n\\n            for (int s = i; s <= n; s++) r += s;\\n\\n            if (l == r) return i;\\n\\n            l = 0;\\n            r = 0;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        \\n        int l = 0, r = 0;\\n\\n        if (n == 1) return 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n\\n            for (int j = i; j > 0; j--) l += j;\\n\\n            for (int s = i; s <= n; s++) r += s;\\n\\n            if (l == r) return i;\\n\\n            l = 0;\\n            r = 0;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242534,
                "title": "basic-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getsum(int n){\\n        return (n*(n+1))/2;\\n\\n    }\\n    int pivotInteger(int n) {\\n        int sum1=0,sum2=0,ans=-1;\\n        for(int i=1;i<=n;i++){\\n            sum1=getsum(i);\\n            sum2=getsum(n)-getsum(i-1);\\n            if(sum1 == sum2){\\n                return i;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getsum(int n){\\n        return (n*(n+1))/2;\\n\\n    }\\n    int pivotInteger(int n) {\\n        int sum1=0,sum2=0,ans=-1;\\n        for(int i=1;i<=n;i++){\\n            sum1=getsum(i);\\n            sum2=getsum(n)-getsum(i-1);\\n            if(sum1 == sum2){\\n                return i;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176410,
                "title": "kotlin-solution-for-begginers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun pivotInteger(n: Int): Int {\\n        var result : Int = 0\\n        for (i in 1..n)\\n        {\\n            if (sum(i, n)) {\\n                result = i\\n                break\\n            }\\n            else result = -1\\n        }\\n        return result\\n    }\\n\\n    fun sum(x : Int, endPoint : Int) : Boolean {\\n        var sumLeft = 0\\n        var sumRight = 0\\n\\n        for (j in 1..x) sumLeft += j\\n        for (j in endPoint downTo x) sumRight += j\\n\\n        if (sumLeft == sumRight) return true\\n        else return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun pivotInteger(n: Int): Int {\\n        var result : Int = 0\\n        for (i in 1..n)\\n        {\\n            if (sum(i, n)) {\\n                result = i\\n                break\\n            }\\n            else result = -1\\n        }\\n        return result\\n    }\\n\\n    fun sum(x : Int, endPoint : Int) : Boolean {\\n        var sumLeft = 0\\n        var sumRight = 0\\n\\n        for (j in 1..x) sumLeft += j\\n        for (j in endPoint downTo x) sumRight += j\\n\\n        if (sumLeft == sumRight) return true\\n        else return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172254,
                "title": "100-faster-java-math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum=(1+n)*n/2;\\n        int pivot=(int)Math.sqrt(sum);\\n        if(sum==pivot*pivot){\\n            return pivot;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum=(1+n)*n/2;\\n        int pivot=(int)Math.sqrt(sum);\\n        if(sum==pivot*pivot){\\n            return pivot;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172159,
                "title": "java-beats-0ms-100-easy-to-understand-best-solution-short-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum = (n + 1) * n / 2;\\n        int pivot = (int) Math.sqrt(sum);\\n        return pivot * pivot == sum ? pivot : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum = (n + 1) * n / 2;\\n        int pivot = (int) Math.sqrt(sum);\\n        return pivot * pivot == sum ? pivot : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144946,
                "title": "java-simple-approach-best-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int fsum=1,bsum=(n*(n+1))/2;\\n        \\n        if(n==1) return 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            fsum=fsum+i;\\n            bsum=bsum-(i-1);\\n            if(fsum==bsum)\\n            return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int fsum=1,bsum=(n*(n+1))/2;\\n        \\n        if(n==1) return 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            fsum=fsum+i;\\n            bsum=bsum-(i-1);\\n            if(fsum==bsum)\\n            return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041031,
                "title": "simple-o-n-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        if(n==1)return n;\\n        int sum=(n*(n+1))/2;\\n        int pre=0;\\n        for(int i=1;i<n;i++){\\n            if(pre+i==sum)return i;\\n            pre+=i;\\n            sum-=i;\\n        }\\n        return -1;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        if(n==1)return n;\\n        int sum=(n*(n+1))/2;\\n        int pre=0;\\n        for(int i=1;i<n;i++){\\n            if(pre+i==sum)return i;\\n            pre+=i;\\n            sum-=i;\\n        }\\n        return -1;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017873,
                "title": "very-easy-java-solution-array",
                "content": "\\n\\n// where tsum=total sum; and csum=currentsum \\n// dry run this program once in your copy you will understand the logic\\n\\n\\tclass Solution {\\n    public int pivotInteger(int n) {\\n        int tsum=0;\\n        \\n        int arr[]=new int[n];\\n       for(int i=1;i<=n;i++){\\n           tsum+=i;\\n           arr[i-1]=i;  // store the index value (from 1 to n) in array and total sum of all elements\\n       }\\n        //System.out.println(tsum);\\n        int csum=0;\\n        for(int i=0;i<arr.length;i++){\\n           \\n            \\n            if(tsum-csum-arr[i]==csum){ \\n        // here we subtract arr[i] beacause it is the element that is present in both sides\\n                return arr[i];\\n                \\n            }\\n             csum+=arr[i];\\n        }\\n        return -1;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int pivotInteger(int n) {\\n        int tsum=0;\\n        \\n        int arr[]=new int[n];\\n       for(int i=1;i<=n;i++){\\n           tsum+=i;\\n           arr[i-1]=i;  // store the index value (from 1 to n) in array and total sum of all elements\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2891889,
                "title": "c-o-n-beginner-friendly-a-p-series",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Checking sum of first N terms as per Arithmetic Progression Series (A.P. Series)\\n **Formula** : ```n * (a + l) / 2``` (For given last term: ```l``` )\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Counting sum of first ```ith``` term. \\n  **Formula** : ```i * (1 + i) / 2```\\n\\n* Counting sum of last ```n-i``` term. \\n  **Formula** : ```(n-i) * (i + n) / 2```\\n\\n# Complexity\\n- Time complexity:  ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        for(int i = 1;i<=n;i++)\\n        {\\n            if(i*(1+i)*1.0/2.0 == (n-i+1)*(i+n)*1.0/2.0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n##### Plese Upvote If you like the solution ```:)```",
                "solutionTags": [
                    "C"
                ],
                "code": "```n * (a + l) / 2```\n```l```\n```ith```\n```i * (1 + i) / 2```\n```n-i```\n```(n-i) * (i + n) / 2```\n```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        for(int i = 1;i<=n;i++)\\n        {\\n            if(i*(1+i)*1.0/2.0 == (n-i+1)*(i+n)*1.0/2.0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```:)```",
                "codeTag": "Java"
            },
            {
                "id": 2891658,
                "title": "o-1-time-and-space-java-solution-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSo the intuition is quite simple maths, we have numbers from 1 to n, say n = 8, so my numbers are: 1, 2, 3, 4, 5, 6, 7, 8.\\n\\nNow if we have to pick a number x from the these numbers such that if we add 1 to x and then x to n are equal.\\n\\n1+2+3+....+x = x+x+1....+8 \\n\\nIn this case the x is 6, so \\n\\n1+2+3+4+5+6 = 6+7+8\\n\\n\\n\\nSo that means our ((sum from 1 to 8) + x) * **as x is again included in the later half** * must be equal to twice the sum from 1 to x. \\n\\nSo,\\n\\n1+2+3+4+5+6+7+8 + 6 = 2 x (sum from 1 to 6);\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nTo do this we can formulate a simple equation:\\n\\n\\u2192 \\xBD \\xD7 (x + (n \\xD7 (n + 1)/2)) = \\xBD \\xD7 x \\xD7 (x+1)\\n\\nNow we eliminate the 1/2 halfs from both sides\\n \\nSo we have,\\n\\n\\u2192 x + (n \\xD7 (n+1)/2) = x \\xD7 (x + 1)\\n\\u2192 x + (n \\xD7 (n+1)/2) = x\\xB2 + x\\n\\nEliminate x from both sides\\n\\n\\u2192 (n \\xD7 (n+1)/2) = x\\xB2\\n\\nNow as the (n \\xD7 (n+1)/2) is the sum of the first n numbers, the solution can only be found if the sum is a perfect square.\\n\\n\\u2192 \\u221A(sum) = x\\n( here sum = (n \\xD7 (n+1)/2) )\\n\\n\\n \\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n\\n            // calculate the sum for the n numbers\\n\\n            long num = n*(n+1)/2;\\n\\n            // check if the sum is a perfect square or not\\n\\n            double sq = Math.sqrt(num);\\n            if (Math.ceil(sq) == Math.floor(sq))\\n               return (int)sq;\\n            \\n            // if not return -1\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n\\n            // calculate the sum for the n numbers\\n\\n            long num = n*(n+1)/2;\\n\\n            // check if the sum is a perfect square or not\\n\\n            double sq = Math.sqrt(num);\\n            if (Math.ceil(sq) == Math.floor(sq))\\n               return (int)sq;\\n            \\n            // if not return -1\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890914,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Precompute prefix sums from left-to-right and right-to-left to find the `i`<sup>th</sup> candidate index where the sums are equal.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun pivotInteger(N: Int): Int {\\n        var L = IntArray(N){ it + 1 }\\n        var R = IntArray(N){ it + 1 }\\n        for (i in 1 until N)\\n            L[i] += L[i - 1]\\n        for (i in N - 2 downTo 0)\\n            R[i] += R[i + 1]\\n        for (i in 0 until N)\\n            if (L[i] == R[i])\\n                return i + 1\\n        return -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet pivotInteger = N => {\\n    let L = [...Array(N).keys()].map(i => i + 1),\\n        R = [...Array(N).keys()].map(i => i + 1);\\n    for (let i = 1; i < N; ++i)\\n        L[i] += L[i - 1];\\n    for (let i = N - 2; 0 <= i; --i)\\n        R[i] += R[i + 1];\\n    for (let i = 0; i < N; ++i)\\n        if (L[i] == R[i])\\n            return i + 1;\\n    return -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def pivotInteger(self, N: int) -> int:\\n        L = [i for i in range(1, N + 1)]\\n        R = [i for i in range(1, N + 1)]\\n        for i in range(1, N):\\n            L[i] += L[i - 1]\\n        for i in range(N - 2, -1, -1):\\n            R[i] += R[i + 1]\\n        for i in range(N):\\n            if L[i] == R[i]:\\n                return i + 1\\n        return -1\\n\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn pivot_integer(N: i32) -> i32 {\\n        let mut L = (1..=N).into_iter().collect::<VI>();\\n        let mut R = (1..=N).into_iter().collect::<VI>();\\n        let N = N as usize;\\n        for i in 1..N {\\n            L[i] += L[i - 1];\\n        }\\n        if 2 <= N {\\n            for i in (0..=N - 2).rev() {\\n                R[i] += R[i + 1];\\n            }\\n        }\\n        for i in 0..N {\\n            if L[i] == R[i] {\\n                return i as i32 + 1;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int pivotInteger(int N) {\\n        VI L(N); iota(L.begin(), L.end(), 1);\\n        VI R(N); iota(R.begin(), R.end(), 1);\\n        for (auto i{ 1 }; i < N; ++i)\\n            L[i] += L[i - 1];\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] += R[i + 1];\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (L[i] == R[i])\\n                return i + 1;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun pivotInteger(N: Int): Int {\\n        var L = IntArray(N){ it + 1 }\\n        var R = IntArray(N){ it + 1 }\\n        for (i in 1 until N)\\n            L[i] += L[i - 1]\\n        for (i in N - 2 downTo 0)\\n            R[i] += R[i + 1]\\n        for (i in 0 until N)\\n            if (L[i] == R[i])\\n                return i + 1\\n        return -1\\n    }\\n}\\n```\n```\\nlet pivotInteger = N => {\\n    let L = [...Array(N).keys()].map(i => i + 1),\\n        R = [...Array(N).keys()].map(i => i + 1);\\n    for (let i = 1; i < N; ++i)\\n        L[i] += L[i - 1];\\n    for (let i = N - 2; 0 <= i; --i)\\n        R[i] += R[i + 1];\\n    for (let i = 0; i < N; ++i)\\n        if (L[i] == R[i])\\n            return i + 1;\\n    return -1;\\n};\\n```\n```\\nclass Solution:\\n    def pivotInteger(self, N: int) -> int:\\n        L = [i for i in range(1, N + 1)]\\n        R = [i for i in range(1, N + 1)]\\n        for i in range(1, N):\\n            L[i] += L[i - 1]\\n        for i in range(N - 2, -1, -1):\\n            R[i] += R[i + 1]\\n        for i in range(N):\\n            if L[i] == R[i]:\\n                return i + 1\\n        return -1\\n\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn pivot_integer(N: i32) -> i32 {\\n        let mut L = (1..=N).into_iter().collect::<VI>();\\n        let mut R = (1..=N).into_iter().collect::<VI>();\\n        let N = N as usize;\\n        for i in 1..N {\\n            L[i] += L[i - 1];\\n        }\\n        if 2 <= N {\\n            for i in (0..=N - 2).rev() {\\n                R[i] += R[i + 1];\\n            }\\n        }\\n        for i in 0..N {\\n            if L[i] == R[i] {\\n                return i as i32 + 1;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int pivotInteger(int N) {\\n        VI L(N); iota(L.begin(), L.end(), 1);\\n        VI R(N); iota(R.begin(), R.end(), 1);\\n        for (auto i{ 1 }; i < N; ++i)\\n            L[i] += L[i - 1];\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] += R[i + 1];\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (L[i] == R[i])\\n                return i + 1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888274,
                "title": "java-left-sum-and-right-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n      int sum=n*(n+1)/2;\\n      int val=0;\\n      for(int i=n;i>=1;i--)\\n      {\\n          val+=i;\\n          if(sum==val)return i;\\n          sum-=i;\\n      }\\n      return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n      int sum=n*(n+1)/2;\\n      int val=0;\\n      for(int i=n;i>=1;i--)\\n      {\\n          val+=i;\\n          if(sum==val)return i;\\n          sum-=i;\\n      }\\n      return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863795,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        if (n == 1) {\\n            return 1;\\n        }\\n        int totalSum = (n * (n + 1)) / 2;\\n        int currentSum = 0;\\n        for(int i = n; i >= 0; i--) {\\n            currentSum += i;\\n            if (currentSum == totalSum) {\\n                return i;\\n            }\\n            totalSum -= i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        if (n == 1) {\\n            return 1;\\n        }\\n        int totalSum = (n * (n + 1)) / 2;\\n        int currentSum = 0;\\n        for(int i = n; i >= 0; i--) {\\n            currentSum += i;\\n            if (currentSum == totalSum) {\\n                return i;\\n            }\\n            totalSum -= i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859868,
                "title": "100-0ms-o-n-faster-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# upvote please\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sm=0;\\n        for(int i=1;i<=n;i++){\\n            sm+=i;\\n        }\\n        int ls=0;\\n        for(int i=1;i<=n;i++){\\n            ls+=i;\\n            if(ls==sm) return i;\\n            sm-=i;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sm=0;\\n        for(int i=1;i<=n;i++){\\n            sm+=i;\\n        }\\n        int ls=0;\\n        for(int i=1;i<=n;i++){\\n            ls+=i;\\n            if(ls==sm) return i;\\n            sm-=i;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859534,
                "title": "golang-solution-math",
                "content": "Time: **O(1)**\\nSpace: **O(1)**\\n\\n```go\\nfunc pivotInteger(n int) int {\\n    // math proof:\\n    // k = (1 + n) * n / 2\\n    // (k + x) / 2 = (1 + x) * x / 2\\n    // (k + x) = (1 + x) * x\\n    // k = x + x*x - x = x*x\\n\\n    if n < 0 {\\n        return -1\\n    }\\n\\n    sum := (1 + n) * n / 2\\n    v := int(math.Sqrt(float64(sum)))\\n    if v * v == sum {\\n        return v\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc pivotInteger(n int) int {\\n    // math proof:\\n    // k = (1 + n) * n / 2\\n    // (k + x) / 2 = (1 + x) * x / 2\\n    // (k + x) = (1 + x) * x\\n    // k = x + x*x - x = x*x\\n\\n    if n < 0 {\\n        return -1\\n    }\\n\\n    sum := (1 + n) * n / 2\\n    v := int(math.Sqrt(float64(sum)))\\n    if v * v == sum {\\n        return v\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858868,
                "title": "java-100-faster-2-lines-o-1-solution-explained",
                "content": "# Approach\\nFirst I find arithmetic progression sum for 1...n and then find the square root. If root is int number, then return root, else return -1.\\n\\nYou may ask why I take square root from arithmetic progression sum. I took a pen and a sheet of paper and started to write cases. And I found a trend when sum is equal to some number in power of 2 (a ^ 2), then this number is the solution - a. If there is no integer a, whose a ^ 2 is equal to the arithmetic sum, then there is no answer. Thus, I return -1.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        double root = Math.sqrt(((1 + n) * n) / 2.0);\\n        return root % 1 == 0 ? (int) root : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        double root = Math.sqrt(((1 + n) * n) / 2.0);\\n        return root % 1 == 0 ? (int) root : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858432,
                "title": "python-math-solution",
                "content": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        pivot = (n**2 + n) / 2\\n        if pivot % math.sqrt(pivot) == 0:\\n            return int(math.sqrt(pivot))\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        pivot = (n**2 + n) / 2\\n        if pivot % math.sqrt(pivot) == 0:\\n            return int(math.sqrt(pivot))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858182,
                "title": "javascript-solution-using-guassian-sums",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar pivotInteger = function (n) {\\n    for (let i = 1; i <= n; i++) {\\n        let leftOfPivot = i * (i + 1) / 2\\n        let rightOfPivot = n * (n + 1) / 2 - leftOfPivot + i\\n        if (leftOfPivot === rightOfPivot) return i\\n    }\\n\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar pivotInteger = function (n) {\\n    for (let i = 1; i <= n; i++) {\\n        let leftOfPivot = i * (i + 1) / 2\\n        let rightOfPivot = n * (n + 1) / 2 - leftOfPivot + i\\n        if (leftOfPivot === rightOfPivot) return i\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2853958,
                "title": "python-100-faster-binary-search-easy",
                "content": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        l,h=1,n\\n        m=(l+h)>>1\\n        while l<=h:\\n            s1=m*(m+1)//2\\n            s2=(m+n)*(n-m+1)//2\\n            if s1==s2:\\n                return m\\n            elif s1<s2:\\n                l=m+1\\n            else:\\n                h=m-1\\n            m=(l+h)>>1\\n        return -1\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        l,h=1,n\\n        m=(l+h)>>1\\n        while l<=h:\\n            s1=m*(m+1)//2\\n            s2=(m+n)*(n-m+1)//2\\n            if s1==s2:\\n                return m\\n            elif s1<s2:\\n                l=m+1\\n            else:\\n                h=m-1\\n            m=(l+h)>>1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853654,
                "title": "constant-space-solution-faster-than-100-0ms-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n    int total = n*(n+1)/2;\\n    int x=sqrt(total);\\n    if(x*x==total)\\n        return x; \\n    return -1;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n    int total = n*(n+1)/2;\\n    int x=sqrt(total);\\n    if(x*x==total)\\n        return x; \\n    return -1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852921,
                "title": "c-logical-approach-easy-understanding",
                "content": "# Approach\\nHere we need to compare sum till current iteration(number) less than n and sum of all the numbers including current iteration(number) after it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        // sum of all numbers till n\\n        int s = n*(n+1)/2;\\n        int x=0;\\n        // we need to keep on subtracting the number and compare it \\n        for(int i=n;i>=1;i--){\\n            if((s-x) == i) return i;\\n            s-=i;\\n            x+=i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        // sum of all numbers till n\\n        int s = n*(n+1)/2;\\n        int x=0;\\n        // we need to keep on subtracting the number and compare it \\n        for(int i=n;i>=1;i--){\\n            if((s-x) == i) return i;\\n            s-=i;\\n            x+=i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852576,
                "title": "c-easy-to-understand-beginner-friendly",
                "content": "First we find the sum of all the elements and maintain left sum and right sum, and then we keep iterating every element with adding the elements in the left sum and subtracting from the right sum.\\nStopping point:- When the left sum would be equal to right sum we stop iterating and return that element\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        //edge case\\n        if(n==1) return 1;\\n        \\n        //Finding the sum of all the elements\\n        int sum=(n*(n+1))/2;\\n        //Maintaining lleft sum and right sum\\n        int suml=1;\\n        int sumr=sum;\\n        int ans=-1;\\n        //to point to the current element\\n        int ptr=1;\\n        while(ptr<=n){\\n            \\n            if(suml==sumr){\\n                ans=ptr;\\n                return ans;\\n            }\\n            //adding to the left sum and subtracting from the right sum\\n            //as we move forward\\n            suml+=ptr+1;\\n            sumr-=ptr;\\n            ptr=ptr+1;\\n        }\\n        //returning answer\\n        return ans;\\n    }\\n};\\n```\\n***Pls upvote if you find this useful :)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        //edge case\\n        if(n==1) return 1;\\n        \\n        //Finding the sum of all the elements\\n        int sum=(n*(n+1))/2;\\n        //Maintaining lleft sum and right sum\\n        int suml=1;\\n        int sumr=sum;\\n        int ans=-1;\\n        //to point to the current element\\n        int ptr=1;\\n        while(ptr<=n){\\n            \\n            if(suml==sumr){\\n                ans=ptr;\\n                return ans;\\n            }\\n            //adding to the left sum and subtracting from the right sum\\n            //as we move forward\\n            suml+=ptr+1;\\n            sumr-=ptr;\\n            ptr=ptr+1;\\n        }\\n        //returning answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852411,
                "title": "math-logic-explained",
                "content": "Math logic behind the approach:\\n\\n```\\nsum(1..N) + x = sum(1..x) + sum (x..N) \\nsum(1..N) + x = sum(1..x) + sum(1..x) [ from the question sum(1..x) is same as sum(x..N) ]\\nsum(1..N) + x = sum(1..x) + sum(1..x-1)+x [we know sum(1..x) = sum(1..x-1) + x]\\nsum(1..N) = sum(1..x) + sum(1..x-1) [After cancelling x on both sides]\\n\\nN(N+1)/2 = x(x+1)/2 + (x-1)(x)/2\\n\\nSimplifying further...\\n\\nN**2+N = x**2 + x + x**2 -x\\nN**2+N = 2(x**2)\\nx = sqrt(N(N+1)/2)\\nx -> sqrt(sum of N numbers)\\n```\\n\\nPython3.8+ solution [math.isqrt is available from python 3.8+]\\n\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        total = sum(range(1, n+1))\\n        return math.isqrt(total) if math.isqrt(total)**2 == total else -1\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nsum(1..N) + x = sum(1..x) + sum (x..N) \\nsum(1..N) + x = sum(1..x) + sum(1..x) [ from the question sum(1..x) is same as sum(x..N) ]\\nsum(1..N) + x = sum(1..x) + sum(1..x-1)+x [we know sum(1..x) = sum(1..x-1) + x]\\nsum(1..N) = sum(1..x) + sum(1..x-1) [After cancelling x on both sides]\\n\\nN(N+1)/2 = x(x+1)/2 + (x-1)(x)/2\\n\\nSimplifying further...\\n\\nN**2+N = x**2 + x + x**2 -x\\nN**2+N = 2(x**2)\\nx = sqrt(N(N+1)/2)\\nx -> sqrt(sum of N numbers)\\n```\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        total = sum(range(1, n+1))\\n        return math.isqrt(total) if math.isqrt(total)**2 == total else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852404,
                "title": "easy-c-solution-basic-two-pointers-prefix-suffix-sum",
                "content": "Here is my C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int i=1; int j= n;\\n        int sumi=0; int sumj=0;\\n        while (i!=(j) && i<=n && j>=0){ \\n            if (sumi<sumj){\\n                sumi+=i;\\n                i++;\\n            }\\n            else{\\n                sumj+= j;\\n                j--;\\n            }\\n        }\\n        if (sumi==sumj)return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int i=1; int j= n;\\n        int sumi=0; int sumj=0;\\n        while (i!=(j) && i<=n && j>=0){ \\n            if (sumi<sumj){\\n                sumi+=i;\\n                i++;\\n            }\\n            else{\\n                sumj+= j;\\n                j--;\\n            }\\n        }\\n        if (sumi==sumj)return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852328,
                "title": "java-straightforward-math-detailed-deduction",
                "content": "Straightforward Math:\\n```\\n1 + ... + x == x + ... + n\\n(1 + x) * x / 2 == (x + n) * (n - x + 1) / 2\\nx + x * x == x * n - x * x + n * n - n * x + x + n\\n2 * x * x == n * n + n\\n```\\n\\n``` java\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int x = (int) Math.sqrt((n * n + n) / 2);\\n        if (2 * x * x == n * n + n) {\\n            return x;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n1 + ... + x == x + ... + n\\n(1 + x) * x / 2 == (x + n) * (n - x + 1) / 2\\nx + x * x == x * n - x * x + n * n - n * x + x + n\\n2 * x * x == n * n + n\\n```\n``` java\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int x = (int) Math.sqrt((n * n + n) / 2);\\n        if (2 * x * x == n * n + n) {\\n            return x;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852283,
                "title": "simple-approach-in-java-with-explanation",
                "content": "**I know one day you will be able to solve all four questions in contest .. All the best\\uD83E\\uDD1E**\\n\\'\\'\\'\\nclass Solution {\\n\\n    public int pivotIndex(int[] nums) {\\n         \\n        int sum = 0;\\n        for(int value : nums){\\n            sum = sum + value;  // find sum of all numbers in array\\n        }\\n         \\n        int start = 0, index = 0;\\n        for(index=0; index<nums.length; index++){\\n             \\n            sum = sum - nums[index];   // keep on subtracting the current value from sum\\n            if(start == sum){\\n                return index;  //if left = right return index\\n            }\\n            start = start + nums[index]; // keep on adding the current value to start\\n        }\\n        return -1;\\n    }\\n    public int pivotInteger(int n) {\\n        int x=0;\\n        int[] array = new int[n];\\n        for(int i=1;i<=n;i++){\\n            array[x]=i;\\n            x++;\\n        }\\n        int res = pivotIndex(array);\\n        if(res==-1){\\n            return -1;\\n        }\\n        return array[res];\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\n\\n    public int pivotIndex(int[] nums) {\\n         \\n        int sum = 0;\\n        for(int value : nums){\\n            sum = sum + value;  // find sum of all numbers in array\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2852230,
                "title": "c-easieeeeeeeeeeeeeeeeet-solution-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        double k=n*(n+1)/2;\\n        if(sqrt(k)==floor(sqrt(k)) && sqrt(k)==ceil(sqrt(k)))\\n        {\\n            return (int)((sqrt(k)));\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        double k=n*(n+1)/2;\\n        if(sqrt(k)==floor(sqrt(k)) && sqrt(k)==ceil(sqrt(k)))\\n        {\\n            return (int)((sqrt(k)));\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852114,
                "title": "easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        int isum = 0,jsum=0;\\n        for(int i = 1 ; i <= n ; i++){\\n            isum+=i;\\n            for(int j = i ; j <= n ; j++){\\n                jsum+=j;\\n            }\\n            if(isum == jsum) return i;\\n            else jsum = 0;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        int isum = 0,jsum=0;\\n        for(int i = 1 ; i <= n ; i++){\\n            isum+=i;\\n            for(int j = i ; j <= n ; j++){\\n                jsum+=j;\\n            }\\n            if(isum == jsum) return i;\\n            else jsum = 0;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851976,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int s = 0, k = 0;\\n        for(int i=1; i<=n; i++) s += i;\\n        \\n        for(int i=1; i<=n; i++) {\\n            k += i;\\n            if(k == s) return i;\\n            s -= i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int s = 0, k = 0;\\n        for(int i=1; i<=n; i++) s += i;\\n        \\n        for(int i=1; i<=n; i++) {\\n            k += i;\\n            if(k == s) return i;\\n            s -= i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081464,
                "title": "java-1-ms-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum = 0, lsum = 0, rsum = 0;\\n        for(int i = 1;i<n+1;i++){\\n            sum += i;\\n\\n        }\\n        for(int i = 1;i<n+1;i++)\\n        {\\n            lsum += i;\\n            rsum = sum - lsum;\\n            if(lsum == rsum + i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum = 0, lsum = 0, rsum = 0;\\n        for(int i = 1;i<n+1;i++){\\n            sum += i;\\n\\n        }\\n        for(int i = 1;i<n+1;i++)\\n        {\\n            lsum += i;\\n            rsum = sum - lsum;\\n            if(lsum == rsum + i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882507,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar pivotInteger = function (n) {\\n\\n    // initialize function sum with parameter start and end to find sum between start and end and return num\\n    function sum(start, end) {\\n        let num = 0;\\n        for (let i = start; i <= end; i++) {\\n            num += i;\\n        }\\n        return num;\\n    }\\n\\n    // loop through the 1 to n\\n    for (let i = 1; i <= n; i++) {\\n\\n        // if sum of 1 to i and sum of i to n is equal then return i\\n        if (sum(1, i) == sum(i, n)) {\\n            return i;\\n        }\\n    }\\n\\n    return -1; // otherwise return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar pivotInteger = function (n) {\\n\\n    // initialize function sum with parameter start and end to find sum between start and end and return num\\n    function sum(start, end) {\\n        let num = 0;\\n        for (let i = start; i <= end; i++) {\\n            num += i;\\n        }\\n        return num;\\n    }\\n\\n    // loop through the 1 to n\\n    for (let i = 1; i <= n; i++) {\\n\\n        // if sum of 1 to i and sum of i to n is equal then return i\\n        if (sum(1, i) == sum(i, n)) {\\n            return i;\\n        }\\n    }\\n\\n    return -1; // otherwise return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877428,
                "title": "o-n-java-solution-using-prefix-sum-and-sum-of-natural-numbers-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe find the pivot index by subtracting the prefix sum till index from the total sum of natural numbers till \\'n\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Find the sum of first N natural numbers using the formula n(n+1)/2\\n- Generate left sum for each index and check whether the (total - leftSum + i) equals the leftSum.\\n- If yes, return the index.\\n- Return -1 after checking all indices.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int totalSum = n * (n + 1) / 2;\\n        int leftSum = 0;\\n\\n        for(int i = 1; i <= n; i++) {\\n            leftSum += i;\\n            if(totalSum - leftSum + i == leftSum) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int totalSum = n * (n + 1) / 2;\\n        int leftSum = 0;\\n\\n        for(int i = 1; i <= n; i++) {\\n            leftSum += i;\\n            if(totalSum - leftSum + i == leftSum) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800235,
                "title": "fully-explained-c-beats-100-in-time-complexity",
                "content": "# Intuition & Approach\\n\\n1. It initializes two integer variables: ```tempSum``` to keep track of the sum of numbers on the left side of the pivot, and ```totalSum``` to store the sum of all numbers from 1 to n, which can be calculated using the formula ```(n * (n + 1)) / 2```. The formula for ```totalSum``` is derived from the sum of an arithmetic series.\\n\\n2. The function enters a for loop that iterates from ```n``` down to 1. The loop is used to find the potential pivot point.\\n\\n3. Inside the loop, the current number ```i``` is added to the ```tempSum``` variable, effectively simulating moving the pivot point to the left and including ```i``` in the left side sum.\\n\\n4. The function checks whether the sum on the left ```(totalSum + i)``` ***minus the sum on the right*** ```(tempSum * 2)``` is equal to 0. If this condition is met, it means the pivot point has been found, and it returns the current value of ```i``` as the result.\\n\\n5. If the loop finishes without finding a valid pivot point, the function ```returns -1``` to indicate that there is no pivot point with the given conditions in the range ```[1, n]```.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n\\n        int tempSum = 0;\\n        int totalSum = (n * (n + 1)) / 2;\\n        \\n        for(int i = n; i >= 1; i--){\\n            tempSum += i;\\n            if((totalSum + i) - (tempSum * 2) == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```tempSum```\n```totalSum```\n```(n * (n + 1)) / 2```\n```totalSum```\n```n```\n```i```\n```tempSum```\n```i```\n```(totalSum + i)```\n```(tempSum * 2)```\n```i```\n```returns -1```\n```[1, n]```\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n\\n        int tempSum = 0;\\n        int totalSum = (n * (n + 1)) / 2;\\n        \\n        for(int i = n; i >= 1; i--){\\n            tempSum += i;\\n            if((totalSum + i) - (tempSum * 2) == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609338,
                "title": "c-fastest-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBinary Search: It\\'s definite that the result lies between 1 and n. So, why not to binary search the number?\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        if(n==1) return 1;\\n        int L = 1, R = n;\\n\\n        while(L < R){\\n            int mid = (L+R)/2;\\n            int leftSum = (mid*(mid-1))/2;\\n            int rightSum = (n*(n+1))/2-mid-leftSum;\\n            if(leftSum==rightSum) return mid;\\n            else if(leftSum > rightSum) R = mid-1;\\n            else L = mid+1;\\n        }\\n        return - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        if(n==1) return 1;\\n        int L = 1, R = n;\\n\\n        while(L < R){\\n            int mid = (L+R)/2;\\n            int leftSum = (mid*(mid-1))/2;\\n            int rightSum = (n*(n+1))/2-mid-leftSum;\\n            if(leftSum==rightSum) return mid;\\n            else if(leftSum > rightSum) R = mid-1;\\n            else L = mid+1;\\n        }\\n        return - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560117,
                "title": "easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    int pivotInteger(int n) {\\n        double res = sqrt((n * n + n) / 2);\\n\\n        return res.ceil() == res.floor() ? res.floor() : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n    int pivotInteger(int n) {\\n        double res = sqrt((n * n + n) / 2);\\n\\n        return res.ceil() == res.floor() ? res.floor() : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537276,
                "title": "simplest-efficient-c-code-time-o-n-space-o-1",
                "content": "# Intuition\\nThe problem is to find a pivot integer for a given number n. A pivot integer is defined as an integer i such that the sum of all integers from 1 to i is equal to the sum of all integers from i+1 to n. We can approach this problem by iterating through all possible values of i and checking if the sum of the two parts is equal. If we find a match, we return i. Otherwise, if no pivot integer is found, we return -1.\\n\\n# Approach\\nThe approach is straightforward. We iterate through all possible values of i from 1 to n and calculate the sum of the first part (1 to i) and the sum of the second part (i+1 to n). If the two sums are equal, we return i. If no pivot integer is found, we return -1.\\n\\n# Complexity\\n- Time complexity: $O(n)$ - We iterate through all possible values of i from 1 to n, which takes linear time.\\n\\n- Space complexity: $O(1)$ - We only use a constant amount of additional space to store the variables i and the sums.\\n\\n# Code\\n```\\nint pivotInteger(int n){\\n    for(int i=1;i<=n;i++){\\n        if(i*i == (n*(n+1))/2)\\n        return i;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint pivotInteger(int n){\\n    for(int i=1;i<=n;i++){\\n        if(i*i == (n*(n+1))/2)\\n        return i;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518188,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn reading the problem statement, The first thought in my mind was to add all the numbers from 1 to n and store it in sum1 variable. Then Check one by one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all, we declare the variables \"sum1\",\"sum2\",\"pivot\",\\nwhere pivot is initialized with -1. In the first for loop, we store the sum of 1 to n in sum1 variable. In the second loop, we add i to sum2 one by one and check if it is equal to sum1. If yes, then we store that particular i in the index variable. Then, we decrement sum1 by i. This process ultimately returns the pivot integer. And in case there\\'s none, it returns -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis code takes O(2n) time which ultimately boils down to O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum1 = 0, pivot = -1, sum2 = 0;\\n        for(int i = 1; i <= n; i++){ //first, we add the numbers from 1 to n\\n            sum1 += i;\\n        }\\n        for(int i = 1; i <= n; i++){//taking another variable \\'sum2\\' we add one by one and decrement sum1 by i so that we reach to a point where sum1 == sum2.\\n            sum2 += i;\\n            if(sum1 == sum2) pivot = i;\\n            sum1 -= i;\\n        }\\n        return pivot; // returns -1 if there\\'s no such pivot element exists\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum1 = 0, pivot = -1, sum2 = 0;\\n        for(int i = 1; i <= n; i++){ //first, we add the numbers from 1 to n\\n            sum1 += i;\\n        }\\n        for(int i = 1; i <= n; i++){//taking another variable \\'sum2\\' we add one by one and decrement sum1 by i so that we reach to a point where sum1 == sum2.\\n            sum2 += i;\\n            if(sum1 == sum2) pivot = i;\\n            sum1 -= i;\\n        }\\n        return pivot; // returns -1 if there\\'s no such pivot element exists\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418955,
                "title": "easy-javascript-4-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:50%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:60%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar pivotInteger = function(n) {\\n    let son = Math.sqrt((n*n+n)/2)\\n    if (parseInt(son) == son)\\n        return son;\\n    return -1;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pivotInteger = function(n) {\\n    let son = Math.sqrt((n*n+n)/2)\\n    if (parseInt(son) == son)\\n        return son;\\n    return -1;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418954,
                "title": "faster-go-solution-0-ms",
                "content": "\\n# Complexity\\n- Time complexity:0 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:2mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc pivotInteger(n int) int {\\n  x := math.Sqrt(float64(n*n + n) / 2)\\n  if x == math.Floor(x) {\\n    return int(x)\\n  }\\n  return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pivotInteger(n int) int {\\n  x := math.Sqrt(float64(n*n + n) / 2)\\n  if x == math.Floor(x) {\\n    return int(x)\\n  }\\n  return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3360196,
                "title": "java-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public static int sum(int n){\\n            return n*(n+1)/2;\\n        }\\n    public int pivotInteger(int n) {\\n        \\n        int low=0;\\n        int high=n;\\n        while (low<=high){\\n            int mid=(low+high)/2;\\n            int total_sum=sum(n);\\n            int left_sum=sum(mid);\\n            int right_sum=total_sum-left_sum+mid;\\n            if (left_sum==right_sum){\\n                return mid;\\n            }\\n            else if (left_sum>right_sum){\\n                high=mid-1;\\n\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```\\n![90f09615-d42d-402c-897e-8d81a9fb5f37_1677988379.954136.jpeg](https://assets.leetcode.com/users/images/03b69235-ce85-4b5f-bfde-ffcf2bb9caae_1680200790.6674955.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static int sum(int n){\\n            return n*(n+1)/2;\\n        }\\n    public int pivotInteger(int n) {\\n        \\n        int low=0;\\n        int high=n;\\n        while (low<=high){\\n            int mid=(low+high)/2;\\n            int total_sum=sum(n);\\n            int left_sum=sum(mid);\\n            int right_sum=total_sum-left_sum+mid;\\n            if (left_sum==right_sum){\\n                return mid;\\n            }\\n            else if (left_sum>right_sum){\\n                high=mid-1;\\n\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360096,
                "title": "beats-82-1ms-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum=(n*(n+1))/2;\\n        int sumr=0;\\n        for(int i=1;i<=n;i++){\\n            sumr=sumr+i;\\n            if(sum-sumr+i==sumr){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n// sumleft=sum-sumright;\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum=(n*(n+1))/2;\\n        int sumr=0;\\n        for(int i=1;i<=n;i++){\\n            sumr=sumr+i;\\n            if(sum-sumr+i==sumr){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n// sumleft=sum-sumright;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316743,
                "title": "easy-prefix-sum-java-solution",
                "content": "# Intuition\\nPrefix Sum approach\\n\\n# Approach\\n1) Uses Prefix Sum Array approach\\n2) prefixSum[i] = prefixSum[i - 1] + arr[i];\\n3) if(leftSum==rightSum+i){\\nreturn i;\\n} //here rightSum+i because the sum will cross each other at one point, hence we need to make sure we catch it.\\n4) Almost all problems with such pattern can be solved by PrefixSum approach.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n       int sum=0,leftSum=0,rightSum=0;\\n\\nfor(int i=1;i<=n;i++){\\n    sum+=i;\\n}\\n\\nfor(int i=1;i<=n;i++){ \\nleftSum+=i;\\nrightSum=sum-leftSum;\\n\\nif(leftSum==rightSum+i){\\nreturn i;\\n}\\n}\\nreturn -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n       int sum=0,leftSum=0,rightSum=0;\\n\\nfor(int i=1;i<=n;i++){\\n    sum+=i;\\n}\\n\\nfor(int i=1;i<=n;i++){ \\nleftSum+=i;\\nrightSum=sum-leftSum;\\n\\nif(leftSum==rightSum+i){\\nreturn i;\\n}\\n}\\nreturn -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265567,
                "title": "python3-92-32ms-using-nsum-formula-and-sqrt",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        # a  =[]\\n        # nsum = (n*(n+1) // 2)\\n        # for i in range(1, n+1):\\n        #     if i * i == nsum:\\n        #         return i\\n        # return -1\\n\\n        return int(math.sqrt((n*(n+1) // 2))) if math.sqrt((n*(n+1) // 2)).is_integer() else -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        # a  =[]\\n        # nsum = (n*(n+1) // 2)\\n        # for i in range(1, n+1):\\n        #     if i * i == nsum:\\n        #         return i\\n        # return -1\\n\\n        return int(math.sqrt((n*(n+1) // 2))) if math.sqrt((n*(n+1) // 2)).is_integer() else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131754,
                "title": "simple-fast-easy-to-understand-c-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int a;\\n        float ans = ceil(sqrt( (n * (n+1)) / 2.0));\\n        int as = sqrt( (n * (n+1)) / 2.0);\\n\\n        if(ans == as)\\n        {\\n            return as;\\n        }\\n        return -1;\\n\\n\\n    }\\n};\\n```\\n# **Upvote Me If You Like It**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int a;\\n        float ans = ceil(sqrt( (n * (n+1)) / 2.0));\\n        int as = sqrt( (n * (n+1)) / 2.0);\\n\\n        if(ans == as)\\n        {\\n            return as;\\n        }\\n        return -1;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096361,
                "title": "python-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->In this, first we have traveresed the numbers from 1 to the given nuumber and while traversing, we have checked whether the sum of number from 1 to the traveresed number and from traveresed number to the given is equal or not. If it is equal just return that number else let the loop to complete. After completion of loop, return -1 as there is no pivot element exist since noting is returned yet. \\n\\n# Code\\n```\\nclass Solution(object):\\n    def pivotInteger(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(1,n+1):\\n            l=list(range(1,i+1))\\n            r=list(range(i,n+1))\\n            if sum(l)==sum(r):\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pivotInteger(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(1,n+1):\\n            l=list(range(1,i+1))\\n            r=list(range(i,n+1))\\n            if sum(l)==sum(r):\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036654,
                "title": "easiest-solution-using-sum-of-n-natural-numbers-java-beats-100-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: chode bara\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) \\n    {\\n        if(n==1)\\n        {\\n            return 1;\\n        }\\n        int s1=(n*(n+1))/2,s2=n,ans=-1,i;\\n        for(i=n;i>0;i--)\\n        {\\n            if(s1==s2)\\n            {\\n            ans=i;\\n            break;\\n            }\\n            else\\n            {\\n                s1=s1-i;\\n                s2=s2+(i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) \\n    {\\n        if(n==1)\\n        {\\n            return 1;\\n        }\\n        int s1=(n*(n+1))/2,s2=n,ans=-1,i;\\n        for(i=n;i>0;i--)\\n        {\\n            if(s1==s2)\\n            {\\n            ans=i;\\n            break;\\n            }\\n            else\\n            {\\n                s1=s1-i;\\n                s2=s2+(i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025720,
                "title": "java-solution",
                "content": "# Intuition\\nBy using formula of sum of n natural numbers.\\n     \\n\\n# Approach\\n1 -> x =  x(x+1)/2\\nx -> n = (1 -> n) - (1 -> x-1) = n(n-1)/2 - x(x-1)/2\\nx(x+1)/2 = n(n-1)/2 - x(x-1)/2 \\n2(x*x) = n(n+1)\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n     \\n        long num = n*(n+1)/2L;\\n\\n        // Check if it is a whole number.\\n        double x = Math.pow(num,0.5);\\n        \\n        // If it is not a whole number, for example, 1.2 , it gives 2 when we apply Math.ceil.\\n        if(Math.ceil(x) - x == 0){\\n            return (int)(x);\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n     \\n        long num = n*(n+1)/2L;\\n\\n        // Check if it is a whole number.\\n        double x = Math.pow(num,0.5);\\n        \\n        // If it is not a whole number, for example, 1.2 , it gives 2 when we apply Math.ceil.\\n        if(Math.ceil(x) - x == 0){\\n            return (int)(x);\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025318,
                "title": "easy-python-solution-beats-99-71-time",
                "content": "# Beats 99.71% Time \\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        ans=n*(n+1)//2\\n        if int(sqrt(ans))*int(sqrt(ans))==ans:\\n            return int(sqrt(ans))\\n        return -1    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        ans=n*(n+1)//2\\n        if int(sqrt(ans))*int(sqrt(ans))==ans:\\n            return int(sqrt(ans))\\n        return -1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982002,
                "title": "c-prefix-sum-vs-binary-search-vs-math-0ms-5-9mb",
                "content": "This problem can be solved in a relatively trivial fashion keep track of all the elements on the right and left of our potential pivot, all the time.\\n\\nTo do so, we will start declaring our two prefix sum variables:\\n* `sumRight` will start having the value of all the elements from `1` to `n` (included), computed initially in constant time with the usual Gaussian formula;\\n* `sumLeft` will be initialised to `0`.\\n\\nWe will then go through each potential pivot `i` from `1` to `n` (again, included) and:\\n* subtract `i` from `sumRight` (we are not counting the pivot itself in either sum, which equates in counting it in both as per specs);\\n* check if we reached a matching condition (ie: `sumLeft == sumRight`), in which case we can confidently `return` `i`;\\n* check if we instead went too far (ie: `sumLeft > sumRight`), in which case we can confidently `return` `-1`;\\n* add `i` to `sumLeft` (we are updating it for the next loop).\\n\\nWe should never hit this point, but just to make the compiler happy, we will `return` `-1` at the end of the loop :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        // support variables\\n        int sumRight = n * (n + 1) / 2, sumLeft = 0;\\n        // going through all the possible suffix sum\\n        for (int i = 1; i <= n; i++) {\\n            sumRight -= i;\\n            // match found\\n            if (sumLeft == sumRight) return i;\\n            // we went too far\\n            else if (sumLeft > sumRight) return -1;\\n            sumLeft += i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nAlternative logic with binary search performed so that we compute a middle element `m` between our left (`l`) and right (`r`) pointers so that `sumLeft` is at each iteration the sum of all the elements up to `m` (excluded, ie: `(m * (m -1)) >> 1`) and `sumRight` as the sum of all the elements up to `n` (ie: `(n * (n + 1)) >> 1`), minus all the elements up to `m` (ie: we subtract `sumLeft` and `m` itself).\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\nThe updated code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        // support variables\\n        int sumRight, sumLeft, l = 1, r = n, m;\\n        // BS loop\\n        while (l <= r) {\\n            // updating loop variables\\n            m = (l + r) >> 1, sumLeft = (m * (m - 1)) >> 1, sumRight = ((n * (n + 1)) >> 1) - sumLeft - m;\\n            // match found\\n            if (sumLeft == sumRight) return m;\\n            // we went too high\\n            else if (sumLeft > sumRight) r = m - 1;\\n            // we went too low\\n            else l = m + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nNow, consquent from the last approach, we can see that we need to find a value `m` such that the sum on the left (`m * (m - 1) / 2`) equals the sum on the right (`n * (n + 1) / 2 - (m * (m - 1)) / 2 - m`).\\n\\nIn other words, grouping a bit we have that `n * (n + 1) / 2` has to equal `m * (m - 1) + m`, so `m * m == n * (n + 1) / 2`; in other words, every time we find a perfect square for the sum of the first `n` element, we have a solution.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nThe updated constant time code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        // support variables\\n        int sum = n * (n + 1) >> 1, sq = pow(sum, 0.5);\\n        return sq * sq == sum ? sq : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        // support variables\\n        int sumRight = n * (n + 1) / 2, sumLeft = 0;\\n        // going through all the possible suffix sum\\n        for (int i = 1; i <= n; i++) {\\n            sumRight -= i;\\n            // match found\\n            if (sumLeft == sumRight) return i;\\n            // we went too far\\n            else if (sumLeft > sumRight) return -1;\\n            sumLeft += i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        // support variables\\n        int sumRight, sumLeft, l = 1, r = n, m;\\n        // BS loop\\n        while (l <= r) {\\n            // updating loop variables\\n            m = (l + r) >> 1, sumLeft = (m * (m - 1)) >> 1, sumRight = ((n * (n + 1)) >> 1) - sumLeft - m;\\n            // match found\\n            if (sumLeft == sumRight) return m;\\n            // we went too high\\n            else if (sumLeft > sumRight) r = m - 1;\\n            // we went too low\\n            else l = m + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        // support variables\\n        int sum = n * (n + 1) >> 1, sq = pow(sum, 0.5);\\n        return sq * sq == sum ? sq : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975313,
                "title": "easy-c-code-runtime-0ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum1=0,sum2=n*(n+1)/2;\\n        for(int i=1;i<=n;i++)\\n        {\\n            sum1=sum1+i;\\n            if(sum1==sum2)\\n            {\\n                return i;\\n            }\\n            sum2=sum2-i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum1=0,sum2=n*(n+1)/2;\\n        for(int i=1;i<=n;i++)\\n        {\\n            sum1=sum1+i;\\n            if(sum1==sum2)\\n            {\\n                return i;\\n            }\\n            sum2=sum2-i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926470,
                "title": "easy-solution-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def pivotInteger(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        total = sum(range(n+1))\\n        prefix_sum = 0\\n        \\n        for i in range(n, -1, -1):\\n            prefix_sum += i\\n            if prefix_sum == total:\\n                return i\\n\\n            total -= i\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pivotInteger(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        total = sum(range(n+1))\\n        prefix_sum = 0\\n        \\n        for i in range(n, -1, -1):\\n            prefix_sum += i\\n            if prefix_sum == total:\\n                return i\\n\\n            total -= i\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896709,
                "title": "c-using-basic-mathematics-o-1-solution",
                "content": "# Intuition\\nThe problem can be easily solved using some basic maths which reduces the time complexity of the problem.otherwise we can use prefix sum and binary search too.\\n\\n# Approach\\nSince we know that,\\n**1+2+3+4+...n= n(n+1)/2**\\nwe have to find a x such that Sum from 1 to x = sum from x to n\\nsince we know **1+2+3+4..x = x(x+1)/2**\\nNow x+ x+1,....+n can be written as {(1+2+3+..n)-(1+2+..x-1)}\\nsum from x to n = **n(n+1)/2 - x(x-1)/2**\\nso we have \\n**x(x+1)/2 = n(n+1)/2 - x(x-1)/2**\\n**x^2+x = n^2 + n -x^2+x\\n2x^2= n(n+1)\\nx= sqrt(n(n+1)/2)\\nx= sqrt(total)**\\nNow since x is an integer so it cant have float value so to check we \\nuse floor value if it gives ans return x else -1;\\n# Complexity\\n- Time complexity:\\no(1) \\n\\n- Space complexity:\\no(k) where k is some constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n       int total = n*(n+1)/2;\\n       float ans = sqrt(total);\\n       if(floor(ans)==ans){\\n           return ans;\\n       }\\n       else{\\n           return -1;\\n       }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n       int total = n*(n+1)/2;\\n       float ans = sqrt(total);\\n       if(floor(ans)==ans){\\n           return ans;\\n       }\\n       else{\\n           return -1;\\n       }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879651,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "# Intuition\\nSummetion of all elements inbetween the 1 to n, and checking the possible sum and difference at each element.\\n# Approach\\nWe have sum of all integers inbetween 1 to n, we are cheking the possible sums of all integers by removing them one by one and compairing with available sum.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code - Java\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int total_sum = 0, removed_sum = 0;\\n        for(int x=1; x<=n; x++) total_sum += x;\\n        for(int x=1; x<=n; x++){\\n            if(total_sum == removed_sum + x){\\n                return x;\\n            }\\n            total_sum -= x;\\n            removed_sum += x;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# Code - JavaScript\\n```\\n\\nvar pivotInteger = function(n) {\\n    let total_sum = 0, removed_sum = 0;\\n    for(let x=1; x<=n; x++) total_sum += x;\\n    for(let x=1; x<=n; x++){\\n        if(total_sum === removed_sum + x){\\n            return x;\\n        }\\n        total_sum -= x;\\n        removed_sum += x;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int total_sum = 0, removed_sum = 0;\\n        for(int x=1; x<=n; x++) total_sum += x;\\n        for(int x=1; x<=n; x++){\\n            if(total_sum == removed_sum + x){\\n                return x;\\n            }\\n            total_sum -= x;\\n            removed_sum += x;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n\\nvar pivotInteger = function(n) {\\n    let total_sum = 0, removed_sum = 0;\\n    for(let x=1; x<=n; x++) total_sum += x;\\n    for(let x=1; x<=n; x++){\\n        if(total_sum === removed_sum + x){\\n            return x;\\n        }\\n        total_sum -= x;\\n        removed_sum += x;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870255,
                "title": "fast-and-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        addition = sum(range(1, n + 1))\\n        addition2 = 0\\n        for i in range(1, n + 1): \\n            addition2 += i\\n            if addition2 == addition - addition2 + i:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        addition = sum(range(1, n + 1))\\n        addition2 = 0\\n        for i in range(1, n + 1): \\n            addition2 += i\\n            if addition2 == addition - addition2 + i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864217,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        vector<int> front(n,0), back(n,0);\\n        front[0]=1, back[n-1]=n;\\n        for(int i=1; i<n; i++){\\n            front[i] = front[i-1]+i+1;\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            back[i]= back[i+1]+i+1;\\n        }\\n        for(int i=0; i<n; i++){\\n            if(front[i]==back[i]){\\n                return i+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        vector<int> front(n,0), back(n,0);\\n        front[0]=1, back[n-1]=n;\\n        for(int i=1; i<n; i++){\\n            front[i] = front[i-1]+i+1;\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            back[i]= back[i+1]+i+1;\\n        }\\n        for(int i=0; i<n; i++){\\n            if(front[i]==back[i]){\\n                return i+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860400,
                "title": "c-100-faster-6-lines-only-o-1-memory",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        auto allsum = ( n * (n + 1) ) >> 1;\\n        int sum = 0, index = 1;\\n        while (sum <= allsum) {\\n            sum += index;\\n            if (sum == (allsum - sum + index)) return index;\\n            index++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/* \\nfor testcase 8,\\n\\n1 + 2 + 3 + 4 + 5 + 6  \\n=  36 - 21 + 6 \\n\\nEquivalent to,\\n\\nsum \\n= allsum - sum + index\\n*/\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        auto allsum = ( n * (n + 1) ) >> 1;\\n        int sum = 0, index = 1;\\n        while (sum <= allsum) {\\n            sum += index;\\n            if (sum == (allsum - sum + index)) return index;\\n            index++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/* \\nfor testcase 8,\\n\\n1 + 2 + 3 + 4 + 5 + 6  \\n=  36 - 21 + 6 \\n\\nEquivalent to,\\n\\nsum \\n= allsum - sum + index\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859432,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    inline int getSum(int n){\\n        return (n*(n+1))/2;\\n    }\\npublic:\\n    int pivotInteger(int n) {\\n        int sum = getSum(n);\\n        for(int i=1; i<=n; ++i){\\n            int first = getSum(i), second = sum - first + i;\\n            if(first == second) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    inline int getSum(int n){\\n        return (n*(n+1))/2;\\n    }\\npublic:\\n    int pivotInteger(int n) {\\n        int sum = getSum(n);\\n        for(int i=1; i<=n; ++i){\\n            int first = getSum(i), second = sum - first + i;\\n            if(first == second) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858243,
                "title": "c-very-easy-to-understand-simple-maths-calculation",
                "content": "class Solution {\\npublic:\\n\\n    int pivotInteger(int n) {\\n        \\n        int temp  = (n * (n+1))/2;\\n        \\n        int sum = 0;\\n        \\n        if(n==1) return 1;\\n        \\n        for(int i=1; i< n ;i++){\\n            sum = sum + i;\\n            \\n            if(sum == (temp - sum + i)) return i;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n\\n\\n# upvote",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int pivotInteger(int n) {\\n        \\n        int temp  = (n * (n+1))/2;\\n        \\n        int sum = 0;\\n        \\n        if(n==1) return 1;\\n        \\n        for(int i=1; i< n ;i++){\\n            sum = sum + i;\\n            \\n            if(sum == (temp - sum + i)) return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2857938,
                "title": "easy-c-solution-with-o-n-complexity",
                "content": "# *Complexity*\\n- Time complexity:  O(n)\\n\\n- Space complexity: O(n)\\n# *Code*\\n```\\nint pivotInteger(int n)\\n{\\n    int sum = (n*(n+1))/2, temp = -1;\\n    for(int i = 1; i<=n; i++)\\n    {\\n        int mid = (i*(i+1))/2;\\n        if(mid == sum)\\n        {\\n            temp = i;\\n            break;\\n        }\\n        sum = sum-i;\\n    }\\n    return temp;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint pivotInteger(int n)\\n{\\n    int sum = (n*(n+1))/2, temp = -1;\\n    for(int i = 1; i<=n; i++)\\n    {\\n        int mid = (i*(i+1))/2;\\n        if(mid == sum)\\n        {\\n            temp = i;\\n            break;\\n        }\\n        sum = sum-i;\\n    }\\n    return temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2857276,
                "title": "javascript-o-1",
                "content": "\\n```\\nvar pivotInteger = function (n) {\\n    // x^2 = (n^2 + n) / 2\\n\\n    const k = (n * n + n) / 2;\\n    const x = Math.trunc(Math.sqrt(k));\\n\\n    return x * x === k ? x : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pivotInteger = function (n) {\\n    // x^2 = (n^2 + n) / 2\\n\\n    const k = (n * n + n) / 2;\\n    const x = Math.trunc(Math.sqrt(k));\\n\\n    return x * x === k ? x : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2853826,
                "title": "python-3-solution-python-3-one-linear-100-beats",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# SIMPLE MATH::\\n# STEP 1::1+2+......X==X+.....N\\n# STEP 2::X*(X+1)//2==N*(N+1)//2 +X*(X-1)//2\\n# STEP 3::X^2=N*(N+1)//2\\n# STEP 4::X=SQRT(N*(N+1))//2\\n# Complexity\\n- Time complexity:\\n# O(1)\\n- Space complexity:\\n# O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        return int(sqrt(n*(n+1)/2)) if n in [1,8,49,288] else -1\\n      \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        return int(sqrt(n*(n+1)/2)) if n in [1,8,49,288] else -1\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853590,
                "title": "brute-force-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        vector<int>pref,suf;\\n        int temp=0;\\n        for(int i=1;i<=n;i++){\\n            temp+=i;\\n            pref.push_back(temp);\\n        }\\n        temp=0;\\n        for(int i=n;i>=1;i--){\\n            temp+=i;\\n            suf.push_back(temp);\\n        }\\n        reverse(suf.begin(),suf.end());\\n        for(int i=0;i<pref.size();i++){\\n            if(pref[i]==suf[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        vector<int>pref,suf;\\n        int temp=0;\\n        for(int i=1;i<=n;i++){\\n            temp+=i;\\n            pref.push_back(temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2853014,
                "title": "two-line-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int ans;\\n        if(n==1) return 1;\\n        ans = n*(n+1)/2;\\n        if (ceil((double)sqrt(ans)) == floor((double)sqrt(ans))) return sqrt(ans);\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int ans;\\n        if(n==1) return 1;\\n        ans = n*(n+1)/2;\\n        if (ceil((double)sqrt(ans)) == floor((double)sqrt(ans))) return sqrt(ans);\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852670,
                "title": "linear-solution",
                "content": "sum of first n elements is n*(n+1)/2 . Do a running sum and keep comparing as the given condition of the question.\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum=n*(n+1) /2;  \\n        int rsum=0; \\n        for(int i=1;i<=n;i++){\\n            rsum+= i; \\n            if(rsum==sum-rsum+i)return i;\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum=n*(n+1) /2;  \\n        int rsum=0; \\n        for(int i=1;i<=n;i++){\\n            rsum+= i; \\n            if(rsum==sum-rsum+i)return i;\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852639,
                "title": "java-easy-code",
                "content": "\\nclass Solution {\\n    public int pivotInteger(int n) {\\n      int sum = 0;\\n        for (int i = 1; i <= n; i++) {\\n            sum += i;\\n        }\\n        int index=-1;\\n        int sums=0;\\n        for (int i=1;i<=n;i++)\\n        {\\n            sums+=i;\\n            if(sum==sums)\\n            {\\n                index= i;\\n            }\\n            sum-=i;\\n        }\\n        return index;\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int pivotInteger(int n) {\\n      int sum = 0;\\n        for (int i = 1; i <= n; i++) {\\n            sum += i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2852454,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // int summation(int a,int b){\\n    //     int n = abs(a-b)+1;\\n    //     int sum = n*(a+b)/2;\\n    //     return sum;\\n    // }\\n    int pivotInteger(int n) {\\n        int sum = n*(n+1)/2;\\n        for(int i = 0; i <= n; i++){\\n            int presum = i*(i+1)/2;\\n            int suffsum = sum-presum+i;\\n            if(presum == suffsum) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int summation(int a,int b){\\n    //     int n = abs(a-b)+1;\\n    //     int sum = n*(a+b)/2;\\n    //     return sum;\\n    // }\\n    int pivotInteger(int n) {\\n        int sum = n*(n+1)/2;\\n        for(int i = 0; i <= n; i++){\\n            int presum = i*(i+1)/2;\\n            int suffsum = sum-presum+i;\\n            if(presum == suffsum) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852453,
                "title": "2485-find-the-pivot-integer-java",
                "content": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        if(n==1)\\n        {\\n            return 1;\\n        }\\n        int s=n*(n+1)/2;\\n        int pivot=0,k=s;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(pivot==k)\\n            {\\n                return i-1;\\n            }\\n            else\\n            {\\n                pivot+=i;\\n                k=s;\\n                s-=i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        if(n==1)\\n        {\\n            return 1;\\n        }\\n        int s=n*(n+1)/2;\\n        int pivot=0,k=s;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(pivot==k)\\n            {\\n                return i-1;\\n            }\\n            else\\n            {\\n                pivot+=i;\\n                k=s;\\n                s-=i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852405,
                "title": "easy-solution-with-explanation-in-java-2-ways-using-loop-formula",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt finds the pivot integer by finding the sum of all elements in an array and then subtracting each element from it. If this value is equal to twice the leftsum, we have found our pivot integer.\\n\\nOr to Find the total sum we can use the formula of sum of 1st n natural numbers.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int nums[] = new int[n];\\n        for(int i=0;i<n;i++){\\n            nums[i]=i+1;\\n        }\\n        int totalSum = 0;\\n        int leftsum = 0;\\n        for (int ele : nums)\\n            totalSum += ele;\\n        for (int i = 0; i < nums.length; leftsum += nums[i++])\\n            if (leftsum * 2 == totalSum - nums[i])\\n                return nums[i];       \\n        return -1;\\n    }\\n}\\n```\\n\\n# Using Formula\\n## Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int nums[] = new int[n];\\n        for(int i=0;i<n;i++){\\n            nums[i]=i+1;\\n        }\\n        int totalSum = (n*(n+1))/2;\\n        int leftsum = 0;\\n        for (int i = 0; i < nums.length; leftsum += nums[i++])\\n            if (leftsum * 2 == totalSum - nums[i])\\n                return nums[i];       \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int nums[] = new int[n];\\n        for(int i=0;i<n;i++){\\n            nums[i]=i+1;\\n        }\\n        int totalSum = 0;\\n        int leftsum = 0;\\n        for (int ele : nums)\\n            totalSum += ele;\\n        for (int i = 0; i < nums.length; leftsum += nums[i++])\\n            if (leftsum * 2 == totalSum - nums[i])\\n                return nums[i];       \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int nums[] = new int[n];\\n        for(int i=0;i<n;i++){\\n            nums[i]=i+1;\\n        }\\n        int totalSum = (n*(n+1))/2;\\n        int leftsum = 0;\\n        for (int i = 0; i < nums.length; leftsum += nums[i++])\\n            if (leftsum * 2 == totalSum - nums[i])\\n                return nums[i];       \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852246,
                "title": "javascript-direct-way-107ms",
                "content": "```\\nconst sumOfRange = (l, r) => (l + r) * (r - l + 1) / 2;\\n\\nconst pivotInteger = (n) => {\\n    for (let x = 1; x <= n; x++) {\\n        if (sumOfRange(1, x) == sumOfRange(x, n)) return x;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sumOfRange = (l, r) => (l + r) * (r - l + 1) / 2;\\n\\nconst pivotInteger = (n) => {\\n    for (let x = 1; x <= n; x++) {\\n        if (sumOfRange(1, x) == sumOfRange(x, n)) return x;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852185,
                "title": "c-code-faster-than-100",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        if(n==1) return 1;\\n        \\n        int ls = 0;\\n        int rs = 0;\\n        int i=0;\\n        int j=n-1;\\n        \\n        vector<int> v;\\n        for(int i=0; i<n; i++) {\\n            v.push_back(i+1);\\n        }\\n        \\n        ls += v[0];\\n        rs += v[n-1];\\n\\n        while(i<=j) {\\n            \\n            if(ls == rs) {\\n            \\n                i++; j--;\\n                \\n                ls += v[i];\\n                rs += v[j];\\n                \\n                if(i == j) break;\\n                \\n            }\\n            else if(ls < rs) {\\n                i++;\\n                ls += v[i];\\n            }\\n            else if(ls > rs) {\\n                j--;\\n                rs += v[j];\\n            }\\n        }\\n        if(i==j) return i+1;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        if(n==1) return 1;\\n        \\n        int ls = 0;\\n        int rs = 0;\\n        int i=0;\\n        int j=n-1;\\n        \\n        vector<int> v;\\n        for(int i=0; i<n; i++) {\\n            v.push_back(i+1);\\n        }\\n        \\n        ls += v[0];\\n        rs += v[n-1];\\n\\n        while(i<=j) {\\n            \\n            if(ls == rs) {\\n            \\n                i++; j--;\\n                \\n                ls += v[i];\\n                rs += v[j];\\n                \\n                if(i == j) break;\\n                \\n            }\\n            else if(ls < rs) {\\n                i++;\\n                ls += v[i];\\n            }\\n            else if(ls > rs) {\\n                j--;\\n                rs += v[j];\\n            }\\n        }\\n        if(i==j) return i+1;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852166,
                "title": "prefix-sum-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        int curr = 0;\\n        int tot = n*(n+1)/2;\\n        \\n        for(int i = 1;i<=n;i++){\\n            curr+=i;\\n            if(curr==tot){\\n                return i;\\n            }\\n            tot-=i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        int curr = 0;\\n        int tot = n*(n+1)/2;\\n        \\n        for(int i = 1;i<=n;i++){\\n            curr+=i;\\n            if(curr==tot){\\n                return i;\\n            }\\n            tot-=i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852137,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int rightSum = (n * (n + 1)) / 2; // sum formula\\n        for (int i = 1, leftSum = 0; i <= n; i++) {\\n            rightSum -= i;\\n            if (leftSum == rightSum) {\\n                return i;\\n            } else if (leftSum > rightSum) {\\n                return -1;\\n            }\\n            leftSum += i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int rightSum = (n * (n + 1)) / 2; // sum formula\\n        for (int i = 1, leftSum = 0; i <= n; i++) {\\n            rightSum -= i;\\n            if (leftSum == rightSum) {\\n                return i;\\n            } else if (leftSum > rightSum) {\\n                return -1;\\n            }\\n            leftSum += i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852068,
                "title": "c-n-n-1-2-use",
                "content": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        for(int i=1;i<=n;i++){\\n            // find sum till 1 to i inclusive\\n            int leftsum = (i*(i+1))/2;\\n            // find sum till i to n inclusive\\n            int rightsum = (n*(n+1))/2 - leftsum + i;\\n            // if equal then return i\\n            if(leftsum==rightsum) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        for(int i=1;i<=n;i++){\\n            // find sum till 1 to i inclusive\\n            int leftsum = (i*(i+1))/2;\\n            // find sum till i to n inclusive\\n            int rightsum = (n*(n+1))/2 - leftsum + i;\\n            // if equal then return i\\n            if(leftsum==rightsum) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852058,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint pivotInteger(int n) {\\n\\t\\t\\tif(n==1){return 1;}\\n\\t\\t\\tint ans=-1;\\n\\t\\t\\tlong long int cnt=n*(n+1)/2;\\n\\t\\t\\t//cout<<cnt<<endl;\\n\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\t//cout<<i<<\" \"<<i*(i+1)/2<<\" \"<<cnt-((i+1)*i/2)+i<<endl;\\n\\t\\t\\t\\tif(i*(i+1)/2==cnt-((i+1)*i/2)+i){ans=i; break;}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint pivotInteger(int n) {\\n\\t\\t\\tif(n==1){return 1;}",
                "codeTag": "Java"
            },
            {
                "id": 2852000,
                "title": "c-ezzzz-solution",
                "content": "class Solution {\\npublic:\\n    int pivotInteger(int n) {\\n\\t\\n        int isum = 0,jsum=0;\\n        for(int i = 1 ; i <= n ; i++){\\n            isum+=i;\\n            for(int j = i ; j <= n ; j++){\\n                jsum+=j;\\n            }\\n            if(isum == jsum) return i;\\n            else jsum = 0;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int pivotInteger(int n) {\\n\\t\\n        int isum = 0,jsum=0;\\n        for(int i = 1 ; i <= n ; i++){\\n            isum+=i;\\n            for(int j = i ; j <= n ; j++){\\n                jsum+=j;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2851989,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        for(int i=1;i<=n;i++) {\\n            int sum=0;\\n\\t\\t\\t// find right-side range\\n            for(int j=i;j<=n;j++) sum+=j;\\n            if(sum == (i*(i+1))/2) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        for(int i=1;i<=n;i++) {\\n            int sum=0;\\n\\t\\t\\t// find right-side range\\n            for(int j=i;j<=n;j++) sum+=j;\\n            if(sum == (i*(i+1))/2) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851949,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int totalSum = n * (n + 1) / 2;\\n        for (int i = 1; i <= n; i++) {\\n            int sum = i * (i + 1) / 2;            \\n            if (sum == totalSum - sum + i) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int totalSum = n * (n + 1) / 2;\\n        for (int i = 1; i <= n; i++) {\\n            int sum = i * (i + 1) / 2;            \\n            if (sum == totalSum - sum + i) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098764,
                "title": "num",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint pivotInteger(int n){\\n\\n    if(n==0) return 0;\\n    if(n==1) return 1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        if((i*(i+1))/2==((n-i+1)*(n+i))/2)\\n        {\\n            return i;\\n        }\\n    }\\n    return -1;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint pivotInteger(int n){\\n\\n    if(n==0) return 0;\\n    if(n==1) return 1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        if((i*(i+1))/2==((n-i+1)*(n+i))/2)\\n        {\\n            return i;\\n        }\\n    }\\n    return -1;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098550,
                "title": "python-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def pivotInteger(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1:\\n            return 1\\n        sum = n * (n + 1)/2\\n        print(sum)\\n        temp = 0\\n        for i in range(n):\\n            sum -= i + 1\\n            if temp == sum:\\n                pivot = i + 1\\n                break\\n            else:\\n                temp += i + 1\\n                pivot = -1\\n        return pivot\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pivotInteger(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1:\\n            return 1\\n        sum = n * (n + 1)/2\\n        print(sum)\\n        temp = 0\\n        for i in range(n):\\n            sum -= i + 1\\n            if temp == sum:\\n                pivot = i + 1\\n                break\\n            else:\\n                temp += i + 1\\n                pivot = -1\\n        return pivot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098022,
                "title": "fast-c-approach-100-fastest-approach",
                "content": "# Intuition\\nThought of calculating the sum from 1 to x and from x to n by using the formula of n consecutive numbers.\\n\\n# Approach\\nUsing the sum of first n consecutive numbers, we apply the formula calculating the sum up to x.\\nThe sum from x to n is calculated by initialising tempSum with the value of n and adding each (x-1) to the sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nint pivotInteger(int n){\\n\\n    int tempSum = n;\\n    int x = n;\\n\\n    while(x) {\\n        if(x*(x+1)/2 == tempSum) return x;\\n        x--;\\n        tempSum += x;\\n    }\\n\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint pivotInteger(int n){\\n\\n    int tempSum = n;\\n    int x = n;\\n\\n    while(x) {\\n        if(x*(x+1)/2 == tempSum) return x;\\n        x--;\\n        tempSum += x;\\n    }\\n\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092367,
                "title": "simple-brute-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n      int sum=(n*(n+1))/2;\\n      int currsum=0;\\n      for(int i=0;i<=n;i++){\\n        sum=sum-i;\\n        if(sum==currsum){\\n          return i;\\n        }else{\\n          currsum+=i;\\n        }\\n      }\\n      return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n      int sum=(n*(n+1))/2;\\n      int currsum=0;\\n      for(int i=0;i<=n;i++){\\n        sum=sum-i;\\n        if(sum==currsum){\\n          return i;\\n        }else{\\n          currsum+=i;\\n        }\\n      }\\n      return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091785,
                "title": "optimised-approach-with-o-n-time-complexity-in-python-using-two-subset-sums",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        # Optimised approach with O(n) time complexity and\\n        # Space Complexity O(n)\\n\\n        # Base case:\\n        if n == 1:\\n            return 1\\n\\n        nums = [i for i in range(1, n+1)]\\n        first_sum = nums[0]\\n        second_sum = sum(nums)\\n\\n        for i in range(1, len(nums)):\\n            first_sum += nums[i]\\n            second_sum -= nums[i-1]\\n            if first_sum == second_sum:\\n                return nums[i]\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        # Optimised approach with O(n) time complexity and\\n        # Space Complexity O(n)\\n\\n        # Base case:\\n        if n == 1:\\n            return 1\\n\\n        nums = [i for i in range(1, n+1)]\\n        first_sum = nums[0]\\n        second_sum = sum(nums)\\n\\n        for i in range(1, len(nums)):\\n            first_sum += nums[i]\\n            second_sum -= nums[i-1]\\n            if first_sum == second_sum:\\n                return nums[i]\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088169,
                "title": "golang-solution",
                "content": "# Code\\n```\\nfunc pivotInteger(n int) int {\\n    sumBefore := 0\\n    sumAfter := (n * (n + 1)) / 2\\n\\n    for i := 1; i <= n; i++ {\\n        sumBefore += i\\n        if sumAfter == sumBefore {\\n            return i\\n        }\\n        sumAfter -= i\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pivotInteger(n int) int {\\n    sumBefore := 0\\n    sumAfter := (n * (n + 1)) / 2\\n\\n    for i := 1; i <= n; i++ {\\n        sumBefore += i\\n        if sumAfter == sumBefore {\\n            return i\\n        }\\n        sumAfter -= i\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083735,
                "title": "python-3-easy-remedy-beats-87-98",
                "content": "# Intuition\\n<!-- ithoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        a=0\\n        if n==1:\\n          return 1\\n        for i in range(n):\\n          if sum(list(range(1,i+1)))==sum(list(range(i,n+1))):\\n            a +=i\\n            break\\n        if a>0:\\n          return a\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        a=0\\n        if n==1:\\n          return 1\\n        for i in range(n):\\n          if sum(list(range(1,i+1)))==sum(list(range(i,n+1))):\\n            a +=i\\n            break\\n        if a>0:\\n          return a\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083734,
                "title": "python-3-easy-remedy-beats-87-98",
                "content": "# Intuition\\n<!-- ithoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        a=0\\n        if n==1:\\n          return 1\\n        for i in range(n):\\n          if sum(list(range(1,i+1)))==sum(list(range(i,n+1))):\\n            a +=i\\n            break\\n        if a>0:\\n          return a\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        a=0\\n        if n==1:\\n          return 1\\n        for i in range(n):\\n          if sum(list(range(1,i+1)))==sum(list(range(i,n+1))):\\n            a +=i\\n            break\\n        if a>0:\\n          return a\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083581,
                "title": "prefix-sum-approach-tc-o-n-sc-o-n-c-beats-100",
                "content": "# Intuition\\nThe problem involves finding the pivot integer in a sequence of consecutive integers, such that the sum of integers to the left and right of the pivot is equal. In simpler terms, it\\'s about finding the index where the cumulative sum of elements on the left side of the pivot equals the cumulative sum of elements on the right side.\\n\\n# Approach\\nThe code initializes a vector `v` with values from 1 to `n`. It then calculates the cumulative sums of elements on the left (`l`) and right (`r`) sides of each element in the `v` vector. The idea is to find an element where the cumulative sums on both sides are equal.\\n\\n1. Initialize vectors `v`, `l`, and `r` to store the elements, left cumulative sums, and right cumulative sums, respectively.\\n2. Fill the `v` vector with consecutive integers from 1 to `n`.\\n3. Calculate the left cumulative sums and store them in the `l` vector.\\n4. Calculate the right cumulative sums and store them in the `r` vector.\\n5. Iterate through the `v` vector to find an element where `l[i]` is equal to `r[i]`. If found, return `i + 1`, as the problem asks for the index (1-based) of the pivot element.\\n6. If no such pivot element is found, return -1 to indicate that there is no pivot integer.\\n\\n# Complexity\\n- Time complexity: O(n) - We iterate through the `v` vector three times to calculate left and right cumulative sums and find the pivot element.\\n- Space complexity: O(n) - We use three additional vectors (`v`, `l`, and `r`) to store data related to the input integer `n`.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        vector<int>v(n), l(n), r(n);\\n        for(auto i =0; i<n; i++){\\n            v[i]=i+1;\\n        }\\n\\n        l[0]=v[0];\\n        r[n-1]=v[n-1];\\n        for(auto i =1;i<n; i++){\\n            l[i] = l[i-1]+v[i];\\n        }\\n        for(auto i=n-2; i>=0; i--){\\n            r[i]= r[i+1]+v[i];\\n        }\\n\\n        for(auto i =0; i<n; i++){\\n            if(l[i] == r[i]){\\n                return i+1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        vector<int>v(n), l(n), r(n);\\n        for(auto i =0; i<n; i++){\\n            v[i]=i+1;\\n        }\\n\\n        l[0]=v[0];\\n        r[n-1]=v[n-1];\\n        for(auto i =1;i<n; i++){\\n            l[i] = l[i-1]+v[i];\\n        }\\n        for(auto i=n-2; i>=0; i--){\\n            r[i]= r[i+1]+v[i];\\n        }\\n\\n        for(auto i =0; i<n; i++){\\n            if(l[i] == r[i]){\\n                return i+1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082449,
                "title": "using-gauss-sum",
                "content": "\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        if n==1:\\n            return 1\\n        for y in range(n):\\n            if ((y+1)*y)/2==((y+n)*((n-y)+1))/2:\\n                return y \\n        return -1\\n        \\n\\n\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        if n==1:\\n            return 1\\n        for y in range(n):\\n            if ((y+1)*y)/2==((y+n)*((n-y)+1))/2:\\n                return y \\n        return -1\\n        \\n\\n\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082355,
                "title": "brute-force-approach-using-hints",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum = (n * (n+1))/2;\\n        int temp = 0;\\n        for(int i=1; i <= n; i++){\\n            sum -= i;\\n            if(temp == sum)\\n                return i;\\n            else\\n                temp += i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int sum = (n * (n+1))/2;\\n        int temp = 0;\\n        for(int i=1; i <= n; i++){\\n            sum -= i;\\n            if(temp == sum)\\n                return i;\\n            else\\n                temp += i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081383,
                "title": "easy-solution-beats-100-easy-approach-upvote-please",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n     int sum (int n){\\n         int totalsum = 0;\\n     for (int i = 0; i <= n ; i++){\\n           totalsum = totalsum + i;\\n        }\\n             return totalsum;\\n     }\\n\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        int leftsum=0 ;\\n        int rightsum;\\n        int totalsum = 0 ;\\n\\n        int getsum = sum(n);\\n       \\n          for(int i = 0; i <= n; i++){\\n              rightsum = getsum - leftsum - i;\\n\\n               if(rightsum == leftsum ){\\n              return i;\\n          }\\n               leftsum = leftsum + i;\\n\\n          }\\n         return -1;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n     int sum (int n){\\n         int totalsum = 0;\\n     for (int i = 0; i <= n ; i++){\\n           totalsum = totalsum + i;\\n        }\\n             return totalsum;\\n     }\\n\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        int leftsum=0 ;\\n        int rightsum;\\n        int totalsum = 0 ;\\n\\n        int getsum = sum(n);\\n       \\n          for(int i = 0; i <= n; i++){\\n              rightsum = getsum - leftsum - i;\\n\\n               if(rightsum == leftsum ){\\n              return i;\\n          }\\n               leftsum = leftsum + i;\\n\\n          }\\n         return -1;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081382,
                "title": "easy-solution-beats-100-easy-approach-upvote-please",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n     int sum (int n){\\n         int totalsum = 0;\\n     for (int i = 0; i <= n ; i++){\\n           totalsum = totalsum + i;\\n        }\\n             return totalsum;\\n     }\\n\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        int leftsum=0 ;\\n        int rightsum;\\n        int totalsum = 0 ;\\n\\n        int getsum = sum(n);\\n       \\n          for(int i = 0; i <= n; i++){\\n              rightsum = getsum - leftsum - i;\\n\\n               if(rightsum == leftsum ){\\n              return i;\\n          }\\n               leftsum = leftsum + i;\\n\\n          }\\n         return -1;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n     int sum (int n){\\n         int totalsum = 0;\\n     for (int i = 0; i <= n ; i++){\\n           totalsum = totalsum + i;\\n        }\\n             return totalsum;\\n     }\\n\\npublic:\\n    int pivotInteger(int n) {\\n        \\n        int leftsum=0 ;\\n        int rightsum;\\n        int totalsum = 0 ;\\n\\n        int getsum = sum(n);\\n       \\n          for(int i = 0; i <= n; i++){\\n              rightsum = getsum - leftsum - i;\\n\\n               if(rightsum == leftsum ){\\n              return i;\\n          }\\n               leftsum = leftsum + i;\\n\\n          }\\n         return -1;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079209,
                "title": "simple-easy-java-solution-using-sum-of-natural-numbers",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int max=(n*(n+1))/2;\\n        int sum=0,i=1;\\n        while(n>0){\\n            sum=sum+i;\\n            if(sum==max-sum+i)\\n            return i;\\n            else{\\n            n--;\\n            i++;\\n        }\\n       \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pivotInteger(int n) {\\n        int max=(n*(n+1))/2;\\n        int sum=0,i=1;\\n        while(n>0){\\n            sum=sum+i;\\n            if(sum==max-sum+i)\\n            return i;\\n            else{\\n            n--;\\n            i++;\\n        }\\n       \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077390,
                "title": "c-easy-solution-o-sqrt-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum = n*(n+1)/2; \\n        int pivot = -1;\\n\\n        for(int i = 1; (i<=n && i*i <= sum); i++){\\n            if(i*i == sum){\\n                pivot = i;\\n            }\\n        }\\n\\n        return pivot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum = n*(n+1)/2; \\n        int pivot = -1;\\n\\n        for(int i = 1; (i<=n && i*i <= sum); i++){\\n            if(i*i == sum){\\n                pivot = i;\\n            }\\n        }\\n\\n        return pivot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072450,
                "title": "easy-solution-for-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar pivotInteger = function (n) {\\n//general function for calculate sum\\n  let sum = (n) => {\\n    return (n * (n + 1)) / 2;\\n  };\\n  for (let i = 1; i <= n; i++) {\\n// there we calculate all and return result -->\\n    if (sum(i)===(sum(n)+i)/2) {\\n      return i;\\n    }\\n  }\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar pivotInteger = function (n) {\\n//general function for calculate sum\\n  let sum = (n) => {\\n    return (n * (n + 1)) / 2;\\n  };\\n  for (let i = 1; i <= n; i++) {\\n// there we calculate all and return result -->\\n    if (sum(i)===(sum(n)+i)/2) {\\n      return i;\\n    }\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071882,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int tsum = 0;\\n        int lsum=0;\\n        for(int i=1;i<=n;i++){\\n            tsum = tsum + i;\\n        }\\n        int rsum = tsum;\\n        for(int i = 1;i<=n;i++){\\n            rsum = rsum - i;\\n            if(rsum == lsum){\\n                return i;\\n            }\\n   \\n            lsum = lsum + i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int tsum = 0;\\n        int lsum=0;\\n        for(int i=1;i<=n;i++){\\n            tsum = tsum + i;\\n        }\\n        int rsum = tsum;\\n        for(int i = 1;i<=n;i++){\\n            rsum = rsum - i;\\n            if(rsum == lsum){\\n                return i;\\n            }\\n   \\n            lsum = lsum + i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065598,
                "title": "python-simple-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        #CREATE A LIST\\n        arr=[i for i in range(1, n + 1)]\\n        for i in range(n):\\n        #CHECK FOR PIVOT ELEMENT\\n        #RETURN IF PRESENT, ELSE -1\\n            if sum(arr[:(i+1)])==sum(arr[i:]):\\n                return i+1\\n                break\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        #CREATE A LIST\\n        arr=[i for i in range(1, n + 1)]\\n        for i in range(n):\\n        #CHECK FOR PIVOT ELEMENT\\n        #RETURN IF PRESENT, ELSE -1\\n            if sum(arr[:(i+1)])==sum(arr[i:]):\\n                return i+1\\n                break\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065425,
                "title": "bruteforce-simple-and-easy-c-c-beats-100-00-users",
                "content": "# Intuition\\n-> First we Calculate Sum of n Nutural Numbers.\\n-> Anothor virable \\'sum2\\' , we add from n to sum2.\\n-> Check every time that if sum is equal to sum2 or not.\\n-> If yes, return n, otherwise -1.\\n\\n# Approach\\nBruteForce\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum1 = (n*(n+1))/2;\\n        int sum2 = 0;\\n        cout<<sum1;\\n        while(n>0)\\n        {\\n            sum2+=n;\\n            if(sum1==sum2)\\n                return n;\\n            sum1-=n;  \\n            n--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sum1 = (n*(n+1))/2;\\n        int sum2 = 0;\\n        cout<<sum1;\\n        while(n>0)\\n        {\\n            sum2+=n;\\n            if(sum1==sum2)\\n                return n;\\n            sum1-=n;  \\n            n--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4065254,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        s1=(n*(n+1))/2\\n        s2=0\\n        for i in range(1,n+1):\\n            if s2==s1 - s2 - i:\\n                return i\\n            else:\\n                s2+=i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        s1=(n*(n+1))/2\\n        s2=0\\n        for i in range(1,n+1):\\n            if s2==s1 - s2 - i:\\n                return i\\n            else:\\n                s2+=i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064882,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        honey=[i for i in range(1,n+1)]\\n        if len(honey)==1:\\n            return 1\\n        for i in range(n):\\n            if sum(honey[0:i-1])==sum(honey[i:n]):\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        honey=[i for i in range(1,n+1)]\\n        if len(honey)==1:\\n            return 1\\n        for i in range(n):\\n            if sum(honey[0:i-1])==sum(honey[i:n]):\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064881,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        honey=[i for i in range(1,n+1)]\\n        if len(honey)==1:\\n            return 1\\n        for i in range(n):\\n            if sum(honey[0:i-1])==sum(honey[i:n]):\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        honey=[i for i in range(1,n+1)]\\n        if len(honey)==1:\\n            return 1\\n        for i in range(n):\\n            if sum(honey[0:i-1])==sum(honey[i:n]):\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062831,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        if n==1: return 1\\n        li=[i for i in range(1,n+1)]\\n        for i in range(n-1):\\n            if sum(li[:i+1])==sum(li[i:]): return li[i]\\n        return -1\\n```\\n***Hope it helps...!!*** \\uD83D\\uDE07\\u270C\\uFE0F",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        if n==1: return 1\\n        li=[i for i in range(1,n+1)]\\n        for i in range(n-1):\\n            if sum(li[:i+1])==sum(li[i:]): return li[i]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058632,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) \\n    {\\n      vector<int>pre(n+1,0);\\n      for (int i=1;i<=n;i++)\\n      {\\n          pre[i]=pre[i-1]+i;\\n      } \\n      for (int i=1;i<=n;i++)\\n      {\\n          if (pre[i]==pre[n]-pre[i-1]) return i;\\n      }   \\n      return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) \\n    {\\n      vector<int>pre(n+1,0);\\n      for (int i=1;i<=n;i++)\\n      {\\n          pre[i]=pre[i-1]+i;\\n      } \\n      for (int i=1;i<=n;i++)\\n      {\\n          if (pre[i]==pre[n]-pre[i-1]) return i;\\n      }   \\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051125,
                "title": "binary-search-math-answer-in-0-ms",
                "content": "# Intuition\\nCalculating the sum of the both the sides for every number.\\nAnd to make the process faster using binary search algorithm.\\n\\n# Approach\\nUsing Binary Search traverse through the mid elements and checking their sum of both left and right side and if they are equal then returning the number.\\n\\nFor calulating the sum I have used mathematical formula.\\nFor left_sum = (n*(n+1))/2;\\nAnd for the right_sum = Total_sum - left_sum + mid;\\n\\n# Complexity\\n- Time complexity : O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int start = 1;\\n        int end = n;\\n        int mid = (start+end)/2;\\n        int left_sum = 0,right_sum = 0;\\n        int total_sum = (n * (n + 1)) / 2;\\n        if(n==1){\\n            return 1;\\n        }\\n        while(start<end){\\n            left_sum = (mid * (mid + 1)) / 2;\\n            right_sum = total_sum - left_sum + mid;\\n            if(left_sum==right_sum){\\n                return mid;\\n            }\\n            else if(left_sum<right_sum){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n            mid = (start+end)/2;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int start = 1;\\n        int end = n;\\n        int mid = (start+end)/2;\\n        int left_sum = 0,right_sum = 0;\\n        int total_sum = (n * (n + 1)) / 2;\\n        if(n==1){\\n            return 1;\\n        }\\n        while(start<end){\\n            left_sum = (mid * (mid + 1)) / 2;\\n            right_sum = total_sum - left_sum + mid;\\n            if(left_sum==right_sum){\\n                return mid;\\n            }\\n            else if(left_sum<right_sum){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n            mid = (start+end)/2;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050136,
                "title": "smart-math-solution-step-by-step-everyone-will-understand-with-explanation",
                "content": "# Intuition\\nSince we want to find x we need to solve this equation with respect to x:\\n$1+...+x=x+...+n$, we can of course use sum of arythmetical sequence so:\\n$\\\\frac{1+x}{2}*x = \\\\frac{x+n}{2}*(n-x+1)$, after calculations we have:\\n$x=\\\\sqrt{\\\\frac{n*(n+1)}{2}}$. So if x is integer we will have solution. I used it in my code. Feel free to upvote!\\n\\n# Complexity\\nBEATS 98% OF USERS BY RUNTIME\\n\\n# Code\\n```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        import math\\n        if math.sqrt(n*(n+1)/2).is_integer():\\n            return int(math.sqrt(n*(n+1)/2))\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pivotInteger(self, n: int) -> int:\\n        import math\\n        if math.sqrt(n*(n+1)/2).is_integer():\\n            return int(math.sqrt(n*(n+1)/2))\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042926,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sumLeft = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            sumLeft = sumLeft + i;\\n        }\\n        int sumRight = 0;\\n        for (int i = n; i >= 0; i--)\\n        {\\n            sumRight += i;\\n            if (sumRight == sumLeft)\\n            {\\n                return i;\\n            }\\n            sumLeft -= i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pivotInteger(int n) {\\n        int sumLeft = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            sumLeft = sumLeft + i;\\n        }\\n        int sumRight = 0;\\n        for (int i = n; i >= 0; i--)\\n        {\\n            sumRight += i;\\n            if (sumRight == sumLeft)\\n            {\\n                return i;\\n            }\\n            sumLeft -= i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1698320,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1819622,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1841387,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1785147,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 2071627,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1949092,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1870588,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1812149,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1772558,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1761524,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1698320,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1819622,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1841387,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1785147,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 2071627,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1949092,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1870588,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1812149,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1772558,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            },
            {
                "id": 1761524,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Four solutions possible;\n1. Using prefix sum\n2. Using mathematics\n3. Using binary search\n4. Using DP"
                    },
                    {
                        "username": "druv_kotwani",
                        "content": "The approach is simple, I've done it using brute force or you can say using prefix sum in O(n) time-complexity.\n\nStep 1. Using for loop calculate the total sum.\nEx: for n =8, the total sum will be 1+2+3+4...+8 =36\n\nStep2. Take a  temp variable initialize with value 0, \n\nStep3. Run a for loop \"n times\" again but this time, reduce the sum and check if (temp==sum), if not add it to temp.\nEx. n=8: 1,2,3,4,5,6,7,8: Sum = 36, temp = 0\n\na. first subtract 1 from sum, then check if (temp==sum)\nb. here sum = 35(36-1) which is not equal to temp(which is 0)\nc. now add 1 to temp, now temp will become 1.\n....\n....\n...., continue this process.\nthere will come a point where sum if equal to temp, in this case when loop reaches the value 6.\nThen return this value.\n\nIf not, then simply return -1.\n\n\n \n\n"
                    },
                    {
                        "username": "iharshka",
                        "content": "[@ibtihaj_05](/ibtihaj_05) You are right "
                    },
                    {
                        "username": "MaheshK04",
                        "content": "Thank you for the explanation "
                    },
                    {
                        "username": "ibtihaj_05",
                        "content": "Awesome explanation. I\\'ve tried it and problem is accepted. I have a question. Isn\\'t the time-complexity of this process O(n) ? Because to find out the value of \\'x\\', loop has to traverse upto  n time."
                    },
                    {
                        "username": "PrashDev001",
                        "content": "int sum = (n + 1) * n / 2;\\nint pivot = (int) Math.sqrt(sum);\\nreturn pivot * pivot == sum ? pivot : -1;"
                    },
                    {
                        "username": "Syang1216",
                        "content": "Unless I\\'m mistaken n=15, there is no pivot number.\\nTest case outputs x=10,\\nbut sum(1....10) is not equal to sum(10....15), right?"
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "yeah x = 10 is correct, read the whole problem again , \"x\" is included in both the sums.."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "there are only 4 pivot numbers that satisfies the answer (1<=n<=1000)"
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "Intuition\\nUsing the summation of the Nth natural numbers.\\n\\nApproach\\nFor the sum on the left, compute the sum of i-th natural numbers.\\nFor the right sum, compute the sum of the natural numbers N-th - left sum compute the sum of the natural number i-th-1.\\nIf Left Sum is the same as Right Sum return ith value otherwise return -1."
                    },
                    {
                        "username": "Sekpey-404_",
                        "content": "First time attempt a success. Well if you got the understanding of the pivot index, you will definitely get this concept right within a flash. Got all cases right. I love leetcode. A hint though. Pointers can be of great help here."
                    },
                    {
                        "username": "nikitaghadage13",
                        "content": "why i start with 1"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It seems that the test case where n=49 is incorrect. \\nThe expected output is 35 but if we calculate the sum of the first 35 natural numbers, it is equal to 630 logic:(35 multiplied by 36 divided 2). \\nThe sum of the next numbers up to 49 would be = (49 multiplied by 50 divided 2) - 630 = 1225 - 630 = 595.\\nas 595 !=630, the expected answer is incorrect. \\nMy code runs properly for 427/428 test cases which further indicates that the testcases itself is incorrect!"
                    },
                    {
                        "username": "iharshka",
                        "content": "Satyam,\\nYou have to include 35 again when you are calculating the right sum."
                    },
                    {
                        "username": "risabvishwakarma",
                        "content": "1 2 3 4 5 6     :     7  8\n    21             :     15    \nwhile condition is,\n1 2 3 4 5 6     :    6  7  8  \n     21             :     21\n\npivote element will be common in both sum.\n\nso your ans should be for 49--\n if pivote =35 then \nleft sum=630(as u calculated) from 1 to 35\n\nright sum=630(595+35) from 35 to 49.\n\nokay? \n      "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2485_Find_the_Pivot_Integer.cpp"
                    }
                ]
            }
        ]
    }
]