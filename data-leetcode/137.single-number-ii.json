[
    {
        "title": "Single Number II",
        "question_content": "Given an integer array nums where&nbsp;every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.\n&nbsp;\nExample 1:\nInput: nums = [2,2,3,2]\nOutput: 3\nExample 2:\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 3 * 104\n\t-231 <= nums[i] <= 231 - 1\n\tEach element in nums appears exactly three times except for one element which appears once.",
        "solutions": [
            {
                "id": 43295,
                "title": "detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers",
                "content": "`I -- Statement of our problem`\\n\\n\"Given an array of integers, every element appears `k` (`k > 1`) times except for one, which appears `p` times (`p >= 1, p % k != 0`). Find that single one.\" \\n\\n---\\n\\n`II -- Special case with 1-bit numbers`\\n\\nAs others pointed out, in order to apply the bitwise operations, we should rethink how integers are represented in computers -- by bits. To start, let\\'s consider only one bit for now. Suppose we have an array of **1-bit** numbers (which can only be `0` or `1`), we\\'d like to count the number of `1`\\'s in the array such that whenever the counted number of `1` reaches a certain value, say `k`, the count returns to zero and starts over (in case you are curious, this `k` will be the same as the one in the problem statement above). To keep track of how many `1`\\'s we have encountered so far, we need a counter. Suppose the counter has `m` bits in binary form: `xm, ..., x1` (from most significant bit to least significant bit). We can conclude at least the following four properties of the counter:\\n\\n1. There is an initial state of the counter, which for simplicity is zero;\\n2. For each input from the array, if we hit a `0`, the counter should remain unchanged;\\n3. For each input from the array, if we hit a `1`, the counter should increase by one;\\n4. In order to cover `k` counts, we require `2^m >= k`, which implies `m >= logk`.\\n\\nHere is the key part: how each bit in the counter (`x1` to `xm`) changes as we are scanning the array. Note we are prompted to use bitwise operations. In order to satisfy the second property, recall what bitwise operations will not change the operand if the other operand is `0`? Yes, you got it: `x = x | 0` and `x = x ^ 0`. \\n\\nOkay, we have an expression now: `x = x | i`  or  `x = x ^ i`, where `i` is the scanned element from the array. Which one is better?  We don\\'t know yet. So, let\\'s just do the actual counting.\\n\\nAt the beginning, all bits of the counter is initialized to zero, i.e., `xm = 0, ..., x1 = 0`.  Since we are gonna choose bitwise operations that guarantee all bits of the counter remain unchanged if we hit `0`\\'s, the counter will be `0` until we hit the first `1` in the array. After we hit the first `1`, we got:  `xm = 0,  ...,x2 = 0, x1 = 1`. Let\\'s continue until we hit the second `1`, after which we have:  `xm = 0, ..., x2 = 1, x1 = 0`. Note that `x1` changed from `1` to `0`. For `x1 = x1 | i`, after the second count, `x1` will still be `1`. So it\\'s clear we should use `x1 = x1 ^ i`. What about `x2, ..., xm`? The idea is to find the condition under which `x2, ..., xm` will change their values. Take `x2` as an example. If we hit a `1` and need to change the value of `x2`, what must be the value of `x1` right before we do the change? The answer is: `x1` must be `1` otherwise we shouldn\\'t change `x2` because changing `x1` from `0` to `1` will do the job. So `x2` will change value only if `x1` and `i` are both `1`, or mathematically, `x2 = x2 ^ (x1 & i)`.  Similarly `xm` will change value only when `xm-1, ..., x1` and `i` are all `1`: `xm = xm ^ (xm-1 & ... &  x1 & i)`. Bingo, we\\'ve found the bitwise operations! \\n\\nHowever, you may notice that the bitwise operations found above will count from `0` until `2^m - 1`, instead of `k`. If `k < 2^m - 1`, we need some \"cutting\" mechanism to reinitialize the counter to `0` when the count reaches `k`. To this end, we apply bitwise **AND** to `xm,..., x1` with some variable called `mask`, i.e., `xm = xm & mask,  ...,  x1 = x1 & mask`. If we can make sure that `mask` will be `0` only when the count reaches `k` and be `1` for all other count cases, then we are done. How do we achieve that? Try to think what distinguishes the case with `k` count from all other count cases. Yes, it\\'s the count of `1`\\'s! For each count, we have unique values for each bit of the counter, which can be regarded as its state. If we write `k` in its binary form: `km,..., k1`, we can construct `mask` as follows:\\n\\n`mask = ~(y1 & y2 & ... & ym)`,  where `yj = xj`  if `kj = 1`, and  `yj = ~xj`  if `kj = 0` (`j = 1` to `m`). \\n\\nLet\\'s do some examples:\\n\\n`k = 3: k1 = 1, k2 = 1, mask = ~(x1 & x2)`;\\n\\n`k = 5: k1 = 1, k2 = 0, k3 = 1, mask = ~(x1 & ~x2 & x3)`;\\n\\nIn summary, our algorithm will go like this (`nums` is the input array):\\n```\\nfor (int i : nums) {\\n    xm ^= (xm-1 & ... & x1 & i);\\n    xm-1 ^= (xm-2 & ... & x1 & i);\\n    .....\\n    x1 ^= i;\\n    \\n    mask = ~(y1 & y2 & ... & ym) where yj = xj if kj = 1, and yj = ~xj if kj = 0 (j = 1 to m).\\n\\n    xm &= mask;\\n    ......\\n    x1 &= mask;\\n}\\n```\\n\\n---\\n`III -- General case with 32-bit numbers`\\n\\nNow it\\'s time to generalize our results from 1-bit number case to 32-bit integers. One straightforward way would be creating `32` counters for each bit in the integer. You\\'ve probably already seen this in other posted [solutions](https://discuss.leetcode.com/topic/455/constant-space-solution/4). However, if we take advantage of bitwise operations, we may be able to manage all the `32` counters \"collectively\". By saying \"collectively\", we mean using `m` **32-bit** integers instead of `32` **m-bit** counters, where `m` is the minimum integer that satisfies `m >= logk`. The reason is that bitwise operations apply only to each bit so operations on different bits are independent of each other (kind obvious, right?). This allows us to group the corresponding bits of the `32` counters into one 32-bit integer. Here is a schematic diagram showing how this is done. \\n\\n![0_1510941016426_137. Single Number II .png](/assets/uploads/files/1510941017203-137.single-number-ii-resized.png) \\n\\nThe top row is the 32-bit integer, where for each bit, we have a corresponding m-bit counter (shown by the column below the upward arrow). Since bitwise operations on each of the `32` bits are independent of each other, we can group, say the `m-th` bit of all counters, into one 32-bit number (shown by the orange box). All bits in this 32-bit number (denoted as `xm`) will follow the same bitwise operations. Since each counter has `m` bits, we end up with `m` 32-bit numbers, which correspond to `x1, ..., xm` defined in part `II`, but now they are 32-bit integers instead of 1-bit numbers. Therefore, in the algorithm developed above, we just need to regard `x1` to `xm` as 32-bit integers instead of 1-bit numbers. Everything else will be the same and we are done. Easy, hum?\\n\\n---\\n`IV -- What to return`\\n\\nThe last thing is what value we should return, or equivalently which one of `x1` to `xm` will equal the single element. To get the correct answer, we need to understand what the `m` 32-bit integers `x1` to `xm` represent. Take `x1` as an example. `x1` has `32` bits and let\\'s label them as `r` (`r = 1` to `32`). After we are done scanning the input array, the value for the `r-th` bit of `x1` will be determined by the `r-th` bit of all the elements in the array (more specifically, suppose the total count of `1` for the `r-th` bit of all the elements in the array is `q`, `q\\' = q % k` and in its binary form: `q\\'m,...,q\\'1`, then by definition the `r-th` bit of `x1` will be equal to `q\\'1`). Now you can ask yourself this question: what does it imply if the `r-th` bit of `x1` is `1`?\\n\\nThe answer is to find what can contribute to this `1`. Will an element that appears `k` times contribute? No. Why? Because for an element to contribute, it has to satisfy at least two conditions at the same time: the `r-th` bit of this element is `1` and the number of appearance of this `1` is not an integer multiple of `k`. The first condition is trivial. The second comes from the fact that whenever the number of `1` hit is `k`, the counter will go back to zero, which means the corresponding bit in `x1` will be reset to `0`. For an element that appears `k` times, it\\'s impossible to meet these two conditions simultaneously so it won\\'t contribute. At last, only the single element which appears `p` (`p % k != 0`) times will contribute. If `p > k`, then the first `k * [p/k]` (`[p/k]`denotes the integer part of `p/k`) single elements won\\'t contribute either. So we can always set `p\\' = p % k` and say the single element appears effectively `p\\'` times.\\n\\nLet\\'s write `p\\'` in its binary form: `p\\'m, ..., p\\'1` (note that `p\\' < k`, so it will fit into `m` bits). Here I **claim the condition** for `xj` to equal the single element is `p\\'j = 1` (`j = 1` to `m`), with a quick proof given below.\\n\\nIf the `r-th` bit of `xj` is `1`, we can safely say the `r-th` bit of the single element is also `1` (otherwise nothing can make the `r-th` bit of `xj` to be `1`). We are left to prove that if the `r-th` bit of `xj` is `0`, then the `r-th` bit of the single element can only be `0`. Just suppose in this case the `r-th` bit of the single element is `1`, let\\'s see what will happen. At the end of the scan, this `1` will be counted `p\\'` times. By definition the `r-th` bit of `xj` will be equal to `p\\'j`, which is `1`. This contradicts with the presumption that the `r-th` bit of `xj` is `0`. Therefore we conclude the `r-th` bit of `xj` will always be the same as the `r-th` bit of the single number as long as `p\\'j = 1`. Since this is true for all bits in `xj` (i.e., true for `r = 1` to `32`), we conclude `xj` will equal the single element as long as `p\\'j = 1`. \\n\\nSo now it\\'s clear what we should return. Just express `p\\' = p % k` in its binary form and return any of the corresponding `xj` as long as `p\\'j = 1`. In total, the algorithm will run in `O(n * logk)` time and `O(logk)` space.\\n\\n---\\n**Side note**: There is a general formula relating each bit of `xj` to `p\\'j` and each bit of the single number `s`, which is given by `(xj)_r = s_r & p\\'j`, with `(xj)_r` and `s_r` denoting respectively the `r-th` bit of `xj` and the single number `s`. From this formula, it\\'s easy to see that `(xj)_r = s_r` if `p\\'j = 1`, that is, `xj = s` as long as `p\\'j = 1`, as shown above. Furthermore, we have `(xj)_r = 0` if `p\\'j = 0`, regardless of the value of the single number, that is, `xj = 0` as long as `p\\'j = 0`. So in summary we obtain: `xj = s` if `p\\'j = 1`, and `xj = 0` if `p\\'j = 0`. This implies the expression (`x1 | x2 | ... | xm`) will also be evaluated to the single number `s`, since the expression will essentially take the `OR` operations of the single number with itself and some `0`s, which boils down to the single number eventually.\\n\\n---\\n`V -- Quick examples`\\n\\nHere is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):\\n\\n1. `k = 2, p = 1`\\n`k` is `2`, then `m = 1`, we need only one 32-bit integer (`x1`) as the counter. And `2^m = k` so we do not even need a mask! A complete java program will look like:\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0;\\n         \\n        for (int i : nums) {\\n            x1 ^= i;\\n        }\\n         \\n        return x1;\\n    }\\n```\\n\\n2. `k = 3, p = 1`\\n`k` is `3`, then `m = 2`, we need two 32-bit integers(`x2`, `x1`) as the counter. And `2^m > k` so we do need a mask. Write `k` in its binary form: `k = \\'11\\'`, then `k1 = 1`, `k2 = 1`, so we have `mask = ~(x1 & x2)`. A complete java program will look like:\\n\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, mask = 0;\\n         \\n        for (int i : nums) {\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & x2);\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n\\n        return x1;  // Since p = 1, in binary form p = \\'01\\', then p1 = 1, so we should return x1. \\n                    // If p = 2, in binary form p = \\'10\\', then p2 = 1, and we should return x2.\\n                    // Or alternatively we can simply return (x1 | x2).\\n    }\\n```\\n\\n3. `k = 5, p = 3`\\n`k` is `5`, then `m = 3`, we need three 32-bit integers(`x3`, `x2`, `x1`) as the counter. And `2^m > k` so we need a mask. Write `k` in its binary form: `k = \\'101\\'`, then `k1 = 1`, `k2 = 0`, `k3 = 1`, so we have `mask = ~(x1 & ~x2 & x3)`. A complete java program will look like:\\n\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, x3  = 0, mask = 0;\\n   \\n        for (int i : nums) {\\n            x3 ^= x2 & x1 & i;\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & ~x2 & x3);\\n            x3 &= mask;\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n        \\n        return x1;  // Since p = 3, in binary form p = \\'011\\', then p1 = p2 = 1, so we can return either x1 or x2. \\n                    // If p = 4, in binary form p = \\'100\\', only p3 = 1, which implies we can only return x3.\\n                    // Or alternatively we can simply return (x1 | x2 | x3).\\n    }\\n```\\n\\nLastly I would like to thank those for providing feedbacks to make this post better. Hope it helps and happy coding!",
                "solutionTags": [],
                "code": "```\\nfor (int i : nums) {\\n    xm ^= (xm-1 & ... & x1 & i);\\n    xm-1 ^= (xm-2 & ... & x1 & i);\\n    .....\\n    x1 ^= i;\\n    \\n    mask = ~(y1 & y2 & ... & ym) where yj = xj if kj = 1, and yj = ~xj if kj = 0 (j = 1 to m).\\n\\n    xm &= mask;\\n    ......\\n    x1 &= mask;\\n}\\n```\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0;\\n         \\n        for (int i : nums) {\\n            x1 ^= i;\\n        }\\n         \\n        return x1;\\n    }\\n```\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, mask = 0;\\n         \\n        for (int i : nums) {\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & x2);\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n\\n        return x1;  // Since p = 1, in binary form p = \\'01\\', then p1 = 1, so we should return x1. \\n                    // If p = 2, in binary form p = \\'10\\', then p2 = 1, and we should return x2.\\n                    // Or alternatively we can simply return (x1 | x2).\\n    }\\n```\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, x3  = 0, mask = 0;\\n   \\n        for (int i : nums) {\\n            x3 ^= x2 & x1 & i;\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & ~x2 & x3);\\n            x3 &= mask;\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n        \\n        return x1;  // Since p = 3, in binary form p = \\'011\\', then p1 = p2 = 1, so we can return either x1 or x2. \\n                    // If p = 4, in binary form p = \\'100\\', only p3 = 1, which implies we can only return x3.\\n                    // Or alternatively we can simply return (x1 | x2 | x3).\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43294,
                "title": "challenge-me-thx",
                "content": "    public int singleNumber(int[] A) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < A.length; i++){\\n            ones = (ones ^ A[i]) & ~twos;\\n            twos = (twos ^ A[i]) & ~ones;\\n        }\\n        return ones;\\n    }",
                "solutionTags": [],
                "code": "    public int singleNumber(int[] A) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < A.length; i++){\\n            ones = (ones ^ A[i]) & ~twos;\\n            twos = (twos ^ A[i]) & ~ones;\\n        }\\n        return ones;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43297,
                "title": "java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance",
                "content": "The usual bit manipulation code is bit hard to get and replicate.  I like to think about the number in 32 bits and just count how many 1s are there in each bit, and `sum %= 3` will clear it once it reaches 3.  After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing `ans |= sum << i;`  \\n\\nThis has complexity of O(32n), which is essentially O(n) and very easy to think and implement.  Plus, you get a general solution for any times of occurrence.  Say all the numbers have 5 times, just do `sum %= 5`.\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(((nums[j] >> i) & 1) == 1) {\\n                    sum++;\\n                    sum %= 3;\\n                }\\n            }\\n            if(sum != 0) {\\n                ans |= sum << i;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The usual bit manipulation code is bit hard to get and replicate.  I like to think about the number in 32 bits and just count how many 1s are there in each bit, and `sum %= 3` will clear it once it reaches 3.  After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing `ans |= sum << i;`  \\n\\nThis has complexity of O(32n), which is essentially O(n) and very easy to think and implement.  Plus, you get a general solution for any times of occurrence.  Say all the numbers have 5 times, just do `sum %= 5`.\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(((nums[j] >> i) & 1) == 1) {\\n                    sum++;\\n                    sum %= 3;\\n                }\\n            }\\n            if(sum != 0) {\\n                ans |= sum << i;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43296,
                "title": "an-general-way-to-handle-all-this-sort-of-questions",
                "content": "this kind of question the key idea is design a counter that record state. the problem can be every one occurs K times except one occurs M times. for this question, K =3 ,M = 1(or 2) .\\nso to represent 3 state, we need two bit. let say it is a and b, and c is the incoming bit.\\nthen we can design a table to implement the state move.\\n\\n    current   incoming  next\\n    a b            c    a b\\n    0 0            0    0 0\\n    0 1            0    0 1\\n    1 0            0    1 0\\n    0 0            1    0 1\\n    0 1            1    1 0\\n    1 0            1    0 0\\n\\nlike circuit design, we can find out what the next state will be with the incoming bit.( we only need find the ones)\\nthen we have for a to be 1, we have \\n\\n        current   incoming  next\\n        a b            c    a b\\n        1 0            0    1 0\\n        0 1            1    1 0\\n and this is can be represented by \\n\\n    a=a&~b&~c + ~a&b&c\\n\\nand b can do the same  we , and we find that \\n\\n    b= ~a&b&~c+~a&~b&c\\nand this is the final formula of a and b and just one of the result set, because for different state move table definition, we can generate different formulas, and this one is may not the most optimised. as you may see other's answer that have a much simple formula, and that formula also corresponding to specific state move table. (if you like ,you can reverse their formula to a state move table, just using the same way but reversely) \\n\\nfor this questions we need to find the except one \\nas the question don't say if the one appears one time or two time ,\\nso for ab both \\n\\n    01 10 => 1\\n    00 => 0\\nwe should return a|b;\\nthis is the key idea , we can design any based counter and find the occurs any times except one .\\nhere is my code. with comment.\\n\\n    public class Solution {\\n        \\n        public int singleNumber(int[] nums) {\\n            //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero.\\n            //#curent  income  ouput\\n            //# ab      c/c       ab/ab\\n            //# 00      1/0       01/00\\n            //# 01      1/0       10/01\\n            //# 10      1/0       00/10\\n            // a=~abc+a~b~c;\\n            // b=~a~bc+~ab~c;\\n            int a=0;\\n            int b=0;\\n            for(int c:nums){\\n                int ta=(~a&b&c)|(a&~b&~c);\\n                b=(~a&~b&c)|(~a&b&~c);\\n                a=ta;\\n            }\\n            //we need find the number that is 01,10 => 1, 00 => 0.\\n            return a|b;\\n            \\n        }\\n    }\\nthis is a general solution . and it comes from the Circuit Design on course digital logic.",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public int singleNumber(int[] nums) {\\n            //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero.\\n            //#curent  income  ouput\\n            //# ab      c/c       ab/ab\\n            //# 00      1/0       01/00\\n            //# 01      1/0       10/01\\n            //# 10      1/0       00/10\\n            // a=~abc+a~b~c;\\n            // b=~a~bc+~ab~c;\\n            int a=0;\\n            int b=0;\\n            for(int c:nums){\\n                int ta=(~a&b&c)|(a&~b&~c);\\n                b=(~a&~b&c)|(~a&b&~c);\\n                a=ta;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3714928,
                "title": "bit-manipulation-c-java-python-beginner-friendly",
                "content": "# Approach 1: Brute Force\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        \\n        for(auto x: nums){\\n            m[x]++;\\n        }\\n\\n        for(auto x: m){\\n            if(x.second == 1){\\n                return x.first;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : nums) {\\n            map.put(x, map.getOrDefault(x, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() == 1) {\\n                return entry.getKey();\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        count = defaultdict(int)\\n        \\n        for x in nums:\\n            count[x] += 1\\n\\n        for x, freq in count.items():\\n            if freq == 1:\\n                return x\\n        \\n        return -1\\n```\\n\\n# Approach 2: Bit Manipulation\\n# Explanation:\\n\\n1. Initialize the variable `ans` to 0. This variable will store the resulting single number.\\n\\n2. Iterate from `i = 0` to `i = 31`. This loop considers each bit position from the least significant bit (LSB) to the most significant bit (MSB) of a 32-bit integer.\\n\\n3. Inside the loop, initialize a variable `sum` to 0. This variable will keep track of the number of 1s at the current bit position (`i`) for all the numbers in the input array.\\n\\n4. Iterate through each number `num` in the input array:\\n   - Right-shift `num` by `i` positions: `num >> i`. This operation moves the bit at position `i` to the least significant bit position.\\n   - Perform a bitwise AND with 1: `(num >> i) & 1`. This extracts the value of the bit at position `i` from `num`. If it is 1, the result will be 1; otherwise, it will be 0.\\n   - Add the result of `(num >> i) & 1` to `sum`. This counts the number of 1s at bit position `i` for all the numbers in the array.\\n\\n5. Take the modulo of `sum` by 3: `sum %= 3`. This step is performed to handle the numbers that appear three times. If `sum` is divisible by 3, it means the bit at position `i` has a balanced number of 1s. Otherwise, it is an unbalanced line.\\n\\n6. Left-shift the value of `sum` by `i` positions: `sum << i`. This step creates a bitmask `pos` where only the bit at position `i` is set to the value of `sum`. This bitmask identifies the position of the unbalanced line.\\n\\n7. Use the bitwise OR operation with `ans` and `pos`: `ans |= pos`. This sets the corresponding bit in `ans` to 1 if the bit at position `i` is part of an unbalanced line.\\n\\n8. After the loop completes, the value stored in `ans` represents the single number that appears only once in the array.\\n\\nThe logical thinking behind this approach is to count the number of 1s at each bit position for all the numbers. Since each number appears three times except for the single number, the sum of 1s at each bit position should be divisible by 3 for a balanced line. Any number of 1s that is not divisible by 3 indicates an unbalanced line, which means the single number contributes to that particular bit position.\\n\\nBy masking the positions of the unbalanced lines with 1s in `ans`, we effectively isolate the bits that are part of the single number. Finally, the resulting value in `ans` represents the binary representation of the single number.\\n\\nUsing the provided example: [1, 1, 1, 2, 2, 2, 5]\\n- At the LSB (i = 0), the sum of the number of 1s is 3 (balanced line).\\n- At the second bit (i = 1), the sum of the number of 1s is 4 (unbalanced line, not divisible by 3).\\n- At the third bit (i = 2), the sum of the number of 1s is 2 (unbalanced line, not divisible by 3).\\n- At the fourth bit\\n\\n (i = 3), the sum of the number of 1s is 1 (balanced line).\\n\\nThus, the resulting binary representation is \\'0101\\', which corresponds to the decimal value 5, and that is the single number we are searching for.\\n\\nThis approach effectively identifies the unbalanced lines and constructs the single number by setting the corresponding bit positions in `ans`.\\n\\n# Code\\n```C++ []\\nclass Solution {\\n public:\\n  int singleNumber(vector<int>& nums) {\\n    int ans = 0;\\n\\n    for (int i = 0; i < 32; ++i) {\\n      int sum = 0;\\n      for (const int num : nums)\\n        sum += num >> i & 1;\\n      sum %= 3;\\n      ans |= sum << i;\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int singleNumber(int[] nums) {\\n    int ans = 0;\\n\\n    for (int i = 0; i < 32; ++i) {\\n      int sum = 0;\\n      for (final int num : nums)\\n        sum += num >> i & 1;\\n      sum %= 3;\\n      ans |= sum << i;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        ans = 0\\n\\n        for i in range(32):\\n            bit_sum = 0\\n            for num in nums:\\n                # Convert the number to two\\'s complement representation to handle large test case\\n                if num < 0:\\n                    num = num & (2**32-1)\\n                bit_sum += (num >> i) & 1\\n            bit_sum %= 3\\n            ans |= bit_sum << i\\n\\n        # Convert the result back to two\\'s complement representation if it\\'s negative to handle large test case\\n        if ans >= 2**31:\\n            ans -= 2**32\\n\\n        return ans\\n\\n```\\n\\n# Approach 3: Magic:\\n# Explanation:\\n\\n1. Initialize two variables, `ones` and `twos`, to keep track of the count of each bit position.\\n   - `ones`: Tracks the bits that have appeared once.\\n   - `twos`: Tracks the bits that have appeared twice.\\n\\n2. Iterate through the array of numbers.\\n   - For each number `i` in the array:\\n     - Update `ones` and `twos`:\\n\\n     - Let\\'s analyze each step of the update process:\\n\\n       a. `ones = (ones ^ i) & (~twos);`:\\n          - `ones ^ i` XORs the current number `i` with the previous value of `ones`. This operation toggles the bits that have appeared an odd number of times, keeping the bits that have appeared twice unchanged.\\n          - `(~twos)` negates the bits in `twos`, effectively removing the bits that have appeared twice from consideration.\\n          - The `&` operation ensures that only the bits that have appeared once (after XOR) and not twice (after negating `twos`) are retained.\\n\\n       b. `twos = (twos ^ i) & (~ones);`:\\n          - `twos ^ i` XORs the current number `i` with the previous value of `twos`. This operation toggles the bits that have appeared an even number of times, effectively removing the bits that have appeared twice.\\n          - `(~ones)` negates the bits in `ones`, effectively removing the bits that have appeared once from consideration.\\n          - The `&` operation ensures that only the bits that have appeared twice (after XOR) and not once (after negating `ones`) are retained.\\n\\n3. After iterating through all the numbers, the value stored in `ones` will represent the single number that appears only once in the array.\\n\\nLet\\'s understand why this approach works:\\n\\n- The key idea is to use bitwise operations to keep track of the count of each bit position. By doing so, we can identify the bits that have appeared once, twice, or three times.\\n- When a bit appears for the first time (`ones` is 0 and the bit is toggled), it is stored in `ones`.\\n- When a bit appears for the second time (`ones` is 1 and the bit is toggled), it is removed from `ones` and stored in `twos`.\\n- When a bit appears for the third time (`ones` is 0 and the bit is toggled), it is removed from both `ones` and `twos`.\\n- By the end of the iteration, the bits that remain in `ones` represent the bits of the single number that appeared only once, while the bits in `twos` represent bits that appeared three times (which is not possible).\\n\\nIn summary, the algorithm uses bit manipulation to efficiently keep track of the counts of each bit position. By utilizing XOR and AND operations, it can identify the bits of the single number that appears only once in the array while ignoring the bits that appear multiple times.\\n\\n# Code\\n```C++ []\\nclass Solution {\\n public:\\n  int singleNumber(vector<int>& nums) {\\n    int ones = 0;\\n    int twos = 0;\\n\\n    for (const int num : nums) {\\n      ones ^= (num & ~twos);\\n      twos ^= (num & ~ones);\\n    }\\n\\n    return ones;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int singleNumber(int[] nums) {\\n    int ones = 0;\\n    int twos = 0;\\n\\n    for (final int num : nums) {\\n      ones ^= (num & ~twos);\\n      twos ^= (num & ~ones);\\n    }\\n\\n    return ones;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    ones = 0\\n    twos = 0\\n\\n    for num in nums:\\n      ones ^= (num & ~twos)\\n      twos ^= (num & ~ones)\\n\\n    return ones\\n\\n```\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/90c52bfd-4b4f-4920-b559-cce87389f517_1688432286.2663784.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        \\n        for(auto x: nums){\\n            m[x]++;\\n        }\\n\\n        for(auto x: m){\\n            if(x.second == 1){\\n                return x.first;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : nums) {\\n            map.put(x, map.getOrDefault(x, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() == 1) {\\n                return entry.getKey();\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        count = defaultdict(int)\\n        \\n        for x in nums:\\n            count[x] += 1\\n\\n        for x, freq in count.items():\\n            if freq == 1:\\n                return x\\n        \\n        return -1\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int singleNumber(vector<int>& nums) {\\n    int ans = 0;\\n\\n    for (int i = 0; i < 32; ++i) {\\n      int sum = 0;\\n      for (const int num : nums)\\n        sum += num >> i & 1;\\n      sum %= 3;\\n      ans |= sum << i;\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int singleNumber(int[] nums) {\\n    int ans = 0;\\n\\n    for (int i = 0; i < 32; ++i) {\\n      int sum = 0;\\n      for (final int num : nums)\\n        sum += num >> i & 1;\\n      sum %= 3;\\n      ans |= sum << i;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        ans = 0\\n\\n        for i in range(32):\\n            bit_sum = 0\\n            for num in nums:\\n                # Convert the number to two\\'s complement representation to handle large test case\\n                if num < 0:\\n                    num = num & (2**32-1)\\n                bit_sum += (num >> i) & 1\\n            bit_sum %= 3\\n            ans |= bit_sum << i\\n\\n        # Convert the result back to two\\'s complement representation if it\\'s negative to handle large test case\\n        if ans >= 2**31:\\n            ans -= 2**32\\n\\n        return ans\\n\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int singleNumber(vector<int>& nums) {\\n    int ones = 0;\\n    int twos = 0;\\n\\n    for (const int num : nums) {\\n      ones ^= (num & ~twos);\\n      twos ^= (num & ~ones);\\n    }\\n\\n    return ones;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int singleNumber(int[] nums) {\\n    int ones = 0;\\n    int twos = 0;\\n\\n    for (final int num : nums) {\\n      ones ^= (num & ~twos);\\n      twos ^= (num & ~ones);\\n    }\\n\\n    return ones;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    ones = 0\\n    twos = 0\\n\\n    for num in nums:\\n      ones ^= (num & ~twos)\\n      twos ^= (num & ~ones)\\n\\n    return ones\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43313,
                "title": "a-general-c-solution-for-these-type-problems",
                "content": "There are so many brilliant solutions for this problem used \"| & ^ ~\", and I have learned a lot from these solutions. Here is a general solution for who not familiar with \"| & ^ ~\".\\n\\nQ: Most elements appeared k times, except one. Find this \"one\".\\n\\n  \\n\\n       int singleNumber(vector<int>& s) \\n        {\\n        \\tvector<int> t(32);////Made a array contain 32 elements.\\n        \\tint sz = s.size();\\n        \\tint i, j, n;\\n        \\tfor (i = 0; i < sz; ++i)\\n        \\t{\\n        \\t\\tn = s[i];\\n        \\t\\tfor (j = 31; j >= 0; --j)\\n        \\t\\t{\\n        \\t\\t\\tt[j] += n & 1;//Find the last digit.\\n        \\t\\t\\tn >>= 1;\\n        \\t\\t\\tif (!n)\\n        \\t\\t\\t\\tbreak;\\n        \\t    }\\n            }\\n    \\tint res = 0;\\n    \\tfor (j = 31; j >= 0; --j)\\n    \\t{\\n    \\t\\tn = t[j] % 3;//\"3\" represents k times. \\n    \\t\\tif (n)\\n    \\t\\t\\tres += 1 << (31 - j);\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "There are so many brilliant solutions for this problem used \"| & ^ ~\", and I have learned a lot from these solutions. Here is a general solution for who not familiar with \"| & ^ ~\".\\n\\nQ: Most elements appeared k times, except one. Find this \"one\".\\n\\n  \\n\\n       int singleNumber(vector<int>& s) \\n        {\\n        \\tvector<int> t(32);////Made a array contain 32 elements.\\n        \\tint sz = s.size();\\n        \\tint i, j, n;\\n        \\tfor (i = 0; i < sz; ++i)\\n        \\t{\\n        \\t\\tn = s[i];\\n        \\t\\tfor (j = 31; j >= 0; --j)\\n        \\t\\t{\\n        \\t\\t\\tt[j] += n & 1;//Find the last digit.\\n        \\t\\t\\tn >>= 1;\\n        \\t\\t\\tif (!n)\\n        \\t\\t\\t\\tbreak;\\n        \\t    }\\n            }\\n    \\tint res = 0;\\n    \\tfor (j = 31; j >= 0; --j)\\n    \\t{\\n    \\t\\tn = t[j] % 3;//\"3\" represents k times. \\n    \\t\\tif (n)\\n    \\t\\t\\tres += 1 << (31 - j);\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43302,
                "title": "accepted-code-with-proper-explaination-does-anyone-have-a-better-idea",
                "content": "   \\n The code makes use of 2 variables. \\n\\nones - At any point of time, this variable holds XOR of all the elements which have \\nappeared \"only\" once. \\ntwos - At any point of time, this variable holds XOR of all the elements which have \\nappeared \"only\" twice. \\n\\nSo if at any point time, \\n\\n1. A new number appears - It gets XOR'd to the variable \"ones\". \\n2. A number gets repeated(appears twice) - It is removed from \"ones\" and XOR'd to the \\nvariable \"twos\". \\n3. A number appears for the third time - It gets removed from both \"ones\" and \"twos\". \\n\\nThe final answer we want is the value present in \"ones\" - coz, it holds the unique element. \\n\\nSo if we explain how steps 1 to 3 happens in the code, we are done. \\nBefore explaining above 3 steps, lets look at last three lines of the code, \\n\\ncommon_bit_mask = ~(ones & twos) \\n\\nones & = common_bit_mask\\n\\ntwos & = common_bit_mask \\n\\nAll it does is, common 1's between \"ones\" and \"twos\" are converted to zero. \\n\\nFor simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique element and 3 repeated elements - in any order). \\n\\nExplanation for step 1 \\n------------------------ \\nLets say a new element(x) appears. \\n\\nCURRENT SITUATION - Both variables - \"ones\" and \"twos\" has not recorded \"x\". \\n\\nObserve the statement \"twos| = ones & x\". \\nSince bit representation of \"x\" is not present in \"ones\", AND condition yields nothing. So \"twos\" does not get bit representation of \"x\". \\nBut, in next step \"ones ^= x\" - \"ones\" ends up adding bits of \"x\". Thus new element gets recorded in \"ones\" but not in \"twos\". \\n\\nThe last 3 lines of code as explained already, converts common 1's b/w \"ones\" and \"twos\" to zeros. \\nSince as of now, only \"ones\" has \"x\" and not \"twos\" - last 3 lines does nothing. \\n\\nExplanation for step 2. \\n------------------------ \\nLets say an element(x) appears twice. \\n\\nCURRENT SITUATION - \"ones\" has recorded \"x\" but not \"twos\". \\n\\nNow due to the statement, \"twos| = ones & x\" - \"twos\" ends up getting bits of x. \\nBut due to the statement, \"ones ^ = x\" - \"ones\" removes \"x\" from its binary representation. \\n\\nAgain, last 3 lines of code does nothing. \\nSo ultimately, \"twos\" ends up getting bits of \"x\" and \"ones\" ends up losing bits of \"x\". \\n\\nExplanation for step 3. \\n------------------------- \\nLets say an element(x) appears for the third time. \\n\\nCURRENT SITUATION - \"ones\" does not have bit representation of \"x\" but \"twos\" has. \\n\\nThough \"ones & x\" does not yield nothing .. \"twos\" by itself has bit representation of \"x\". So after this statement, \"two\" has bit representation of \"x\". \\nDue to \"ones^=x\", after this step, \"one\" also ends up getting bit representation of \"x\". \\n\\nNow last 3 lines of code removes common 1's of \"ones\" and \"twos\" - which is the bit representation of \"x\".\\nThus both \"ones\" and \"twos\" ends up losing bit representation of \"x\".\\n\\n\\n\\n\\n\\n\\n\\n\\n     class Solution {\\n        public:\\n        // Let us take the example of {3, 3, 2, 3} to understand this\\n            int singleNumber(int A[], int n) {\\n                int ones=0, twos =0;\\n                int common_bit_mask;\\n                for(int i=0; i<n;i++)\\n                {\\n                     /* The expression \"one & arr[i]\" gives the bits that are\\n                   there in both 'ones' and new element from arr[].  We\\n                   add these bits to 'twos' using bitwise OR\\n         \\n                   Value of 'twos' will be set as 0, 3, 3 and 1 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                   \\n                    twos= twos|(ones&A[i]);\\n                    /* XOR the new bits with previous 'ones' to get all bits\\n                   appearing odd number of times\\n         \\n                   Value of 'ones' will be set as 3, 0, 2 and 3 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                    ones=ones^A[i];\\n                     /* The common bits are those bits which appear third time\\n                   So these bits should not be there in both 'ones' and 'twos'.\\n                   common_bit_mask contains all these bits as 0, so that the bits can \\n                   be removed from 'ones' and 'twos'   \\n         \\n                   Value of 'common_bit_mask' will be set as 00, 00, 01 and 10\\n                   after 1st, 2nd, 3rd and 4th iterations respectively */\\n                    common_bit_mask= ~(ones&twos);\\n                    /* Remove common bits (the bits that appear third time) from 'ones'\\n                     \\n                   Value of 'ones' will be set as 3, 0, 0 and 2 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                    ones &=common_bit_mask;\\n                    /* Remove common bits (the bits that appear third time) from 'twos'\\n         \\n                   Value of 'twos' will be set as 0, 3, 1 and 0 after 1st,\\n                   2nd, 3rd and 4th itearations respectively */\\n                    twos &=common_bit_mask;\\n                }\\n                return ones;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        // Let us take the example of {3, 3, 2, 3}",
                "codeTag": "Java"
            },
            {
                "id": 43332,
                "title": "my-own-explanation-of-bit-manipulation-method-might-be-easier-to-understand",
                "content": "Consider the following fact:\\n\\nWrite all numbers in binary form, then for any bit 1 that appeared 3*n times (n is an integer), the bit can only present in numbers that appeared 3 times\\n\\ne.g. 0010 0010 0010 1011 1011 1011 1000 (assuming 4-bit integers)\\n2(0010) and 11(1011) appeared 3 times, and digit counts are:\\n\\n> **Digits**             3 2 1 0 \\n> \\n> **Counts**           4 0 6 3\\n> \\n> **Counts%3**     1 0 0 0\\n\\nCounts on 2,1,0 are all times of 3, the only digit index that has Counts % 3 != 0 is 3\\n\\nTherefore, to find the number that appeared only 1 or 2 times, we only need to extract all bits that has Counts %3 != 0\\n\\nNow consider how we could do this by bit manipulation\\n\\nsince counts % 3 has only 3 states: 0(00),1(01),2(10)\\nwe could use a TWO BIT COUNTER (Two, One) to represent Counts % 3, now we could do a little research on state transitions, for each bit, let B be the input bit, we can enumerate the all possible state transitions, Two+, One+ is the new state of Two, One. (here we need to use some knowledge in Digital Logic Design)\\n\\n-----------------------\\n\\n> Two One B Two+ One+\\n>\\n> 0    0  0    0   0\\n> \\n> 0    0  1    0   1\\n> \\n> 0    1  0    0   1\\n> \\n> 0    1  1    1   0\\n> \\n> 1    0  0    1   0\\n> \\n> 1    0  1    0   0\\n> \\n> 1    1  0    X   X (X represents we don't care)\\n> \\n> 1    1  1    X   X\\n\\n\\nWe could then draw the **Karnaugh map** to analyze the logic (https://en.wikipedia.org/wiki/Karnaugh_map), and then we get:\\n\\n> One+ = (One ^ B) & (~Two)\\n> \\n> Two+ = (~One+) & (Two ^ B)\\n\\nNow for int_32, we need only 2 int_32 two represent Two and One for each bit and update Two and One using the rules derived above\\n\\nCode is here (C++):\\n\\n    class Solution {\\n      public:\\n        int singleNumber(vector<int>& nums) {\\n            int counterOne = 0;\\n            int counterTwo = 0;\\n            \\n            for (int i = 0; i < nums.size(); i++){\\n                counterOne = (~counterTwo) & (counterOne ^ nums[i]);\\n                counterTwo = (~counterOne) & (counterTwo ^ nums[i]);\\n            }\\n            return counterOne;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n      public:\\n        int singleNumber(vector<int>& nums) {\\n            int counterOne = 0;\\n            int counterTwo = 0;\\n            \\n            for (int i = 0; i < nums.size(); i++){\\n                counterOne = (~counterTwo) & (counterOne ^ nums[i]);\\n                counterTwo = (~counterOne) & (counterTwo ^ nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 700046,
                "title": "single-number-ii-easy-to-understand-language-c",
                "content": "#### Basic Idea\\nWe are given an array where every integer, except one, occurs thrice. Therefore, at every bit position, there is an odd bit while all other bits occur as multiples of 3.\\nThe following example will make this clearer.\\n\\nTake the input array  : [2, 2, 2, 4, 4, 4, 5]\\n\\nA  B C\\n0  1  0  ~  2\\n0  1  0\\n0  1  0\\n1  0  0  ~  4\\n1  0  0\\n1  0  0\\n1  0  1 ~  5\\n\\nAt bit position A : 3 occurences of \\'0\\' + 3 occurences of \\'1\\' + **1 occurence of \\'1\\'**\\nAt bit position B : 3 occurences of \\'1\\' + 3 occurences of \\'0\\' + **1 occurence of \\'0\\'**\\nAt bit position C : 6 occurences of \\'0\\' + **1 occurence of  \\'1\\'**\\n\\nTherefore, at each bit position, we have bits that occur in multiples of 3, and one lone bit.\\nSo, if we add up the bits at a given position as *sum*, and find the remainder when *sum* is divided by 3, we get the left over bit.\\n\\nFor the bits at A, *sum*  = 4 :  4 % 3 = 1\\nFor the bits at B, *sum*  = 3 :  3 % 3 = 0\\nFor the bits at C, *sum*  = 1 :  1 % 3 = 1\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        long ans;\\n        int x, t;\\n        ans=0;\\n        int p=0;\\n\\t\\t// We have 32 bits integers as input\\n        for(int i=0;i<32;i++)\\n        {\\n            t=0;\\n            //calculate sum of ith bit for all numbers in nums\\n            for(int j=0;j<n;j++)\\n            {\\n                x=nums[j]&1;\\n                t=t+x;\\n                nums[j]=nums[j]>>1;\\n            }\\n            t=t%3;\\n            //the bit that does not occur as multiple of 3 is left as a remainder \\n            ans=ans+t*pow(2,p);\\n            p++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n\\nAs the loop runs *32 * n*  times, Time Complexity = **O(N)**\\nSpace Complexity = **O(1)**\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        long ans;\\n        int x, t;\\n        ans=0;\\n        int p=0;\\n\\t\\t// We have 32 bits integers as input\\n        for(int i=0;i<32;i++)\\n        {\\n            t=0;\\n            //calculate sum of ith bit for all numbers in nums\\n            for(int j=0;j<n;j++)\\n            {\\n                x=nums[j]&1;\\n                t=t+x;\\n                nums[j]=nums[j]>>1;\\n            }\\n            t=t%3;\\n            //the bit that does not occur as multiple of 3 is left as a remainder \\n            ans=ans+t*pow(2,p);\\n            p++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715277,
                "title": "image-explanation-bit-manipulation-4-methods-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Single Number II` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/e8d593d2-241b-423b-af85-be3ef44fcb78_1688448136.2994149.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/43232616-e389-42ef-8ffe-d43048c68a76_1688442335.1273727.png)\\n![image.png](https://assets.leetcode.com/users/images/5f8e1275-7576-42f6-a3b7-854874b55be2_1688442361.026164.png)\\n![image.png](https://assets.leetcode.com/users/images/6c33c703-0276-48ec-90c2-0e0ef2a02e57_1688442369.934677.png)\\n![image.png](https://assets.leetcode.com/users/images/a4f250dc-1824-4b98-8bd1-8ed69398799e_1688442376.3737812.png)\\n![image.png](https://assets.leetcode.com/users/images/490efbe2-4a17-4b7a-8eef-eda96d74b24d_1688442384.6384706.png)\\n![image.png](https://assets.leetcode.com/users/images/b70e25fb-69d2-4aa2-b1a0-23a58add6f6b_1688442391.8456519.png)\\n![image.png](https://assets.leetcode.com/users/images/fefb3d96-efdc-452d-a268-bafcf2244d86_1688442404.268496.png)\\n![image.png](https://assets.leetcode.com/users/images/22c1cf77-04b7-4b9d-8a85-94c3ad1a4c8b_1688442412.753717.png)\\n![image.png](https://assets.leetcode.com/users/images/6e7d81b3-ed29-42c5-8e0b-7c94251a88c0_1688442419.0192356.png)\\n![image.png](https://assets.leetcode.com/users/images/ca71c58d-b49d-45b9-a332-e2ea25cf82e6_1688442425.601613.png)\\n![image.png](https://assets.leetcode.com/users/images/a01bf25e-c4d0-43b3-a367-3a5e4b31cf93_1688442434.164556.png)\\n![image.png](https://assets.leetcode.com/users/images/ad3ae7eb-daae-45c4-ac36-831df99b64f0_1688442441.8660142.png)\\n![image.png](https://assets.leetcode.com/users/images/767a899f-2d7c-453d-887e-c362770298fd_1688442448.4866774.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        return ones\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        return ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699889,
                "title": "python-bit-manipulation-o-32n-but-easy-exaplained",
                "content": "There are several `\\'magical\\'` solutions for this problem I saw in comments, done in `O(n)`, which I really enjoed to read, however I doubt if you never saw this problem you can suceed in real interview. That is why I suggest maybe not the fastest, but much more easier to come up solution. The idea is similar to problem **Single Number**, but here we need to count each bit modulo `3`. So, we\\n1. Iterate over all possible `32` bits and for each `num` check if this `num` has non-zero bit on position `i` with `num & (1<<i) == (1<<i)` formula.\\n2. We evaluate this sum modulo `3`. Note, that in the end for each bit we can have either `0` or `1` and never `2`.\\n3. Next, update our answer `single` with evaluated bit.\\n4. Finally, we need to deal with overflow cases in python: maximum value for `int32` is `2^31 - 1`, so if we get number more than this value we have negative answer in fact.\\n\\n**Complexity**: time complexity is `O(32n)`, which may be not fully honest linear, but is fine for the purpose of this problem. If we want just `O(n)` complexity, I think problem becomes not medium but hard. Space complexity here is `O(1)`.\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums):\\n        single = 0\\n        for i in range(32):\\n            count = 0\\n            for num in nums:\\n                if num & (1<<i) == (1<<i): count += 1\\n            single |= (count%3) << i\\n            \\n        return single if single < (1<<31) else single - (1<<32)   \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums):\\n        single = 0\\n        for i in range(32):\\n            count = 0\\n            for num in nums:\\n                if num & (1<<i) == (1<<i): count += 1\\n            single |= (count%3) << i\\n            \\n        return single if single < (1<<31) else single - (1<<32)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 43403,
                "title": "java-bit-manipulation-solution",
                "content": "    public int singleNumber(int[] nums) {\\n      int ones = 0, twos = 0, threes = 0;\\n            \\n      for (int i = 0; i < nums.length; i++) {\\n        // twos holds the num that appears twice\\n        twos |= ones & nums[i];\\n        \\n        // ones holds the num that appears once\\n        ones ^= nums[i];\\n     \\n        // threes holds the num that appears three times\\n        threes = ones & twos;\\n                \\n        // if num[i] appears three times\\n        // doing this will clear ones and twos\\n        ones &= ~threes;\\n        twos &= ~threes;\\n      }\\n            \\n      return ones;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n      int ones = 0, twos = 0, threes = 0;\\n            \\n      for (int i = 0; i < nums.length; i++) {\\n        // twos holds the num that appears twice\\n        twos |= ones & nums[i];\\n        \\n        // ones holds the num that appears once\\n        ones ^= nums[i];\\n     \\n        // threes holds the num that appears three times\\n        threes = ones & twos;\\n                \\n        // if num[i] appears three times\\n        // doing this will clear ones and twos\\n        ones &= ~threes;\\n        twos &= ~threes;\\n      }\\n            \\n      return ones;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43360,
                "title": "the-simplest-solution-ever-with-clear-explanation",
                "content": "The key to solve this problem is the count of 1s of each bit of all numbers.\\n\\nTake one bit number for example: nums = [1, 1, 1, 0, 0, 0, ..., x] . All numbers are 0 or 1.\\n\\nWe know that every number appears three times except for just one number. So, if the count of 1s in nums is 0, 3, 6, ..., 3 * n, then the single number is 0. And if the count of 1s in nums is 1, 4, 7, ..., 3*n+1, then the single number is 1.\\n\\nSo, for an array \" nums \" that contains only 0 or 1, the code to find the single number are:\\n\\n    count = 0\\n    for num in nums:\\n        count = (count + num) % 3\\n    return count\\n\\nTo make \"count\" less than 3, mod \"count\" with 3 in every loop.\\n\\nBelow is the procedure for finding the single number in [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]:\\n\\n    Table 1:\\n    ++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++\\n    || num   ||   | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0  ||\\n    ++-------++---+---+---+---+---+---+---+---+---+---+---+---+---+----++\\n    || count || 0 | 1 | 1 | 2 | 0 | 0 | 1 | 1 | 2 | 2 | 0 | 0 | 1 | 1* ||\\n    ++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++\\n\\nSo the single number is 1.\\n\\nWe can write the calculate table for expression \"count' = (count + num) % 3\":\\n\\n    Table 2:\\n    ++=======+=====+========++\\n    || count | num | count' ||\\n    ++-------+-----+--------++\\n    ||   0   |  0  |   0    ||\\n    ++-------+-----+--------++\\n    ||   1   |  0  |   1    ||\\n    ++-------+-----+--------++\\n    ||   2   |  0  |   2    ||\\n    ++-------+-----+--------++\\n    ||   0   |  1  |   1    ||\\n    ++-------+-----+--------++\\n    ||   1   |  1  |   2    ||\\n    ++-------+-----+--------++\\n    ||   2   |  1  |   0    ||\\n    ++-------+-----+--------++\\n\\nTo extend this algorithm to 32bits number. We need to rewrite these code to bit operation expressions. \\n\\nAnd the key is rewriting the expression \" count' = (count + num) % 3 \" to bit operation expressions.\\n\\nWrite binary numbers of \" count \" and \" count' \" in \"Table 2\". And split their bits into two column:\\n\\n    Table 3:\\n    ++=======+============+=====+============+========++\\n    ||       |    count   | num |   count'   |        ||\\n    || count |    (bin)   |     |   (bin)    | count' ||\\n    || (dec) ++=====+=====+=====+=====+=====++ (dec)  ||\\n    ||       || b1  | b0  | num | b1' | b0' ||        ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   0   ||  0  |  0  |  0  |  0  |  0  ||   0    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   1   ||  0  |  1  |  0  |  0  |  1  ||   1    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   2   ||  1  |  0  |  0  |  1  |  0  ||   2    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   0   ||  0  |  0  |  1  |  0  |  1  ||   1    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   1   ||  0  |  1  |  1  |  1  |  0  ||   2    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   2   ||  1  |  0  |  1  |  0  |  0  ||   0    ||\\n    ++=======++===========+=====+===========++========++\\n\\nHere comes the hardest part of this solution. \\n\\n\"Table 3\" is a truth table, we need to use it to find the formulas to calculate \" b0' \" and \" b1' \":\\n    \\n    b0' = f(b1, b0, num)\\n    b1' = g(b1, b0, num)\\n\\nWith observations, guesses, experiments and even some luck. Finally I got two simple and elegant formulas:\\n    \\n    b0' = (b0 ^ num) & (~b1)\\n    b1' = (b1 ^ num) & (~b0')\\n\\nThe AC code:\\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def singleNumber(self, nums):\\n            b1, b0 = 0, 0\\n            for num in nums:\\n                b0 = (b0 ^ num) & (~b1)\\n                b1 = (b1 ^ num) & (~b0)\\n            return b0",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 43385,
                "title": "python-bitwise-solution",
                "content": "    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        ans = 0\\n        for i in xrange(0,32):\\n            count = 0\\n            for a in A:\\n                if ((a >> i) & 1):\\n                    count+=1\\n            ans |= ((count%3) << i)\\n        return self.convert(ans)\\n        \\n    def convert(self,x):\\n        if x >= 2**31:\\n            x -= 2**32\\n        return x",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        ans = 0\\n        for i in xrange(0,32):\\n            count = 0\\n            for a in A:\\n                if ((a >> i) & 1):\\n                    count+=1\\n            ans |= ((count%3) << i)\\n        return self.convert(ans)\\n        \\n    def convert(self,x):\\n        if x >= 2**31:\\n            x -= 2**32\\n        return x",
                "codeTag": "Java"
            },
            {
                "id": 3527570,
                "title": "mastering-bitwise-operations-a-guide-to-boost-your-interview-preparation",
                "content": "# Mastering Bitwise Operations\\n![image.png](https://assets.leetcode.com/users/images/6f6003f9-98f2-487d-9c5a-7d50f38f9be0_1684162754.1822438.png)\\n\\nBitwise operations are an essential aspect of low-level programming and are frequently encountered in technical interviews. Understanding bitwise operations and their applications can greatly enhance your problem-solving skills and make you stand out as a candidate. In this blog, we will provide a detailed explanation and generalization of the bitwise operation method for single numbers, covering the most commonly used operators and their applications.\\n\\n1. Bitwise AND (&):\\nThe bitwise AND operation compares the corresponding bits of two numbers and returns a new number where each bit is set to 1 if and only if the corresponding bits of both numbers are 1. Otherwise, the bit is set to 0. This operation is useful for checking the presence of specific bits or extracting specific information from a number.\\n\\n- Generalization:\\nGiven two integers, perform a binary AND operation on their corresponding bits, resulting in a new integer with bits set to 1 where both input integers have 1s and 0s otherwise.\\n\\n2. Bitwise OR (|):\\nThe bitwise OR operation compares the corresponding bits of two numbers and returns a new number where each bit is set to 1 if either of the corresponding bits in the input numbers is 1. If both bits are 0, the result bit is set to 0. This operation is often used for setting specific bits or combining different bit patterns.\\n\\n- Generalization:\\nGiven two integers, perform a binary OR operation on their corresponding bits, resulting in a new integer with bits set to 1 where either input integer has a 1, and 0s otherwise.\\n\\n3. Bitwise XOR (^):\\nThe bitwise XOR operation compares the corresponding bits of two numbers and returns a new number where each bit is set to 1 if the corresponding bits of the input numbers are different (one is 0 and the other is 1). If the corresponding bits are the same (both 0s or both 1s), the result bit is set to 0. This operation is useful for toggling bits or checking parity.\\n\\n- Generalization:\\nGiven two integers, perform a binary XOR operation on their corresponding bits, resulting in a new integer with bits set to 1 where the input integers have different bit values, and 0s otherwise.\\n\\n4. Bitwise NOT (~):\\nThe bitwise NOT operation (also called bitwise complement) negates each bit of a number, flipping 0s to 1s and 1s to 0s. This operation is often used in conjunction with other bitwise operations or for creating bit masks.\\n\\n- Generalization:\\nGiven an integer, perform a binary NOT operation on each bit of the number, resulting in a new integer with all its bits flipped (0s become 1s and 1s become 0s).\\n\\n![image.png](https://assets.leetcode.com/users/images/19d6977a-c5ae-44c0-bb05-050762f40c79_1684162852.8252938.png)\\n\\n#### Happy coding!\\n\\n---\\n\\n# Intuition:\\nThe approach used in the code is based on bitwise operations. It maintains two variables, \\'ones\\' and \\'twos\\', to keep track of the bits that appear once and twice, respectively.\\n\\n# Approach:\\n1. Initialize \\'ones\\' and \\'twos\\' as 0.\\n2. Iterate through each number \\'num\\' in the input vector \\'nums\\'.\\n3. Update \\'ones\\' and \\'twos\\' using bitwise operations:\\n   - ones = (ones ^ num) & ~twos: XOR the current number \\'num\\' with \\'ones\\' to toggle the bits that appear once, then perform bitwise AND with the complement of \\'twos\\' to remove the bits that appear twice.\\n   - twos = (twos ^ num) & ~ones: XOR the current number \\'num\\' with \\'twos\\' to toggle the bits that appear twice, then perform bitwise AND with the complement of \\'ones\\' to remove the bits that appear once.\\n4. After iterating through all the numbers, the value stored in \\'ones\\' will be the single number that appears only once.\\n5. Return the value of \\'ones\\' as the result.\\n\\n# Complexity:\\n- The time complexity of this approach is O(n), where n is the number of elements in the input vector \\'nums\\', as we iterate through all the numbers once.\\n- The space complexity is O(1) since we are using a constant amount of extra space to store the variables \\'ones\\' and \\'twos\\'.\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0;\\n        int twos = 0;\\n\\n        for (int num : nums) {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n\\n        return ones;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0;\\n        int twos = 0;\\n\\n        for (int num : nums) {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n\\n        return ones;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0\\n\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n\\n        return ones\\n```\\n---\\n# JavaScript\\n```\\nvar singleNumber = function(nums) {\\n    let ones = 0;\\n    let twos = 0;\\n\\n    for (let num of nums) {\\n        ones = (ones ^ num) & ~twos;\\n        twos = (twos ^ num) & ~ones;\\n    }\\n\\n    return ones;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0;\\n        int twos = 0;\\n\\n        for (int num : nums) {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n\\n        return ones;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0;\\n        int twos = 0;\\n\\n        for (int num : nums) {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n\\n        return ones;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        ones = 0\\n        twos = 0\\n\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n\\n        return ones\\n```\n```\\nvar singleNumber = function(nums) {\\n    let ones = 0;\\n    let twos = 0;\\n\\n    for (let num of nums) {\\n        ones = (ones ^ num) & ~twos;\\n        twos = (twos ^ num) & ~ones;\\n    }\\n\\n    return ones;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43417,
                "title": "my-c-code-12ms-one-iteration-3-int-variables-b0-b1-reset-with-algorithm-description",
                "content": "    /*\\n    The basic idea is to implement a modulo-3 counter (to count how many times \"1\" occurs) for each bit position.\\n    Such modulo-3 counter needs two bits (B1,B0) to represent. \\n    (B1,B0): \\n    (0, 0) : '1' occurs zero times after last resetting,\\n    (0, 1) : '1' occurs one times after last resetting,\\n    (1, 0) : '1' occurs two times after last resetting,\\n    (1, 1) : '1' occurs three times after last resetting, then we need to reset the counter to (0,0)\\n    So to implement such modulo-3 counters, we need three variables (b0, b1, reset)\\n    The n-th bit of b0 is the B0 bit of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit)\\n    The n-th bit of b1 is the B1 bit of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit)\\n    The n-th bit of reset is the reset flag of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit), \\n    \\n    - b0: can be easily implemented with XOR bit operation,  as b0 = b0^ A[i]\\n    - b1: B1 will only be set to 1, when B0 (of the n-th bit counter) =1 and the n-th bit of A[i] = 1, and stay '1' until it is reseted. So b1 |=  b0 & A[i]; \\n    - The reset flag is set when (B1, B0) = (1,1). So, reset = b0 & b1;\\n    - The reset operation can be done by b0 = b0 ^ reset and b1 = b1 ^ reset;\\n    \\n    After updating the b0, b1, reset with all A[], the b0 will be the final result since if the n-th bit of the to-be-found element is 1, then the times of '1' occurs on the n-th bit is 3*x+1, which is 1 after the modulo 3 opertation.   \\n    */\\n    class Solution {\\n    public:\\n    \\n        int singleNumber(int A[], int n) {\\n            int b0=0, b1=0, reset=0;\\n            int i;\\n            \\n            if(n>0)\\n            {\\n            for(i = 0; i<n; i++)\\n            {\\n                b1 |= (b0 & A[i]);\\n                b0 = b0 ^ A[i];\\n                reset = b1 & b0;\\n                b1 = b1 ^ reset;\\n                b0 = b0 ^ reset;\\n            }\\n            \\n            return b0;\\n            }\\n        }\\n    //------------------------------------------------------------------------------------------------------------\\n    /*\\n    //--  Another version with explicit modulo-3 counters implemented, just for reference-----//\\n        const int int_bitwidth = 32;\\n        int singleNumber(int A[], int n) {\\n            int mod3Counter[int_bitwidth];\\n            int i,j;\\n            unsigned int temp = 0;\\n            \\n            if(n>0)\\n            {\\n                for(i=0; i<int_bitwidth; i++) mod3Counter[i] = 0;\\n                \\n                for(i=0; i<n; i++)\\n                {\\n                    temp = (unsigned int) A[i];\\n                    for(j=0; j<int_bitwidth; j++)\\n                    {\\n                        if(temp & 0x1)\\n                        {\\n                            mod3Counter[j] = (mod3Counter[j] + 1) % 3;\\n                        }\\n                        temp = temp>>1;\\n                    }\\n                    \\n                    temp =0;\\n                    for(j=0; j<int_bitwidth; j++)\\n                    {\\n                        temp = temp << 1;\\n                        if(mod3Counter[int_bitwidth - 1 -j]) \\n                        {\\n                            temp = temp | 0x1;\\n                        }\\n                    }\\n                }\\n                return (int)temp;\\n    \\n            }\\n        }\\n    */\\n        \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\n        int singleNumber(int A[], int n) {\\n            int b0=0, b1=0, reset=0;\\n            int i;\\n            \\n            if(n>0)\\n            {\\n            for(i = 0; i<n; i++)\\n            {\\n                b1 |= (b0 & A[i]);\\n                b0 = b0 ^ A[i];\\n                reset = b1 & b0;\\n                b1 = b1 ^ reset;\\n                b0 = b0 ^ reset;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1296437,
                "title": "c-5-solutions-time-o-n-2-o-n-logn-o-n",
                "content": "```\\n// Brute Force Algo\\n// Time: O(n^2)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        for ( int i = 0; i < nums.size(); i++) {\\n            bool found = false;\\n            for ( int j = 0; j < nums.size(); j++) {\\n                if ( nums[i] == nums[j] && i != j) {\\n                    found = true;\\n                }\\n            }\\n            if ( !found ) {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n// Sorting Algo\\n// Time: O(n.logn)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if ( n == 1)\\n            return nums[0];\\n\\n        sort(nums.begin(), nums.end());\\n        \\n        if ( nums[0] != nums[1])\\n            return nums[0];\\n        if ( nums[n-1] != nums[n-2])\\n            return nums[n-1];\\n        for ( int i = 1; i < n - 1; i++) \\n            if ( nums[i] != nums[i+1] && nums[i] != nums[i-1]) \\n                return nums[i];\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n// Hash Table Algo\\n// Time: O(n)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        unordered_map<int,int> freq;\\n        for (int i : nums) {\\n            freq[i]++;\\n        }\\n        for (auto kv : freq) {\\n            if (kv.second == 1) {\\n                return kv.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n// Bit Manipulation Algo\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {        \\n        unsigned int shift = 1;\\n        unsigned int ans = 0;\\n        \\n        for (int i = 0; i < 32; ++i) {\\n            int count = 0;\\n            for (int i : nums) \\n                if (i & shift)\\n                    count += 1;\\n            if ((count % 3) != 0)\\n                ans = ans + shift;\\n            shift <<= 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n// XOR Bit Manipulation Algo\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {       \\n        int ones = 0;\\n        int twos = 0;\\n        \\n        for ( int i : nums ) {\\n            ones = (ones ^ i) & (~twos);\\n            twos = (twos ^ i) & (~ones);\\n        }\\n        \\n        return ones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\n// Brute Force Algo\\n// Time: O(n^2)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        for ( int i = 0; i < nums.size(); i++) {\\n            bool found = false;\\n            for ( int j = 0; j < nums.size(); j++) {\\n                if ( nums[i] == nums[j] && i != j) {\\n                    found = true;\\n                }\\n            }\\n            if ( !found ) {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n// Sorting Algo\\n// Time: O(n.logn)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if ( n == 1)\\n            return nums[0];\\n\\n        sort(nums.begin(), nums.end());\\n        \\n        if ( nums[0] != nums[1])\\n            return nums[0];\\n        if ( nums[n-1] != nums[n-2])\\n            return nums[n-1];\\n        for ( int i = 1; i < n - 1; i++) \\n            if ( nums[i] != nums[i+1] && nums[i] != nums[i-1]) \\n                return nums[i];\\n        return -1;\\n    }\\n};\\n```\n```\\n// Hash Table Algo\\n// Time: O(n)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {\\n        unordered_map<int,int> freq;\\n        for (int i : nums) {\\n            freq[i]++;\\n        }\\n        for (auto kv : freq) {\\n            if (kv.second == 1) {\\n                return kv.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n// Bit Manipulation Algo\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {        \\n        unsigned int shift = 1;\\n        unsigned int ans = 0;\\n        \\n        for (int i = 0; i < 32; ++i) {\\n            int count = 0;\\n            for (int i : nums) \\n                if (i & shift)\\n                    count += 1;\\n            if ((count % 3) != 0)\\n                ans = ans + shift;\\n            shift <<= 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n// XOR Bit Manipulation Algo\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) \\n    {       \\n        int ones = 0;\\n        int twos = 0;\\n        \\n        for ( int i : nums ) {\\n            ones = (ones ^ i) & (~twos);\\n            twos = (twos ^ i) & (~ones);\\n        }\\n        \\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700329,
                "title": "cpp-solution-o-32-n-easy-to-understand-fully-explained",
                "content": "\\n**lets array is [2,2,3,2,3,4,3]\\nNumber binary form\\n2 ->   ---------------------------_____           0 0 1 0\\n2 ->   ---------------------------_____           0 0 1 0\\n3 ->   ---------------------------_____           0 0 1 1\\n2 ->   ---------------------------_____           0 0 1 0\\n3 ->   ---------------------------_____           0 0 1 1\\n4 ->   ---------------------------_____           0 1 0 0\\n3 ->   ---------------------------_____           0 0 1 1\\nSum of total at every index _____ 0 1 6 3\\nTaking mod by 3 at every index   _0 1 0 0  (0%3=0 , 1%3=1 , 6%3=0 , 3%3=0)\\nNow it is (0100) is binary form of final result i.e 4 is final answer.\\n if number present 3 times then by taking modulo 3 we will eleminate it\\'s bit from result\\n If sum of every index bits taken mod 3 is 0 means that there is no set bit result bit\\n If sum of every index bits taken mod 3 is 1 means that there is set bit result bit\\n Now we will get final result by bits taken by mod and generate decimal form of bits**\\n \\n         for negative single number , check if result in nums or not if not return -res || see solution\\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        long long int res=0;\\n        for(int i=0;i<32;i++)\\n        {   int p=0;\\n            for(int j=0;j<nums.size();j++)\\n            {   \\n\\t\\t\\t    int k=abs(nums[j]);\\n                p+=(k&(1<<i))!=0?1:0;    //by shifting 1 to left ith time and taking and with1  will give us \\n\\t\\t\\t\\t                                         //that ith bit of nums[j] is 1 or 0\\n            } \\n           p%=3; \\n          res+=pow(2,i)*p;\\n        } \\n\\t\\t/*\\n\\t\\t**To handle if res is -ve**\\n\\t\\t We have calculated our result positive number\\n\\t\\t But there may be chance that single number may be negative\\n\\t\\t Eg.array= [2,2,-4,2]\\n\\t\\t Here after bitwise calculation our res will store 4 \\n\\t\\t but you see that 4 is not present in  our array.\\n\\t\\t So , we will check if res (4) is present in array or not\\n\\t\\t if present , then return it else res must be -ve\\n\\t\\t Hence return -res (-4):\\n\\t\\t*/\\n        cout<<res;\\n        int c=0;\\n        for(auto x:nums)   //for negative numbers\\n          if(x==res) {c++;}   //if our calculates value res is present in array, then increment c\\n        return c==1?res:-res; //if c=1 return res else res must be -ve\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        long long int res=0;\\n        for(int i=0;i<32;i++)\\n        {   int p=0;\\n            for(int j=0;j<nums.size();j++)\\n            {   \\n\\t\\t\\t    int k=abs(nums[j]);\\n                p+=(k&(1<<i))!=0?1:0;    //by shifting 1 to left ith time and taking and with1  will give us \\n\\t\\t\\t\\t                                         //that ith bit of nums[j] is 1 or 0\\n            } \\n           p%=3; \\n          res+=pow(2,i)*p;\\n        } \\n\\t\\t/*\\n\\t\\t**To handle if res is -ve**\\n\\t\\t We have calculated our result positive number\\n\\t\\t But there may be chance that single number may be negative\\n\\t\\t Eg.array= [2,2,-4,2]\\n\\t\\t Here after bitwise calculation our res will store 4 \\n\\t\\t but you see that 4 is not present in  our array.\\n\\t\\t So , we will check if res (4) is present in array or not\\n\\t\\t if present , then return it else res must be -ve\\n\\t\\t Hence return -res (-4):\\n\\t\\t*/\\n        cout<<res;\\n        int c=0;\\n        for(auto x:nums)   //for negative numbers\\n          if(x==res) {c++;}   //if our calculates value res is present in array, then increment c\\n        return c==1?res:-res; //if c=1 return res else res must be -ve\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 43409,
                "title": "12-ms-c-solution-with-only-1-int-space",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int> nums) {\\n            int tempNum = 0;\\n            for (int i = 1; i < nums.size(); i++) {\\n                tempNum = nums[0] & (tempNum ^ nums[i]);\\n                nums[0] = tempNum | (nums[0] ^ nums[i]);\\n            }\\n            return nums[0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int> nums) {\\n            int tempNum = 0;\\n            for (int i = 1; i < nums.size(); i++) {\\n                tempNum = nums[0] & (tempNum ^ nums[i]);\\n                nums[0] = tempNum | (nums[0] ^ nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 163772,
                "title": "logical-thinking-with-code",
                "content": "Thanks for the original posts.\\n\\n**Logical Thinking**\\nTake [1, 1, 1, 2, 2, 2, 5] for example, binary representation of each number is as below:\\n```\\n0001\\n0001\\n0001\\n0010\\n0010\\n0010\\n0101\\n____\\n0134 if we count the number of 1\\'s for each \\'line\\' by simple addition \\n```\\nIf every element appears three times, the number of 1\\'s for each \\'line\\' should divide by `3`. We define a \\'line\\' with the number of 1\\'s that can divide by `3` as a `balanced` line.\\nThus, the single number must be the only one that contributes to an `unbalanced` line. That is, it has 1 at each position of `unbalanced` lines. Finally, we can identify the single number.\\nIn the example above, 1 and 4 in \\'0134\\' are `unbalanced` lines, thus, \\'0101\\' is the single number we are searching for.\\n\\n**Trick**\\n`(num >> i) & 1`: get the digit of ith least significant position in binary representation of num.\\n`pos = (sum % 3) << i` mask the position `pos` of unbalanced line (as defined above) to 1\\n`result = result | pos` set the digit of position `pos` to 1.\\n\\n**Code**\\n```\\n    public int singleNumber(int[] nums) {\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for (int num : nums) {\\n                sum += (num >> i) & 1;\\n            }\\n            result = result | ((sum % 3) << i);\\n        }\\n    \\n        return result;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n0001\\n0001\\n0001\\n0010\\n0010\\n0010\\n0101\\n____\\n0134 if we count the number of 1\\'s for each \\'line\\' by simple addition \\n```\n```\\n    public int singleNumber(int[] nums) {\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for (int num : nums) {\\n                sum += (num >> i) & 1;\\n            }\\n            result = result | ((sum % 3) << i);\\n        }\\n    \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43363,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static int singleNumber(int[] nums) {\\n\\t\\tint len = nums.length, result = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\t\\tsum += (nums[j] >> i) & 1;\\n\\t\\t\\t}\\n\\t\\t\\tresult |= (sum % 3) << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static int singleNumber(int[] nums) {\\n\\t\\tint len = nums.length, result = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\t\\tsum += (nums[j] >> i) & 1;\\n\\t\\t\\t}\\n\\t\\t\\tresult |= (sum % 3) << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3715167,
                "title": "bit-manipulation-fast-code-detailed-explanation-video-tutorial-c-java-python",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can count bits here ith bit can be in the form of 3*x+1 or 3*x.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtube.com/@LetsCodeTogether72?sub_confirmation=1\\n or link in my comment section.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49`Single Number || by Let\\'s Code Together` on youtube\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n If any number is occuring 3 times then the count of every set bit of that number will also be 3.\\n            For example, let\\'s say we have 5,5,5 then,\\n            Binary representation is 101,101,101.\\n            We can see that the count of 0th and 2nd bit will be 3.\\n            Now if another number comes, let\\'s say 4(100) then the count of every set bit will be:\\n                0th: 3\\n                2nd: 4\\n            So by using the above logic if we get a count of each set bit for all the numbers and take modulo of 3 for each bit then the resulting number would be our answer.\\n            Like in above example, count of each bit became 4, 0, 3 and if we take % 3 then it will become 1,0,0 and 100 is 4(our answer).\\n\\n\\nPlease upvote if u like this \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n           int res= 0;\\n        for(int i=0;i<32;i++){\\n            int countones = 0;\\n            for(int j=0;j<nums.size();j++){\\n                countones =countones+ ((nums[j]>>i)&1);\\n            }\\n            countones = countones % 3;\\n            res = (res | countones << i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Java Code\\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            int countOnes = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                countOnes += (nums[j] >> i) & 1;\\n            }\\n            countOnes = countOnes % 3;\\n            if (countOnes != 0) {\\n                res |= countOnes << i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n# Python Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                temp = n >> i\\n                temp = temp & 1\\n                count += temp\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res\\n```\\nPlease upvote if you like this",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n           int res= 0;\\n        for(int i=0;i<32;i++){\\n            int countones = 0;\\n            for(int j=0;j<nums.size();j++){\\n                countones =countones+ ((nums[j]>>i)&1);\\n            }\\n            countones = countones % 3;\\n            res = (res | countones << i);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            int countOnes = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                countOnes += (nums[j] >> i) & 1;\\n            }\\n            countOnes = countOnes % 3;\\n            if (countOnes != 0) {\\n                res |= countOnes << i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                temp = n >> i\\n                temp = temp & 1\\n                count += temp\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43300,
                "title": "my-simple-python-solution",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def singleNumber(self, nums):\\n            a= set(nums)\\n            a = sum(a)*3 -sum(nums)\\n            a = a/2\\n            return a",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 869698,
                "title": "my-understanding-on-bit-manipulation-method",
                "content": "OK I have to admit that I\\'m no expert on bit manipulation, so when I first looked at the solution on this, I was really confused. I could understand if the numbers are fed in in order, but if they are out of order, I could not figure out why our counts still work. FInally I got up with this. Noted that I got this AFTER I looked at the solution, so it\\'s more like an explaination rather than a solution.\\n\\nSo we need to think every number as a set of bits. If we stack them together like this:\\n\\n8: 1 0 0 0\\n8: 1 0 0 0\\n8: 1 0 0 0\\n2: 0 0 1 0\\n\\nWe can see that we need some kind of operations that can cancel out any zeros or ones that appears 3 time. We can think this like we are adding all bits on a certain position then mod by 3. But since every bit only has two values (0 or 1), we cannot do this within one bit sequence, so we need two.\\n\\nSince all bit positions are the same, we only consider one bit here. Also since adding zeros together does not really change the added value, we focus on the appearances of ones here. Following is how the two numbers should change when adding ones. When adding zeros, they should stay the same.\\n```\\n               Initial State   Add first one   Add second one   Add third one\\nseenOnce          0                  1              0                 0\\nseenTwice         0                  0              1                 0\\n```\\nSo we can now try to find the operations that can fulfill this requirement. Here we can refer to the explainations within the solution itself. When developing the equation, we need to keep in mind that we update `seenOnce` first. We we update `seenTwice`, `seenOnce` already has the new value. So we need to check the values within the correct spot.\\n\\nFor `seenOnce`, `(seenOnce ^ num)` makes sense for the first two appearance, for the third appearance, we need it to be zero, and by then `seenTwice` is 1, so we AND a `~seenTwice` to it, the final equation is `~seenTwice & (seenOnce ^ 1)`.\\n\\nFor `seenTwice`, similarly, we AND a `~seenOnce` to force the first appearance\\'s value to be zero, then `(seenTwice ^ num)` will handle the last two appearances. The final equation will be `~seenOnce & (seenTwice ^ num)`.\\n\\nHere is the code, which is exactly the same with the solution ;)\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // This problem can be translated to:\\n        //      For every bit position, we cancel any 3-time 1 and 3-time 0 to a 0\\n        //      Then we need to find equations that fits this: (assume we apply 3 1s)\\n        //               Zero 1      First 1     Second 1    Third 1\\n        // seenOnce        0            1           0           0\\n        // seenTwice       0            0           1           0\\n        int seenOnce = 0;\\n        int seenTwice = 0;\\n        \\n        for(int num: nums) {\\n            seenOnce = ~seenTwice & (seenOnce ^ num);\\n            seenTwice = ~seenOnce & (seenTwice ^ num);\\n        }\\n        \\n        return seenOnce;\\n    }\\n}\\n```\\n\\nHope this can help you!",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n               Initial State   Add first one   Add second one   Add third one\\nseenOnce          0                  1              0                 0\\nseenTwice         0                  0              1                 0\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // This problem can be translated to:\\n        //      For every bit position, we cancel any 3-time 1 and 3-time 0 to a 0\\n        //      Then we need to find equations that fits this: (assume we apply 3 1s)\\n        //               Zero 1      First 1     Second 1    Third 1\\n        // seenOnce        0            1           0           0\\n        // seenTwice       0            0           1           0\\n        int seenOnce = 0;\\n        int seenTwice = 0;\\n        \\n        for(int num: nums) {\\n            seenOnce = ~seenTwice & (seenOnce ^ num);\\n            seenTwice = ~seenOnce & (seenTwice ^ num);\\n        }\\n        \\n        return seenOnce;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327103,
                "title": "python-binary-solution",
                "content": "```python\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        is_neg = False\\n        for i in xrange(32):\\n            counter = 0\\n            for num in nums:\\n                if (num >> i) & 1:\\n                    counter += 1\\n            \\n            if counter % 3 == 1:\\n                ans += pow(2, i)\\n                if i == 31:\\n                    is_neg = True\\n        return ans if not is_neg else ans - pow(2, 32)\\n```\\n\\n`1 0 0 1` is  9\\n`1 0 0 1` is  9\\n`1 0 0 1` is  9\\n`0 1 0 1` is  5\\n\\nRecord how many `1`s are on the same bit. In this example, 3 `1` on the first bit, 1 `1` on the second bit and 4 `1` on the last bit. Only need the number which appearing once, so it is `0101`. Convert it to integer.\\n\\nI used 32 bits to record the result, so the largest positive interger is `01111...111` which has 31 `1`s(`pow(2,31) - 1`). If the first bit is `1`, the result is negtive.  `ans - pow(2, 32)` will be the final result.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        is_neg = False\\n        for i in xrange(32):\\n            counter = 0\\n            for num in nums:\\n                if (num >> i) & 1:\\n                    counter += 1\\n            \\n            if counter % 3 == 1:\\n                ans += pow(2, i)\\n                if i == 31:\\n                    is_neg = True\\n        return ans if not is_neg else ans - pow(2, 32)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43436,
                "title": "just-6-lines-accepted-o-n-solution",
                "content": "Image the numbers in A have just one bit,\\n\\nthat is: A = [0, 0, 0, 1, 1, 1, x]\\n\\nWe have three times \"0\", three times \"1\", and a different \"x\".\\n\\nSo, if count of \"1\" in A is three's multiple, than x = 0,\\n\\nelse, x = 1.\\n\\nIterate all numbers in A. \\n\\nWhen encount FIRST        \"1\", set \"ec1 = 1\";\\n\\nWhen encount SECOND   \"1\", set \"ec2 = 1\";\\n\\nWhen encount THIRD       \"1\", set \"ec3 = 1, ec1 = 0, ec2 = 0\", and move on...\\n\\nAt last \"ec1\" is the different number.\\n\\n\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n        def singleNumber(self, A):\\n            ec1, ec2, ec3 = 0, 0, 0\\n            for ai in A:\\n                ec3 = ec2 & ai\\n                ec2 = (ec2 | (ec1 & ai)) & (~ec3)\\n                ec1 = (ec1 | ai) & (~ec3)        \\n            return ec1",
                "solutionTags": [],
                "code": "Image the numbers in A have just one bit,\\n\\nthat is: A = [0, 0, 0, 1, 1, 1, x]\\n\\nWe have three times \"0\", three times \"1\", and a different \"x\".\\n\\nSo, if count of \"1\" in A is three's multiple, than x = 0,\\n\\nelse, x = 1.\\n\\nIterate all numbers in A. \\n\\nWhen encount FIRST        \"1\", set \"ec1 = 1\";\\n\\nWhen encount SECOND   \"1\", set \"ec2 = 1\";\\n\\nWhen encount THIRD       \"1\", set \"ec3 = 1, ec1 = 0, ec2 = 0\", and move on...\\n\\nAt last \"ec1\" is the different number.\\n\\n\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n        def singleNumber(self, A):\\n            ec1, ec2, ec3 = 0, 0, 0\\n            for ai in A:\\n                ec3 = ec2 & ai\\n                ec2 = (ec2 | (ec1 & ai)) & (~ec3)\\n                ec1 = (ec1 | ai) & (~ec3)        \\n            return ec1",
                "codeTag": "Java"
            },
            {
                "id": 1615247,
                "title": "bit-manipulation-bitwise-logic-explanation",
                "content": "# Bit Manipulation\\n\\nBefore I try to solve this problem. I never touch the bit manipulation. However, I found the solution people solve is elegant and smart. I want to understand the logic behind. And I finally did. I am here to share my understanding.\\n\\ninput : [ 36, 96, 36, 96, 4, 96, 36 ]\\n\\nLet us represent the above number in bit first.\\n\\n0010 0100 (36)\\n0110 0000 (96)\\n0010 0100 (36)\\n0110 0000 (96)\\n0000 0100 (4)\\n0110 0000 (96)\\n0010 0100 (36)\\n\\nok.  Now let us try to sum each column bit. we want to see how many times each columns occurs\\n\\n0010 0100 (36)\\n0110 0000 (96)\\n0010 0100 (36)\\n0110 0000 (96)\\n0000 0100 (4)\\n0110 0000 (96)\\n0010 0100 (36)\\n..........................\\n0360 0400 \\n\\n\\nok. since every element appears three times except for one.\\nWhich means we can mod 3 to check if the remainder is 0 or not.\\nif the remainder is 0, it means the except one does not contain the bit in that column.\\n\\n\\n 0360 0400 \\n%3\\n..........................\\n 0000 0100\\n\\nNow we found out that 0000 0100, which is equal to 4 is our desired single number.\\n\\nThe next step is to convert our idea to code.\\n\\n```\\nint singleNumber(vector<int>& nums)\\n{\\n\\tint ans = 0;\\n\\n\\tfor (int i = 0; i < 32; i++)\\n\\t{\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums)\\n\\t\\t{\\n\\t\\t\\tif (num & 1 << i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (sum % 3)\\n\\t\\t{\\n\\t\\t\\tans |= (1 << i);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n\\n\\nSince int = 4bytes, 1byte = 8bits, we are going to loop 32 times. \\nwhich means, we are going to loop through each bit, from the most significant to less significant or vice versa. (for my example is from right to left, since i am using left shift operator \\u201C`<<`\\u201D)\\n\\nThe variable sum is the number of times that the bit occurs.\\nWe use `1 << i` to target specific column of bit\\nSince we are using `&` operator, combine with `1 << i`, which means we ignore all other columns of bit.\\n\\ninput : [ 36, 96, 36, 96, 4, 96, 36 ]\\n_____________________________________\\nnow, `i=0`, so we are looking at the less significant bit first.\\n\\nsum = 0\\nnum = 36\\n\\n0010 010**0** num(36)   \\n0000 000**1**  1 << **0**  (&) \\n..........................................\\n0000 000**0** \\n\\n_____________________________________\\n\\nsum = 0       \\nnum = 96\\n                        \\n0110 000**0**  num(96)   \\n0000 000**1**  1 << **0**  (&)\\n..........................................\\n0000 000**0** \\n\\n_____________________________________\\n\\nsum = 0       \\nnum = 4\\n                        \\n0000 010**0** num(4)     \\n0000 000**1**  1 << **0**      (&)\\n..........................................\\n0000 000**0** \\n.\\n.\\n.\\n_____________________________________\\n\\nnow i = 1, then we loop through the nums\\n\\nsum = 0\\nnum = 36\\n\\n0010 01**0**0 num(36)   \\n0000 00**1**0  1 << **1** (&)\\n..........................................\\n0000 00**0**0 \\n_____________________________________\\n\\nsum = 0\\nnum = 96\\n\\n0110 00**0**0 num(96)   \\n0000 00**1**0  1 << **1**    (&)\\n..........................................\\n0000 00**0**0 \\n_____________________________________\\n\\nsum = 0\\nnum = 4\\n\\n0000 01**0**0 num(4)     \\n0000 00**1**0  1 << **1**   (&)\\n..........................................\\n0000 00**0**0 \\n.\\n.\\n.\\n_____________________________________\\n\\nnow i = 2, then we loop through the nums\\n\\nsum = 0\\nnum = 36\\n\\n0010 0**1**00 num(36)  \\n0000 0**1**00  1 << **2** (&)\\n..........................................\\n0000 0**1**00 \\n\\nsum = 1\\nnum = 96\\n\\n0110 0**0**00 num(96)  \\n0000 0**1**00  1 << **2** (&)\\n..........................................\\n0000 0**0**00 \\n\\nsum = 1\\nnum = 4\\n\\n0000 0**1**00 num(4)    \\n0000 0**1**00  1 << **2** (&)\\n..........................................\\n0000 0**1**00 \\n\\n\\nsum = 2\\n.\\n.\\n.\\nIn the end we will find that sum = 4, which sum % 3 is  = 1, will trigger our if statement.\\n\\nThe next step is to add this column of bit to our answer variable. That all. After loop through 32 times. the answer will be our single number\\n__________________________\\n# BitWise\\n\\nThe idea of bitwise vs bit manipulation is almost the same. Only the representation is different.\\n\\nwe will declare 2 variables.\\n\\nint seenOnce = 0\\nint seenTwice = 0 \\n\\nif the input occurs 1st, we will change seenOnce to 1\\nif the input occurs 2nd, we will change seenOnce to 0, seenTwice to 1\\nif the input occurs 3rd, we will change seenOnce to 0, seenTwice to 0\\n\\nbut let\\'s think about it as bit. If that column of bit occurs 1st, we set seenOnce\\u2019s that column of bit to 1,  what does i mean, let look this example\\n\\ninput : [ 36, 96, 36, 96, 4, 96, 36 ]\\n\\n\\nin the very first beginning\\nseenOnce :  0000 0000\\nseenTwice : 0000 0000\\n\\nnow we detect 36,\\n36 = 0010 0100, the 2nd and 5nd column of bit (from right to left, from 0 to 7) seen once, now we add to seen once.\\n\\nseenOnce  : 0010 0100\\nseenTwice : 0000 0000\\n\\n\\nnow we detect 96,\\n96 = 0010 0000, the 5nd column of bit seen,  this is the 2nd time that 5nd column we see. so we change seenOnce 5nd bit column to 0, and change seenTwice 5nd bit column to 1\\n\\nseenOnce  : 0100 0100\\nseenTwice : 0010 0000\\n\\n\\nnow we detect 36,\\n36 = 0010 0100, the 2nd bit column seen twice, the 5nd column seen third now. so we \\nchange the seenOnce 2nd bit column to 0, and change seenTwice 2nd bit column to 1.\\nwe also change the seenTwice 5nd bit column to 0, since this is the third time. \\n\\nseenOnce  : 0100 0000\\nseenTwice : 0000 0100\\n\\n.\\n.\\n.\\n.\\nnow you will find out that,  if that column of bit occurs 3 times, seenOnce will reset to zero. seenTwice will reset to zero. So the remaining bit will be our single number.\\n\\nthe idea behind is very similar to sum%3 == 0\\n\\nNow we understand the logic, let us look through the code\\n\\n```\\n    int seenOnce = 0, seenTwice = 0;\\n\\n    for (int num : nums) {\\n      seenOnce = ~seenTwice & (seenOnce ^ num);\\n      seenTwice = ~seenOnce & (seenTwice ^ num);\\n    }\\n\\n    return seenOnce;\\n```\\n\\n\\nlet\\'s look this code separately\\n\\nseenOnce = `~seenTwice` & (seenOnce ^ num);\\nseenOnce is only allow to set if seenTwice is zero\\n\\nseenOnce = ~seenTwice & `(seenOnce ^ num)`;\\nseenOnce will set to 1 - 0 - 1 - 0 - 1 - 0 repeatedly\\n\\n________________\\nNow i am going to find the magic Single Number 3 behind, happing coding day. Thx the community let me learn so much things. \\nFirst time to post the discussion. Lost a lot of style and color where i did it from google doc :( \\nHope everyone dont mind my ugly typesetting.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums)\\n{\\n\\tint ans = 0;\\n\\n\\tfor (int i = 0; i < 32; i++)\\n\\t{\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums)\\n\\t\\t{\\n\\t\\t\\tif (num & 1 << i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (sum % 3)\\n\\t\\t{\\n\\t\\t\\tans |= (1 << i);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\n    int seenOnce = 0, seenTwice = 0;\\n\\n    for (int num : nums) {\\n      seenOnce = ~seenTwice & (seenOnce ^ num);\\n      seenTwice = ~seenOnce & (seenTwice ^ num);\\n    }\\n\\n    return seenOnce;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43381,
                "title": "clean-c-solution-for-generic-k",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            auto r = 0, k = 3;\\n            for (auto i = 0; i < 32; ++i) {\\n                auto mask = 1 << i, cnt = 0;\\n    \\n                for (auto num : nums)\\n                    cnt += bool(num & mask);\\n    \\n                if (cnt % k)\\n                    r |= mask;\\n            }\\n            return r;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            auto r = 0, k = 3;\\n            for (auto i = 0; i < 32; ++i) {\\n                auto mask = 1 << i, cnt = 0;\\n    \\n                for (auto num : nums)\\n                    cnt += bool(num & mask);\\n    \\n                if (cnt % k)\\n                    r |= mask;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43383,
                "title": "a-simple-solution-for-all-similar-problems",
                "content": "    public class Solution {\\n     public int singleNumber(int[] nums) {\\n        int[] digit = new int[32];\\n        for(int i = 0; i < 32; i++){\\n            // for each digit, we count the number of appearance in the array\\n            for (int j = 0; j < nums.length; j++){\\n                digit[i]+= (nums[j]>>i)&1; // get the value (0 or 1) at ith digit of nums[j]\\n            }\\n        }\\n        int res = 0;\\n        for (int i =0; i< 32; i++){\\n            // (digit[i]%3) is mode of 3, if it is not zero, it means the single number has 1 on this digit.\\n            int d = digit[i]%3 ==0 ? 0: 1;\\n            res += (d)<<i;\\n        }\\n        return res;\\n    }\\n }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     public int singleNumber(int[] nums) {\\n        int[] digit = new int[32];\\n        for(int i = 0; i < 32; i++){\\n            // for each digit, we count the number of appearance in the array\\n            for (int j = 0; j < nums.length; j++){\\n                digit[i]+= (nums[j]>>i)&1; // get the value (0 or 1) at ith digit of nums[j]\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1771908,
                "title": "c-simplest-solution-bit-manipulation-o-n",
                "content": "Given an array in which each number repeats thrice, except for one, we need to find and return it using O(n) time & constant space.\\n\\n**APPROACH :**\\n\\n* Since all the elements in the array are positive integers, we can traverse all the 32 bits & check if the number of elements this bit is set in is a multiple of 3.\\n* If not, then that bit is set in the single number too.\\n* So we ```OR``` the answer with the bit.\\n\\n\\n**How to get a single bit set in all 32 bits :** 1<<i  (Left shift operator to set only the ```i```th bit)\\n\\n**How to check if that bit is set in any element ```n``` of nums :** Do n & (1<<i) (Since ```AND``` results in zero for any combination except ```1&1```, we get ```1``` if that bit is set and ```0``` otherwise).\\n\\n**How to add that bit to the ans (the final single number we\\'re going to return) :** Just ```OR``` ```(1<<i)``` with the answer ( The ```OR``` operation can set any single bit in a number).\\n\\n\\n\\n**Time Complexity :** O(32n) == O(n)\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int check, count, ans = 0;\\n        for(int i=0; i<=31; i++){\\n            check = 1<<i, count=0;\\n            for(auto n : nums) if(n & check) count++;\\n            if(count%3) ans |= check;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if you\\'ve found my solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```OR```\n```i```\n```n```\n```AND```\n```1&1```\n```1```\n```0```\n```OR```\n```(1<<i)```\n```OR```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int check, count, ans = 0;\\n        for(int i=0; i<=31; i++){\\n            check = 1<<i, count=0;\\n            for(auto n : nums) if(n & check) count++;\\n            if(count%3) ans |= check;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43396,
                "title": "o-n-solution-c",
                "content": "    int singleNumber(int* nums, int numsSize) {\\n        // idea : iterate over all elements in array for every bit, get sum of all 1s, \\n        // bits with sum not multiple of 3, are 1's bit in the single occurance element\\n        // e.g. , 5,5,5,2 - 101 101 101 010 - 313 - answer is 3%3,1%3,3%3 - 010\\n        \\n        int x, res = 0;\\n        \\n        for(int i = 0; i < sizeof(int)*8; i++){\\n            x = 1 << i;\\n            int sum = 0;\\n            for(int j = 0; j < numsSize; j++){\\n                if(x & nums[j]) sum++;\\n            }\\n            \\n            if(sum % 3) res = res | x;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    int singleNumber(int* nums, int numsSize) {\\n        // idea : iterate over all elements in array for every bit, get sum of all 1s, \\n        // bits with sum not multiple of 3, are 1's bit in the single occurance element\\n        // e.g. , 5,5,5,2 - 101 101 101 010 - 313 - answer is 3%3,1%3,3%3 - 010\\n        \\n        int x, res = 0;\\n        \\n        for(int i = 0; i < sizeof(int)*8; i++){\\n            x = 1 << i;\\n            int sum = 0;\\n            for(int j = 0; j < numsSize; j++){\\n                if(x & nums[j]) sum++;\\n            }\\n            \\n            if(sum % 3) res = res | x;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3715134,
                "title": "single-line-mathematical-solution-beats-100",
                "content": "# Approach\\n- Find all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)\\n- Now substract the sum of original list of nums, which gives total as 2*(number which repeats only once)\\n\\n(Note: This solution works for this particular problem but don\\'t use where it says to use constant space as sets space complexity in worst case is $$O(n)$$, Thank you)\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return ((3*sum((set(nums))))-sum(nums))//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return ((3*sum((set(nums))))-sum(nums))//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43412,
                "title": "python-bit-manipulation-with-more-general-case",
                "content": "    class Solution(object):\\n        def singleNumber(self, nums):\\n            one, two = 0, 0\\n            for x in nums:\\n                one, two, three = one ^ x, two | (one & x), two & x\\n                one, two = one & ~three, two & ~three\\n            return one\\n\\nActually, this approach can be generalized for the case that each number appears 5 times except one:\\n\\n    class Solution(object):\\n        def singleNumber(self, nums):\\n            one = two = three = four = 0\\n            for x in nums:\\n                one, two, three, four, five = one ^ x, two | (one & x), three | (two & x), four | (three & x), four & x\\n                one, two, three, four = one & ~three & ~five, two & ~three, three & ~four, four & ~five\\n            return one\\n\\nIf each number appears 5 times except that one number appears only 3 times, `return three` will be the result",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "    class Solution(object):\\n        def singleNumber(self, nums):\\n            one, two = 0, 0\\n            for x in nums:\\n                one, two, three = one ^ x, two | (one & x), two & x\\n                one, two = one & ~three, two & ~three\\n            return one\\n\\nActually, this approach can be generalized for the case that each number appears 5 times except one:\\n\\n    class Solution(object):\\n        def singleNumber(self, nums):\\n            one = two = three = four = 0\\n            for x in nums:\\n                one, two, three, four, five = one ^ x, two | (one & x), three | (two & x), four | (three & x), four & x\\n                one, two, three, four = one & ~three & ~five, two & ~three, three & ~four, four & ~five\\n            return one\\n\\nIf each number appears 5 times except that one number appears only 3 times, `return three` will be the result",
                "codeTag": "Java"
            },
            {
                "id": 3715000,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/o-CSM80MPvk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for(int e : nums) {\\n            ones = ((ones ^ e) & (~ twos));  \\n            twos = ((twos ^ e) & (~ ones)); \\n        }\\n        return ones;  \\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(std::vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n        for (int e : nums) {\\n            ones = ((ones ^ e) & (~twos));\\n            twos = ((twos ^ e) & (~ones));\\n        }\\n        return ones;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ones = 0\\n        twos = 0\\n        for e in nums:\\n            ones = (ones ^ e) & (~twos)\\n            twos = (twos ^ e) & (~ones)\\n        return ones\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for(int e : nums) {\\n            ones = ((ones ^ e) & (~ twos));  \\n            twos = ((twos ^ e) & (~ ones)); \\n        }\\n        return ones;  \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(std::vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n        for (int e : nums) {\\n            ones = ((ones ^ e) & (~twos));\\n            twos = ((twos ^ e) & (~ones));\\n        }\\n        return ones;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ones = 0\\n        twos = 0\\n        for e in nums:\\n            ones = (ones ^ e) & (~twos)\\n            twos = (twos ^ e) & (~ones)\\n        return ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43442,
                "title": "short-java-code-with-bit-summation-and-modulo-3",
                "content": "274ms, not quite fast, can be any faster?\\n\\nanother question, the problem should clarify that the single number only appears once (not twice)\\n\\n\\n    public class Solution {\\n        public int singleNumber(int[] A) {\\n            /*\\n            element in A is 32bit,\\n            sum corresponding bits from all elements and mod each by 3 then should left the single number\\n            */\\n            int[] sum=new int[32];\\n            int res=0;\\n            for(int i=0;i<32;i++)\\n            {\\n                for(int j=0;j<A.length;j++)\\n                {\\n                    sum[i]+=((A[j]>>>i)&1);//sum every bit of all numbers\\n                }\\n                sum[i]%=3;\\n                res+=((sum[i]&1)<<i);// recover the single number\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            /*\\n            element in A is 32bit,\\n            sum corresponding bits from all elements and mod each by 3 then should left the single number\\n            */\\n            int[] sum=new int[32];\\n            int res=0;\\n            for(int i=0;i<32;i++)\\n            {\\n                for(int j=0;j<A.length;j++)\\n                {\\n                    sum[i]+=((A[j]>>>i)&1);//sum every bit of all numbers\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 749087,
                "title": "multiple-approaches-explained-worst-to-best",
                "content": "**1. Sorting O(nlogn) time, space O(1)**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)return nums[0];\\n        sort(nums.begin(), nums.end());\\n        \\n        //edge case: when the single no is at one of any end of the cluster\\n        if(nums[0] != nums[1])return nums[0];\\n        if(nums[n-1] != nums[n-2])return nums[n-1];\\n        \\n        // when the single no is in the middle of the cluster\\n        int i = 1;\\n        while(i < n){\\n            if(nums[i] != nums[i-1]){\\n                return nums[i-1];\\n            }\\n            i += 3;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**2. Hashtable O(n) space and time**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int>m;\\n        for(int num: nums)m[num]++;\\n        for(auto i: m){\\n            if(i.second == 1)return i.first;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**3. Taking the count at each bit position, time O(n) space O(1)**\\n\\n**Approach**: Just take the sum of each ofthe 32 bit position and keep adding the sum%3 in the result. If the sum is divisible is 3, then the ith bit in the single no is 0, else 1.\\n\\nExample : Let us consider the example array {5, 5, 5, 8}. The 101, 101, 101, 1000\\n* Sum of first bits%3 = (1 + 1 + 1 + 0)%3 = 0;\\n* Sum of second bits%3 = (0 + 0 + 0 + 0)%0 = 0;\\n* Sum of third bits%3 = (1 + 1 + 1 + 0)%3 = 0;\\n* Sum of fourth bits%3 = (1)%3 = 1;\\n\\n*Hence number which appears once is 1000*\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i = 0; i < 32; ++i){\\n            int bitCount = 0;\\n            for(int num: nums){\\n                bitCount += ((num >> i)&1); // for first bit, right shift num by 0 and for 2nd bit, right shift num by 1 and so on...\\n            }\\n            if(bitCount%3){\\n                result |= (1<<i); // left shift 1 by i bit starting from 0\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n**4. Smart bit manipulation time O(n) space O(1)**\\n**Approach** : ones will contain the no appearing once, and twos will contain the no appearing twice. \\nExample : 2, 2, 5, 2\\n* 2: ones = 2, twos = 0 (ones will get 2, and twos won\\'t get 2 since ones had 2 already)\\n* 2: ones = 0, twos = 2 (ones will get 2 but ones = 2^2 = 0, hence twos will get 2)\\n* 5: ones = 5, twos = 2 (ones will get 5 and twos will not get 5 since ones had 5 already)\\n* 2: ones = 5, twos = 0 (ones won\\'t get 2, since twos already had 2. And twos will get 2 but it had already 2. Hence twos = 2^2 = 0)\\n\\n*Hence the no which appears thrice is not in any of the two. ones will have the final answer. And twos will be 0 finally. Since all the no either appears thrice or once.*\\n```\\nclass Solution {\\npublic:    \\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n         for(int num: nums){\\n             ones = (ones ^ num) & (~twos);\\n             twos = (twos ^ num) & (~ones);\\n         }\\n        return ones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)return nums[0];\\n        sort(nums.begin(), nums.end());\\n        \\n        //edge case: when the single no is at one of any end of the cluster\\n        if(nums[0] != nums[1])return nums[0];\\n        if(nums[n-1] != nums[n-2])return nums[n-1];\\n        \\n        // when the single no is in the middle of the cluster\\n        int i = 1;\\n        while(i < n){\\n            if(nums[i] != nums[i-1]){\\n                return nums[i-1];\\n            }\\n            i += 3;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int>m;\\n        for(int num: nums)m[num]++;\\n        for(auto i: m){\\n            if(i.second == 1)return i.first;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i = 0; i < 32; ++i){\\n            int bitCount = 0;\\n            for(int num: nums){\\n                bitCount += ((num >> i)&1); // for first bit, right shift num by 0 and for 2nd bit, right shift num by 1 and so on...\\n            }\\n            if(bitCount%3){\\n                result |= (1<<i); // left shift 1 by i bit starting from 0\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0, twos = 0;\\n         for(int num: nums){\\n             ones = (ones ^ num) & (~twos);\\n             twos = (twos ^ num) & (~ones);\\n         }\\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548323,
                "title": "python-bit-manipulation-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n            This question can be solved using bit manipulation.\\n            If any number is occuring 3 times then the count of every set bit of that number will also be 3.\\n            For example, let\\'s say we have 5,5,5 then,\\n            Binary representation is 101,101,101.\\n            We can see that the count of 0th and 2nd bit will be 3.\\n            Now if another number comes, let\\'s say 4(100) then the count of every set bit will be:\\n                0th: 3\\n                2nd: 4\\n            \\n            So by using the above logic if we get a count of each set bit for all the numbers and take modulo of 3 for each bit then the resulting number would be our answer.\\n            Like in above example, count of each bit became 4, 0, 3 and if we take % 3 then it will become 1,0,0 and 100 is 4(our answer).\\n            \\n        \"\"\"\\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                temp = n >> i\\n                temp = temp & 1\\n                count += temp\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n            This question can be solved using bit manipulation.\\n            If any number is occuring 3 times then the count of every set bit of that number will also be 3.\\n            For example, let\\'s say we have 5,5,5 then,\\n            Binary representation is 101,101,101.\\n            We can see that the count of 0th and 2nd bit will be 3.\\n            Now if another number comes, let\\'s say 4(100) then the count of every set bit will be:\\n                0th: 3\\n                2nd: 4\\n            \\n            So by using the above logic if we get a count of each set bit for all the numbers and take modulo of 3 for each bit then the resulting number would be our answer.\\n            Like in above example, count of each bit became 4, 0, 3 and if we take % 3 then it will become 1,0,0 and 100 is 4(our answer).\\n            \\n        \"\"\"\\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                temp = n >> i\\n                temp = temp & 1\\n                count += temp\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217292,
                "title": "big-but-clear-solution-explained-counter-conditions-properly-o-n-time-o-1-space",
                "content": "**Special cases which can give runtime error are solved**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int> bits(32, 0);\\n        \\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            long long int n = abs(nums[i]);      // number can be large so to avoid overflow take long long int. Also the taken integer can be negative so to avoid ambiguity and complexity of code take absolute value of the number\\n            int j = 0;\\n            while(n)\\n            {\\n                if((n & 1) == 1)\\n                    ++bits[j];\\n                \\n                ++j;\\n                n >>= 1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < bits.size(); ++i)\\n        {\\n            if((bits[i] % 3) == 0)\\n                bits[i] = 0;\\n            else\\n                bits[i] = 1;\\n        }\\n        \\n        long long int res = 0;     // result can be large so to avoid overflow take long long int\\n        \\n        for(int i = 0; i < bits.size(); ++i)\\n        {\\n            if(bits[i] == 1)\\n                res += (1 * pow(2, i));\\n            else\\n                continue;\\n        }\\n        \\n\\t\\t//since our result can be negative or positive. We have solved the problem for positive consideration. But it can be possible that our result may be present both in positive and negative form\\n\\t\\t// example: [-2,-2,1,1,4,1,4,4,-4,-2]\\n\\t\\t//So the below lines will help us to give our final result\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(res == nums[i])\\n                ++count;\\n        }\\n        \\n        return (count == 1 ? res : (-res));\\n    }\\n};\\n```\\n\\nI have tried my best to explain the things which were not explained in the other solutions properly. If you have any doubts then feel free to comment it I will try to explain it more. Also if u have find it useful then plz upvote.\\nsorry for any mistakes",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int> bits(32, 0);\\n        \\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            long long int n = abs(nums[i]);      // number can be large so to avoid overflow take long long int. Also the taken integer can be negative so to avoid ambiguity and complexity of code take absolute value of the number\\n            int j = 0;\\n            while(n)\\n            {\\n                if((n & 1) == 1)\\n                    ++bits[j];\\n                \\n                ++j;\\n                n >>= 1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < bits.size(); ++i)\\n        {\\n            if((bits[i] % 3) == 0)\\n                bits[i] = 0;\\n            else\\n                bits[i] = 1;\\n        }\\n        \\n        long long int res = 0;     // result can be large so to avoid overflow take long long int\\n        \\n        for(int i = 0; i < bits.size(); ++i)\\n        {\\n            if(bits[i] == 1)\\n                res += (1 * pow(2, i));\\n            else\\n                continue;\\n        }\\n        \\n\\t\\t//since our result can be negative or positive. We have solved the problem for positive consideration. But it can be possible that our result may be present both in positive and negative form\\n\\t\\t// example: [-2,-2,1,1,4,1,4,4,-4,-2]\\n\\t\\t//So the below lines will help us to give our final result\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(res == nums[i])\\n                ++count;\\n        }\\n        \\n        return (count == 1 ? res : (-res));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205709,
                "title": "137-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe use two variables ones and twos to keep track of the bits that appear once and twice respectively. Initially, both variables are set to 0.\\n\\nFor each number in the input list, we update the variables as follows:\\n\\nones is updated by XORing it with the current number and then ANDing it with the complement of twos.\\nThis ensures that only the bits that appear once are set in ones.\\ntwos is updated by XORing it with the current number and then ANDing it with the complement of ones.\\nThis ensures that only the bits that appear twice are set in twos.\\nFinally, we return the value of ones, which represents the single number that appears once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ones = 0\\n        twos = 0\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        return ones\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ones = 0\\n        twos = 0\\n        for num in nums:\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        return ones\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938486,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var a = 0\\n        var b = 0\\n        \\n        for num in nums {\\n            let newA = a & ~b & ~num + ~a & b & num\\n            let newB = ~a & b & ~num + ~a & ~b & num\\n            \\n            (a, b) = (newA, newB)\\n        }\\n        \\n        return a | b\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var a = 0\\n        var b = 0\\n        \\n        for num in nums {\\n            let newA = a & ~b & ~num + ~a & b & num\\n            let newB = ~a & b & ~num + ~a & ~b & num\\n            \\n            (a, b) = (newA, newB)\\n        }\\n        \\n        return a | b\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43334,
                "title": "python-constant-space-solution-bit-manipulation",
                "content": "```\\n    def singleNumber(self, nums):\\n        res = 0\\n        for i in xrange(32):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            rem = count % 3\\n            if i == 31 and rem:\\n                res -= 1 << 31\\n            else:\\n                res |= rem * (1 << i)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def singleNumber(self, nums):\\n        res = 0\\n        for i in xrange(32):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            rem = count % 3\\n            if i == 31 and rem:\\n                res -= 1 << 31\\n            else:\\n                res |= rem * (1 << i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1110333,
                "title": "3-python-solutions-with-different-approaches",
                "content": "Bit Manupulation:\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        a, b = 0, 0\\n        for x in nums:\\n            a, b = (~x&a&~b)|(x&~a&b), ~a&(x^b)\\n        return b\\n```\\nHashing:\\n```\\n    class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for a,b in d.items():\\n            print(a,b)\\n            if b == 1:\\n                return a\\n```\\nArray Sum\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        a = sum(nums) - 3*sum(set(list(nums)))\\n        return (-a)//2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        a, b = 0, 0\\n        for x in nums:\\n            a, b = (~x&a&~b)|(x&~a&b), ~a&(x^b)\\n        return b\\n```\n```\\n    class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        for a,b in d.items():\\n            print(a,b)\\n            if b == 1:\\n                return a\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        a = sum(nums) - 3*sum(set(list(nums)))\\n        return (-a)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709864,
                "title": "python-98-9-faster-one-line-code-explain-in-details",
                "content": "\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\t# Let the numbers be x,y,z,.....\\n\\t\\t\\t# require sum should be 3x+3y+3z\\n\\t\\t\\t# original sum = 3x+3y+z\\n\\t\\t\\t# Subtract require sum from original sum\\n\\t\\t\\t# (3x+3y+3z) - (3x+3y-z) = 2z\\n\\t\\t\\t# div the ans by 2 = 2z/2 = z--> our ans\\n\\n\\t\\t\\treturn (3 * sum(set(nums)) - sum(nums)) // 2\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\t# Let the numbers be x,y,z,.....\\n\\t\\t\\t# require sum should be 3x+3y+3z\\n\\t\\t\\t# original sum = 3x+3y+z\\n\\t\\t\\t# Subtract require sum from original sum\\n\\t\\t\\t# (3x+3y+3z) - (3x+3y-z) = 2z\\n\\t\\t\\t# div the ans by 2 = 2z/2 = z--> our ans\\n\\n\\t\\t\\treturn (3 * sum(set(nums)) - sum(nums)) // 2\\n",
                "codeTag": "Java"
            },
            {
                "id": 43387,
                "title": "java-o-n-time-with-o-1-space-by-bit-manipulation",
                "content": "    public int singleNumber(int[] nums) {\\n        int[] digits = new int[32];\\n        for(int i=0; i<nums.length; i++){\\n            int mask = 1;\\n            for(int j=31; j>=0; j--){\\n                if((mask & nums[i])!=0)\\n                    digits[j] ++;\\n                mask <<= 1;\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<32; i++){\\n            if(digits[i]%3==1)\\n                res += 1;\\n            if(i==31)\\n                continue;\\n            res <<= 1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n        int[] digits = new int[32];\\n        for(int i=0; i<nums.length; i++){\\n            int mask = 1;\\n            for(int j=31; j>=0; j--){\\n                if((mask & nums[i])!=0)\\n                    digits[j] ++;\\n                mask <<= 1;\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<32; i++){\\n            if(digits[i]%3==1)\\n                res += 1;\\n            if(i==31)\\n                continue;\\n            res <<= 1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3091160,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int bit=1<<i;\\n            int c=0;\\n            for(int j:nums)\\n            {\\n                if(j&bit)\\n                c++;\\n            }\\n            if(c%3)\\n            ans|=bit;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int bit=1<<i;\\n            int c=0;\\n            for(int j:nums)\\n            {\\n                if(j&bit)\\n                c++;\\n            }\\n            if(c%3)\\n            ans|=bit;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755642,
                "title": "explanation-of-bit-manipulation-solution-as-easy-as-pie",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int o = 0, t = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int x = nums[i];\\n            // int oo = ((~t) & o & (~x)) | ((~t) & (~o) & x); // position of this statement doesn\\'t matter\\n            int tt = (t & (~o) & (~x)) | ((~t) & o & x);\\n            int oo = ((~t) & o & (~x)) | ((~t) & (~o) & x);\\n            \\n            o = oo;\\n            t = tt;\\n        }\\n        return o;  \\n    }\\n}\\n```\\n\\nHey we have done a similar problem [All repeating twice except one](https://leetcode.com/problems/single-number/)\\nLet\\u2019s look at that first to draw some insights\\n\\nLet\\u2019s consider the following scenario\\n```\\ni           arr[i]                          Implication\\n0            3               I have seen 3 for the first time\\n1            3               I have seen 3 for the second time\\n                             => no more 3 to be seen again \\n                             => don\\u2019t worry about 3, no need to remember ever seeing it\\n                             => How can we forget about something when it has appeared twice ( or even number of times) ?\\n                             => So the transition of states is something like 0 -> 1 -> again 0 -> again 1 and so on\\n                             => Isn\\u2019t this the behaviour of XOR ? yes\\n```\\nLet\\u2019s try  XOR\\n\\nLet X = 0 => I have not seen any element yet\\n```\\ni         arr[i]           Binary form of arr[i]                  XORresult = X ^ arr[i]\\n0          3                     011                                        011                             ( 0 ^ N = N)\\n1          3                     011                                        000                             ( N ^ N = 0)\\n2          4                     100                                        100 \\n```\\nFinal XORresult -> 100 which is 4 which is the element which appeared only once\\nThus our train of thoughts seem correct\\n\\n\\nSo now let\\u2019s try thinking on the same lines for the problem [All repeating thrice except once](https://leetcode.com/problems/single-number-ii/)\\n\\nThinking on the same lines, we\\u2019ll use XOR for this problem too to transition from one state to another \\n```\\ni                    arr[i]                     Implication\\n0                      3               I have seen 3 for the first time\\n1                      3               I have seen 3 for the second time\\n2                      3               I have seen 3 for the third time\\n                                       => I don\\u2019t want to remember ever seeing it\\n                                       => So the transition of states is something like 0 -> 1 -> 2 -> again 0 and so on\\n```\\n\\nIn the previous problem only two states were involved (state 0, state 1) so we needed only one bit/flag ( XORresult )  to track the transition of states ( as only one bit is required to express 1 in binary)\\n\\nBut in this problem three states (state 0, state 1, state 2) are involved and since 2 bits are required to express 2 in binary, so we need two flags this time. Let\\u2019s call them  \\u201Co\\u201D, \\u201Ct\\u201D.\\n \\u201Cto\\u201D together tell us about the state.\\n\\nTo be noted : ^ ( XOR) is a bitwise operation\\nXOR rule -> low when both inputs are alike else high\\n\\nSo let\\u2019s try to understand what might be happening at the bit level\\n\\nCase 1\\n```\\nith bit of Incoming no. x :                           0 \\n\\nith bit of Current t                                  1  \\nith bit of Current o                                  0    // note: \\u201Cto\\u201D can be either of 00,01,10 i.e state 0,1,2\\n\\nith bit of New t after t ^ x                          1 \\nith bit of New o after o ^ x                          0\\n```\\nRemarks: No change in t, o cuz 0 ^ 0 = 0 , 1 ^ 0 = 1\\n\\n\\nCase 2\\n```\\nith bit of Incoming no. x :                           1\\n\\nith bit of Current t                                  0      \\nith bit of Current o                                  1          \\n\\nith bit of New t after t ^ x                          1 \\nith bit of New o after o ^ x                          0\\n```\\nRemarks: \\u201Cto\\u201D changed from 01 to 10 i.e state 1 to state 2\\n\\n\\nSince XOR is performed for each bit independently, truth table can be prepared even by seeing state transition of just a single bit\\n\\n```\\n  Col 0                Col 1             Col 2                     Col 3                          Col 4\\nith bit of           ith bit of        ith bit of             ith bit of new                 ith bit of new                     State change\\n    t                    o                  x                        t                              o                              of \\u201Cto\\u201D\\n\\n\\n    0                    0                  0                        0                              0                              No change\\n    0                    1                  0                        0                              1                              No change\\n    1                    0                  0                        1                              0                              No change\\n    0                    0                  1                        0                              1                              00 -> 01\\n    0                    1                  1                        1                              0                              01 -> 10\\n    1                    0                  1                        0                              0                              10 -> 00\\n```\\nLooking at columns 0,1,2,3\\nt = (t & (~o) & (~x)) | ((~t) & o & x)\\n\\nLooking at columns 0,1,2,4\\no = ((~t) & o & (~x)) | ((~t) & (~o) & x)\\n\\nMaybe the above expressions can be simplified. But why do that? Interview duration is limited right?\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int o = 0, t = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int x = nums[i];\\n            // int oo = ((~t) & o & (~x)) | ((~t) & (~o) & x); // position of this statement doesn\\'t matter\\n            int tt = (t & (~o) & (~x)) | ((~t) & o & x);\\n            int oo = ((~t) & o & (~x)) | ((~t) & (~o) & x);\\n            \\n            o = oo;\\n            t = tt;\\n        }\\n        return o;  \\n    }\\n}\\n```\n```\\ni           arr[i]                          Implication\\n0            3               I have seen 3 for the first time\\n1            3               I have seen 3 for the second time\\n                             => no more 3 to be seen again \\n                             => don\\u2019t worry about 3, no need to remember ever seeing it\\n                             => How can we forget about something when it has appeared twice ( or even number of times) ?\\n                             => So the transition of states is something like 0 -> 1 -> again 0 -> again 1 and so on\\n                             => Isn\\u2019t this the behaviour of XOR ? yes\\n```\n```\\ni         arr[i]           Binary form of arr[i]                  XORresult = X ^ arr[i]\\n0          3                     011                                        011                             ( 0 ^ N = N)\\n1          3                     011                                        000                             ( N ^ N = 0)\\n2          4                     100                                        100 \\n```\n```\\ni                    arr[i]                     Implication\\n0                      3               I have seen 3 for the first time\\n1                      3               I have seen 3 for the second time\\n2                      3               I have seen 3 for the third time\\n                                       => I don\\u2019t want to remember ever seeing it\\n                                       => So the transition of states is something like 0 -> 1 -> 2 -> again 0 and so on\\n```\n```\\nith bit of Incoming no. x :                           0 \\n\\nith bit of Current t                                  1  \\nith bit of Current o                                  0    // note: \\u201Cto\\u201D can be either of 00,01,10 i.e state 0,1,2\\n\\nith bit of New t after t ^ x                          1 \\nith bit of New o after o ^ x                          0\\n```\n```\\nith bit of Incoming no. x :                           1\\n\\nith bit of Current t                                  0      \\nith bit of Current o                                  1          \\n\\nith bit of New t after t ^ x                          1 \\nith bit of New o after o ^ x                          0\\n```\n```\\n  Col 0                Col 1             Col 2                     Col 3                          Col 4\\nith bit of           ith bit of        ith bit of             ith bit of new                 ith bit of new                     State change\\n    t                    o                  x                        t                              o                              of \\u201Cto\\u201D\\n\\n\\n    0                    0                  0                        0                              0                              No change\\n    0                    1                  0                        0                              1                              No change\\n    1                    0                  0                        1                              0                              No change\\n    0                    0                  1                        0                              1                              00 -> 01\\n    0                    1                  1                        1                              0                              01 -> 10\\n    1                    0                  1                        0                              0                              10 -> 00\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715332,
                "title": "c-beginner-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=31;i>=0;i--){\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j]>>i) & 1){\\n                    count++;\\n                }\\n            }\\n            if(count%3){\\n                ans += (1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/b21242bd-f420-41e4-a889-7ad56df93f59_1688443496.2088463.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=31;i>=0;i--){\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j]>>i) & 1){\\n                    count++;\\n                }\\n            }\\n            if(count%3){\\n                ans += (1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715267,
                "title": "easy-c-code-highly-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(32*N)~=O(N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<32; i++){     //0(32*N)\\n            int t=0;\\n            for(int j=0; j<nums.size(); j++){\\n                t+=(nums[j]&1);\\n                nums[j]>>=1;\\n            }\\n            ans+=((t%3)<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<32; i++){     //0(32*N)\\n            int t=0;\\n            for(int j=0; j<nums.size(); j++){\\n                t+=(nums[j]&1);\\n                nums[j]>>=1;\\n            }\\n            ans+=((t%3)<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714943,
                "title": "bitwise-operations-python-js-solution",
                "content": "Hello **Tenno leetcoders**, \\n\\nWe are given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return a solution with a linear runtime complexity and use only constant extra space.\\n\\n### Explanation\\n\\nThe problem requires finding the single element that appears exactly once in the nums array, where all other elements appear three times.\\n\\nSince we need constant space and linear time, we can rely on bitwise XOR `^`, AND `&`, OR `|`, NOT `~`\\n\\n#### XOR operation\\n\\n- The bitwise XOR operation returns 1 if the corresponding bits are different and 0 if they are the same\\n\\n- The bitwise XOR operation will be used to update our ones variable as it helps keep track of the bits that have appeared once\\n\\n- When we perform `ones ^= num`, the XOR operation toggles the bits in `ones` that are in `num` to ensure that the ones variable stores the bits that have appeared only once across the numbers encountered so far \\n\\n\\n#### AND operation\\n\\n- The bitwise AND operation returns 1 only if both corresponding bits are 1; otherwise, it returns 0.\\n\\n- The bitwise AND operation is used to update the twos variable by performing `twos |= ones & num`. This represents the operation which adds the bits that are set in both `ones` and `num` to `twos` to ensure that twos keep track of the bits that have appeared twice\\n\\n- Also the AND operation is used to clear the bits that have appeared three times in both `ones` and `twos`. By performing,\\n`ones &= ~threes` and `twos &= ~threes`, it clears the bits that are set in `threes` from both `ones` and `twos`\\n\\n\\n####  OR operation\\n\\n- The bitwise OR operation returns 1 if at least one of the corresponding bits is 1; otherwise, it returns 0.\\n\\n- the bitwise OR operation is used to update the twos variable. By perform `twos |= ones & num`, the operation combines the bits that are set in both `ones` and `num`, adding them to `twos` to ensure that twos accumulates the bits that have appeared twice\\n\\n\\n#### NOT operation\\n\\n- The bitwise NOT operation flips the bits, changing 0s to 1s and 1s to 0s.\\n\\n- The bitwise NOT operation is used to clear the bits that have appeared three times.\\n\\n- Our threes temporary variable is used to clear the bits that have appeared three times between `ones` and `twos` using the AND operator. These two operations find the bits that are set in both `ones` and `twos`, indicating the bits that have appeared three times\\n\\n- By performing `ones &= ~threes` and `twos &= ~threes`, the NOT operation is applied to `threes` to help clear the bits that are set in `threes` from both `ones` and `twos`, which help remove the bits that have appeared three times\\n\\n\\n#### Solution\\n\\n- Initialize two variables, ones and twos and set it to `0`. This will help represent and keep track of bits that have appeared once or twice\\n\\n- Iterate through each number `num` in the nums array.\\n\\n    - Update twos variable by performing a bitwise OR operation between the twos and the bits that are set in both ones and the current number as it will help accumulate the bits that have appeared twice\\n        \\n    - Update ones variable by performing a bitwise XOR operations between ones and the current number as it toggles the bits in ones that are set in num to help keep track of bits that have appeared once\\n        \\n        \\n    - At this point, both ones and twos may contain some bits that have appeared three times. We need to clear these bits.\\n        \\n        \\n    - To help clear the bits which appeared three times, we use a temporary variable threes and set it as bitwise AND of ones and twos as it helps identifies the bits that are set in both ones and twos, indicating the bits have appeared three times\\n        \\n        \\n    - To clear the bits, we perform bitwise NOT operation on threes and also apply bitwise AND operation with ones and two to help clear the bits that have appeared three times. \\n        \\n\\n- At the end of the loops, `ones` will contain the bits of the single element that appeared exactly ones\\n\\n\\n\\n# Code\\n\\n**Python**\\n```\\n  def singleNumber(self, nums: List[int]) -> int:\\n\\n        ones = 0  \\n        twos = 0  \\n\\n        for num in nums:\\n\\n            twos |= ones & num\\n            ones ^= num\\n            \\n            threes = ones & twos\\n            ones &= ~threes\\n            twos &= ~threes\\n\\n        return ones\\n```\\n\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n\\n    let ones = 0\\n    let twos = 0\\n\\n    for(let num of nums){\\n        twos |= ones & num\\n        ones ^= num\\n\\n        threes = ones & twos\\n        ones &= ~threes\\n        twos &= ~threes\\n    }\\n    return ones\\n};\\n```\\n### Time Complexity: O(n)\\n### Space Complexity: O(1)\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n  def singleNumber(self, nums: List[int]) -> int:\\n\\n        ones = 0  \\n        twos = 0  \\n\\n        for num in nums:\\n\\n            twos |= ones & num\\n            ones ^= num\\n            \\n            threes = ones & twos\\n            ones &= ~threes\\n            twos &= ~threes\\n\\n        return ones\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n\\n    let ones = 0\\n    let twos = 0\\n\\n    for(let num of nums){\\n        twos |= ones & num\\n        ones ^= num\\n\\n        threes = ones & twos\\n        ones &= ~threes\\n        twos &= ~threes\\n    }\\n    return ones\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3714938,
                "title": "c-more-intuitive-bit-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are more sophiscated bit manipuation solutions out there; however, those solution were not intuitive for me. This solution takes more time and more space, but it is more intuitive and reasonable to come up with during an interview.\\n\\nIntuition is that we remove all numbers that repeat $3$ times. However, there are too man numbers thus we will remove bits that repeat $3$ times. \\n\\nThere are only $32$ bits in `int`, thus we would only need array of size $32$.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFor each number $x$ in `nums`, we we check the $i$th bit, and incerement `arr[i]` if the bit is set to 1.  \\n\\nAfter the scan of `nums`, we know the number $1$\\'s in $i$th bits in `nums`. If `arr[i]` is divisible by 3, then we know the single number\\'s $i$th bit is 0. If `arr[i]` is not divisible by 3, then we know the single number\\'s $i$th bit is 1. We scan $arr$ to figure out the single number.\\n\\nHere\\'s the example with `nums` = $[2, 2, 5, 2]$. For similicity we will consider $4$ bits instead of $32$.\\n\\nNote that $2$\\'s bit is $0 0 10$, whereas $5$\\'s bit is $0101$.\\n\\nAfter scanning the first number ($2$), the array has value $[0,0,1,0]$.\\nAfter scanning the second number ($2$), the array has value $[0,0,2,0]$.\\nSimilarly scanning $5$ gives $[0,1,2,1]$, Then scanning $2$ gives $[0,1,3,1]$.\\n\\n $2$ $=$ $0$ $0$ $1$ $0$\\n $2$ $=$ $0$ $0$ $1$ $0$\\n $5$ $=$ $0$ $1$ $0$ $1$\\n $2$ $=$ $0$ $0$ $1$ $0$\\n $arr.$ $0$ $1$ $3$ $1$ \\n\\nSince `arr[0]` and `arr[2]` are divisible by 3 and `arr[1]` and `arr[3]` are not divisible by 3, we get result of $0101$ which is $5$ as we expected.\\n\\n# Complexity\\n- Time complexity: $O(N)$. We scan the input array once $O(N)$, then we scan `arr` which has size 32 $O(1)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$, our array stores 32 integers, therefore it is constant. However, if the memroy is a bigger concern, you can reduce size of the array by using uint8_t or even smaller struct, we just have to maintain number of bits mod 3.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        uint32_t arr[32] = {0};\\n\\n        for (int x : nums) {\\n            for (int ii = 0; ii < 32; ++ii) {\\n                arr[ii] += x&1;\\n                x >>= 1;\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int ii = 31; ii >= 0; --ii) {\\n            res <<= 1;\\n            if (arr[ii] % 3 != 0) {\\n                res |= 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n# Comments\\nIf you\\'re interviewing for a place where bit manipulation are not important, the interviewee would not expect you to come up with complicated bit manipulation solution. Therefore, coming with simple solution like this would give you good enough impression. Also if you can mention how we can improve space complexty from here, the interview would go smoothly.\\n\\nMy explanation is not perfect, but hope this gives people different ways to think about this problem.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        uint32_t arr[32] = {0};\\n\\n        for (int x : nums) {\\n            for (int ii = 0; ii < 32; ++ii) {\\n                arr[ii] += x&1;\\n                x >>= 1;\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int ii = 31; ii >= 0; --ii) {\\n            res <<= 1;\\n            if (arr[ii] % 3 != 0) {\\n                res |= 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396124,
                "title": "99-5-faster-python-one-liner-very-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/8c211ead-22e1-4bdc-8a7f-d2cc3b46ee4c_1659935676.8670282.png)\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(list(set(nums))*3)-sum(nums))//2\\n        \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8c211ead-22e1-4bdc-8a7f-d2cc3b46ee4c_1659935676.8670282.png)\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(list(set(nums))*3)-sum(nums))//2\\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 709160,
                "title": "java-clean-code-bits-manipulation-approach-o-n-time-complexity-0-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n\\tpublic int singleNumber (int[] nums) {\\n\\t\\t\\n\\t\\tint ones = 0;\\n\\t\\tint twos = 0;\\n\\t\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tones = (ones ^ num) & ~twos;\\n\\t\\t\\ttwos = (twos ^ num) & ~ones;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ones;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic int singleNumber (int[] nums) {\\n\\t\\t\\n\\t\\tint ones = 0;\\n\\t\\tint twos = 0;\\n\\t\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tones = (ones ^ num) & ~twos;\\n\\t\\t\\ttwos = (twos ^ num) & ~ones;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ones;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558210,
                "title": "java-easy-to-understand-o-1-space",
                "content": "First, calculate the number of 1s in each bit about each number in the input array.\\nif in one bit, the number of 1s can be divided by 3, then ths bit of result will be 0. Otherwise, it will be 1.\\nE.g. input: [2,2,3,2]\\n\\t  (2): 1 0\\n\\t  (2): 1 0\\n\\t  (3): 1 1\\n\\t  (2): 1 0\\ncount:  4 1\\nWe can see that the number of 1s in these two bits cannot be devided by 3. So, the result will be 3 (11).\\n```\\n\\tpublic int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i = 0; i < 32; i++) {// because the number of bits in Integer can be up to 32\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if((nums[j] & (1 << i)) != 0)\\n                    count++;\\n            }\\n            result = result | ((count % 3) << i);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i = 0; i < 32; i++) {// because the number of bits in Integer can be up to 32\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if((nums[j] & (1 << i)) != 0)\\n                    count++;\\n            }\\n            result = result | ((count % 3) << i);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 300081,
                "title": "java-clean-bitwise-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] arr) {\\n        int ones = 0;\\n        int twos = 0;\\n        for (int value : arr) {\\n            ones = (ones ^ value) & ~twos;\\n            twos = (twos ^ value) & ~ones;\\n        }\\n        return ones;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] arr) {\\n        int ones = 0;\\n        int twos = 0;\\n        for (int value : arr) {\\n            ones = (ones ^ value) & ~twos;\\n            twos = (twos ^ value) & ~ones;\\n        }\\n        return ones;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43424,
                "title": "another-bitwise-operation-method-for-single-numbers-with-detailed-explanation",
                "content": "I think my solution is easier to understand.\\n\\nFirst, here is my code for Single Number II\\n\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0 , threes = 0;\\n        for(int x:nums){\\n            threes = twos&x;\\n            twos = (ones&x|twos) & (~threes);\\n            ones = (ones|x)&(~threes);\\n        }\\n        return ones;\\n    }\\n\\n\\nRun a loop for all elements in array. At the end of every iteration, maintain following three values.\\n\\nthrees: The bits that have appeared 3st time or 6th time or 9th time .. etc  [times % 3 == 0 && times > 1].\\n\\ntwos: The bits that have appeared 2nd time or 5th time or 8th time .. etc.   [times % 3 >= 2 && times%3 != 0, here so times%3 == 2]\\n\\nones: The bits that have appeared 1nd/2nd time or 4th/5th time or 7th/8th time .. etc.  [times %3 >=1 && time %3 != 0, here (times %3 ==1 or times %3 == 2)]\\n\\neach iteration, when x comes\\n\\ncause pre twos is (times%3 == 2), then now threes = twos&x;\\n\\nto calculate twos, first we get the bits satify times % 3 >= 2 , it's  (ones&x|twos), then get rid of the bits that  times%3 == 2 namely threes, then twos = (ones&x|twos) & (~threes);\\n\\nto calculate ones, first we get the bits satify times % 3 >= 1, it may come from pre ones or new comer x, so it's (ones|x) , also we need to get rid of the bits that times%3 == 2 namely threes, then ones =  (ones|x)&(~threes);\\n\\nsorry for my English.\\n\\n\\n===============================================================================\\n\\nfor this problem,\\n\\nStatement of our problem: \"Given an array of integers, every element appears k (k >1) times except for one, which appears p times(p>=1, p % k != 0). Find that single one.\"\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ks = 0, k_1s = 0 ... ps=0, ... ones = 0;\\n        for(int x:nums){\\n            ks = k_1s&x;\\n            k_1s = (k_2s&x|k_1s) & (~ks);\\n            k_2s = (k_3s&x|k_2s) & (~ks);\\n            .......\\n            twos = (ones&x|twos) & (~ks);\\n            ones = (ones|x)&(~ks);\\n        }\\n        return ps;\\n    }",
                "solutionTags": [],
                "code": "I think my solution is easier to understand.\\n\\nFirst, here is my code for Single Number II\\n\\n    public int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0 , threes = 0;\\n        for(int x:nums){\\n            threes = twos&x;\\n            twos = (ones&x|twos) & (~threes);\\n            ones = (ones|x)&(~threes);\\n        }\\n        return ones;\\n    }\\n\\n\\nRun a loop for all elements in array. At the end of every iteration, maintain following three values.\\n\\nthrees: The bits that have appeared 3st time or 6th time or 9th time .. etc  [times % 3 == 0 && times > 1].\\n\\ntwos: The bits that have appeared 2nd time or 5th time or 8th time .. etc.   [times % 3 >= 2 && times%3 != 0, here so times%3 == 2]\\n\\nones: The bits that have appeared 1nd/2nd time or 4th/5th time or 7th/8th time .. etc.  [times %3 >=1 && time %3 != 0, here (times %3 ==1 or times %3 == 2)]\\n\\neach iteration, when x comes\\n\\ncause pre twos is (times%3 == 2), then now threes = twos&x;\\n\\nto calculate twos, first we get the bits satify times % 3 >= 2 , it's  (ones&x|twos), then get rid of the bits that  times%3 == 2 namely threes, then twos = (ones&x|twos) & (~threes);\\n\\nto calculate ones, first we get the bits satify times % 3 >= 1, it may come from pre ones or new comer x, so it's (ones|x) , also we need to get rid of the bits that times%3 == 2 namely threes, then ones =  (ones|x)&(~threes);\\n\\nsorry for my English.\\n\\n\\n===============================================================================\\n\\nfor this problem,\\n\\nStatement of our problem: \"Given an array of integers, every element appears k (k >1) times except for one, which appears p times(p>=1, p % k != 0). Find that single one.\"\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ks = 0, k_1s = 0 ... ps=0, ... ones = 0;\\n        for(int x:nums){\\n            ks = k_1s&x;\\n            k_1s = (k_2s&x|k_1s) & (~ks);\\n            k_2s = (k_3s&x|k_2s) & (~ks);\\n            .......\\n            twos = (ones&x|twos) & (~ks);\\n            ones = (ones|x)&(~ks);\\n        }\\n        return ps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43467,
                "title": "general-solution-constant-space",
                "content": "    class Solution {   \\n    public:\\n    int singleNumber(int A[], int n) {\\n        int sum = 0;\\n\\t\\tint result = 0;\\n\\t\\tint x = 0;\\n        int mod = 3;\\n        for(int i = 0; i < 32 ; i++){\\n\\t\\t\\tsum = 0;\\n            x = (1 << i);\\n            for(int j = 0; j < n; j++){\\n            \\tif((A[j] & x)){\\n            \\t\\tsum++;\\n            \\t}\\n            }\\n            if((sum % mod)){\\n            \\tresult |= x;\\n            }\\n        }\\n        return result;\\n      }\\n    };\\n\\nWe can sum the bits in same positions for all the numbers and take modulo 3. The bits for which sum is not multiple of 3, are the bits of number which does not occur 3 times.\\n\\nExample array {5, 5, 5, 8}.\\n\\n5 = 0101, 5 = 0101, 5 = 0101, 8 = 1000\\n\\nSum of first bits%3 = (1 + 1 + 1 + 0)%3 = 0;\\n\\nSum of second bits%3 = (0 + 0 + 0 + 0)%3 = 0;\\n\\nSum of third bits%3 = (1 + 1 + 1 + 0)%3 = 0;\\n\\nSum of fourth bits%3 = (1)%3 = 1;\\n\\nHence number which appears once is 1000\\nWe can use that method for any number of occurrences. We just need to modify the mod from 3 to anything we want.",
                "solutionTags": [],
                "code": "class Solution {   \\n    public:\\n    int singleNumber(int A[], int n) {\\n        int sum = 0;\\n\\t\\tint result = 0;\\n\\t\\tint x = 0;\\n        int mod = 3;\\n        for(int i = 0; i < 32 ; i++){\\n\\t\\t\\tsum = 0;\\n            x = (1 << i);\\n            for(int j = 0; j < n; j++){\\n            \\tif((A[j] & x)){\\n            \\t\\tsum++;\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2593094,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        long long int ans = 0, c=0;\\n\\t\\t//for every position, find out the number of set bits in the array for that particular position\\n        for(int i=31;i>=0;i--){\\n            c=0;\\n            for(int j=0;j<nums.size();j++){\\n                int temp = abs(nums[j]); //to handle negative\\n\\t\\t\\t\\t//if the bit is set increase the count\\n                if(temp & (1<<i)) c++; \\n            }   \\n\\t\\t\\t// if the count is divisible by 3 it means that the bit of our answer at that position is 0\\n\\t\\t\\t// else if the count is not divisible by 3 it means that the bit of our answer at that position is 1\\n\\t\\t\\t// whenever the bit is set we just add that number to the ans\\n            if(c%3!=0) ans+=(1<<i);   \\n        }\\n\\t\\t\\n\\t\\t//this code is to handle negative occurance of the elements \\n\\t\\t//if the abs of negative element occurs in the array\\n        c=0;\\n        for(auto i:nums) if(i==ans)c++;  \\n        if(c==1) return ans;\\n        return -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        long long int ans = 0, c=0;\\n\\t\\t//for every position, find out the number of set bits in the array for that particular position\\n        for(int i=31;i>=0;i--){\\n            c=0;\\n            for(int j=0;j<nums.size();j++){\\n                int temp = abs(nums[j]); //to handle negative\\n\\t\\t\\t\\t//if the bit is set increase the count\\n                if(temp & (1<<i)) c++; \\n            }   \\n\\t\\t\\t// if the count is divisible by 3 it means that the bit of our answer at that position is 0\\n\\t\\t\\t// else if the count is not divisible by 3 it means that the bit of our answer at that position is 1\\n\\t\\t\\t// whenever the bit is set we just add that number to the ans\\n            if(c%3!=0) ans+=(1<<i);   \\n        }\\n\\t\\t\\n\\t\\t//this code is to handle negative occurance of the elements \\n\\t\\t//if the abs of negative element occurs in the array\\n        c=0;\\n        for(auto i:nums) if(i==ans)c++;  \\n        if(c==1) return ans;\\n        return -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600128,
                "title": "i-was-confused-how-using-2-variables-is-being-used-here-is-my-explanation-for-both-the-approaches",
                "content": "First of all everyone who knows about basic bitmanipulation could easily come up with solution like counting  and storing count of each bits int array[32] (\"let it be called bit array). in the end we know if a no has appeared 3 times then its each bit must have contributed 3 times in bit array.\\nand then simple bit[i]%3 will tell us uniqe bits which has occured only ones.\\n\\nbit array for sample TC : [2,2,3,2] is [ 0 , 3 , 1 , 0 ,0 ,0 . . . . . .rest all zeros ]\\nafter mod array becomes [0 , 0 , 1 , 0, 0 , . . . . rest all zeros ]\\n\\nso we know that 3rd bit contributes to answer and simple  \" ans | = (bit[i]<<i)  \" will make answer\\'s 3rd bit to 1, and we proceed with other bits which adds to answer\\nhere is **1st approach** code\\n```\\n int singleNumber(vector<int>& nums) {\\n      \\n        int bit[32]={};        \\n        for(int i=0 ; i<32 ; i++)\\n        {\\n            for(auto num : nums)\\n            {\\n                bit[i] += (num>>i)&1;\\n                bit[i] %= 3;\\n            }\\n        }\\n        int res = 0;\\n        \\n        for(int i=0 ; i<32 ; i++)            res |= (bit[i]<<i);\\n       \\n        return res;\\n    }\\n```\\n**Approach 2 : (best and difficult to understand at first )**\\nwe will use 2 variables let it be called \"ones\" and \"twos\" \\nthis is how will proceed \\n\\n* First time number appear : save it in \"ones\"\\n* Second time :  clear \"ones\" but save it in \"twos\" for later check\\n* Third time : try to save in \"ones\" but value saved in \"twos\" clear it.\\n\\nnow we know that a simple Xor \\'^\\' can be used to save the no no set \\nand not \\'~\\' can be used to flip all bits , this NOT operator will be used for \"Clearing\" as stated above.\\n```\\nint singleNumber(vector<int>& nums) {\\n      \\n        int ones = 0;\\n        int twos = 0;\\n        \\n        for(auto i:nums)\\n        {\\n            ones = (ones^i);               // adding num to set \"ones\" if not present already\\n            ones = ones & (~twos);         // removing num if it was present in set \"twos\" ( NOT flips all bits , the  by using AND operator no is being removed\\n            twos = (twos^i);               // similarly adding to second \\n            twos = twos & (~ones);\\n        }\\n        return ones;\\n```\\nnumber that appears a first time will be in set \"ones\" so it will not be added to \"twos\". Any number appearing a second time would be removed from set \"ones\" in the previous step and will now be added to set \"twos\". Lastly, any number appearing a third time will simply be removed from the set \"twos\" and will no longer exist in either set.\\n\\nFinally, once we are done iterating over the entire list, set \"twos\" would be empty and set \"ones\" will contain the only number that appears once.\\nthis is what i understand after reading others explanation and reading more about bit manipulation thanks for reading.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n int singleNumber(vector<int>& nums) {\\n      \\n        int bit[32]={};        \\n        for(int i=0 ; i<32 ; i++)\\n        {\\n            for(auto num : nums)\\n            {\\n                bit[i] += (num>>i)&1;\\n                bit[i] %= 3;\\n            }\\n        }\\n        int res = 0;\\n        \\n        for(int i=0 ; i<32 ; i++)            res |= (bit[i]<<i);\\n       \\n        return res;\\n    }\\n```\n```\\nint singleNumber(vector<int>& nums) {\\n      \\n        int ones = 0;\\n        int twos = 0;\\n        \\n        for(auto i:nums)\\n        {\\n            ones = (ones^i);               // adding num to set \"ones\" if not present already\\n            ones = ones & (~twos);         // removing num if it was present in set \"twos\" ( NOT flips all bits , the  by using AND operator no is being removed\\n            twos = (twos^i);               // similarly adding to second \\n            twos = twos & (~ones);\\n        }\\n        return ones;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538917,
                "title": "python-one-line-solution-beats-97-64",
                "content": "make use of the condition that same number repeats three times.\\n```\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(set(nums))*3 - sum(nums)) // 2\\n",
                "solutionTags": [],
                "code": "make use of the condition that same number repeats three times.\\n```\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(set(nums))*3 - sum(nums)) // 2\\n",
                "codeTag": "Python3"
            },
            {
                "id": 501465,
                "title": "java-1ms-solution-with-full-explanation-o-n-time",
                "content": "The idea is to use counts of 1s set in the binary representation of numbers in given array. Let\\'s start with example [2,5,3,2,3,5,2,3,8,5] whose binary reprsenations are as below:\\n\\n2 -> 0010\\n5 -> 0101\\n3 -> 0011\\n2 -> 0010\\n3 -> 0011\\n5 -> 0101\\n2 -> 0010\\n3 -> 0011\\n8 -> 1000\\n5 -> 0101\\n________________\\nNo. of bits set according to position are:  1366\\n(For example, total number of 1s which are set in the right most position in the numbers of the given array are (Least significant bit) are 6, \\ntotal number of 1s which are set in left most position in the numbers of the given array are (Most Significant Bit) are 1 - Only in 8 which is represented as <1000>)\\n\\n**Here is the idea:** All the numbers which appear *thrice*, will have number of 1s in the multiple of 3s in their respective position. For example, [2,2,2] is the array, then the no. of bits set in the respective positions are [030]. As you can see, there are *3* 1s set in position-1. Now, to solve the problem we have to cancel these *triplets*. So, let\\'s take modulo 3 in the number of set bits. \\n\\nComing back to our example, [1366] will become [1000] if modulo 3 is taken for each bit-count in respective position. And, as you can see 1000, in binary, represents 8 in decimal, which is the answer. \\n\\n```\\npublic int singleNumber(int[] nums) {\\n\\tint n = nums.length;\\n\\tint[] counts = new int[32]; // because int in Java has 32 bits\\n\\n\\tfor (int num : nums) {\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tcounts[i] += num & 1;\\n\\t\\t\\tnum >>= 1;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\tfor (int i = 0; i < 32; i++) {\\n\\t\\tres += (counts[i] % 3) << i;\\n\\t}\\n\\n\\treturn res;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n\\tint n = nums.length;\\n\\tint[] counts = new int[32]; // because int in Java has 32 bits\\n\\n\\tfor (int num : nums) {\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tcounts[i] += num & 1;\\n\\t\\t\\tnum >>= 1;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\tfor (int i = 0; i < 32; i++) {\\n\\t\\tres += (counts[i] % 3) << i;\\n\\t}\\n\\n\\treturn res;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715772,
                "title": "go-xor-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 GO XOR \\uD83D\\uDD25 || Simple Fast and Easy || with Explanation \\uD83D\\uDE08\\n\\n\\n#### Algorithm Explanation\\nThe given algorithm is used to find a single number in a list of integers where all other numbers appear twice except for the single number. It uses bitwise operations to achieve this.\\n\\nThe algorithm maintains two variables, `ones` and `twos`, to keep track of the occurrences of the numbers in the list. The `ones` variable represents the bits that have appeared once, while the `twos` variable represents the bits that have appeared twice.\\n\\nThe algorithm iterates through the list of numbers. For each number, it performs bitwise operations to update the `ones` and `twos` variables. The specific operations used are XOR (^) and bitwise negation (~).\\n\\nAt the end of the iteration, the value of `ones` will represent the single number that appeared only once in the list.\\n\\n#### Space Complexity\\n\\nThe algorithm uses a constant amount of extra space. It only requires two integer variables (`ones` and `twos`) to keep track of the bit occurrences. Therefore, the space complexity is O(1).\\n\\n#### Time Complexity\\n\\nThe algorithm iterates through the entire list of numbers once, performing constant time operations for each number. Thus, the time complexity is O(n), where n is the length of the input list.\\n\\nThe algorithm\\'s time complexity is linear, making it an efficient solution for finding the single number in the given context.\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n\\tvar ones int = 0\\n\\tvar twos int = 0\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tvar number int = nums[i]\\n\\t\\tones ^= (number & ^twos)\\n\\t\\ttwos ^= (number & ^ones)\\n\\t}\\n\\n\\treturn ones\\n}\\n```\\n## [GitHub](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```go\\nfunc singleNumber(nums []int) int {\\n\\tvar ones int = 0\\n\\tvar twos int = 0\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tvar number int = nums[i]\\n\\t\\tones ^= (number & ^twos)\\n\\t\\ttwos ^= (number & ^ones)\\n\\t}\\n\\n\\treturn ones\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715438,
                "title": "c-solution-for-single-number-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use bitwise manipulation to keep track of the bits that have appeared once and twice. By doing so, we can identify the single element that appears only once in the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The approach used in the solution is based on two bitmasks: ones and twos. The ones bitmask keeps track of the bits that have appeared once, and the twos bitmask keeps track of the bits that have appeared twice.\\n- For each number in the array, we update the bitmasks as follows:\\n\\n1. Update the ones bitmask: We perform the XOR operation between ones and the number to update the bits that have appeared once. Then, we clear the bits that also appear in the twos bitmask by using the bitwise AND operation with the negation of twos.\\n1. Update the twos bitmask: We perform the XOR operation between twos and the number to update the bits that have appeared twice. Then, we clear the bits that also appear in the ones bitmask by using the bitwise AND operation with the negation of ones.\\n1. At the end of the iteration, the ones bitmask will contain the bits of the single element that appears only once in the array, and we return its value as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the input array. This is because we iterate through the array once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) because we only use two integer variables (ones and twos) to keep track of the bitmasks. The space usage does not depend on the size of the input array.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        int ones = 0; // Tracks the bits that have appeared once\\n        int twos = 0; // Tracks the bits that have appeared twice\\n    \\n        foreach (int num in nums) \\n        {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n        \\n        return ones;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        int ones = 0; // Tracks the bits that have appeared once\\n        int twos = 0; // Tracks the bits that have appeared twice\\n    \\n        foreach (int num in nums) \\n        {\\n            ones = (ones ^ num) & ~twos;\\n            twos = (twos ^ num) & ~ones;\\n        }\\n        \\n        return ones;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384357,
                "title": "python-o-n-solution-using-sop-and-bit-manipulation",
                "content": "**Motivation**\\n--\\nIf the number of duplicates for all but one number were two(or any even number), we can XOR all the elements of `nums` to get the single element that is not duplicated in nums. Since XOR is commutative, the order we XOR the elements of `nums` doesn\\'t matter as long as we XOR all of them.\\n\\nFor example: If `nums = [2,2,3,4,4]`, then `2^2^3^4^4` is 3, which is the single number. \\n\\nThis works because XOR is essentially an \"odd counter\": The number of bits that are set at the end of the XOR-ing operation are those that occur odd number of times. If a number is duplicate, it\\'s 1 bit occur at least twice thus XOR-ing them turn them off.\\n\\nThis doesn\\'t work if the number of duplicates is 3(or any odd number) since XOR is an odd-counter and XOR will basically be XORing the distinct elements of `nums` which is not what we want. We need an operation similar to XOR, but it is `3n+1` -counter instead of odd-counter. We don\\'t have such kind of operation.... Or don\\'t we?\\n\\n**Triple-XOR**\\n--\\nThe name is not that creative but let\\'s define a **\"ternary\"** operation that does exactly the job we want.  The operation ouputs two values, `x` and `y` from three inputs `a`, `b` and `c`. The reason will become clear in a second. Let\\'s define our `tripleXOR` function using truth table:\\n```\\na     b     c    x      y\\n0     0     0    0      0\\n0     0     1    0      1\\n0     1     0    0      1\\n0     1     1    1      0\\n1     0     0    1      0\\n1     0     1    0      0\\n1     1     0    0      0\\n1     1     1    0      1  \\n```\\nThe operation definition might seem arbitrary at first. But if we assume the concatenation of `a` and `b` tells us the total number of 1-bits that we have counted before modulo 3 and `c` is the incoming bit then the concatenation of  `x` and `y` tells us the the current number of  1-bits (i.e., including the incoming bit) modulo 3. I\\'ll illustrate with an example.\\n\\nFor example, if we have counted 10 1-bits, our `a` and `b` will assume the value `0` and `1` respectively since `10 % 3 = 1`. If the incoming bit is `c=1` the `tripleXOR(0, 1, 1) = 1, 0`, meaning`11%3 = 2` which is `10` in binary.\\n\\nSince every number but one occurs 3 times, our final answer should a `0, 0` and `0, 1` for the 0-bits and 1-bits of the single number.  \\n\\n**Sum-Of-Products**\\n--\\n\\nWe can use the famous sum-of-products technique to compute our `tripleXOR` function as \\n```\\ntripleXOR(a, b, c) = ~a & b & c  | a & ~b & ~c,  ~a & ~b & c | ~a & b & ~c | a & b & c\\n```\\nThat\\'s it. Our single number becomes `~x` or `y` because the 1-bits of the single number will \"tripleXOR\" to `0, 1`.\\n\\n**Implementation**\\n--\\n```\\nclass Solution:\\n    \\n    def singleNumber(self, nums: List[int]) -> int:\\n            \\n        def tripleXOR(a,b,c):\\n            return ~a&b&c | a &~b&~c, a&b&c| ~a&~b&c| ~a&b&~c\\n        \\n        x  = y = i = 0\\n        while i < len(nums):\\n            \\n            x, y = tripleXOR(x, y, nums[i])\\n            i+=1\\n            \\n        return y\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\na     b     c    x      y\\n0     0     0    0      0\\n0     0     1    0      1\\n0     1     0    0      1\\n0     1     1    1      0\\n1     0     0    1      0\\n1     0     1    0      0\\n1     1     0    0      0\\n1     1     1    0      1  \\n```\n```\\ntripleXOR(a, b, c) = ~a & b & c  | a & ~b & ~c,  ~a & ~b & c | ~a & b & ~c | a & b & c\\n```\n```\\nclass Solution:\\n    \\n    def singleNumber(self, nums: List[int]) -> int:\\n            \\n        def tripleXOR(a,b,c):\\n            return ~a&b&c | a &~b&~c, a&b&c| ~a&~b&c| ~a&b&~c\\n        \\n        x  = y = i = 0\\n        while i < len(nums):\\n            \\n            x, y = tripleXOR(x, y, nums[i])\\n            i+=1\\n            \\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742939,
                "title": "c-100-faster-o-1-space",
                "content": "```\\nint singleNumber(vector<int>& nums) {\\n       unsigned int ans=0,shift=1;\\n        for(int i=0;i<32;++i){\\n            int count=0;\\n            for(auto ele:nums){\\n                if(ele&shift) count+=1;\\n            }\\n            if(count%3!=0){\\n                ans+=shift;\\n                \\n            }\\n            shift*=2;\\n        \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n       unsigned int ans=0,shift=1;\\n        for(int i=0;i<32;++i){\\n            int count=0;\\n            for(auto ele:nums){\\n                if(ele&shift) count+=1;\\n            }\\n            if(count%3!=0){\\n                ans+=shift;\\n                \\n            }\\n            shift*=2;\\n        \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848434,
                "title": "c-4-lines-code-only-very-easy-and-simple-bit-manipulation",
                "content": "If you find helpful just make me happy by giving a upvate :)\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n    \\n\\n        int oneTime =0;\\n        int twoTime =0;\\n        \\n        for(auto it: nums){\\n            oneTime = (oneTime^it) & (~twoTime);\\n            twoTime = (twoTime ^it) & (~oneTime);\\n        }\\n        \\n        return oneTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n    \\n\\n        int oneTime =0;\\n        int twoTime =0;\\n        \\n        for(auto it: nums){\\n            oneTime = (oneTime^it) & (~twoTime);\\n            twoTime = (twoTime ^it) & (~oneTime);\\n        }\\n        \\n        return oneTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562448,
                "title": "easy-solution-with-explanation",
                "content": "I really enjoyed solving this problem, although I saw some other solutions having complex bit manipulation equations the idea behind this solution if fairly simple.\\n\\nLet\\'s take an example: \\n\\n3 1 1 1 2 2 2 \\n\\nFrom the above example it is clear that 3 is the answer. Now, let us look at the binary representation of the numbers. \\n\\n3 ----> 0 0 1 1\\n1 ----> 0 0 0 1\\n1 ----> 0 0 0 1\\n1 ----> 0 0 0 1\\n2 ----> 0 0 1 0\\n2 ----> 0 0 1 0\\n2 ----> 0 0 1 0\\n\\n* If you notice in the above table, numbers of ones in some columns are in the form 3n and 3n+1, where n is the frequency of the numbers.\\n* Whichever columns have 3n+1 1\\'s must contain the element that occurs only once and thats what we want as the result.\\n* So, we check for every bit in the whole array and if the count of that bit is in the form 3n+1 then we add it to our result.\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int res = 0;\\n        for(int i = 0; i <= 31; ++i) {\\n            int check = 1 << i, count = 0;\\n            for(auto child : nums) {\\n                if(child & check)\\n                    count += 1;\\n            }\\n            if(count % 3 == 1) \\n                res = res | check;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\nTime Complexity: O(Nx32) == O(N)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int res = 0;\\n        for(int i = 0; i <= 31; ++i) {\\n            int check = 1 << i, count = 0;\\n            for(auto child : nums) {\\n                if(child & check)\\n                    count += 1;\\n            }\\n            if(count % 3 == 1) \\n                res = res | check;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501849,
                "title": "easy-to-read-commented-and-explained-c-solution",
                "content": "```\\n// Idea of solution:\\n\\n// Consider case where input is not type int, but a bit array, we want to\\n// count the number of 1s in the bit array and know if it is a multiple of 3:\\n\\n// 1. we want a counter which overflows when count = 3 (n mod 3 or n % 3)\\n//    so the number remaining in couter after counting is the number\\n//    that has not appear 3 times\\n\\n// 2. Let\\'s do so by creating 2 (2^2 = 4 > 3) 1-bit counter\\n//      bit oneCounter = 0;\\n//      bit twoCounter = 0;\\n\\n// 3. Consider an input: 10010101, now count the number using\\n//    the 2 counter above:\\n//          the first 1:    twoCounter = 0, oneCounter = 1\\n//          the second 1:   twoCounter = 1, oneCounter = 0\\n//          the third 1:    twoCounter = 0, oneCounter = 0\\n//          (repeat...)\\n\\n// 4. How would we do that?\\n\\n// 5. For the first 1, we simply flip oneCounter (i.e. XOR)\\n//    For the second 1, we reset oneCounter to 0, and flip twoCounter\\n//    For the third 1, we flip twoCounter\\n\\n// 6. Find the pattern of step 5:\\n//      oneCounter: only set to one if twoCounter is 0\\n//      twoCounter: only set to one if oneCounter is 0 (after flipping oneCoutner)\\n\\n// 7. So what we want to do is:\\n//      1. XOR (^) oneCounter (i.e. flipping the bit)\\n//      2. Only allow the flip bit to remain flipped when two counter is 0,\\n//         We can do it by first reversing twoCounter (~) and logical and (&)\\n//         oneCounter.\\n//      3. Same for twoCounter.\\n\\n// 8. Expanding on this idea, it is the same for any integer, note that we can\\n//     also use the same counters for differnet integers since eveually if a number\\n//     appeared 3 times, it will cancel itself out in the buffer, leaving the single number.\\n\\n// 9. Additional:\\n//      What if we want to find a number in a given array that did not appear 4 times?\\n//      The answer is:\\n//          first 1:    twoCounter = 0, oneCounter = 1\\n//          second 1:   twoCounter = 1, oneCounter = 0\\n//          third 1:    twoCounter = 1, oneCounter = 1\\n//          fourth 1:   twoCounter = 0, oneCounter = 0\\n//          (repeat ...)\\n//      Observe the pattern\\n//          oneCounter flips every time\\n//          twoCounter will only flip when oneCounter is 0 (after flipping)\\n//      So the answer is:\\n//          for loop {\\n//              oneCounter = (oneCounter ^ n);\\n//              twoCounter = (twoCounter ^ n) & ~oneCounter;\\n//          }\\n\\n// Hopes this helped :)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int oneCounter = 0;\\n        int twoCounter = 0;\\n        \\n        for (int &n : nums) {\\n            oneCounter = (oneCounter ^ n) & ~twoCounter;\\n            twoCounter = (twoCounter ^ n) & ~oneCounter;\\n        }\\n        \\n        return oneCounter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Idea of solution:\\n\\n// Consider case where input is not type int, but a bit array, we want to\\n// count the number of 1s in the bit array and know if it is a multiple of 3:\\n\\n// 1. we want a counter which overflows when count = 3 (n mod 3 or n % 3)\\n//    so the number remaining in couter after counting is the number\\n//    that has not appear 3 times\\n\\n// 2. Let\\'s do so by creating 2 (2^2 = 4 > 3) 1-bit counter\\n//      bit oneCounter = 0;\\n//      bit twoCounter = 0;\\n\\n// 3. Consider an input: 10010101, now count the number using\\n//    the 2 counter above:\\n//          the first 1:    twoCounter = 0, oneCounter = 1\\n//          the second 1:   twoCounter = 1, oneCounter = 0\\n//          the third 1:    twoCounter = 0, oneCounter = 0\\n//          (repeat...)\\n\\n// 4. How would we do that?\\n\\n// 5. For the first 1, we simply flip oneCounter (i.e. XOR)\\n//    For the second 1, we reset oneCounter to 0, and flip twoCounter\\n//    For the third 1, we flip twoCounter\\n\\n// 6. Find the pattern of step 5:\\n//      oneCounter: only set to one if twoCounter is 0\\n//      twoCounter: only set to one if oneCounter is 0 (after flipping oneCoutner)\\n\\n// 7. So what we want to do is:\\n//      1. XOR (^) oneCounter (i.e. flipping the bit)\\n//      2. Only allow the flip bit to remain flipped when two counter is 0,\\n//         We can do it by first reversing twoCounter (~) and logical and (&)\\n//         oneCounter.\\n//      3. Same for twoCounter.\\n\\n// 8. Expanding on this idea, it is the same for any integer, note that we can\\n//     also use the same counters for differnet integers since eveually if a number\\n//     appeared 3 times, it will cancel itself out in the buffer, leaving the single number.\\n\\n// 9. Additional:\\n//      What if we want to find a number in a given array that did not appear 4 times?\\n//      The answer is:\\n//          first 1:    twoCounter = 0, oneCounter = 1\\n//          second 1:   twoCounter = 1, oneCounter = 0\\n//          third 1:    twoCounter = 1, oneCounter = 1\\n//          fourth 1:   twoCounter = 0, oneCounter = 0\\n//          (repeat ...)\\n//      Observe the pattern\\n//          oneCounter flips every time\\n//          twoCounter will only flip when oneCounter is 0 (after flipping)\\n//      So the answer is:\\n//          for loop {\\n//              oneCounter = (oneCounter ^ n);\\n//              twoCounter = (twoCounter ^ n) & ~oneCounter;\\n//          }\\n\\n// Hopes this helped :)\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int oneCounter = 0;\\n        int twoCounter = 0;\\n        \\n        for (int &n : nums) {\\n            oneCounter = (oneCounter ^ n) & ~twoCounter;\\n            twoCounter = (twoCounter ^ n) & ~oneCounter;\\n        }\\n        \\n        return oneCounter;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 700305,
                "title": "python-3-very-simple-one-liner-and-a-bitwise-with-o-1-space-only-2-variables",
                "content": "Here\\'s a simple and straightforward one liner. Get the count of the items using `Counter(nums)`. Sort them in descending count order with `most_common()` and take the last element by indexing with `[-1][0]`. Voila!\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n    return Counter(nums).most_common()[-1][0]\\n```\\n\\nI also came across this bitwise solution in a [Quora post](https://www.quora.com/Given-an-integer-array-such-that-every-element-occurs-3-times-except-one-element-which-occurs-only-once-how-do-I-find-that-single-element-in-O-1-space-and-O-n-time-complexity) I thought was very elegant.\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n    ones, twos = 0, 0\\n    for num in nums:\\n        ones, twos = (ones ^ num) & ~twos, (ones & num) | (twos & ~num)\\n    return ones\\n```\\n\\nLet\\'s unpack what the code is doing. We have two updates:\\n1. `ones = (ones ^ num) & ~twos`\\n\\t* `ones ^ num` performs the same XOR operation you see in the duplicate entries version of Single Number\\n\\t* `& ~twos` removes the newly added number if it\\'s been seen twice\\n2. `twos = (ones & num) | (twos & ~num)`\\n\\t* `ones & num` takes the number if it\\'s in `ones`\\n\\t* `twos & ~num` takes the number only if it\\'s not in `twos`\\n\\nThese updates work because of the communtativity and associativity of `&` and `^`.\\n\\nThe following explanation is my original attempt at explaining the above algorithm. I leave it here for those who prefer these types of explanations. The gist of the algorithm is that `ones` is XORed with `num` in the same way that you would in the duplicate number version of the Single Number problem (`ones ^ num`), but we remove the number if it has already been stored in `twos` by only accepting the bits not present in `twos` (`& ~twos)`. This gives us the update `ones = (ones ^ num) & ~twos`. The twos update simply checks if the number has been seen in `ones` (`ones & num`) and if the number has not been seen in `twos` (`twos & ~num`). This gives us the `twos` update of `twos = (ones & num) | (twos & ~num)`. It\\'s important to note that this works because of the commutativity and associativity of the AND (`&`) and XOR (`^`) operators.\\n\\n**Please upvote if you found this helpful! It helps the visibility of the bitwise solution.**",
                "solutionTags": [],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n    return Counter(nums).most_common()[-1][0]\\n```\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n    ones, twos = 0, 0\\n    for num in nums:\\n        ones, twos = (ones ^ num) & ~twos, (ones & num) | (twos & ~num)\\n    return ones\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 548174,
                "title": "bit-manipulation-solution",
                "content": "This is not the optimal bit solution as the top 2 submissions on this answer are better, but I don\\'t quite get them, I\\'m new to trying questions in this way, if anybody gets them, leave a comment explaining them!\\n```\\nint result = 0, count = 0;\\nfor(int i = 0; i < 32; i++) {\\n    count = 0;\\n    for(const auto &num: nums)\\n\\t    // counting number of 1s by checking if bit is set\\n        if((num & (1 << i)) != 0) count++;\\n\\t// setting result bit with 0 or 1 based on whether count is multiple of 3 or not\\n    result |= ((count%3) << i);\\n}\\nreturn result;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint result = 0, count = 0;\\nfor(int i = 0; i < 32; i++) {\\n    count = 0;\\n    for(const auto &num: nums)\\n\\t    // counting number of 1s by checking if bit is set\\n        if((num & (1 << i)) != 0) count++;\\n\\t// setting result bit with 0 or 1 based on whether count is multiple of 3 or not\\n    result |= ((count%3) << i);\\n}\\nreturn result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355996,
                "title": "python-solution-in-1-line-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return int((sum(set(nums))*3-sum(nums))/2)\\n```\\nfirst, I use `set` to remove duplicate in nums array, let\\'s call it new array.\\nthen, since we know that every element appears three times except for one, we can simply multiply the sum of new array by 3 and subtract the number by the sum of nums array.\\nlast, divide the number by 2, here\\'s the single number in nums array.\\n\\nhere\\'s an example:\\n1. given an array [1,2,3,1,2,2,1], we will have [1,2,3] after removing duplicate nums in array.\\n2. calculate the sum of [1,2,3] and multiply it by 3, which is equal to calculate the sum of [1,1,1,2,2,2,3,3,3].\\n3. calculate the sum of nums array, which is equal to calculate the sum of [1,1,1,2,2,2,3].\\n4. substract the number in step 2 by number in step 3, we will have 6, which is the sum of extra [3,3] in step 2, now that we know that the single number must be 3, we just divide 6 by 2, we will have the final result.\\n\\nthis method can be apply to any array whose \\'every element appears n times except for one\\', just mutiply the sum of non-duplicate array by n and substract it by the sum of nums array and then divide it by (n-1), here we are.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return int((sum(set(nums))*3-sum(nums))/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43451,
                "title": "c-solution-add-bit-by-bit-but-mod-3",
                "content": "We generalize the bitwise XOR idea so that if one bit repeats 3 times, it goes back to zero. To achieve that, we expand each bit to two bits (using the extra variable carryBits to hold the extra bits).\\n\\nFor example, if we have a 1 bit, we expand it to 01, but hold that 0 in the auxiliary variable carryBits. If we add the bit to itself once, we get 10, if we add the bit again, we get 11, which means it is zero mod 3, so we clear that position if both bits are 1. \\n\\n    class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            int carryBits = 0, sumMod3 = 0, zeroBitsMod3;\\n            for(int i = 0; i < n; i++) {\\n\\n                // Keep adding A[i] to the sum, and keep the overflow bits in carryBits\\n                carryBits += sumMod3 & A[i];\\n                sumMod3 = sumMod3 ^ A[i];\\n\\n                // Find the bit positions where both carryBits and sumMod3 are 1\\n                zeroBitsMod3 = carryBits & sumMod3;  \\n\\n                // Clear the those bits that is zero mod 3\\n                carryBits ^= zeroBitsMod3;\\n                sumMod3 ^= zeroBitsMod3;\\n            }\\n\\n            // Don't forget that the part of the sum is held in carryBits\\n            return (carryBits<<1) + sumMod3;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            int carryBits = 0, sumMod3 = 0, zeroBitsMod3;\\n            for(int i = 0; i < n; i++) {\\n\\n                // Keep adding A[i] to the sum, and keep the overflow bits in carryBits\\n                carryBits += sumMod3 & A[i];\\n                sumMod3 = sumMod3 ^ A[i];\\n\\n                // Find the bit positions where both carryBits and sumMod3 are 1\\n                zeroBitsMod3 = carryBits & sumMod3;  \\n\\n                // Clear the those bits that is zero mod 3\\n                carryBits ^= zeroBitsMod3;\\n                sumMod3 ^= zeroBitsMod3;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3715302,
                "title": "single-number-ii-easy-java-solution-t-o-n-s-o-1",
                "content": "# Approach\\n1. Initialize three variables `once`, `twice`, and `thrice` to 0.\\n2. Iterate over each element `nums[i]` in the given array.\\n3. Update `twice` using the bitwise OR operator (`|`): It combines the current value of `twice` with the bitwise AND (`&`) operation between `once` and `nums[i]`. This operation captures the bits that appear twice in the array.\\n4. Update `once` using the bitwise XOR operator (`^`): It performs an XOR operation between the current value of `once` and `nums[i]`. This operation captures the bits that appear once in the array.\\n5. Update `thrice` using the bitwise AND operator (`&`): It calculates the bits that appear three times by performing the AND operation between `once` and `twice`.\\n6. Update `once` by removing the bits that appear three times: It performs the AND operation between `once` and the negation (`~`) of `thrice`. This operation removes the bits that appear three times from `once`.\\n7. Update `twice` by removing the bits that appear three times: It performs the AND operation between `twice` and the negation of `thrice`. This operation removes the bits that appear three times from `twice`.\\n8. Repeat steps 3-7 for all elements in the array.\\n9. After iterating through all elements, `once` will hold the single number that appears only once in the array.\\n10. Return the value of `once`.\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int singleNumber(int[] nums) {\\n        int once = 0;\\n        int twice = 0;\\n        int thrice = 0;\\n        for (int i = 0; i < nums.length; i ++){\\n            twice = twice | ( once & nums[i]);\\n            once = once ^ nums[i];\\n            thrice = once & twice;\\n            once = once & (~thrice);\\n            twice = twice & (~thrice);\\n        }\\n        return once;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n     public int singleNumber(int[] nums) {\\n        int once = 0;\\n        int twice = 0;\\n        int thrice = 0;\\n        for (int i = 0; i < nums.length; i ++){\\n            twice = twice | ( once & nums[i]);\\n            once = once ^ nums[i];\\n            thrice = once & twice;\\n            once = once & (~thrice);\\n            twice = twice & (~thrice);\\n        }\\n        return once;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591339,
                "title": "easy-to-understand-bit-manipulation-solution-with-explanation",
                "content": "# Approach\\nLets understand this with an example \\n```\\nelements:  1    3   2   3   4   2   1   1   3  2\\nBinary Rep:001 011 010 011 100 010 001 001 011 010\\n```\\n\\nConsider the Binary representation of each element, for number which are present 3 times, the count of set bits must be a multiple of 3 (same numbers will have same Binary representation, if it is present thrice, set bit count will become multiple of 3). \\n\\nWe will count set bits at every position (according to constraints we will consider 32 bits) if the count is not multiple of 3 then we are sure that this bit must be 1 in the answer (i.e. unique number)\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n    public:\\n    bool getBit(int n, int pos)\\n    {       //find bit at 2nd position in 5:  101 & 10 -> 0;\\n        return ((n &(1 << pos)) != 0); \\n    }\\n    int setBit(int n, int pos)\\n    {      // set bit at 2nd position in 5:  101 | 10 -> 111;\\n        return (n | (1 << pos));\\n    }\\n\\n    int singleNumber(vector<int> &nums)\\n    {\\n        int ans = 0;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            int sum = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (getBit(nums[j], i)) sum++;\\n            }\\n            if (sum % 3 != 0)\\n                ans = setBit(ans, i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nupvote if helpful :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nelements:  1    3   2   3   4   2   1   1   3  2\\nBinary Rep:001 011 010 011 100 010 001 001 011 010\\n```\n```\\nclass Solution\\n{\\n\\n    public:\\n    bool getBit(int n, int pos)\\n    {       //find bit at 2nd position in 5:  101 & 10 -> 0;\\n        return ((n &(1 << pos)) != 0); \\n    }\\n    int setBit(int n, int pos)\\n    {      // set bit at 2nd position in 5:  101 | 10 -> 111;\\n        return (n | (1 << pos));\\n    }\\n\\n    int singleNumber(vector<int> &nums)\\n    {\\n        int ans = 0;\\n        for (int i = 0; i < 32; i++)\\n        {\\n            int sum = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (getBit(nums[j], i)) sum++;\\n            }\\n            if (sum % 3 != 0)\\n                ans = setBit(ans, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280746,
                "title": "bit-manipulation-approach-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int tn = -1;\\n        int tnp1 = 0;\\n        int tnp2 = 0;\\n        for(int& num : nums){\\n            int cwtn = num & tn;\\n            int cwtnp1 = num &  tnp1;\\n            int cwtnp2 = num & tnp2;\\n            // jo mere tn aur cwtn mein common 1 hai use off kr dunga \\n            // aur unhe tnp1 mein on kr dunga because ab wo 3n + 1 form ke ho gye hai\\n            tn = tn & (~cwtn);\\n            tnp1 = tnp1 | cwtn;\\n            \\n           // jo mere tnp1 aur cwtnp1 mein common 1 hai use off kr dunga \\n            // aur unhe tnp2 mein on kr dunga because ab wo 3n + 2 form ke ho gye hai\\n            tnp1 = tnp1 & (~cwtnp1);\\n            tnp2 = tnp2 | cwtnp1;\\n            \\n            // same ab 3n form mein ho jayenge\\n            tnp2 = tnp2 & (~cwtnp2);\\n            tn = tn | cwtnp2;\\n        }\\n        return tnp1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int tn = -1;\\n        int tnp1 = 0;\\n        int tnp2 = 0;\\n        for(int& num : nums){\\n            int cwtn = num & tn;\\n            int cwtnp1 = num &  tnp1;\\n            int cwtnp2 = num & tnp2;\\n            // jo mere tn aur cwtn mein common 1 hai use off kr dunga \\n            // aur unhe tnp1 mein on kr dunga because ab wo 3n + 1 form ke ho gye hai\\n            tn = tn & (~cwtn);\\n            tnp1 = tnp1 | cwtn;\\n            \\n           // jo mere tnp1 aur cwtnp1 mein common 1 hai use off kr dunga \\n            // aur unhe tnp2 mein on kr dunga because ab wo 3n + 2 form ke ho gye hai\\n            tnp1 = tnp1 & (~cwtnp1);\\n            tnp2 = tnp2 | cwtnp1;\\n            \\n            // same ab 3n form mein ho jayenge\\n            tnp2 = tnp2 & (~cwtnp2);\\n            tn = tn | cwtnp2;\\n        }\\n        return tnp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680131,
                "title": "one-way-of-solving-all-these-types-of-problem-explained-simple-and-concise",
                "content": "Question -  Unique number\\nGeneralized form-\\nThere are kn+1 numbers in an array. There is one unique number and other numbers come k times. Find the unique number.  \\n\\n\\nCase 1- k is even \\na^a=0.\\nWe know if xor a number even number of times, we get 0.           \\nWe will xor all numbers of the array. All repeating numbers cancel out and we are left with the unique number.  \\n\\nCase 2- k is odd\\nXor will not work here.\\nLet\\'s take the example of k=3.\\nArr = 1 2 2 2 3 3 3\\nAdd bits at every position.\\n00001\\n00010\\n00010\\n00010\\n00011\\n00011\\n00011\\n\\u2014-------\\n00064\\n\\n6=3x2\\n4=3x1+1\\n0=3x0\\nWe will have only 3n or 3n+1 bits at every position in the sum.\\nWe have 3n+1 bits at points where the unique number has a set bit.\\n\\nSo we can just run through the sum of bits and wherever we have 3n+1 bits we know this place will have a set bit in the unique number.\\n\\n\\nCODE for odd k.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int orbits=0;\\n        \\n        int shft=0, i,ans=0;\\n        \\n        for( i=0;i<32;i++)\\n        {\\n            int sum=0;\\n            for(int x:nums)\\n            {\\n                if((x&(1<<shft)))\\n                {\\n                    sum++;\\n                }\\n                \\n            }\\n            if(sum%3==1)\\n            {\\n                ans=(ans|(1<<shft));\\n            }\\n            shft++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int orbits=0;\\n        \\n        int shft=0, i,ans=0;\\n        \\n        for( i=0;i<32;i++)\\n        {\\n            int sum=0;\\n            for(int x:nums)\\n            {\\n                if((x&(1<<shft)))\\n                {\\n                    sum++;\\n                }\\n                \\n            }\\n            if(sum%3==1)\\n            {\\n                ans=(ans|(1<<shft));\\n            }\\n            shft++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555396,
                "title": "explained-with-example-bit-manipulation-python-c",
                "content": "* First we will `count` number of set bits at `ith` position for all elements in the array.\\n* Now if `count%3==0` means till now the number `2^i` has been found multiple of three times.\\n\\t* No updation in `ans`.\\n* If `count%3!=0` means till now the number 2^i has been found multiple of three +1 times.\\n\\t* It may be our `ans` so update it to `ans |= 2^i`.\\n* At the end all the set bits that occurred multiple of three + 1 times will be collected at their respective position by OR operation in previous step.\\n\\n**ILLUSTRATION :** \\n\\nA = [6, 3, 5, 6, 3, 5, 4, 9, 4, 4, 6, 3, 5]\\n\\n6 : 0 1 1 0\\n3 : 0 0 1 1\\n5 : 0 1 0 1\\n6 : 0 1 1 0\\n3 : 0 0 1 1\\n5 : 0 1 0 1\\n4 : 0 1 0 0\\n9 : 1 0 0 1\\n4 : 0 1 0 0\\n4 : 0 1 0 0\\n6 : 0 1 1 0\\n3 : 0 0 1 1\\n5 : 0 1 0 1\\n\\\\-----------\\n......1 9 6 7 : no. of set bits at `i`th position.\\n\\n* `ans = 0`\\n* at 0th position 7%3!=0\\n\\t* `ans |= 2^0  --> 1`\\n* at 1th position 6%3==0\\n\\t* No update\\n* at 2nd position 9%3==0\\n\\t* No update\\n* at 3rd position 1%3!=0\\n\\t* `ans |= 2^3 --> 9`\\n--------------------------------------------------------\\n* In some languages such as python it will give wrong answer in case of negative elements.\\n* To handle this case whenever we find a set bit at `31`th position we just subtract 2^31 from our answer.\\n* Since binary of negative number is represented in its 2\\'s complement, in each step  we are continuously collecting set bits, means subtracting 2^31 from our answer will give us desired output.\\n\\n**ILLUSTRATION :**\\n\\nA = [-2, 2, 2, 2]\\n.-2 : 1 1 1 0\\n+2 : 0 0 1 0\\n+2 : 0 0 1 0\\n+2 : 0 0 1 0\\n\\\\--------------\\n.........1 1 4 0  : no. of set bits at `i`th position.\\n\\n* `ans = 0`\\n* at 0th position 0%3!=0\\n\\t* No update\\n* at 1th position 4%3!=0\\n\\t* `ans |= 2^1 --> 2`\\n* at 2nd position 1%3!=0\\n\\t* `ans |= 2^2 --> 6`\\n* at 3rd position 1%3!=0\\n\\t* `ans |= 2^3 --> 14`\\n* at position (4 to 30) 1%3!=0\\n\\t* `ans |= 2^30 --> 2147483646`\\n* at position 31st 1%3!=0 and i==31\\n\\t* `ans -= 2^31 --> -2`\\n-----------------------------------------------\\n**Python** :\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(32):\\n            mask = 1<<i\\n            \\n            count = 0\\n            for num in nums:\\n                if num&mask:\\n                    count += 1\\n            \\n            if count%3:\\n                if i == 31:\\n                    print(ans, mask)\\n                    ans -= mask\\n                else:\\n                    ans |= mask\\n        \\n        return ans\\n\\n```\\n\\n-----------------------------------------------\\n**C++** : [we don\\'t need to add negative element case in c++, it will automatically handle this case.]\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask = 1<<i;\\n            int count = 0;\\n            \\n            for(auto num:nums)\\n                if(num&mask)\\n                  count += 1;      \\n\\n            if(count%3 != 0){\\n                ans |= mask; \\n            }     \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n-----------------------------------\\n**Upvote the post if you find it helpful.**\\n**Happy coding.**\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(32):\\n            mask = 1<<i\\n            \\n            count = 0\\n            for num in nums:\\n                if num&mask:\\n                    count += 1\\n            \\n            if count%3:\\n                if i == 31:\\n                    print(ans, mask)\\n                    ans -= mask\\n                else:\\n                    ans |= mask\\n        \\n        return ans\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask = 1<<i;\\n            int count = 0;\\n            \\n            for(auto num:nums)\\n                if(num&mask)\\n                  count += 1;      \\n\\n            if(count%3 != 0){\\n                ans |= mask; \\n            }     \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338589,
                "title": "c-bitwise-solution-o-n",
                "content": "Runtime: 12 ms, faster than 36.94% of C++ online submissions for Single Number II.\\nMemory Usage: 9.6 MB, less than 49.89% of C++ online submissions for Single Number II.\\n\\n```\\nAs we have 3 occurence of each element except one element which occurs only once. We can go through\\nall the numbers in the array and check their each bit positions and count number of 1. \\nNow in each bit position number of 1 can be multiple of 3 or (multiple of 3) + 1. So, we can know if the \\nbit postion of the uique number is 1 if count of 1 % 3 ==1 and construct the unique number bitwise.\\n\\nExample: [2,2,3,2]\\n2 => 010\\n2 => 010\\n2 => 010\\n3 => 011\\n___________\\nCount of 1 => [ 0, 4, 1 ] % 3 = [0, 1, 1] => 3 \\n\\nComplexity : O(N * 32)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // unique number\\n        int ans = 0;\\n        \\n        // go through each bit position\\n        for(int i=0;i<32;i++)\\n        {\\n            // go though all numbers and count the number of 1 in bit position i\\n            int sum = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((nums[j]&1)==1)sum++;\\n                nums[j]=nums[j]>>1;                \\n            }\\n            \\n            // get the count 1 mod 3\\n            sum%=3;\\n            \\n            // if ith bit position is 1 then unique number\\'s ith bit is 1 \\n            if(sum!=0)ans|=sum<<i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nAs we have 3 occurence of each element except one element which occurs only once. We can go through\\nall the numbers in the array and check their each bit positions and count number of 1. \\nNow in each bit position number of 1 can be multiple of 3 or (multiple of 3) + 1. So, we can know if the \\nbit postion of the uique number is 1 if count of 1 % 3 ==1 and construct the unique number bitwise.\\n\\nExample: [2,2,3,2]\\n2 => 010\\n2 => 010\\n2 => 010\\n3 => 011\\n___________\\nCount of 1 => [ 0, 4, 1 ] % 3 = [0, 1, 1] => 3 \\n\\nComplexity : O(N * 32)\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // unique number\\n        int ans = 0;\\n        \\n        // go through each bit position\\n        for(int i=0;i<32;i++)\\n        {\\n            // go though all numbers and count the number of 1 in bit position i\\n            int sum = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((nums[j]&1)==1)sum++;\\n                nums[j]=nums[j]>>1;                \\n            }\\n            \\n            // get the count 1 mod 3\\n            sum%=3;\\n            \\n            // if ith bit position is 1 then unique number\\'s ith bit is 1 \\n            if(sum!=0)ans|=sum<<i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959996,
                "title": "automata-based-bit-manipulation-solution-explained-with-visualizations",
                "content": "Before getting into the solution for the problem, there are a couple observations that I would like to emphasize. Problem states every number in the given array repeats exactly three times except for the number we are interested in. If you think of what are the implications of this condition/constraints on the bits of the numbers involved, you can draw following conclusions\\n* At a particular bit position, all the 1s summed together will add up to either a multiple of three or multiple of three plus one (due to the oulier we are interested in)\\n* In other words, if you can count the number of times 1 occurs at a particular bit position and if that bit position is divisible by three. The correspoding bit for the outlier will 0 else it\\'s 1.\\n* Further, we are not really interested in knowing the total sum of 1s at a particular bit position we are just interested in knowing if the final sum will be divisible with 3 or not. How can we do it? We would do it by __maintaining a state__\\n\\nThey way I\\'m proposing to maintain state is to use a set of two variables. Say v1 and v2. Let\\'s for easier understanding look at the bits of all numbers, plus two additional variables v1 and v2, at a particular bit position. I\\'ll start with assigning the state represented by v1 and v2 bit. Both the numbers are initialized to zero, that would mean at the bit position we are the currently looking at, both the bits will be set to 0.\\n* v1 = 0, v2 = 0 is the initial state and indicate that we havn\\'t seen any 1s yet or all the ones seen yet were in triplets.\\n* __v1 = 1, v2 = 0 represents that we have seen the first 1 from triplet.__\\n* v1 = 1, v2 = 1 represents that we have seen two ones from the triplet.\\n\\nThe state transitions functions that we use are as follows\\n```\\nint tmp = v1\\nv1 = (v1 XOR v2) OR (v1 XOR x)\\nv2 = tmp AND (v2 XOR x)       \\n```\\nThe following diagram captures the behaviour of state machine for 1s and 0s as input against each state.\\n\\n<img src=\"https://assets.leetcode.com/users/images/230bc57c-fac8-46d5-98b1-89c513326b4b_1607118981.5746338.png\" width=\"700\">\\n\\nAt the end of performing the fore-mentioned operations for all the numbers every bit in v1, v2 will be one of the states marked in blue. Taking a XOR between v1 and v2 will give us the final answer. Please find the complete cpp code below (Beats runtime of 100% cpp code submissions):\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int v1 = 0;\\n        int v2 = 0;\\n        int tmp;\\n        for (auto x: nums) {\\n            tmp = v1;\\n            v1 = (v1 ^ v2) | (v1 ^ x);\\n            v2 = tmp & (v2 ^ x);\\n        }\\n        return v2 ^ v1;\\n    }\\n};\\n```\\nHappy coding :)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint tmp = v1\\nv1 = (v1 XOR v2) OR (v1 XOR x)\\nv2 = tmp AND (v2 XOR x)       \\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int v1 = 0;\\n        int v2 = 0;\\n        int tmp;\\n        for (auto x: nums) {\\n            tmp = v1;\\n            v1 = (v1 ^ v2) | (v1 ^ x);\\n            v2 = tmp & (v2 ^ x);\\n        }\\n        return v2 ^ v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936917,
                "title": "python-bitwise-solution-with-explanation",
                "content": "## Algorithm\\nThe basic idea is to design a finite state machine which has 3 states. Let\\'s assume: `a` is the high bit. `b` is the low bit. `c` is the data. `a\\'` is the a\\'s result. `b\\'` is the b\\'s result. \\n\\n### Table 1: c is 0\\n|a|b|c|a\\'|b\\'|\\n|-|-|-|-|-|\\n|0|0|0|0|0|\\n|0|1|0|0|1|\\n|1|0|0|1|0|\\n\\n### Table 2: c is 1\\n|a|b|c|a\\'|b\\'|\\n|-|-|-|-|-|\\n|0|0|1|0|1|\\n|0|1|1|1|0|\\n|1|0|1|0|0|\\n\\n**Then we can get**:\\n\\nb\\' = 1: `(a==0 && b==1 && c==0) || (a==0 && b==0 && c==1)` \\n=> `b\\' = (~a & b & ~c) + (~a & ~b & c) = ~a & (b & ~c + ~b & c) = ~a & (b ^ c)` <br>\\na\\' = 1: `(a==1 && b==0 && c==0) || (a==0 && b==1 && c==1)` \\n=> `a\\' = (a & ~b & ~c) + (~a & b & c)` \\n=> `a\\' = (~a & ~b\\' & c) + (a & ~b\\' & ~c) = ~b\\' & (~a & c + a & ~c) = ~b\\' & (a ^ c)`\\n\\n## Code\\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        a, b = 0, 0\\n        for c in nums:\\n            b = (b ^ c) & ~a\\n            a = (a ^ c) & ~b\\n        return b\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        a, b = 0, 0\\n        for c in nums:\\n            b = (b ^ c) & ~a\\n            a = (a ^ c) & ~b\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700604,
                "title": "python-2-solutions",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : HASHMAP ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        counter = collections.Counter(nums)\\n        for num in counter.keys():\\n            if counter[num] == 1:\\n                return num\\n        \\n        ## APPROACH : BIT MANIPULATION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        # XOR operator which could be used to detect the bit which appears odd number of times: 1, 3, 5, etc.\\n        seen_once = seen_twice = 0\\n        for num in nums:\\n            # first appearance: \\n            # add num to seen_once \\n            # don\\'t add to seen_twice because of presence in seen_once\\n            \\n            # second appearance: \\n            # remove num from seen_once \\n            # add num to seen_twice\\n            \\n            # third appearance: \\n            # don\\'t add to seen_once because of presence in seen_twice\\n            # remove num from seen_twice\\n            seen_once = ~seen_twice & (seen_once ^ num) # change seen_once only if seen_twice is unchanged\\n            seen_twice = ~seen_once & (seen_twice ^ num) # change seen_twice only if seen_once is unchanged\\n        return seen_once\\n```\\nReference @ Leetcode\\nUseful article: https://medium.com/@lenchen/leetcode-137-single-number-ii-31af98b0f462",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : HASHMAP ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        counter = collections.Counter(nums)\\n        for num in counter.keys():\\n            if counter[num] == 1:\\n                return num\\n        \\n        ## APPROACH : BIT MANIPULATION ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        # XOR operator which could be used to detect the bit which appears odd number of times: 1, 3, 5, etc.\\n        seen_once = seen_twice = 0\\n        for num in nums:\\n            # first appearance: \\n            # add num to seen_once \\n            # don\\'t add to seen_twice because of presence in seen_once\\n            \\n            # second appearance: \\n            # remove num from seen_once \\n            # add num to seen_twice\\n            \\n            # third appearance: \\n            # don\\'t add to seen_once because of presence in seen_twice\\n            # remove num from seen_twice\\n            seen_once = ~seen_twice & (seen_once ^ num) # change seen_once only if seen_twice is unchanged\\n            seen_twice = ~seen_once & (seen_twice ^ num) # change seen_twice only if seen_once is unchanged\\n        return seen_once\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570559,
                "title": "java-o-1-space-complexity",
                "content": "This particular problem is a tricky one if you want to do it in **O(n)** time and **O(1)** space. \\n\\nSince, this problem is particular related to bit manipulations (which i am still learning), it needs basic knowledge of bitwise operators. So, the solution works like this:\\n\\n**eg. {2,3,2,3,2,4,3}**\\nBits representation of each element of the array is as follow:\\n2 -> 010\\n3 -> 011\\n2 -> 010\\n3 -> 011\\n2 -> 010\\n4 -> 100\\n3 -> 011\\n= -> 163\\nSo the total number of set bits (i.e **1**) at 0th bit is 3, at 1st bit is 6 and at 2nd bit is 1.\\n\\nNow, to get the answer, we divide the total number of set bits at each position by 3, and if it is divisible by 3, we set our final result bit to 0; otherwise 1.\\nSince, 3 is divisible by 3, we will set 0th bit \\xA0of our final **result** to **0**, 6 is divisible by 3, we set our 1st bit to **0**, but 1 is not divisible by 3, so we set the 2nd bit of our result to **1**. Hence the final **result** will be 100 which is equivalent to 4 in decimal representation. And **4** is the only single digit in our array.\\n\\nIn order to find whether the bit is 0 or 1, at a particular bit of an element, we run our first loop from **0** to **32** (because the number of bits in an Integer can be upto 32), and \\ncheck for set bits using \\n```\\nif(num & (1 << i) != 0)\\ncount++\\n}\\n```\\nif the bit is set, then we increment the **count** by **1**.\\n\\nOnce, we are out of the inner loop, we will have the count of set bits of a particular position/bit of each element of the array, using which we will set that particular position/bit of our result to either **0** or **1**.\\n```\\nresult |= ((count % 3) << i);\\n```\\n\\nTime Complexity of the Solution is **O(32 * n)**. Ignoring constants, it will be **O(n)**\\n\\n\\n```\\npublic Solution{\\n\\tpublic int singleNumber(int[] nums) {\\n        int result = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0for(int i = 0; i < 32; i++) { \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  int count = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0for(int num : nums) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if((nums & (1 << i)) != 0)\\n                    count++;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0result |= ((count % 3) << i);\\n        }\\n        return result;\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\nif(num & (1 << i) != 0)\\ncount++\\n}\\n```\n```\\nresult |= ((count % 3) << i);\\n```\n```\\npublic Solution{\\n\\tpublic int singleNumber(int[] nums) {\\n        int result = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0for(int i = 0; i < 32; i++) { \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  int count = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0for(int num : nums) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if((nums & (1 << i)) != 0)\\n                    count++;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0result |= ((count % 3) << i);\\n        }\\n        return result;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43426,
                "title": "4ms-solution-with-comments-single-loop-no-extra-memory",
                "content": "    int singleNumber(int A[], int n) {\\n    int r = 0, c = 0; \\n    // r A c | r  c\\n    // 0 0 0 | 0  0\\n    // 0 0 1 | 0  1\\n    // 0 1 0 | 1  0  ==> r = (~r & A & ~c) | (r & ~A & ~c)\\n    // 0 1 1 | 0  0  ==> c = (~r & ~A & c) | (r & A & ~c)\\n    // 1 0 0 | 1  0\\n    // 1 0 1 | 0  0\\n    // 1 1 0 | 0  1\\n    // 1 1 1 | 0  0\\n   \\n    while(n > 0) {\\n        --n;\\n        int t =  (~r & A[n] & ~c) | (r & ~A[n] & ~c); \\n        c = (~r & ~A[n] & c) | (r & A[n] & ~c);\\n        r = t;\\n    }\\n    return r; \\n}",
                "solutionTags": [],
                "code": "    int singleNumber(int A[], int n) {\\n    int r = 0, c = 0; \\n    // r A c | r  c\\n    // 0 0 0 | 0  0\\n    // 0 0 1 | 0  1\\n    // 0 1 0 | 1  0  ==> r = (~r & A & ~c) | (r & ~A & ~c)\\n    // 0 1 1 | 0  0  ==> c = (~r & ~A & c) | (r & A & ~c)\\n    // 1 0 0 | 1  0\\n    // 1 0 1 | 0  0\\n    // 1 1 0 | 0  1\\n    // 1 1 1 | 0  0\\n   \\n    while(n > 0) {\\n        --n;\\n        int t =  (~r & A[n] & ~c) | (r & ~A[n] & ~c); \\n        c = (~r & ~A[n] & c) | (r & A[n] & ~c);\\n        r = t;\\n    }\\n    return r; \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3721401,
                "title": "simple-iteration-method-with-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nneed a map for saving the frequency of the elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate a map , save frequency of elements in it. return the element with frequency 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto i: nums){\\n            mp[i]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==1)return x.first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto i: nums){\\n            mp[i]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==1)return x.first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715044,
                "title": "simple-c-bit-manipulation",
                "content": "This is the general question . \\n\\nYou may encounter where every digit appears 2 times except one then in that cases k=2 and p=1 ->k is 2, then m = 1, we need only one 32-bit integer (x1) as the counter. And 2^m = k so we do not even need a mask.\\n\\n``here \\n(k = 3, p = 1)\\nk is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m > k so we do need a mask. Write k in its binary form: k = \\'11\\', then k1 = 1, k2 = 1, so we have mask = ~(x1 & x2).``\\n\\n\\nIf k = 5, p = 3\\nk is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m > k so we need a mask. Write k in its binary form: k = \\'101\\', then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 & ~x2 & x3). \\n\\nIf you like the Solution then upvote me.\\n\\nCase->(k = 3, p = 1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int x1=0,x2=0,mask=0;\\n        for(auto i:nums)\\n        {\\n            x2^=x1&i;\\n            x1^=i;\\n            mask=~(x2&x1);\\n            x2&=mask;\\n            x1&=mask;\\n        }\\n        return x1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int x1=0,x2=0,mask=0;\\n        for(auto i:nums)\\n        {\\n            x2^=x1&i;\\n            x1^=i;\\n            mask=~(x2&x1);\\n            x2&=mask;\\n            x1&=mask;\\n        }\\n        return x1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714874,
                "title": "java-easy-2-step-bit-manipulation",
                "content": "# Explanation:\\nInitialize two variables, ones and twos, to keep track of the count of each bit position.\\n\\nones: Tracks the bits that have appeared once.\\ntwos: Tracks the bits that have appeared twice.\\nIterate through the array of numbers.\\n\\nFor each number i in the array:\\nUpdate ones and twos:\\n\\nLet\\'s analyze each step of the update process:\\n\\na. ones = (ones ^ i) & (~twos);:\\n\\nones ^ i XORs the current number i with the previous value of ones. This operation toggles the bits that have appeared an odd number of times, keeping the bits that have appeared twice unchanged.\\n(~twos) negates the bits in twos, effectively removing the bits that have appeared twice from consideration.\\nThe & operation ensures that only the bits that have appeared once (after XOR) and not twice (after negating twos) are retained.\\n\\nb. twos = (twos ^ i) & (~ones);:\\n\\ntwos ^ i XORs the current number i with the previous value of twos. This operation toggles the bits that have appeared an even number of times, effectively removing the bits that have appeared twice.\\n(~ones) negates the bits in ones, effectively removing the bits that have appeared once from consideration.\\nThe & operation ensures that only the bits that have appeared twice (after XOR) and not once (after negating ones) are retained.\\nAfter iterating through all the numbers, the value stored in ones will represent the single number that appears only once in the array.\\n\\nLet\\'s understand why this approach works:\\n\\nThe key idea is to use bitwise operations to keep track of the count of each bit position. By doing so, we can identify the bits that have appeared once, twice, or three times.\\nWhen a bit appears for the first time (ones is 0 and the bit is toggled), it is stored in ones.\\nWhen a bit appears for the second time (ones is 1 and the bit is toggled), it is removed from ones and stored in twos.\\nWhen a bit appears for the third time (ones is 0 and the bit is toggled), it is removed from both ones and twos.\\nBy the end of the iteration, the bits that remain in ones represent the bits of the single number that appeared only once, while the bits in twos represent bits that appeared three times (which is not possible).\\nIn summary, the algorithm uses bit manipulation to efficiently keep track of the counts of each bit position. By utilizing XOR and AND operations, it can identify the bits of the single number that appears only once in the array while ignoring the bits that appear multiple times.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       int ones = 0, twos = 0;\\n        for(int e : nums) {\\n            ones = ((ones ^ e) & (~ twos));  \\n            twos = ((twos ^ e) & (~ ones)); \\n        }\\n        return ones;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       int ones = 0, twos = 0;\\n        for(int e : nums) {\\n            ones = ((ones ^ e) & (~ twos));  \\n            twos = ((twos ^ e) & (~ ones)); \\n        }\\n        return ones;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190823,
                "title": "solution-using-bit-tricks",
                "content": "# Time Complexity - O(32*N)\\n# Space - O(1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans= 0;\\n        for(int i=0;i<32;i++){\\n            int ctBits = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j] &(1<<i))) // if bit is set     \\n                    ctBits++;\\n            }\\n            ctBits %=3;\\n\\n            if(ctBits==1)\\n            ans |=(1<<i); // if that position has 3*k+1 bits then set that bit into our ans\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n\\n# Most Optimised Solution\\n# Time Complexity - O(N)\\n# Space - O(1)\\n\\nThe idea is that while traversing in the array , at any postion we have three types of bitcounts 3n , 3n+1 and 3n+2 and our answer is the bits of 3n+1 type in the last iteration.\\nSo what we can do, we can maintain 3 numbers \\nWe intialise 3n number as all set bits and other two as zero.\\n\\n    Eg - [ 2, 2, 3, 2 ]    \\n|  | 3n | 3n+1 | 3n+2 |\\n| :--- | ---:| :---: | :---:|\\n|  start   |    111111 |   000000 |  000000 |    \\n| 2 --0010 |    000000 |   000010 |  000000 |\\n| 2 --0010 |    000000 |   000000 |  000010 |\\n| 3 --0011 |    000010 |   000001 |  000000 |\\n| 2 --0010 |    000000 |   000011 |  000000 |\\n    \\n    \\n      Answer - 3n+1 = 000011 = 3 \\n\\nSo how can we update the numbers at every iteration?\\nWell, if a bit is set in 3n and also set in A[i] ,then this bit will become a 3n+1 type bit , so we have to remove these common bits from 3n and add those bits in 3n+1. and similarly for 3n+1 and 3n+2 types also.\\nNow i think you get the idea why i have initialise the 3n type with 111....111(= -1) and other with zero.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& a) {\\n       int t3n=-1,t3n1=0,t3n2=0;\\n       for (int i=0;i<a.size();i++){\\n           int comt3n =  t3n &a[i]; // common bits with 3n types\\n           int comt3n1 = t3n1 &a[i];// common bits with 3n+1 types\\n           int comt3n2 = t3n2 &a[i];// common bits with 3n+2 types\\n\\n           t3n = t3n &(~comt3n); // remove common bits from 3n type\\n           t3n1 = t3n1| comt3n;  // add those bits to 3n+1 type\\n\\n           t3n1 = t3n1 &(~comt3n1);// remove common bits from 3n+1 type\\n           t3n2 = t3n2| comt3n1; // add those bits to 3n+2 type\\n\\n           t3n2 = t3n2 &(~comt3n2);// remove common bits from 3n+2 type\\n           t3n = t3n| comt3n2; // add those bits to 3n type\\n       }\\n\\n       return t3n1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans= 0;\\n        for(int i=0;i<32;i++){\\n            int ctBits = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j] &(1<<i))) // if bit is set     \\n                    ctBits++;\\n            }\\n            ctBits %=3;\\n\\n            if(ctBits==1)\\n            ans |=(1<<i); // if that position has 3*k+1 bits then set that bit into our ans\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& a) {\\n       int t3n=-1,t3n1=0,t3n2=0;\\n       for (int i=0;i<a.size();i++){\\n           int comt3n =  t3n &a[i]; // common bits with 3n types\\n           int comt3n1 = t3n1 &a[i];// common bits with 3n+1 types\\n           int comt3n2 = t3n2 &a[i];// common bits with 3n+2 types\\n\\n           t3n = t3n &(~comt3n); // remove common bits from 3n type\\n           t3n1 = t3n1| comt3n;  // add those bits to 3n+1 type\\n\\n           t3n1 = t3n1 &(~comt3n1);// remove common bits from 3n+1 type\\n           t3n2 = t3n2| comt3n1; // add those bits to 3n+2 type\\n\\n           t3n2 = t3n2 &(~comt3n2);// remove common bits from 3n+2 type\\n           t3n = t3n| comt3n2; // add those bits to 3n type\\n       }\\n\\n       return t3n1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106228,
                "title": "c-bit-manipulation-solution-fast-simple-try-once",
                "content": "\\t**All suggestions are welcome.\\n\\tIf you have any query or suggestion please comment below.\\n\\tPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         int ans=0;\\n        for(int i=0 ; i<32 ; i++){\\n            int sum =0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j]>>i) & 1){ sum++;}\\n            }\\n            if(sum%3!=0){\\n                ans = ans | 1<<i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         int ans=0;\\n        for(int i=0 ; i<32 ; i++){\\n            int sum =0;\\n            for(int j=0;j<nums.size();j++){\\n                if((nums[j]>>i) & 1){ sum++;}\\n            }\\n            if(sum%3!=0){\\n                ans = ans | 1<<i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772454,
                "title": "c-count-freq-of-each-bit-similar-to-xor",
                "content": "Before solving this question. solve the following one.\\n\\nhttps://leetcode.com/problems/single-number/\\n\\nIn the above question, since all elements occus twice and only one element occur once. so we use xor.\\nBecause when we get 2 \\'1\\'s in a bit , the result is \\'0\\' in that bit. so all the elements that are occuring twice, xor makes the effect of those nullified.\\n\\nIn this question. Each element except the answer occurs thrice.\\nSo instead of nullifying a bit when 2 \\'1\\'s occurs in a bit , we should nullify when we get 3 \\'1\\'s.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums)\\n    {\\n        vector<int> freq(32,0)  ;\\n        \\n        for(auto x : nums)\\n        {\\n            for(int i=0;i<32;i++)\\n            {\\n                if(x&(1<<i))\\n                    freq[i]++ ;\\n            }\\n        }\\n        \\n        int ans = 0 ;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            int f = freq[i] ;\\n            \\n            f = f%3 ;\\n            \\n            if(f)\\n                ans = ans + (1<<i) ;\\n        }\\n        \\n       \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums)\\n    {\\n        vector<int> freq(32,0)  ;\\n        \\n        for(auto x : nums)\\n        {\\n            for(int i=0;i<32;i++)\\n            {\\n                if(x&(1<<i))\\n                    freq[i]++ ;\\n            }\\n        }\\n        \\n        int ans = 0 ;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            int f = freq[i] ;\\n            \\n            f = f%3 ;\\n            \\n            if(f)\\n                ans = ans + (1<<i) ;\\n        }\\n        \\n       \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752436,
                "title": "simple-c-solution-o-1-space-and-o-32-n-time-complexity",
                "content": "According to the problem every number occurs thrice  except one .So we will count the number of set bits for each position , and whenever we get the no of set bits which is not a multiple of 3 it concludes that that particular bit is set in the single number .So we will add these masks and the result will be answer.Follow the code for more clarity.. Please do upvote if yu like my explanation.This is my first article.\\nOne more point this solution can work for all similar type of problems where all numbers except one occur k times and the remainimg one occurs m times..\\n\\nTime Complexity=0(32*n);\\nSpace Complexity=O(1);\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=0;i<=31;i++){\\n            int cnt=0;\\n            for(auto x:nums){\\n                if(x&(1<<i))cnt++;\\n            }\\n            if(cnt%3)res+=1<<i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=0;i<=31;i++){\\n            int cnt=0;\\n            for(auto x:nums){\\n                if(x&(1<<i))cnt++;\\n            }\\n            if(cnt%3)res+=1<<i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739638,
                "title": "solution-swift-single-number-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ones = 0, twos = 0\\n        for n in nums {\\n            ones = ones ^ n & ~twos\\n            twos = twos ^ n & ~ones\\n        }\\n        return ones\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,3,2])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([0,1,0,1,0,1,99])\\n        XCTAssertEqual(value, 99)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ones = 0, twos = 0\\n        for n in nums {\\n            ones = ones ^ n & ~twos\\n            twos = twos ^ n & ~ones\\n        }\\n        return ones\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,3,2])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([0,1,0,1,0,1,99])\\n        XCTAssertEqual(value, 99)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573364,
                "title": "java-simple-solution",
                "content": "The idea of this solution is that we find the count of sets bits in every postion from bit 1 to bit 32 for the whole array. If for bit position 1 we get count which is not multiple of 3 then it means the result has bit set in 1st postion.\\n\\nSimiliary we check count of bits in whole array for all position.\\nNote: The advantage for this approach is that it can be easily handle situation when other numbers repeat 3time, 4times or any N times. We can just replace count % 3 with count % N.\\n```\\npublic int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i=0; i<=31; i++) {\\n            int count = getCount(i,nums);\\n            if(count % 3 != 0) result = result + (1<<i);\\n        }\\n        return result;\\n    }\\n    \\n    private int getCount(int position, int[] arr) {\\n        int count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            if( (arr[i] & 1<<position) != 0) count++; \\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i=0; i<=31; i++) {\\n            int count = getCount(i,nums);\\n            if(count % 3 != 0) result = result + (1<<i);\\n        }\\n        return result;\\n    }\\n    \\n    private int getCount(int position, int[] arr) {\\n        int count = 0;\\n        for(int i=0; i<arr.length; i++) {\\n            if( (arr[i] & 1<<position) != 0) count++; \\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364857,
                "title": "c-o-n-time-o-1-space-clean-concise-solution-with-detailed-explaination",
                "content": "* **Solution**\\nWe count the number of every bit 1 in one position of every element in an array ( position is from 0 to 31 ) because every element appears three times except one element so if the number of bit 1 in one position mod 3 = 0 the bit in that position in our result will be zero otherwise it will be 1. \\n\\n* **Time Complexity**\\nWe just go through all the element of the array size n so the time complexity is O(32n) or **O(n)**.\\n\\n* **Space Complexity**\\nWe just use constant number of variables so the space compleixty is **O(1)**.\\n\\n* **Source Code**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size(),res=0;\\n        for (int i=0;i<32;++i) {\\n            int sum = 0;\\n            int mask = 1<<i;\\n            for (int j=0;j<n;++j) \\n                if ( (nums[j] & mask) !=0)\\n                    ++sum;\\n            if (sum%3!=0) \\n                res |= mask;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size(),res=0;\\n        for (int i=0;i<32;++i) {\\n            int sum = 0;\\n            int mask = 1<<i;\\n            for (int j=0;j<n;++j) \\n                if ( (nums[j] & mask) !=0)\\n                    ++sum;\\n            if (sum%3!=0) \\n                res |= mask;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249795,
                "title": "c-easy-to-understand-using-two-approaches",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\n**Using hashtables-[time complexity O(n) and space complexity O(n)]**\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second==1)\\n            return it.first;\\n        }\\n        return 0;\\n    }\\n};\\n**Using bitwise operators[time complexity O(n) and space complexity O(1)]**\\nclass Solution {\\npublic:\\nint singleNumber(vector<int>& nums) {\\nint ones = 0, twos = 0;\\nfor(int i = 0; i < nums.size(); i++){\\nones = (ones ^ nums[i]) & ~twos;\\ntwos = (twos ^ nums[i]) & ~ones;\\n}\\nreturn ones;\\n}\\n};",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1245007,
                "title": "simple-c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j < n; j++) {\\n                if(((nums[j]&(1<<i)) != 0)) {\\n                    cnt+=1;\\n                }\\n            }\\n            res|=((cnt%3)<<i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**please upvote if you like it.**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j < n; j++) {\\n                if(((nums[j]&(1<<i)) != 0)) {\\n                    cnt+=1;\\n                }\\n            }\\n            res|=((cnt%3)<<i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165580,
                "title": "generic-way-to-solve-k-repeat-1-single-problems",
                "content": "```\\nclass Solution {\\npublic:\\n    // All numbers appear exactly K times but one number appears only once. Find it.\\n    // TC: O(32 * N) ~ O(N)\\n    int getSingleNumber(vector<int>&arr, int K)\\n    {\\n        long long singleNumber = 0;\\n        for(int bit = 0; bit < 32; bit++)\\n        {\\n            int bitcount = 0;\\n            for(auto &val : arr)\\n            {\\n                if(val & (1LL << bit))\\n                    bitcount++;\\n            }\\n            if(bitcount % K == 1)\\n                singleNumber |= 1LL << bit;\\n        }\\n        return (int)singleNumber;\\n    }\\n    int singleNumber(vector<int>& nums) {\\n        return getSingleNumber(nums, 3);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // All numbers appear exactly K times but one number appears only once. Find it.\\n    // TC: O(32 * N) ~ O(N)\\n    int getSingleNumber(vector<int>&arr, int K)\\n    {\\n        long long singleNumber = 0;\\n        for(int bit = 0; bit < 32; bit++)\\n        {\\n            int bitcount = 0;\\n            for(auto &val : arr)\\n            {\\n                if(val & (1LL << bit))\\n                    bitcount++;\\n            }\\n            if(bitcount % K == 1)\\n                singleNumber |= 1LL << bit;\\n        }\\n        return (int)singleNumber;\\n    }\\n    int singleNumber(vector<int>& nums) {\\n        return getSingleNumber(nums, 3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982107,
                "title": "c-bit-manipulation-with-detailed-explanation-plus-some-generalization",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Bit operation, xor operation can detect (flag) when 1 appears odd number of times. But in this case, we need to distinguish the 1 times from 3 times. \\n\\t\\t// Since only two states available for each binary bit, we need thus two bits (thus allow 4 states) for each bit detection, in other words, we use two variables.\\n        // Recall in Problem 136, we have one variable. Each bit in this variable help us distinguish the odd from even number of times.\\n        // Now, we use two variables, seen_once, seen_twice. Bit in seen_once is 1 only when 1 in this bit position appears 1 time. Bit in seen_twice is 1 only when 1 in this bit position appears 2 times. \\n\\t\\t// The corresponding transformation table is below:\\n        // Number of appearance:        0 time,  1 time,  2 times,  3 times\\n        // seen_once:                    0       ,1      , 0        ,0\\n        // seen_twice:                   0       ,0      , 1        ,0\\n\\t\\t// We now need to construct transformation rules to produce the above table, for example:\\n        // seen_once = (seen_once ^ num) & (~seen_twice);\\n        // seen_twice = (seen_twice ^ num) & (~seen_once);\\n        // Note the order is very important here. You must update seen_once variable before updting seen_twice. \\n\\t\\t// (~seen_twice) is used to notify seen_once to ignore when 1 is about to appear 3 times. (Remember 1 should have appeared already two times in order to appear 3 times.)\\n\\t\\t// (~seen_once) is used to make xor operation detect even times of appearance instead of odd times. \\n        // In fact, you can come up with other transformations as long as they give the above table.\\n\\t\\t// Since bits (seen_once, seen_twice) will be 0 whenever 1 appears 3 or 3n times, while seen_once will be 1 when 1 appears 1 time, we can simply return seen_once at the end of program.\\n        // As you can see, using two variables with the above transformation gives 3 different states instead of only 2 states if using 1 variable (mod 2).\\n\\t\\t// If we want to distinguish 1 time from 5 number of times, we need to have the following table using 3 variables:\\n        // Number of appearance:        0 time,  1 time,  2 times,  3 times,  4 times   5 times\\n        // first_bit:                    0       ,1      , 0        ,1         ,0        0\\n        // second_bit:                   0       ,0      , 1        ,1         ,0        0\\n        // third_bit:                    0       ,0      , 0,       ,0         ,1        0\\n        // This table could let us distinguish 5 states, and any bit (first_bit, second_bit, third_bit) will be 0 as long as 1 appears 5 times or 5n times. One of possible transformation rules are below as an example:\\n        // first_bit = (first_bit ^ num) & (~third_bit);\\n        // second_bit = (first_bit & second_bit | ~first_bit & (second_bit ^ num)) & (~third_bit)\\n        // third_bit = (third_bit ^ num) & (~(first_bit | second_bit))\\n\\t\\t// Anyway, once construct the transformation table, you could play around to think of  the corresponding rules.\\n        int first_bit = 0, second_bit = 0;\\n        for(auto num:nums){\\n           first_bit = (first_bit ^ num) & (~second_bit);\\n           second_bit = (second_bit ^ num) & (~first_bit);\\n        }\\n        return first_bit;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Bit operation, xor operation can detect (flag) when 1 appears odd number of times. But in this case, we need to distinguish the 1 times from 3 times. \\n\\t\\t// Since only two states available for each binary bit, we need thus two bits (thus allow 4 states) for each bit detection, in other words, we use two variables.\\n        // Recall in Problem 136, we have one variable. Each bit in this variable help us distinguish the odd from even number of times.\\n        // Now, we use two variables, seen_once, seen_twice. Bit in seen_once is 1 only when 1 in this bit position appears 1 time. Bit in seen_twice is 1 only when 1 in this bit position appears 2 times. \\n\\t\\t// The corresponding transformation table is below:\\n        // Number of appearance:        0 time,  1 time,  2 times,  3 times\\n        // seen_once:                    0       ,1      , 0        ,0\\n        // seen_twice:                   0       ,0      , 1        ,0\\n\\t\\t// We now need to construct transformation rules to produce the above table, for example:\\n        // seen_once = (seen_once ^ num) & (~seen_twice);\\n        // seen_twice = (seen_twice ^ num) & (~seen_once);\\n        // Note the order is very important here. You must update seen_once variable before updting seen_twice. \\n\\t\\t// (~seen_twice) is used to notify seen_once to ignore when 1 is about to appear 3 times. (Remember 1 should have appeared already two times in order to appear 3 times.)\\n\\t\\t// (~seen_once) is used to make xor operation detect even times of appearance instead of odd times. \\n        // In fact, you can come up with other transformations as long as they give the above table.\\n\\t\\t// Since bits (seen_once, seen_twice) will be 0 whenever 1 appears 3 or 3n times, while seen_once will be 1 when 1 appears 1 time, we can simply return seen_once at the end of program.\\n        // As you can see, using two variables with the above transformation gives 3 different states instead of only 2 states if using 1 variable (mod 2).\\n\\t\\t// If we want to distinguish 1 time from 5 number of times, we need to have the following table using 3 variables:\\n        // Number of appearance:        0 time,  1 time,  2 times,  3 times,  4 times   5 times\\n        // first_bit:                    0       ,1      , 0        ,1         ,0        0\\n        // second_bit:                   0       ,0      , 1        ,1         ,0        0\\n        // third_bit:                    0       ,0      , 0,       ,0         ,1        0\\n        // This table could let us distinguish 5 states, and any bit (first_bit, second_bit, third_bit) will be 0 as long as 1 appears 5 times or 5n times. One of possible transformation rules are below as an example:\\n        // first_bit = (first_bit ^ num) & (~third_bit);\\n        // second_bit = (first_bit & second_bit | ~first_bit & (second_bit ^ num)) & (~third_bit)\\n        // third_bit = (third_bit ^ num) & (~(first_bit | second_bit))\\n\\t\\t// Anyway, once construct the transformation table, you could play around to think of  the corresponding rules.\\n        int first_bit = 0, second_bit = 0;\\n        for(auto num:nums){\\n           first_bit = (first_bit ^ num) & (~second_bit);\\n           second_bit = (second_bit ^ num) & (~first_bit);\\n        }\\n        return first_bit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951472,
                "title": "python-bit-wise-solution",
                "content": "Consider the following operations:\\n0 ^ x = x,\\n\\nx ^ x = 0\\uFF1B\\n\\nx & ~x = 0,\\n\\nx & ~0 =x;\\n\\nif x appears once, a=x, b=0;\\nif x appears twice, a=0,b=x;\\nif x appears triple, a=0,b=0;\\nTherefore, the first case correponds to the single number, a will be the answer.\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a,b=0,0\\n        for num in nums:\\n            a=(a^num)&(~b)\\n            b=(b^num)&(~a)\\n            \\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a,b=0,0\\n        for num in nums:\\n            a=(a^num)&(~b)\\n            b=(b^num)&(~a)\\n            \\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763396,
                "title": "detailed-explained-solution-with-bit-wise-operator",
                "content": "```\\nclass Solution {\\npublic:\\n    //ones - At any point of time, this variable holds XOR of all the elements which have\\n    //appeared \"only\" once. \\n    //twos - At any point of time, this variable holds XOR of all the elements which have\\n    //appeared \"only\" twice.\\n\\n    //So if at any point time,\\n    //1. A new number appears - It gets XOR\\'d to the variable \"ones\".\\n    //2. A number gets repeated(appears twice) - It is removed from \"ones\" and XOR\\'d to the\\n    //variable \"twice\".\\n    //3. A number appears for the third time - It gets removed from both \"ones\" and \"twice\".\\n\\n    //The final answer we want is the value present in \"ones\" - coz, it holds the unique element.\\n\\n    //So if we explain how steps 1 to 3 happens in the code, we are done.\\n    //Before explaining above 3 steps, lets look at last three lines of the code,\\n\\n    //not_threes = ~(ones & twos)\\n    //ones & = not_threes\\n    //twos & = not_threes\\n\\n    //All it does is, common 1\\'s between \"ones\" and \"twos\" are converted to zero.\\n\\n    //For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique     //element and 3 repeated elements - in any order).\\n\\n    //Explanation for step 1\\n    //------------------------\\n    //Lets say a new element(x) appears.\\n    //CURRENT SITUATION - Both variables - \"ones\" and \"twos\" has not recorded \"x\".\\n\\n    //Observe the statement \"twos| = ones & x\".\\n    //Since bit representation of \"x\" is not present in \"ones\", AND condition yields nothing. So \"twos\" does not get     //bit representation of \"x\".\\n    //But, in next step \"ones ^= x\" - \"ones\" ends up adding bits of \"x\". Thus new element gets recorded in \"ones\"       //but not in \"twos\".\\n\\n    //The last 3 lines of code as explained already, converts common 1\\'s b/w \"ones\" and \"twos\" to zeros.\\n    //Since as of now, only \"ones\" has \"x\" and not \"twos\" - last 3 lines does nothing.\\n\\n    //Explanation for step 2.\\n    //------------------------\\n    //Lets say an element(x) appears twice.\\n    //CURRENT SITUATION - \"ones\" has recorded \"x\" but not \"twos\".\\n\\n    //Now due to the statement, \"twos| = ones & x\" - \"twos\" ends up getting bits of x.\\n    //But due to the statement, \"ones ^ = x\" - \"ones\" removes \"x\" from its binary representation.\\n\\n    //Again, last 3 lines of code does nothing.\\n    //So ultimately, \"twos\" ends up getting bits of \"x\" and \"ones\" ends up losing bits of \"x\".\\n\\n    //Explanation for step 3.\\n    //-------------------------\\n    //Lets say an element(x) appears for the third time.\\n    //CURRENT SITUATION - \"ones\" does not have bit representation of \"x\" but \"twos\" has.\\n\\n    //Though \"ones & x\" does not yield nothing .. \"twos\" by itself has bit representation of \"x\". So after this         //statement, \"two\" has bit representation of \"x\".\\n    //Due to \"ones^=x\", after this step, \"one\" also ends up getting bit representation of \"x\".\\n\\n    //Now last 3 lines of code removes common 1\\'s of \"ones\" and \"twos\" - which is the bit representation of \"x\".\\n    //Thus both \"ones\" and \"twos\" ends up losing bit representation of \"x\".\\n\\n    //1st example\\n    //------------\\n    //2, 2, 2, 4\\n\\n    //After first iteration,\\n    //ones = 2, twos = 0\\n    //After second iteration,\\n    //ones = 0, twos = 2\\n    //After third iteration,\\n    //ones = 0, twos = 0\\n    //After fourth iteration,\\n    //ones = 4, twos = 0\\n\\n    //2nd example\\n    //------------\\n    //4, 2, 2, 2\\n\\n    //After first iteration,\\n    //ones = 4, twos = 0\\n    //After second iteration,\\n    //ones = 6, twos = 0\\n    //After third iteration,\\n    //ones = 4, twos = 2\\n    //After fourth iteration,\\n    //ones = 4, twos = 0\\n    //Explanation copied from : https://www.careercup.com/question?id=7902674\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0;\\n        int twos = 0;\\n        int non_threes = 0;\\n        \\n        for(int digIdx = 0; digIdx < nums.size(); digIdx++){\\n            twos |= (ones & nums[digIdx]);\\n            ones ^= nums[digIdx];\\n            \\n            non_threes = ~(ones & twos);\\n            ones &= non_threes;\\n            twos &= non_threes;\\n        }\\n        \\n        return ones;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //ones - At any point of time, this variable holds XOR of all the elements which have\\n    //appeared \"only\" once. \\n    //twos - At any point of time, this variable holds XOR of all the elements which have\\n    //appeared \"only\" twice.\\n\\n    //So if at any point time,\\n    //1. A new number appears - It gets XOR\\'d to the variable \"ones\".\\n    //2. A number gets repeated(appears twice) - It is removed from \"ones\" and XOR\\'d to the\\n    //variable \"twice\".\\n    //3. A number appears for the third time - It gets removed from both \"ones\" and \"twice\".\\n\\n    //The final answer we want is the value present in \"ones\" - coz, it holds the unique element.\\n\\n    //So if we explain how steps 1 to 3 happens in the code, we are done.\\n    //Before explaining above 3 steps, lets look at last three lines of the code,\\n\\n    //not_threes = ~(ones & twos)\\n    //ones & = not_threes\\n    //twos & = not_threes\\n\\n    //All it does is, common 1\\'s between \"ones\" and \"twos\" are converted to zero.\\n\\n    //For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique     //element and 3 repeated elements - in any order).\\n\\n    //Explanation for step 1\\n    //------------------------\\n    //Lets say a new element(x) appears.\\n    //CURRENT SITUATION - Both variables - \"ones\" and \"twos\" has not recorded \"x\".\\n\\n    //Observe the statement \"twos| = ones & x\".\\n    //Since bit representation of \"x\" is not present in \"ones\", AND condition yields nothing. So \"twos\" does not get     //bit representation of \"x\".\\n    //But, in next step \"ones ^= x\" - \"ones\" ends up adding bits of \"x\". Thus new element gets recorded in \"ones\"       //but not in \"twos\".\\n\\n    //The last 3 lines of code as explained already, converts common 1\\'s b/w \"ones\" and \"twos\" to zeros.\\n    //Since as of now, only \"ones\" has \"x\" and not \"twos\" - last 3 lines does nothing.\\n\\n    //Explanation for step 2.\\n    //------------------------\\n    //Lets say an element(x) appears twice.\\n    //CURRENT SITUATION - \"ones\" has recorded \"x\" but not \"twos\".\\n\\n    //Now due to the statement, \"twos| = ones & x\" - \"twos\" ends up getting bits of x.\\n    //But due to the statement, \"ones ^ = x\" - \"ones\" removes \"x\" from its binary representation.\\n\\n    //Again, last 3 lines of code does nothing.\\n    //So ultimately, \"twos\" ends up getting bits of \"x\" and \"ones\" ends up losing bits of \"x\".\\n\\n    //Explanation for step 3.\\n    //-------------------------\\n    //Lets say an element(x) appears for the third time.\\n    //CURRENT SITUATION - \"ones\" does not have bit representation of \"x\" but \"twos\" has.\\n\\n    //Though \"ones & x\" does not yield nothing .. \"twos\" by itself has bit representation of \"x\". So after this         //statement, \"two\" has bit representation of \"x\".\\n    //Due to \"ones^=x\", after this step, \"one\" also ends up getting bit representation of \"x\".\\n\\n    //Now last 3 lines of code removes common 1\\'s of \"ones\" and \"twos\" - which is the bit representation of \"x\".\\n    //Thus both \"ones\" and \"twos\" ends up losing bit representation of \"x\".\\n\\n    //1st example\\n    //------------\\n    //2, 2, 2, 4\\n\\n    //After first iteration,\\n    //ones = 2, twos = 0\\n    //After second iteration,\\n    //ones = 0, twos = 2\\n    //After third iteration,\\n    //ones = 0, twos = 0\\n    //After fourth iteration,\\n    //ones = 4, twos = 0\\n\\n    //2nd example\\n    //------------\\n    //4, 2, 2, 2\\n\\n    //After first iteration,\\n    //ones = 4, twos = 0\\n    //After second iteration,\\n    //ones = 6, twos = 0\\n    //After third iteration,\\n    //ones = 4, twos = 2\\n    //After fourth iteration,\\n    //ones = 4, twos = 0\\n    //Explanation copied from : https://www.careercup.com/question?id=7902674\\n    int singleNumber(vector<int>& nums) {\\n        int ones = 0;\\n        int twos = 0;\\n        int non_threes = 0;\\n        \\n        for(int digIdx = 0; digIdx < nums.size(); digIdx++){\\n            twos |= (ones & nums[digIdx]);\\n            ones ^= nums[digIdx];\\n            \\n            non_threes = ~(ones & twos);\\n            ones &= non_threes;\\n            twos &= non_threes;\\n        }\\n        \\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700038,
                "title": "javascript-bitwise-solution-with-explanation",
                "content": "Here we treat every number as a set of bits. When looping through the array we will get rid of bits that occured **three** times. And we will keep bits that occured only **once**. This way we\\'ll end up with bits that form the number we\\'re looking for.\\n\\n* We define two variables: **singles** and **doubles**. In **singles** we keep bits that occured once, in **doubles** we keep bits that occured twice;\\n* Every bit from every number comes to **singles** first;\\n* When it comes second time it\\'s dropped to **doubles**;\\n* When it comes third time it\\'s removed from **doubles**;\\n* This way we ensure that all the bits that occured three times are sifted;\\n* Basically, we don\\'t care with which numbers bits come, we just count bit occurances;\\n* In the end we can just return **singles** as a result as it will hold bits of a number that occured only once.\\n\\n```js\\nvar singleNumber = function(nums) {\\n    let singles = 0;\\n    let doubles = 0;\\n\\n    for (num of nums) {\\n        // Add to singles if it\\'s not in doubles. Also remove from singles if it\\'s in there\\n        singles = (~doubles) & (singles ^ num);\\n        // Add to doubles if it\\'s not in singles. Also remove from doubles if it\\'s in there\\n        doubles = (~singles) & (doubles ^ num);\\n    }\\n\\n    return singles;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```js\\nvar singleNumber = function(nums) {\\n    let singles = 0;\\n    let doubles = 0;\\n\\n    for (num of nums) {\\n        // Add to singles if it\\'s not in doubles. Also remove from singles if it\\'s in there\\n        singles = (~doubles) & (singles ^ num);\\n        // Add to doubles if it\\'s not in singles. Also remove from doubles if it\\'s in there\\n        doubles = (~singles) & (doubles ^ num);\\n    }\\n\\n    return singles;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 446728,
                "title": "c-solution-linear-time-without-extra-space-bit-manipulation-8ms",
                "content": "Runtime: 8 ms, faster than 97.08% of C++ online submissions for Single Number II.\\nMemory Usage: 9.6 MB, less than 87.50% of C++ online submissions for Single Number II.\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int res = 0;\\n        for(int i=0; i<32; i++)\\n        {\\n            int mask = (1 << i);\\n            int count = 0;\\n            for(int j=0; j<nums.size(); j++)\\n                if(mask&nums[j]) count++;\\n            if(count%3)\\n                res |= (1<<i);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int res = 0;\\n        for(int i=0; i<32; i++)\\n        {\\n            int mask = (1 << i);\\n            int count = 0;\\n            for(int j=0; j<nums.size(); j++)\\n                if(mask&nums[j]) count++;\\n            if(count%3)\\n                res |= (1<<i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 384270,
                "title": "o-n-constant-space-solution-with-intuitive-analysis",
                "content": "Let the number appearing once be x. Let S(x) be the positions whose values equal to 1 for the binary representation of x. For example, when x=3, S(x)={0,1}. \\nFor all the numbers, at the positions other than S(x), the number of 1s appearing is 3k, i.e., a multiple of 3; at the positions of S(x), the number of 1s is 3k+1. So if we record the number of 1s appearing for each position, then use the positions where 1s appear 3k+1 to reconstruct x. \\nFor each position, 1s could appear 3k,3k+1,3k+2 times. To represent 3 statuses, we at least need 2 bits for each position (that is why we need m1,m2 and no need for m3). \\nFor each position, we check manipulate as follows: if the previous status is (0,0) for (m1,m2), when there is 1, we change the status into (1,0); if the previous status is (1,0), when there is 1, we change the status into (0,1).. etc. \\nThe manipulation of each bit can be simplified into a whole integer xor and land. \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    /**\\n    times   m1  m2\\n    0   0   0\\n    1   1   0\\n    2   0   1\\n    3   0   0\\n    4   1   0\\n    5   0   1\\n    */\\n    int singleNumber(vector<int>& nums) {\\n        int m1 = 0, m2 = 0;\\n        for (auto n : nums) {\\n            m1 = (m1 ^ n) & (~m2);\\n            m2 = (m2 ^ n) & (~m1);\\n        }\\n        return m1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n    times   m1  m2\\n    0   0   0\\n    1   1   0\\n    2   0   1\\n    3   0   0\\n    4   1   0\\n    5   0   1\\n    */\\n    int singleNumber(vector<int>& nums) {\\n        int m1 = 0, m2 = 0;\\n        for (auto n : nums) {\\n            m1 = (m1 ^ n) & (~m2);\\n            m2 = (m2 ^ n) & (~m1);\\n        }\\n        return m1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346517,
                "title": "comprehensive-explanation-for-those-confused-using-python",
                "content": "This post emphasizes on explanation of the concept, not on performance.\\n\\nThere has been a number of good posts describing the idea of bitwise operations. They are all correct, but may fall short in explaning the code, plus the usage of various tricks and shortcuts and arbitrary variable names, making them a bit black-magic.\\n\\nI\\'ll try to explain with code what really happens within these approaches.\\n\\nPrerequisite: you should know what bitwise operations are, and we only use those operations that do not carry or borrow (namely, &, |, ^, ~)\\n```python\\n# since we do not borrow or carry, we think of each number simply as one bit (each bit is independently tracked from other bits)\\n# when a bit comes in, if it\\'s 0, we do nothing; if it\\'s 1, we want to know whether our current tracking bit is 0, 1 or 2\\n#   * 0 + 1 --> 1\\n#   * 1 + 1 --> 2\\n#   * 2 + 1 --> 0\\n# since the tracking bit has 3 possible states, we need two variables to track it\\n# let\\'s call the two tracking variables tracking_A and tracking_B\\n# the logic to make use of these two tracking bits are:\\n#   (1) new bit 1 tries to go into A, if not possible (A was already 1), it goes into B\\n#   (2) if it can go into B (B was 0), we are done\\n#   (3) if B was also occupied by 1, then A and B should be both cleared to 0, and we are done\\n#\\n# now the code:\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        tracking_A = 0         # tracking bit A\\n        tracking_B = 0         # tracking bit B\\n        for incoming in nums:  # the incoming bit\\n            bits_to_tracking_B = tracking_A & incoming           # those bits that cannot fit into tracking_A will go to tracking_B, so we take them out first\\n            resetting_bits = tracking_A & tracking_B & incoming  # when we encounter three bit 1, the bit should be reset to 0\\n            tracking_A = tracking_A | incoming           # update tracking_A\\n            tracking_B = tracking_B | bits_to_tracking_B # update tracking_B\\n            tracking_A = tracking_A ^ resetting_bits     # reset tracking_A\\n            tracking_B = tracking_B ^ resetting_bits     # reset tracking_B\\n\\n        return tracking_A                                # tracking_B is always 0 at the end, tracking_A will hold everything that has not cancelled out, which is what we want\\n```\\n\\nYou can clearly see space for optimization in the above code, as there are clearly redundant calculations. Again it is written for clarity, but feel free to optimize!\\n\\nAgain, if you are confused, think about one bit only! Since the algorithm operates on each bit *independently*, when you have an algorithem for one bit, you automatically have an algorithm for an integer!",
                "solutionTags": [],
                "code": "```python\\n# since we do not borrow or carry, we think of each number simply as one bit (each bit is independently tracked from other bits)\\n# when a bit comes in, if it\\'s 0, we do nothing; if it\\'s 1, we want to know whether our current tracking bit is 0, 1 or 2\\n#   * 0 + 1 --> 1\\n#   * 1 + 1 --> 2\\n#   * 2 + 1 --> 0\\n# since the tracking bit has 3 possible states, we need two variables to track it\\n# let\\'s call the two tracking variables tracking_A and tracking_B\\n# the logic to make use of these two tracking bits are:\\n#   (1) new bit 1 tries to go into A, if not possible (A was already 1), it goes into B\\n#   (2) if it can go into B (B was 0), we are done\\n#   (3) if B was also occupied by 1, then A and B should be both cleared to 0, and we are done\\n#\\n# now the code:\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        tracking_A = 0         # tracking bit A\\n        tracking_B = 0         # tracking bit B\\n        for incoming in nums:  # the incoming bit\\n            bits_to_tracking_B = tracking_A & incoming           # those bits that cannot fit into tracking_A will go to tracking_B, so we take them out first\\n            resetting_bits = tracking_A & tracking_B & incoming  # when we encounter three bit 1, the bit should be reset to 0\\n            tracking_A = tracking_A | incoming           # update tracking_A\\n            tracking_B = tracking_B | bits_to_tracking_B # update tracking_B\\n            tracking_A = tracking_A ^ resetting_bits     # reset tracking_A\\n            tracking_B = tracking_B ^ resetting_bits     # reset tracking_B\\n\\n        return tracking_A                                # tracking_B is always 0 at the end, tracking_A will hold everything that has not cancelled out, which is what we want\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340185,
                "title": "python-5-line-bit-operation-92-70",
                "content": "Explanation: the following bit operation is correct because\\n(1) This bit operation (as a whole for each iteration) is communitive, i.e. results are same regardless how nums are re-arranged. (thus we can analyze it as if the repeated numbers are next to each other)\\n(2) res1 = num, res2 = 0 if we encounter a number for the first time\\n(3) res1 = res2 = 0 (i.e. been reset) if we encounter a number repeatedly three times\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res1 = res2 = 0\\n        for num in nums:\\n            res1 = (res1 ^ num) & (~res2)\\n            res2 = (res2 ^ num) & (~res1)\\n        return res1",
                "solutionTags": [],
                "code": "Explanation: the following bit operation is correct because\\n(1) This bit operation (as a whole for each iteration) is communitive, i.e. results are same regardless how nums are re-arranged. (thus we can analyze it as if the repeated numbers are next to each other)\\n(2) res1 = num, res2 = 0 if we encounter a number for the first time\\n(3) res1 = res2 = 0 (i.e. been reset) if we encounter a number repeatedly three times\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res1 = res2 = 0\\n        for num in nums:\\n            res1 = (res1 ^ num) & (~res2)\\n            res2 = (res2 ^ num) & (~res1)\\n        return res1",
                "codeTag": "Java"
            },
            {
                "id": 309261,
                "title": "java-solution-100-faster",
                "content": "//Runtime: 0 ms, faster than 100.00% of Java online submissions for Single Number II.\\nclass Solution {\\n    public int singleNumber(int[] arr) {\\n        int one=0;\\n        int two=0;\\n        for(int value:arr)\\n        {\\n            one=one^value&~two;\\n            two=two^value&~one;\\n        }\\n        return one;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] arr) {\\n        int one=0;\\n        int two=0;\\n        for(int value:arr)\\n        {\\n            one=one^value&~two;\\n            two=two^value&~one;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 300668,
                "title": "c-solution-using-bits",
                "content": "So, the logic is, let\\'s take 32 - bit integer. Initially it would look like this\\n\\n```000000000000000000000000000000```\\n\\nLoop over all the 32 bits .... setting each bit... Masking\\n\\n```mask``` = ```1<<31``` ---> ```1000000000000000000000000000000```\\n\\nCheck if ```ith```  bit is set (here 31st) ,for each element in given array \\n\\nput a counter say ```int count``` ..... ```if  count%3 != 0``` , then the resultant\\'s bit is set here, in this bit.\\nso , set this bit for result.\\n```int res = 0```\\n```res = 1<<i```\\n\\nTried to explain ..... below is the code \\n\\n\\n```\\nclass Solution {\\npublic:\\n\\tint singleNumber(vector<int>& nums) {\\n        //lets deal it with bitwise \\n        int mask =0;\\n        int result = 0;\\n        int count = 0;\\n        for(int i = 31; i >= 0; i-- ){\\n            mask =  1<<i;\\n            count = 0;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(mask & nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count%3 != 0)\\n                result |= (1<<i);\\n        }\\n        return result;\\n\\t}\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```000000000000000000000000000000```\n```mask```\n```1<<31```\n```1000000000000000000000000000000```\n```ith```\n```int count```\n```if  count%3 != 0```\n```int res = 0```\n```res = 1<<i```\n```\\nclass Solution {\\npublic:\\n\\tint singleNumber(vector<int>& nums) {\\n        //lets deal it with bitwise \\n        int mask =0;\\n        int result = 0;\\n        int count = 0;\\n        for(int i = 31; i >= 0; i-- ){\\n            mask =  1<<i;\\n            count = 0;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(mask & nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count%3 != 0)\\n                result |= (1<<i);\\n        }\\n        return result;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43354,
                "title": "an-easy-understood-method-can-be-used-in-general-condtions",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if (nums.size()<3) return nums[0];\\n            int cnt[3]={~0,0,0};\\n            int cntTemp[3];\\n            for (int n:nums) {\\n                cntTemp[0]=(cnt[0]&(~n))|(cnt[2]&n); //3m+0 = (3m+0)+0 or (3m+2)+1\\n                cntTemp[1]=(cnt[1]&(~n))|(cnt[0]&n); //3m+1 = (3m+1)+0 or (3m+0)+1\\n                cntTemp[2]=(cnt[2]&(~n))|(cnt[1]&n); //3m+2 = (3m+2)+0 or (3m+1)+1\\n                swap(cnt,cntTemp);\\n            }\\n            return cnt[1]; //bits that have (3m+1) 1bits\\n        }\\n    };\\n\\n\\n\\nThe solution can be generalized.\\nSuppose given \"every element appears k times except for one\", we just need an array cnt[k], where every cnt[i] shows the bits on which (mk+i) 1 bits have been found (m\\u2208N).\\nBesides, the single number may appear once, twice, ...(k-1) times, using \"return ~cnt[0]\" can well solve this.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if (nums.size()<3) return nums[0];\\n            int cnt[3]={~0,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 43355,
                "title": "c-easy-to-understand",
                "content": "    public:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0,sum;\\n        for(int i=0;i<32;i++){\\n            sum=0;\\n            int tmp=1<<i;\\n            for(int j=0;j<nums.size();j++){\\n                if(tmp & nums[j]) sum++;\\n            }\\n            if(sum%3) ans+=tmp;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    public:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0,sum;\\n        for(int i=0;i<32;i++){\\n            sum=0;\\n            int tmp=1<<i;\\n            for(int j=0;j<nums.size();j++){\\n                if(tmp & nums[j]) sum++;\\n            }\\n            if(sum%3) ans+=tmp;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43367,
                "title": "python-easy-understand-solution-using-32-bit-counters",
                "content": " Using 32 bit counters and count number of 1 on each bit and mod it to 3.\\n   \\n    def singleNumber(nums):\\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                count += (n >> i) & 1\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": " Using 32 bit counters and count number of 1 on each bit and mod it to 3.\\n   \\n    def singleNumber(nums):\\n        res = 0\\n        for i in range(32):\\n            count = 0\\n            for n in nums:\\n                count += (n >> i) & 1\\n            rem = count % 3\\n            if i == 31 and rem:  # must handle the negative case\\n                res -= 1 << 31\\n            else:\\n                res |= rem << i\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 43464,
                "title": "solution-zero-extra-space",
                "content": "Here is how to make the constant space solution into a zero space solution. You simply treat A[0], A[1], and A[2] as the ones, twos, and threes masks. To do this, A[0] and A[1] must be preprocessed.\\n\\n    public class Solution {\\n        public int singleNumber(int[] A) {\\n            if(A.length == 1) return A[0];\\n            // A[0] is correct to start\\n            // Take care of processing A[1]\\n            A[0] ^= A[1];\\n            // Set A[1] to either 0 or itself\\n            A[1] = (A[0]^A[1])&A[1];\\n    \\n            // Continue with algorithm as normal\\n            for(int i = 2; i < A.length; i++){\\n                A[1] |= A[0]&A[i];\\n                A[0] ^= A[i];\\n                A[2] = ~(A[0]&A[1]);\\n                A[0] &= A[2];\\n                A[1] &= A[2];\\n            }\\n            return A[0];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            if(A.length == 1) return A[0];\\n            // A[0] is correct to start\\n            // Take care of processing A[1]\\n            A[0] ^= A[1];\\n            // Set A[1] to either 0 or itself\\n            A[1] = (A[0]^A[1])&A[1];\\n    \\n            // Continue with algorithm as normal\\n            for(int i = 2; i < A.length; i++){\\n                A[1] |= A[0]&A[i];\\n                A[0] ^= A[i];\\n                A[2] = ~(A[0]&A[1]);\\n                A[0] &= A[2];\\n                A[1] &= A[2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43474,
                "title": "i-think-your-code-is-great-but-it-can-accpet-without-saving-32-bit",
                "content": "    public class Solution {\\n    public int singleNumber(int[] A) {\\n        int key;\\n        int result=0;\\n        for(int i=0;i<32;i++){\\n            key=0;\\n            for(int j=0;j<A.length;j++){\\n                key+=(A[j]>>i)&1;\\n            }\\n            result|=((key%3)<<i);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] A) {\\n        int key;\\n        int result=0;\\n        for(int i=0;i<32;i++){\\n            key=0;\\n            for(int j=0;j<A.length;j++){\\n                key+=(A[j]>>i)&1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3715565,
                "title": "c-sorting-of-the-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon reviewing the code, here are my initial thoughts on how to solve the problem:\\n\\n1. The code begins by sorting the input vector `nums` in ascending order. Sorting the array can help in identifying adjacent elements that are the same.\\n\\n2. The code then checks if the size of the vector is not divisible by 3. If it\\'s not divisible, the code adds zeros until it becomes divisible by 3. This step ensures that the vector can be divided into groups of three, as per the problem requirement.\\n\\n3. The code iterates over the vector in groups of three, comparing the first and third elements of each group. If they are not equal, it implies that the first element is the single number that appears only once. The code returns that element.\\n\\n4. If no single number is found after iterating through all the groups, the code returns 0 as the default value.\\n\\nOverall, the approach seems to rely on sorting the array and leveraging the fact that all other numbers appear three times, while the single number appears only once. By comparing adjacent elements in groups of three, the code identifies the single number and returns it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The given code aims to find the single number in a vector, where all other numbers appear three times except for one number that appears only once. Here is an overview of the approach used in the code:\\n\\n1. The code begins by sorting the input vector `nums` in ascending order using the `sort` function from the C++ Standard Library. Sorting the vector allows us to identify adjacent elements easily.\\n\\n2. Next, the code checks if the size of the vector is not divisible by 3. If this condition is true, it means there are missing numbers in the vector. To handle this, the code enters a while loop that continues until the size of the vector becomes divisible by 3. Inside the loop, zeros (0) are pushed back into the vector using the `push_back` function until the size condition is satisfied. This ensures that the vector can be divided into groups of three elements, as required by the problem.\\n\\n3. After ensuring that the vector has a size divisible by 3, the code enters a for loop that iterates over the vector in groups of three. The loop starts from index 0 and increments by 3 in each iteration. This step allows us to examine each group of three adjacent elements.\\n\\n4. Within the loop, the code checks if the first element (`nums[i]`) and the third element (`nums[i + 2]`) of the current group are not equal. If they are not equal, it means that the first element is the single number that appears only once. In this case, the code immediately returns the first element as the result and exits the function.\\n\\n5. If no single number is found after iterating through all the groups, the code returns 0 as the default value, indicating that there is no unique element in the vector.\\n\\nThe approach relies on sorting the vector and comparing adjacent elements in groups of three to identify the single number. By ensuring the vector size is divisible by 3, the code handles cases where there are missing numbers.\\n\\n# Complexity\\n- Time complexity:  O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Sort the vector in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        // If the size of the vector is not divisible by 3, add zeros until it is\\n        if (nums.size() % 3 != 0) {\\n            while (nums.size() % 3 != 0) {\\n                nums.push_back(0);\\n            }\\n        }\\n        \\n        // Iterate over the vector in groups of three\\n        for (int i = 0; i < nums.size() - 2; i = i + 3) {\\n            // If the first and third elements of the group are not equal, return the first element\\n            if (nums[i] != nums[i + 2]) {\\n                return nums[i];\\n            }\\n        }\\n        \\n        // If no single number is found, return 0\\n        return 0;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/bc6efb87-d298-4850-a090-d191b0b35e2d_1688446868.5131214.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Sort the vector in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        // If the size of the vector is not divisible by 3, add zeros until it is\\n        if (nums.size() % 3 != 0) {\\n            while (nums.size() % 3 != 0) {\\n                nums.push_back(0);\\n            }\\n        }\\n        \\n        // Iterate over the vector in groups of three\\n        for (int i = 0; i < nums.size() - 2; i = i + 3) {\\n            // If the first and third elements of the group are not equal, return the first element\\n            if (nums[i] != nums[i + 2]) {\\n                return nums[i];\\n            }\\n        }\\n        \\n        // If no single number is found, return 0\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715264,
                "title": "1-liners-math",
                "content": "# Approach\\nSimple Maths \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n![](https://brighterly.com/wp-content/uploads/2022/03/math-memes-for-kids-13.png)\\n\\n- Suppose nums has a set X which has the reapeated elements\\n- An array sum will be 3*(X)+Y where Y is the single element...\\n- Its set will have X+Y elements.We have to find Y...\\n- So, we multiply set sum with 3 \\n- Sum will be 3X+3Y\\n- nums sum is 3X+Y\\n- by substracting and dividng by 2 we get 2Y/2 = Y\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return int(sum(nums)-3*sum(set(nums)))//-2\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return int(sum(nums)-3*sum(set(nums)))//-2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714950,
                "title": "java-bit-manipulation-very-easy",
                "content": "# Upvote if you relate the solution with yours or if it helpful for you!!!\\n\\n![image](https://assets.leetcode.com/users/images/a6c4545a-3b67-43bf-ba5e-b51f0910d311_1688432891.2068877.jpeg)\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<32;i++){\\n            int ones = 0;\\n            for(int n : nums){\\n                ones += (n>>i)&1;\\n            }\\n            // if 1 count is 0 or 1\\n            ones = ones % 3;\\n            \\n            // making ans by seting the ith bit set \\n            // taking | (or) because it add the decimal if both are different\\n            ans = ans | ones << i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<32;i++){\\n            int ones = 0;\\n            for(int n : nums){\\n                ones += (n>>i)&1;\\n            }\\n            // if 1 count is 0 or 1\\n            ones = ones % 3;\\n            \\n            // making ans by seting the ith bit set \\n            // taking | (or) because it add the decimal if both are different\\n            ans = ans | ones << i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264302,
                "title": "single-number-ii-solution-using-mapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        map<int,int> ans;\\n        for(int i = 0; i<nums.size(); i++ ) {\\n            ans[nums[i]]++;\\n        }\\n        for(auto i: ans) {\\n            if(i.second==1) {\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        map<int,int> ans;\\n        for(int i = 0; i<nums.size(); i++ ) {\\n            ans[nums[i]]++;\\n        }\\n        for(auto i: ans) {\\n            if(i.second==1) {\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158573,
                "title": "c-solution-using-unordered-map-easy-to-understand-and-implement",
                "content": "# Flow of Code\\n1. Pushing the vector elements to unordered map. \\n2. Traverse the map and returning the vector element having their count = 1.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map <int,int> M;\\n        for(auto n:nums)\\n            M[n]++;\\n        int A;\\n        for(auto i:M){\\n            if(i.second==1)\\n                A=i.first;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map <int,int> M;\\n        for(auto n:nums)\\n            M[n]++;\\n        int A;\\n        for(auto i:M){\\n            if(i.second==1)\\n                A=i.first;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156032,
                "title": "easy-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIsn\\'t it same like finding the number which is single time in array and the rest of the elements occurs two times??\\n\\nCan we extend that problem to three times repetation???\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust count the number of ones at each bits for all the array elements. \\n\\nLets say the ith bit is having \\'x\\' number of set bits.\\nThen if x%3 is \\'0\\' then it means the position is having no set bit for that single element.\\n\\nsimilarly count for all 32 bits and then add set bits to the answer accordingly. \\n\\nHere is the simple and easy to understand implementation\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(32* n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(32), which is O(log(n))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>bits(32);\\n\\n        for(int i: nums){\\n            for(int j=0; j<32; j++){\\n                int temp=i&1;\\n                if(temp) bits[j]++;\\n                i=i>>1;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<32; i++){\\n            if(bits[i]%3!=0){\\n                ans=ans|(1<<i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>bits(32);\\n\\n        for(int i: nums){\\n            for(int j=0; j<32; j++){\\n                int temp=i&1;\\n                if(temp) bits[j]++;\\n                i=i>>1;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<32; i++){\\n            if(bits[i]%3!=0){\\n                ans=ans|(1<<i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034668,
                "title": "clear-java-solution",
                "content": "# Approach 1\\n\\nTo count number of occurences of elements and then iterate over map and print that one which has single occurence\\n\\n**Complexity : O(Nlog(N))**\\n\\n# Approach 2\\n\\nUsing bit manipulation \\n\\nCounting the set bit occurences of all whole array .\\n\\n![temp.jpg](https://assets.leetcode.com/users/images/78a64c48-643d-400b-9944-e30a6ff305bd_1673428056.4935951.jpeg)\\n\\n\\n**Complexity : O(N)**\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int bit_change(int n , int posn) {\\n        int i , j , mask ;\\n        if(set_bit_check(n, posn)) {\\n            mask = 1<<posn ;\\n            mask ^= (Integer.MAX_VALUE) ;\\n            return mask&n ;\\n        }\\n        else {\\n            mask = 1<<posn ;\\n            return mask|n ;\\n        }\\n    }\\n\\n    static boolean set_bit_check(int n,int posn) {  // posn will be 0 index\\n        int i , j , mask ;\\n        mask = 1<<posn ;\\n        \\n        if((mask&n) !=0) {\\n            return true ;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    public int singleNumber(int[] nums) {\\n        int xor =0 , n = nums.length, i , j ;\\n\\n        int[] rs = new int[70] ;\\n        for(i=0;i<n;i++) {\\n            for(j=0;j<32;j++) {\\n                if(set_bit_check(nums[i],j)) {\\n                    rs[j]++ ;\\n                }\\n            }\\n        }\\n\\n        int ans  = 0;\\n        for(i=0;i<32;i++) {\\n            if((rs[i]%3)!=0) {\\n                ans = bit_change(ans,i) ;\\n            }\\n        }\\n\\n        System.out.println(ans) ;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int bit_change(int n , int posn) {\\n        int i , j , mask ;\\n        if(set_bit_check(n, posn)) {\\n            mask = 1<<posn ;\\n            mask ^= (Integer.MAX_VALUE) ;\\n            return mask&n ;\\n        }\\n        else {\\n            mask = 1<<posn ;\\n            return mask|n ;\\n        }\\n    }\\n\\n    static boolean set_bit_check(int n,int posn) {  // posn will be 0 index\\n        int i , j , mask ;\\n        mask = 1<<posn ;\\n        \\n        if((mask&n) !=0) {\\n            return true ;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    public int singleNumber(int[] nums) {\\n        int xor =0 , n = nums.length, i , j ;\\n\\n        int[] rs = new int[70] ;\\n        for(i=0;i<n;i++) {\\n            for(j=0;j<32;j++) {\\n                if(set_bit_check(nums[i],j)) {\\n                    rs[j]++ ;\\n                }\\n            }\\n        }\\n\\n        int ans  = 0;\\n        for(i=0;i<32;i++) {\\n            if((rs[i]%3)!=0) {\\n                ans = bit_change(ans,i) ;\\n            }\\n        }\\n\\n        System.out.println(ans) ;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012928,
                "title": "java-simple-o-32-n-for-beginners-with-o-1-space-complexity",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(32*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int od=0,ans=0,sum=0;\\n        for(int i=0;i<32;i++){\\n            sum=0;\\n            od=0;\\n            for(int j=0;j<nums.length;j++){\\n                if((1&nums[j])!=0)od++;\\n                nums[j]>>=1;\\n                sum|=nums[j];\\n            }\\n            if(od%3!=0) ans|=(1<<i);\\n            if(sum==0)  break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int od=0,ans=0,sum=0;\\n        for(int i=0;i<32;i++){\\n            sum=0;\\n            od=0;\\n            for(int j=0;j<nums.length;j++){\\n                if((1&nums[j])!=0)od++;\\n                nums[j]>>=1;\\n                sum|=nums[j];\\n            }\\n            if(od%3!=0) ans|=(1<<i);\\n            if(sum==0)  break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735607,
                "title": "two-ways-bit-manipulation-map-easy-explained",
                "content": "**First Method**\\n1)Go through each bit of the 32 bits of each number in the array and take the sum of last bit of all nums in each iteration.Now if the sum is multiple of 3 that means that corresponding bit in our non repeating number should also be zero.Because all the rest of the numbers apart from the non repeating number appear thrice so the bitsum coming from them is always a multiple of 3.Now the bit of our non repeating number would decide the total sum of the last bit would be a multiple of 3 or not.\\n\\nFor ex:Let\\'s say the input is:-1 0 1 0 0 3 5 2 1 2 2 3 3\\nNumbers and their bit values and S represents the sum of the bits at each position:-\\n\\t\\t\\t\\t1:0 0 1\\n\\t\\t\\t\\t0:0 0 0\\n\\t\\t\\t\\t1:0 0 1\\n\\t\\t\\t\\t0:0 0 0\\n\\t\\t\\t\\t0:0 0 0 \\n\\t\\t\\t\\t3:0 1 1\\n\\t\\t\\t\\t5:**1 0 1**\\n\\t\\t\\t\\t2:0 1 0\\n\\t\\t\\t\\t1:0 0 1\\n\\t\\t\\t\\t2:0 1 0\\n\\t\\t\\t\\t2:0 1 0\\n\\t\\t\\t\\t3:0 1 1\\n\\t\\t\\t\\t3:0 1 1\\n\\t\\t        **S**:**1 6 7**\\n\\t\\t\\t\\tS%3=\\n\\t\\t\\t\\t**S**:**1 0 1**\\n\\t\\t\\t\\tTherefore on calculating the result of S in decimal form we get 5 as our answer.\\n\\n\\n2)Store the result of the sum in a temporary variable bitsum in and then add the corresponding bit value to our result in each iteration.\\n3)For the case of negative numbers after obtaining the final result check if the 32nd or 31 indexed bit is 1 or not.If it is 1 then our result is a negative number.To obtain its magnitude we have to take the 2\\'s complement of our result and then multiply it by -1.\\nFor ex:-3\\n-3=1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 in binary\\nTo take 2\\'s complement invert the bits of -3,\\n~(-3)=0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0=2\\nand then add 1 to the result to the result to get magnitude:2+1=3.\\n\\n*We can generalise this method for any unique number question where each number occours p=3,5,7,.... odd number of times and one number occours once by taking mod of bitsum with p.*\\n\\n*For the cases where each number occours p=1,2,4,.... even number of times and one number occours once,we simply take xor of all numbers.The xor would be our final answer as all the numbers would cancel each other except the non repeating number.*\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int t=0;\\n        long int result=0;\\n        while(t!=32){\\n            long int bitsum=0;\\n            for(int i=0;i<nums.size();i++){\\n                bitsum+=nums[i]&1;\\n                nums[i]=nums[i]>>1;\\n            }\\n            result+=(bitsum%3)*pow(2,t); // check bit value as the remainder of bitsum with respect to 3\\n            if(t==31&&bitsum%3==1){\\n                result=~result;            // 2\\'s complement \\n                result+=1;                 // is being taken here\\n                result*=-1;\\n            }\\n            t++;\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Time Complexity:O(32*n) and Space Complexity:O(1)**\\n**Second method**\\n1)Take an unordered map to store the count of each number in the array.\\n2)Iterate through the map and return the key whose value is 1.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> a;\\n        for(int e:nums){\\n            a[e]++;   // storing the count of each element in map.\\n        }\\n        int one=0;\\n        for(auto i=a.begin();i!=a.end();i++){\\n            if(i->second==1){\\n                one=i->first; // on finding a element whose frequency is 1 we store its value in result \"one\" .\\n                break;\\n            }\\n        }\\n        return one;\\n    }\\n};\\n```\\n**Time Complexity:O(n) and Space Complexity:O(n)**\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int t=0;\\n        long int result=0;\\n        while(t!=32){\\n            long int bitsum=0;\\n            for(int i=0;i<nums.size();i++){\\n                bitsum+=nums[i]&1;\\n                nums[i]=nums[i]>>1;\\n            }\\n            result+=(bitsum%3)*pow(2,t); // check bit value as the remainder of bitsum with respect to 3\\n            if(t==31&&bitsum%3==1){\\n                result=~result;            // 2\\'s complement \\n                result+=1;                 // is being taken here\\n                result*=-1;\\n            }\\n            t++;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> a;\\n        for(int e:nums){\\n            a[e]++;   // storing the count of each element in map.\\n        }\\n        int one=0;\\n        for(auto i=a.begin();i!=a.end();i++){\\n            if(i->second==1){\\n                one=i->first; // on finding a element whose frequency is 1 we store its value in result \"one\" .\\n                break;\\n            }\\n        }\\n        return one;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721811,
                "title": "c-java-0-ms-100-00-faster-easy-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<32; i++){\\n            int t=0;\\n            for(int j=0; j<nums.size(); j++){\\n                t+=(nums[j]&1);\\n                nums[j]>>=1;\\n            }\\n            ans+=((t%3)<<i);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<32; i++){\\n            int t=0;\\n            for(int j=0; j<nums.size(); j++){\\n                t+=(nums[j]&1);\\n                nums[j]>>=1;\\n            }\\n            ans+=((t%3)<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631494,
                "title": "using-or-and-bitmanipulation",
                "content": "\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        int num , last;\\n        // take 32 as high becoz we have no idea about ans;\\n        for(int i = 0 ; i < 32 ;i++)\\n        {\\n            int one = 0;\\n            \\n            // traverse for whole elements\\n            for(int j = 0 ; j < nums.size() ; j++)\\n            {\\n                // let\\'s find last digit whether set or not;\\n                num = 1<<i;\\n                last = num & nums[j];\\n                    \\n                if(last) // if one \\n                    one++;\\n                    \\n            }\\n            // if 1s cnt is not divisible by 3 just add 1 in ans;\\n            if( one%3 )\\n            {\\n                ans = (1<<i) | ans;\\n            }    \\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        int num , last;\\n        // take 32 as high becoz we have no idea about ans;\\n        for(int i = 0 ; i < 32 ;i++)\\n        {\\n            int one = 0;\\n            \\n            // traverse for whole elements\\n            for(int j = 0 ; j < nums.size() ; j++)\\n            {\\n                // let\\'s find last digit whether set or not;\\n                num = 1<<i;\\n                last = num & nums[j];\\n                    \\n                if(last) // if one \\n                    one++;\\n                    \\n            }\\n            // if 1s cnt is not divisible by 3 just add 1 in ans;\\n            if( one%3 )\\n            {\\n                ans = (1<<i) | ans;\\n            }    \\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2370639,
                "title": "c-with-explanation-bit",
                "content": "// hey  i am  using the concept of checking set bit \\n// if the **jth** array  elements ** ith**  bit is set then simply increment the **oneCount** (oneCount:- counting number of set bit )\\nand if **oneCount%3!=0** then it means thet the extra element contains 1 at that position \\nso simply add it to your ans \\n\\n\\n\\n\\tint singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<32;i++){\\n            int oneCount=0;\\n            int temp=1<<i;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]& temp){// checking that it has set bit \\n                    oneCount++;\\n                }\\n            }\\n            if(oneCount%3!=0){\\n                ans=ans|temp;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t\\n\\t**** please upvote ****",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "// hey  i am  using the concept of checking set bit \\n// if the **jth** array  elements ** ith**  bit is set then simply increment the **oneCount** (oneCount:- counting number of set bit )\\nand if **oneCount%3!=0** then it means thet the extra element contains 1 at that position \\nso simply add it to your ans \\n\\n\\n\\n\\tint singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<32;i++){\\n            int oneCount=0;\\n            int temp=1<<i;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]& temp){// checking that it has set bit \\n                    oneCount++;\\n                }\\n            }\\n            if(oneCount%3!=0){\\n                ans=ans|temp;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t\\n\\t**** please upvote ****",
                "codeTag": "Unknown"
            },
            {
                "id": 2174191,
                "title": "c-4-solutions-with-explanation-o-nlogn-o-32-n-o-nlogn-n-o-n",
                "content": "#### Method 1 - Hashmap \\n\\tTime complexity  -> O(nlogn) \\n    Space Complexity -> O(n)\\n\\n\\tint singleNumber(vector<int>& nums) {\\n            unordered_map<int,int> freq;\\n\\n            for(auto x : nums) freq[x]++; \\n            //Element appearing three time have frequency three after increment three time and element appearing one time has freq 1 after increment it by one time\\n\\n            for(auto x : nums) \\n                if(freq[x] == 1) //Frequency of single element x is 1\\n                    return x;  // so return that single element x\\n            return -1; //otherwise return -1 \\n\\t}\\n\\t\\n\\t\\n#### Method 2 - Sorting\\n\\tTime complexity  -> O(nlogn + n) -> O(nlogn) \\n\\tSpace Complexity -> O(1)\\n\\n\\tif(size == 1) return single element present in the array\\n\\tthen sort all the elements of nums using sort function\\n\\n\\tExample 1 - nums = [2,3,3,3] -> if(nums[1] != nums[0]) -> return nums[0];\\n\\n\\tExample 2 - nums = [3,3,3,4] -> if(nums[n-1] != nums[n-2]) -> return nums[n-1];\\n\\n\\tExample 3 - nums = [2,2,2,3,5,5,5] \\n\\twhen i=1 -> if(nums[1] == nums[0]) - if(2 == 2) -> i += 3\\n\\tthen i=4 -> if(nums[4] != nums[3]) - if(5 != 3) -> return nums[3] - return 3;\\n\\n***\\n\\n\\tCode\\n\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tif(n == 1) return nums[0]; \\n\\t\\tsort(nums.begin(),nums.end()); \\n\\n\\t\\t//Corner cases\\n\\t\\tif(nums[1] != nums[0]) return nums[0]; \\n\\n\\n\\t\\tif(nums[n-1] != nums[n-2]) return nums[n-1];\\n\\n\\n\\t\\tfor(int i=1; i < nums.size()-1 ; i += 3){\\n\\t\\t\\tif(nums[i] != nums[i-1]) return nums[i-1];\\n\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\t\\n#### \\tMethod 3 - Bit Manipuation (Counting Set bits) \\n\\t Time Complexity -> O(32*n) \\n\\t Space Complexity - O(1)\\n\\n\\t we take two variable result=0 and leftshift=1\\n\\t we add bits of all the elements one by one from rsb (right significant bit) then calculate \\n\\t if(sumbit % 3 == 0) leave the bit and if(sumbit % 3 != 0) the take that bit to the result\\n\\n\\t Example - nums = [1,1,1,5,7,7,7] \\n\\t 1. Decimal     ->       Binary                        |2. Decimal     ->       Binary\\n\\t\\t\\t\\t\\t->              _                      |               ->             _\\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1\\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1    \\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1\\n\\t\\t5           ->       000010|1| -> single element   |   5           ->       00001|0|1 -> single element\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t---------------------------|-|                     |   --------------------------|-|-\\n\\t\\tsumbit ->                  |7|                     |   sumbit ->                 |3|\\n\\t\\t\\t\\t\\t\\t\\t\\t   |_|                     |                             |_|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   |               \\n\\t7 % 3 != 0 -> update result =0(result) + 1(leftshift); |   3 % 3 == 0  do not update result\\n\\tand leftshift *= 2; -> leftshift = 2                   |   update leftshift *= 2; -> leftshift = 4\\n\\n\\t 3. Decimal     ->       Binary                     \\n\\t\\t\\t\\t\\t->            _                     \\n\\t\\t1           ->       0000|0|01                  \\n\\t\\t1           ->       0000|0|01                      \\n\\t\\t1           ->       0000|0|01                  \\n\\t\\t5           ->       0000|1|01 -> single element\\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t-------------------------|-|--                  \\n\\t\\tsumbit ->                |4|                       \\n\\t\\t\\t\\t\\t\\t\\t\\t |_|                    \\n\\t4 % 3 != 0 -> update result = 1(result) + 4(leftshift); -> result = 5 -> required ans  \\n\\tand leftshift *= 2; -> leftshift = 8               \\n\\n\\tand all the remaining bits are zero added by this method upto 32 bits and the final answer in 5 \\n\\n\\tbut sorting method is better than this method because \\n\\t\\t\\t   n <= 3 * pow(10,4)\\n\\t\\t  so,  n < INT_MAX\\n\\ttherefore, logn < 32  ----- equation 1st\\n\\tby multiply the equation 1st by n we will get  ->  n * logn < n * 32\\n\\tO(n*logn) < O(32*n)     ->   therefore , Time complexity of sorting < Time complexity of counting set bits\\n\\n***\\n\\n\\tCode\\n\\t\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tunsigned long int leftshift = 1;\\n\\t\\tint result = 0;\\n\\t\\tint sumbit = 0;\\n\\t\\t\\n\\t\\tfor(int i=0 ; i < 32 ; ++i){\\n\\t\\t\\tfor(auto x : nums)\\n\\t\\t\\t\\tsumbit += ((x >> i) & 1);\\n\\t\\t\\tif(sumbit % 3 != 0){\\n\\t\\t\\t\\tresult += leftshift;\\n\\t\\t\\t\\tsumbit = 0;\\n\\t\\t\\t} \\n\\t\\t\\tleftshift *= 2;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\t\\n\\t\\n#### \\tMethod 4 - Bit Manipulation (XOR)\\n\\tTime Compexity   ->  O(n)\\n\\tSpace Complexity ->  O(1)\\n\\n\\tBest ones and twos method \\n\\n\\tExample - nums = [5,5,5,7] , n=4\\n\\n\\twe will take two variable ones = 0 and twos = 0\\n\\n\\tDecimal    |    Binary\\n\\t5          |    000101\\n\\t7          |    000111\\n\\n***\\n\\n\\twe runs a for loop i = 0 to n-1(4-1=3)\\n\\n***\\n\\n\\tinitialize i as 0 \\n\\n\\t1st - when i = 0\\n\\n\\ta. - ones ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000101\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000101\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 5\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(5) -> 111010\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000101\\n\\t~ones           ->   & 111010\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n***\\n\\n\\tincrement i to 1 -> i = 1\\n\\n\\t2nd - when i = 1\\n\\n\\ta. - ones ^ a[i] (5 ^ 5) ->  00101    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00000                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000000\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 0\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(0) -> 111111\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000101\\n\\t~ones           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000101\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 5\\n\\n***\\n\\n\\t1. when we travel 5 one times ones is 5 and twos is 0\\n\\t2. when we travel 5 two times ones is 0 and twos is 5\\n\\t3. now,when we travel 5 three times both ones and twos is 0\\n\\n***\\n\\n\\tincrement i to 1 -> i = 2    \\n\\n\\t2nd - when i = 2\\n\\n\\ta. - ones ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(5) -> 111010\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000101\\n\\t~twos           ->   & 111010\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 0\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (5 ^ 5) ->  00101    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00000                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(0) -> 111111\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000000\\n\\t~ones           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n\\t-> both  ones and twos is zero\\n\\n***\\n\\n\\tincrement i to 1 -> i = 3\\n\\n\\t4th - when i = 3\\n\\n\\ta. - ones ^ a[i] (0 ^ 7) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00111                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00111                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000111\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000111\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 7\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 7) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00111                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00111                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(7) -> 111000\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000111\\n\\t~ones           ->   & 111000\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n***\\n\\n\\tNOW at last we increment i to 1 -> i = 4\\n\\ti > n -> come out of loop \\n\\treturn ones -> it is the final result\\n\\n\\tYou also use example - nums = [5,5,5,7,9,9,9] -> it will return 7 as ans\\n\\n***\\n\\n\\tCode\\n\\t\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint ones = 0;\\n\\t\\tint twos = 0;\\n\\t\\tfor(int i=0 ; i < nums.size() ; ++i){\\n\\t\\t\\tones = (ones ^ nums[i]) & (~twos);\\n\\t\\t\\ttwos = (twos ^ nums[i]) & (~ones);\\n\\t\\t}\\n\\t\\treturn ones;\\n\\t}\\n\\t\\n\\t",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "#### Method 1 - Hashmap \\n\\tTime complexity  -> O(nlogn) \\n    Space Complexity -> O(n)\\n\\n\\tint singleNumber(vector<int>& nums) {\\n            unordered_map<int,int> freq;\\n\\n            for(auto x : nums) freq[x]++; \\n            //Element appearing three time have frequency three after increment three time and element appearing one time has freq 1 after increment it by one time\\n\\n            for(auto x : nums) \\n                if(freq[x] == 1) //Frequency of single element x is 1\\n                    return x;  // so return that single element x\\n            return -1; //otherwise return -1 \\n\\t}\\n\\t\\n\\t\\n#### Method 2 - Sorting\\n\\tTime complexity  -> O(nlogn + n) -> O(nlogn) \\n\\tSpace Complexity -> O(1)\\n\\n\\tif(size == 1) return single element present in the array\\n\\tthen sort all the elements of nums using sort function\\n\\n\\tExample 1 - nums = [2,3,3,3] -> if(nums[1] != nums[0]) -> return nums[0];\\n\\n\\tExample 2 - nums = [3,3,3,4] -> if(nums[n-1] != nums[n-2]) -> return nums[n-1];\\n\\n\\tExample 3 - nums = [2,2,2,3,5,5,5] \\n\\twhen i=1 -> if(nums[1] == nums[0]) - if(2 == 2) -> i += 3\\n\\tthen i=4 -> if(nums[4] != nums[3]) - if(5 != 3) -> return nums[3] - return 3;\\n\\n***\\n\\n\\tCode\\n\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tif(n == 1) return nums[0]; \\n\\t\\tsort(nums.begin(),nums.end()); \\n\\n\\t\\t//Corner cases\\n\\t\\tif(nums[1] != nums[0]) return nums[0]; \\n\\n\\n\\t\\tif(nums[n-1] != nums[n-2]) return nums[n-1];\\n\\n\\n\\t\\tfor(int i=1; i < nums.size()-1 ; i += 3){\\n\\t\\t\\tif(nums[i] != nums[i-1]) return nums[i-1];\\n\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\t\\n#### \\tMethod 3 - Bit Manipuation (Counting Set bits) \\n\\t Time Complexity -> O(32*n) \\n\\t Space Complexity - O(1)\\n\\n\\t we take two variable result=0 and leftshift=1\\n\\t we add bits of all the elements one by one from rsb (right significant bit) then calculate \\n\\t if(sumbit % 3 == 0) leave the bit and if(sumbit % 3 != 0) the take that bit to the result\\n\\n\\t Example - nums = [1,1,1,5,7,7,7] \\n\\t 1. Decimal     ->       Binary                        |2. Decimal     ->       Binary\\n\\t\\t\\t\\t\\t->              _                      |               ->             _\\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1\\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1    \\n\\t\\t1           ->       000000|1|                     |   1           ->       00000|0|1\\n\\t\\t5           ->       000010|1| -> single element   |   5           ->       00001|0|1 -> single element\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t7           ->       000011|1|                     |   7           ->       00001|1|1\\n\\t\\t---------------------------|-|                     |   --------------------------|-|-\\n\\t\\tsumbit ->                  |7|                     |   sumbit ->                 |3|\\n\\t\\t\\t\\t\\t\\t\\t\\t   |_|                     |                             |_|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   |               \\n\\t7 % 3 != 0 -> update result =0(result) + 1(leftshift); |   3 % 3 == 0  do not update result\\n\\tand leftshift *= 2; -> leftshift = 2                   |   update leftshift *= 2; -> leftshift = 4\\n\\n\\t 3. Decimal     ->       Binary                     \\n\\t\\t\\t\\t\\t->            _                     \\n\\t\\t1           ->       0000|0|01                  \\n\\t\\t1           ->       0000|0|01                      \\n\\t\\t1           ->       0000|0|01                  \\n\\t\\t5           ->       0000|1|01 -> single element\\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t7           ->       0000|1|11                  \\n\\t\\t-------------------------|-|--                  \\n\\t\\tsumbit ->                |4|                       \\n\\t\\t\\t\\t\\t\\t\\t\\t |_|                    \\n\\t4 % 3 != 0 -> update result = 1(result) + 4(leftshift); -> result = 5 -> required ans  \\n\\tand leftshift *= 2; -> leftshift = 8               \\n\\n\\tand all the remaining bits are zero added by this method upto 32 bits and the final answer in 5 \\n\\n\\tbut sorting method is better than this method because \\n\\t\\t\\t   n <= 3 * pow(10,4)\\n\\t\\t  so,  n < INT_MAX\\n\\ttherefore, logn < 32  ----- equation 1st\\n\\tby multiply the equation 1st by n we will get  ->  n * logn < n * 32\\n\\tO(n*logn) < O(32*n)     ->   therefore , Time complexity of sorting < Time complexity of counting set bits\\n\\n***\\n\\n\\tCode\\n\\t\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tunsigned long int leftshift = 1;\\n\\t\\tint result = 0;\\n\\t\\tint sumbit = 0;\\n\\t\\t\\n\\t\\tfor(int i=0 ; i < 32 ; ++i){\\n\\t\\t\\tfor(auto x : nums)\\n\\t\\t\\t\\tsumbit += ((x >> i) & 1);\\n\\t\\t\\tif(sumbit % 3 != 0){\\n\\t\\t\\t\\tresult += leftshift;\\n\\t\\t\\t\\tsumbit = 0;\\n\\t\\t\\t} \\n\\t\\t\\tleftshift *= 2;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\t\\n\\t\\n#### \\tMethod 4 - Bit Manipulation (XOR)\\n\\tTime Compexity   ->  O(n)\\n\\tSpace Complexity ->  O(1)\\n\\n\\tBest ones and twos method \\n\\n\\tExample - nums = [5,5,5,7] , n=4\\n\\n\\twe will take two variable ones = 0 and twos = 0\\n\\n\\tDecimal    |    Binary\\n\\t5          |    000101\\n\\t7          |    000111\\n\\n***\\n\\n\\twe runs a for loop i = 0 to n-1(4-1=3)\\n\\n***\\n\\n\\tinitialize i as 0 \\n\\n\\t1st - when i = 0\\n\\n\\ta. - ones ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000101\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000101\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 5\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(5) -> 111010\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000101\\n\\t~ones           ->   & 111010\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n***\\n\\n\\tincrement i to 1 -> i = 1\\n\\n\\t2nd - when i = 1\\n\\n\\ta. - ones ^ a[i] (5 ^ 5) ->  00101    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00000                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000000\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 0\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(0) -> 111111\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000101\\n\\t~ones           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000101\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 5\\n\\n***\\n\\n\\t1. when we travel 5 one times ones is 5 and twos is 0\\n\\t2. when we travel 5 two times ones is 0 and twos is 5\\n\\t3. now,when we travel 5 three times both ones and twos is 0\\n\\n***\\n\\n\\tincrement i to 1 -> i = 2    \\n\\n\\t2nd - when i = 2\\n\\n\\ta. - ones ^ a[i] (0 ^ 5) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00101                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(5) -> 111010\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000101\\n\\t~twos           ->   & 111010\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 0\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (5 ^ 5) ->  00101    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00101                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00000                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(0) -> 111111\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000000\\n\\t~ones           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n\\t-> both  ones and twos is zero\\n\\n***\\n\\n\\tincrement i to 1 -> i = 3\\n\\n\\t4th - when i = 3\\n\\n\\ta. - ones ^ a[i] (0 ^ 7) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00111                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00111                 1 ^ 0 = 1\\n\\n\\tthen we take complement of twos - ~twos = ~(0) -> 1111111\\n\\tthen we take and of both (ones ^ a[i]) & (~twos) and copy it in ones\\n\\tones ^ a[i]     ->     000111\\n\\t~twos           ->   & 111111\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000111\\n\\tcopy it to , ones = (ones ^ a[i]) & (~twos) = 7\\n\\n\\tNow we go to update twos\\n\\n\\tb. - twos ^ a[i] (0 ^ 7) ->  00000    we know that 0 ^ 0 = 0\\n\\t\\t\\t\\t\\t\\t\\t   ^ 00111                 1 ^ 1 = 0\\n\\t\\t\\t\\t\\t\\t\\t\\t-------                0 ^ 1 = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t 00111                 1 ^ 0 = 1\\n\\n\\tthen we take complement of ones - ~ones = ~(7) -> 111000\\n\\tthen we take and of both (twos ^ a[i]) & (~ones) and copy it in twos\\n\\ttwos ^ a[i]     ->     000111\\n\\t~ones           ->   & 111000\\n\\t\\t\\t\\t\\t\\t----------\\n\\t\\t\\t\\t\\t\\t   000000\\n\\tcopy it to twos = (twos ^ a[i]) & (~ones) = 0\\n\\n***\\n\\n\\tNOW at last we increment i to 1 -> i = 4\\n\\ti > n -> come out of loop \\n\\treturn ones -> it is the final result\\n\\n\\tYou also use example - nums = [5,5,5,7,9,9,9] -> it will return 7 as ans\\n\\n***\\n\\n\\tCode\\n\\t\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint ones = 0;\\n\\t\\tint twos = 0;\\n\\t\\tfor(int i=0 ; i < nums.size() ; ++i){\\n\\t\\t\\tones = (ones ^ nums[i]) & (~twos);\\n\\t\\t\\ttwos = (twos ^ nums[i]) & (~ones);\\n\\t\\t}\\n\\t\\treturn ones;\\n\\t}\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2029704,
                "title": "c-bit-operation-with-explanation",
                "content": "```\\nint singleNumber(vector<int>& nums) {\\n        int mask=0;                             // stores the answer\\n        for (int i=0;i<32;i++)                  \\n        {\\n            int c=0;                            // Count for how many elements ith bit is set\\n            for (int j=0;j<nums.size();j++)\\n            {\\n                if (nums[j]&(1<<i)) c++;        // Check if ith bit is set in nums[j], c++;\\n            }\\n             // If the count of element whose ith bit is set is not a multiple of 3 means the element\\n            //  which appears once has the ith bit set, hence setting the ith bit in mask[answer]. \\n            if (c%3!=0) mask = mask | 1<<i;    \\n        }\\n        return mask;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n        int mask=0;                             // stores the answer\\n        for (int i=0;i<32;i++)                  \\n        {\\n            int c=0;                            // Count for how many elements ith bit is set\\n            for (int j=0;j<nums.size();j++)\\n            {\\n                if (nums[j]&(1<<i)) c++;        // Check if ith bit is set in nums[j], c++;\\n            }\\n             // If the count of element whose ith bit is set is not a multiple of 3 means the element\\n            //  which appears once has the ith bit set, hence setting the ith bit in mask[answer]. \\n            if (c%3!=0) mask = mask | 1<<i;    \\n        }\\n        return mask;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802337,
                "title": "javascript-sorting-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction singleNumber(nums) {\\n    nums.sort((x, y) => x - y);\\n\\n    for (let i = 0; i < nums.length; i += 3) {\\n        if (nums[i] !== nums[i + 1]) {\\n            return nums[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction singleNumber(nums) {\\n    nums.sort((x, y) => x - y);\\n\\n    for (let i = 0; i < nums.length; i += 3) {\\n        if (nums[i] !== nums[i + 1]) {\\n            return nums[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578058,
                "title": "runtime-4-ms-faster-than-97-25-easy-c-explanation-tc-o-n-sc-o-1",
                "content": "```\\n     // TC- O(n) , Sc- O(1)\\n    int singleNumber(vector<int>& nums) {\\n        \\n        long long int ans = 0;\\n        vector<int>cnt(32,0);   // count bit array => Constant Extra Space\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=31;\\n            long long int n = abs(nums[i]);  // int-Range\\t=>\\t[ -2,147,483,648 to 2,147,483,647 ]\\n            while(n)                    // abs(-2,147,483,648) = 2,147,483,648 not stored in \\'int\\'\\n            {\\n                cnt[j] += n&1;\\n                n >>= 1; \\n                j--;\\n            }\\n        }\\n        \\n        for(int j=31;j>=0;j--)\\n        {\\n            int bit = cnt[j]%3;\\n            if(bit)\\n             ans += 1 <<(31-j); // 1 * 2^(31-j)\\n        }\\n        \\n        int c=0;\\n        for(auto x:nums)   //for negative numbers\\n          if(x==ans) {c++;}   //if our calculates value \\'ans\\' is present in array, then increment c\\n        return c==1?ans:-ans; //if c=1 return \\'ans\\' else \\'ans\\' must be -ve\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n     // TC- O(n) , Sc- O(1)\\n    int singleNumber(vector<int>& nums) {\\n        \\n        long long int ans = 0;\\n        vector<int>cnt(32,0);   // count bit array => Constant Extra Space\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=31;\\n            long long int n = abs(nums[i]);  // int-Range\\t=>\\t[ -2,147,483,648 to 2,147,483,647 ]\\n            while(n)                    // abs(-2,147,483,648) = 2,147,483,648 not stored in \\'int\\'\\n            {\\n                cnt[j] += n&1;\\n                n >>= 1; \\n                j--;\\n            }\\n        }\\n        \\n        for(int j=31;j>=0;j--)\\n        {\\n            int bit = cnt[j]%3;\\n            if(bit)\\n             ans += 1 <<(31-j); // 1 * 2^(31-j)\\n        }\\n        \\n        int c=0;\\n        for(auto x:nums)   //for negative numbers\\n          if(x==ans) {c++;}   //if our calculates value \\'ans\\' is present in array, then increment c\\n        return c==1?ans:-ans; //if c=1 return \\'ans\\' else \\'ans\\' must be -ve\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1559271,
                "title": "c-simple-solution-using-bit-manipulation",
                "content": "Logic:\\n1) If a number repeats 3 times, say number 5 i.e. (101) in binary. 1 will occur at 0th and 2nd bit 3 times.\\n2) Eg: [2,2,3,2] Answer is 3. How? \\n\\t2 -> 10\\n\\t2 -> 10\\n\\t3 -> 11\\n\\t2 -> 10\\nsum of 0th set bits = 1 // 1 is not divisible by 3, our answer has 0th bit set\\nsum of 1st set bits = 4 // 4 is not divisible by 3, our answer has 1st bit set.\\n\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int i,c,ans=0;\\n        for(i=0;i<32;i++) // loop for ith bits\\n        {\\n            c=0;\\n            for(int j:nums) // loop over the numbers\\n            {\\n                if(j&(1<<i))  // check if ith bit is set or not\\n                    c++; // increment if set\\n            }\\n            if(c%3) // if the count c is not divisible by 3, then our answer has ith bit set\\n                ans += (1<<i); // update answer\\n        }\\n        return ans; //return answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int i,c,ans=0;\\n        for(i=0;i<32;i++) // loop for ith bits\\n        {\\n            c=0;\\n            for(int j:nums) // loop over the numbers\\n            {\\n                if(j&(1<<i))  // check if ith bit is set or not\\n                    c++; // increment if set\\n            }\\n            if(c%3) // if the count c is not divisible by 3, then our answer has ith bit set\\n                ans += (1<<i); // update answer\\n        }\\n        return ans; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506305,
                "title": "java-bit-manipulation-o-32n-simple",
                "content": "The idea is to take sum of all i\\'th bits and check if it\\'s divisible by 3. If bit%3 is 0, then no change in bit. If it is 1 then that bit is contributed by the odd element in the list. This process, when repeated for each bit, leaves us with final ans which is the odd element in the list.\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i=0;i<32;i++){\\n            int bit = 0;\\n            for(int j=0;j<nums.length;j++){\\n                bit+=((nums[j]>>i)%2==0)?0:1;\\n            }\\n            result = (bit % 3)<<i | result;\\n            \\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i=0;i<32;i++){\\n            int bit = 0;\\n            for(int j=0;j<nums.length;j++){\\n                bit+=((nums[j]>>i)%2==0)?0:1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1340301,
                "title": "3-methods-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //XOR+AND solution\\n    //TC:O(N) SC:O(1)\\n       int singleNumber(vector<int>& nums){\\n           int ones=0;\\n           int two=0;\\n           for(auto x:nums){\\n               ones=(x ^ones) & (~two);\\n               two=(x^two) & (~ones);\\n           }\\n           return ones;\\n       }\\n   \\n     int singleNumber(vector<int>& nums) {\\n         int n=nums.size();\\n         //Sorting and Linear Search Solution\\n         //TC:O(Nlogn+N) sc:O(n)\\n         sort(nums.begin(),nums.end());\\n         if(n<3)\\n             return nums[0];\\n         if(nums[0]<nums[1])\\n             return nums[0];\\n         else if(nums[n-2]<nums[n-1])\\n             return nums[n-1];\\n         else{\\n             int i=1;\\n             while(i<n-1){\\n                 if(nums[i-1]!=nums[i]){\\n                     return nums[i-1];\\n                 }\\n                 i+=3;\\n             }\\n         }\\n         return -1;\\n     }\\n   \\n    int singleNumber(vector<int>& nums) {\\n        // basic map solution \\n        //Time Complexity:O(n) Space complexity:O(n)\\n        map<int,int> m;\\n        for(auto it:nums){\\n            m[it]++;\\n        }\\n        for(auto x:m){\\n            if(x.second!=3){\\n                return x.first;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //XOR+AND solution\\n    //TC:O(N) SC:O(1)\\n       int singleNumber(vector<int>& nums){\\n           int ones=0;\\n           int two=0;\\n           for(auto x:nums){\\n               ones=(x ^ones) & (~two);\\n               two=(x^two) & (~ones);\\n           }\\n           return ones;\\n       }\\n   \\n     int singleNumber(vector<int>& nums) {\\n         int n=nums.size();\\n         //Sorting and Linear Search Solution\\n         //TC:O(Nlogn+N) sc:O(n)\\n         sort(nums.begin(),nums.end());\\n         if(n<3)\\n             return nums[0];\\n         if(nums[0]<nums[1])\\n             return nums[0];\\n         else if(nums[n-2]<nums[n-1])\\n             return nums[n-1];\\n         else{\\n             int i=1;\\n             while(i<n-1){\\n                 if(nums[i-1]!=nums[i]){\\n                     return nums[i-1];\\n                 }\\n                 i+=3;\\n             }\\n         }\\n         return -1;\\n     }\\n   \\n    int singleNumber(vector<int>& nums) {\\n        // basic map solution \\n        //Time Complexity:O(n) Space complexity:O(n)\\n        map<int,int> m;\\n        for(auto it:nums){\\n            m[it]++;\\n        }\\n        for(auto x:m){\\n            if(x.second!=3){\\n                return x.first;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326393,
                "title": "detailed-explanation-and-fast-solution-in-c",
                "content": "```\\n\\n```\\'\\'\\'class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        //when we have number which is repeating 1 time then it is stored in the variable ones .when we have number which is repeated two times then it is stored in twos and if number is repeated thrice then it is not stored in both .This is the simple idea behind this algorithm.\\n        int ones = 0;\\n        int twos = 0;\\n        for(int x : nums){ //for each loop to iterate over all the elements of nums vector\\n            ones = (ones^x) & (~twos); //we take xor of number and ones and perform bitwise and operation between the reult and the compliment of twos\\n            twos = (twos^x) & (~ones); //same like above just interchage ones and twos\\n        }\\n        return ones; //since we know that our number is reapeated only once so it is stored at ones so we return the ones\\n    }\\n    \\n    \\n};\\n\\'\\'\\'.\\nGuys do upvote if u like the post.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1212165,
                "title": "8-ms-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint bits = sizeof(int) * 8;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < bits; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.size(); j++) {\\n\\t\\t\\t\\tif (nums[j] & (1 << i)) count++;\\n\\t\\t\\t}\\n\\t\\t\\tcount = count % 3;\\n\\t\\t\\tif (count != 0) {\\n\\t\\t\\t\\tans = ans | (1 << i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\nthis approach is of O(32n) time complexity \\nO(n) complexity approach\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones=0;\\n        int twos=0;\\n        for(int i=0;i<nums.size();i++) {\\n            ones=(nums[i]^ones) & ~twos;\\n            twos=(nums[i]^twos) & ~ones;\\n        }\\n        return ones;\\n    }\\n};\\n```\\nhere we are storing 1st time occuring number in ones then on occuring 2nd time we are storing that no in twos and removing the number from ones and on occuring for 3rd time we are removing that number from twos too. So finally our only 1 time occuring number is stored in ones.\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint singleNumber(vector<int>& nums) {\\n\\t\\tint bits = sizeof(int) * 8;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < bits; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < nums.size(); j++) {\\n\\t\\t\\t\\tif (nums[j] & (1 << i)) count++;\\n\\t\\t\\t}\\n\\t\\t\\tcount = count % 3;\\n\\t\\t\\tif (count != 0) {\\n\\t\\t\\t\\tans = ans | (1 << i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ones=0;\\n        int twos=0;\\n        for(int i=0;i<nums.size();i++) {\\n            ones=(nums[i]^ones) & ~twos;\\n            twos=(nums[i]^twos) & ~ones;\\n        }\\n        return ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112426,
                "title": "java-solution-using-bit-manipulation-o-n-and-o-1",
                "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int visitedOnce = 0, visitedTwice = 0;\\n        \\n        for(int i : nums){\\n            \\n            visitedOnce = (visitedOnce ^ i) & ~visitedTwice;\\n            visitedTwice = (visitedTwice ^ i) & ~visitedOnce;\\n        }\\n        \\n        return visitedOnce;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int visitedOnce = 0, visitedTwice = 0;\\n        \\n        for(int i : nums){\\n            \\n            visitedOnce = (visitedOnce ^ i) & ~visitedTwice;\\n            visitedTwice = (visitedTwice ^ i) & ~visitedOnce;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 892203,
                "title": "python-bit-manipulation",
                "content": "Using a[i]b[i] as a binary number, to indicate (the sum of all i-th bit of num) % 3.\\nYou can use num[0:2] as a, b just with slight changes. => To meet the question requirement.\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:        \\n        a, b = 0, 0\\n        for x in nums:\\n            a, b = (~x&a&~b)|(x&~a&b), ~a&(x^b)\\n        return b\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:        \\n        a, b = 0, 0\\n        for x in nums:\\n            a, b = (~x&a&~b)|(x&~a&b), ~a&(x^b)\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842588,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(set(nums)) * 3 - sum(nums)) // 2\\n```\\n:D",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return (sum(set(nums)) * 3 - sum(nums)) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783524,
                "title": "simple-python3",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n      return (sum(set(nums)) * 3 - sum(nums)) // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n      return (sum(set(nums)) * 3 - sum(nums)) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647051,
                "title": "c-simple-bitmasking-solution-with-constant-space",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int sum[32]={0};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<32;j++)\\n                sum[j]+=(arr[i]>>j)&1;\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n            if(sum[i]%3)\\n                ans=ans|(1<<i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int sum[32]={0};\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<32;j++)\\n                sum[j]+=(arr[i]>>j)&1;\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n            if(sum[i]%3)\\n                ans=ans|(1<<i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628337,
                "title": "three-python-sol-sharing-w-visualization",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u984C\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=Lw85DcQ1f1g)\\n\\nThree python sol sharing.\\n\\nFirst is by python built-in Counter.\\nSecond method is by bit masking with O(1) aux space.\\nThird method is by binary opeartion and FSM with O(1) aux space.\\n\\n![image.png](https://assets.leetcode.com/users/images/dd92b718-d90f-42da-9c16-98f18c9e098b_1688533217.6104689.png)\\n\\n\\n---\\n\\n**Implementation** by by python built-in Counter:\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n\\t\\t# key: number\\n\\t\\t# value: occurrennce\\n        num_occ_dict = Counter( nums )\\n        \\n        return [ number for number in num_occ_dict if num_occ_dict[number] == 1][0]\\n```\\n\\n---\\n\\n**Implementation** by bit masking with O(1) aux space:\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        single_num = 0\\n        \\n        # compute single number by bit masking\\n        for bit_shift in range(32):\\n            \\n            sum = 0\\n            \\n            for number in nums:\\n                \\n                # collect the bit sum\\n                sum += ( number >> bit_shift ) & 1\\n\\n            # Extract bit information of single number by modulo\\n            # Other number\\'s bit sum is removed by mod 3 (i.e., all other numbers appear three times)\\n            single_num |= ( sum % 3 ) << bit_shift\\n            \\n            \\n        \\n        if ( single_num & (1 << 31) ) == 0:\\n            return single_num\\n        else:\\n\\t\\t\\t# handle for negative number\\n            return -( (single_num^(0xFFFF_FFFF))+1 )\\n```\\n\\n---\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        # \\u51FA\\u73FE\\u4E00\\u6B21\\n        state_one = 0\\n\\n        # \\u51FA\\u73FE\\u5169\\u6B21\\n        state_two = 0\\n\\n        for num in nums:\\n            \\n            # \\u9019\\u908A\\u7528\\u767D\\u677F\\u63A8\\u5C0E\\u51FA\\u4F86\\u7684\\u7D50\\u679C\\n            # \\u88E1\\u9762\\u662FLogic Gate \\u548C State machine\\u7684\\u89C0\\u5FF5\\n            state_one = (num ^ state_one) & ~state_two\\n            state_two = (num ^ state_two) & ~state_one\\n\\n        # \\u6700\\u5F8C\\u6211\\u5011\\u60F3\\u8981\\u7684\\u6578\\u5B57\\uFF0C\\u662F\\u53EA\\u6709\\u51FA\\u73FE\\u4E00\\u6B21\\u7684\\u90A3\\u500B\\n        return state_one\\n```\\n\\n# Time complexity: O( n ) on for loop\\n\\n# Space complexity: O( 1 ) on fixed-size of temp variables\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #136 Single Number I](https://leetcode.com/problems/single-number)\\n\\n[Leetcode #260 Single Number III](https://leetcode.com/problems/single-number-iii)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n\\t\\t# key: number\\n\\t\\t# value: occurrennce\\n        num_occ_dict = Counter( nums )\\n        \\n        return [ number for number in num_occ_dict if num_occ_dict[number] == 1][0]\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        single_num = 0\\n        \\n        # compute single number by bit masking\\n        for bit_shift in range(32):\\n            \\n            sum = 0\\n            \\n            for number in nums:\\n                \\n                # collect the bit sum\\n                sum += ( number >> bit_shift ) & 1\\n\\n            # Extract bit information of single number by modulo\\n            # Other number\\'s bit sum is removed by mod 3 (i.e., all other numbers appear three times)\\n            single_num |= ( sum % 3 ) << bit_shift\\n            \\n            \\n        \\n        if ( single_num & (1 << 31) ) == 0:\\n            return single_num\\n        else:\\n\\t\\t\\t# handle for negative number\\n            return -( (single_num^(0xFFFF_FFFF))+1 )\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        # \\u51FA\\u73FE\\u4E00\\u6B21\\n        state_one = 0\\n\\n        # \\u51FA\\u73FE\\u5169\\u6B21\\n        state_two = 0\\n\\n        for num in nums:\\n            \\n            # \\u9019\\u908A\\u7528\\u767D\\u677F\\u63A8\\u5C0E\\u51FA\\u4F86\\u7684\\u7D50\\u679C\\n            # \\u88E1\\u9762\\u662FLogic Gate \\u548C State machine\\u7684\\u89C0\\u5FF5\\n            state_one = (num ^ state_one) & ~state_two\\n            state_two = (num ^ state_two) & ~state_one\\n\\n        # \\u6700\\u5F8C\\u6211\\u5011\\u60F3\\u8981\\u7684\\u6578\\u5B57\\uFF0C\\u662F\\u53EA\\u6709\\u51FA\\u73FE\\u4E00\\u6B21\\u7684\\u90A3\\u500B\\n        return state_one\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559668,
                "title": "bit-wise-ternary-add-truth-table-karnaugh-map-and-logic-expressions",
                "content": "We can implement a ternary add operation.\\n\\nHere is the truth table:\\nhigh low + x = new_high new_low\\n00 + 0 = 00\\n00 + 1 = 01\\n01 + 0 = 01\\n01 + 1 = 10\\n10 + 0 = 10\\n10 + 1 = 00\\n\\nTruth table by digit: (x = don\\'t care)\\nnew_low: \\n   00 01 11 10\\n0   0   1   x   0\\n1   1   0   x   0\\n\\nAssign x = 0 to simplify:\\n   00 01 11 10\\n0   0   1   0   0\\n1   1   0   0   0\\nnew_sum = (low^x) & (~high)\\n\\nnew_high:\\n   00 01 11 10\\n0   0   0   x   1\\n1   0   1   x   0\\n\\nAssign x = 1 to simplify:\\n   00 01 11 10\\n0   0   0   1   1\\n1   0   1   1   0\\nnew_high = (high&~x) | (low&x)\\n\\nHere is the solution:\\n\\n\\tclass Ternary {\\n        private:\\n            int low, high;\\n            \\n        public:\\n            Ternary(int x){\\n                low = x;\\n                high = 0;\\n            }\\n            void add(int x) {\\n                int new_low = (low^x) & (~high); \\n                int new_high = (high&~x) | (low&x);\\n                low = new_low;\\n                high = new_high;\\n            }\\n            int value(){\\n                return low;\\n            }\\n    };\\n\\n    int singleNumber(vector<int>& nums) {\\n        Ternary result(nums[0]);\\n        for(int i = 1; i < nums.size(); i++){\\n            result.add(nums[i]);\\n        }\\n        return result.value();\\n    }\\n\\n\\n",
                "solutionTags": [],
                "code": "We can implement a ternary add operation.\\n\\nHere is the truth table:\\nhigh low + x = new_high new_low\\n00 + 0 = 00\\n00 + 1 = 01\\n01 + 0 = 01\\n01 + 1 = 10\\n10 + 0 = 10\\n10 + 1 = 00\\n\\nTruth table by digit: (x = don\\'t care)\\nnew_low: \\n   00 01 11 10\\n0   0   1   x   0\\n1   1   0   x   0\\n\\nAssign x = 0 to simplify:\\n   00 01 11 10\\n0   0   1   0   0\\n1   1   0   0   0\\nnew_sum = (low^x) & (~high)\\n\\nnew_high:\\n   00 01 11 10\\n0   0   0   x   1\\n1   0   1   x   0\\n\\nAssign x = 1 to simplify:\\n   00 01 11 10\\n0   0   0   1   1\\n1   0   1   1   0\\nnew_high = (high&~x) | (low&x)\\n\\nHere is the solution:\\n\\n\\tclass Ternary {\\n        private:\\n            int low, high;\\n            \\n        public:\\n            Ternary(int x){\\n                low = x;\\n                high = 0;\\n            }\\n            void add(int x) {\\n                int new_low = (low^x) & (~high); \\n                int new_high = (high&~x) | (low&x);\\n                low = new_low;\\n                high = new_high;\\n            }\\n            int value(){\\n                return low;\\n            }\\n    };\\n\\n    int singleNumber(vector<int>& nums) {\\n        Ternary result(nums[0]);\\n        for(int i = 1; i < nums.size(); i++){\\n            result.add(nums[i]);\\n        }\\n        return result.value();\\n    }\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 428107,
                "title": "c-hashing-solution-time-n-space-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        \\n        unordered_map<int,int> m;\\n        \\n        for(int i : nums){\\n            m[i]++;\\n        }\\n        \\n        for(auto x:m){\\n            if(x.second==1)\\n                return x.first;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        \\n        unordered_map<int,int> m;\\n        \\n        for(int i : nums){\\n            m[i]++;\\n        }\\n        \\n        for(auto x:m){\\n            if(x.second==1)\\n                return x.first;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375784,
                "title": "c-o-n-time-and-o-1-space-easy-to-understand-explanation",
                "content": "```\\n/*\\n    Every bit index will occur in multiples of 3 times. So if some bit occurs k % 3 != 0 times then we know that the single number has a 1bit there. In fact that will occur for every 1 bit that the single number has. Thus we can reconstruct the number by creating a 32 bit number for each bit that occurs k%3 != 0 times\\n    \\n    i) Maintain an int[32] space\\n    ii) Get counts for each bit in each num\\n    iii) for ecah count that isn\\'t a multiple of three, then we add that bit to the res.\\n*/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int bits[32];\\n        for (int i = 0; i < 32; i++)\\n            bits[i] = 0;\\n        \\n        for (int num : nums){\\n            for (int i = 0; i < 32; i++){\\n                if ((num >> i) & 1 == 1)\\n                    bits[i]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < 32; i++){\\n            if (bits[i] != 0 && (bits[i] % 3) != 0)\\n                res |= 1 << i;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nNote that we can easily generalize this to the problem \"Every number occurs k>1 except for a single number\", by simply changing the modulo to %k",
                "solutionTags": [],
                "code": "```\\n/*\\n    Every bit index will occur in multiples of 3 times. So if some bit occurs k % 3 != 0 times then we know that the single number has a 1bit there. In fact that will occur for every 1 bit that the single number has. Thus we can reconstruct the number by creating a 32 bit number for each bit that occurs k%3 != 0 times\\n    \\n    i) Maintain an int[32] space\\n    ii) Get counts for each bit in each num\\n    iii) for ecah count that isn\\'t a multiple of three, then we add that bit to the res.\\n*/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int bits[32];\\n        for (int i = 0; i < 32; i++)\\n            bits[i] = 0;\\n        \\n        for (int num : nums){\\n            for (int i = 0; i < 32; i++){\\n                if ((num >> i) & 1 == 1)\\n                    bits[i]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < 32; i++){\\n            if (bits[i] != 0 && (bits[i] % 3) != 0)\\n                res |= 1 << i;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330338,
                "title": "readable-python-solution-beats-93-with-explanation",
                "content": "Like other variants of this problem, the idea is to use bitwise operators to cancel out the triplets. \\n\\nUnfortunately if we take an XOR of the entire input, for each triplet only two of them cancel and we are just left with the XOR of all unique numbers which gives us no information.\\n\\nSo instead of XOR we would like some operation, say #, that has the following properties (along with associativity and commutativity):\\n\\n1. x # x # x = 0\\n2. x # 0 = x\\n\\nAddition modulo 3 has precisely these properties, so we will apply this operation to get the solution. \\n\\nTo implement this, we simply have three bit masks which keep track of the state of the bits throughout the procedure. E.g. the zero mask will keep track of which bits sum to 0mod3 so far (these bits will be set, whereas all other bits will be unset). The one mask will keep track of bits which sum to 1mod3 so far, etc.\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # since we haven\\'t started the sum, initially all bits sum to 0mod3\\n\\t\\t# i.e. all bits in the zero mask should be set\\n        zero_mod3 = ~0\\n        one_mod3 = two_mod3 = 0\\n        \\n        for x in nums:\\n            tmp0, tmp1, tmp2 = zero_mod3, one_mod3, two_mod3\\n            \\n            zero_mod3 = (tmp2 & x) | (tmp0 & ~x)\\n            one_mod3 = (tmp0 & x) | (tmp1 & ~x)\\n            two_mod3 = (tmp1 & x) | (tmp2 & ~x)\\n            \\n        return one_mod3\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # since we haven\\'t started the sum, initially all bits sum to 0mod3\\n\\t\\t# i.e. all bits in the zero mask should be set\\n        zero_mod3 = ~0\\n        one_mod3 = two_mod3 = 0\\n        \\n        for x in nums:\\n            tmp0, tmp1, tmp2 = zero_mod3, one_mod3, two_mod3\\n            \\n            zero_mod3 = (tmp2 & x) | (tmp0 & ~x)\\n            one_mod3 = (tmp0 & x) | (tmp1 & ~x)\\n            two_mod3 = (tmp1 & x) | (tmp2 & ~x)\\n            \\n        return one_mod3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319863,
                "title": "a-generalized-c-solution-with-explanation-8-ms-no-extra-memory",
                "content": "We assume the input array has all unique elements occuring `K + 1` times except one occuring `M + 1` times. \\n\\nFor this question, we need to build an array of size `K` to store the information of bits of `1`. For every incoming bit of `1`, the state shifts down by one row and rolls back to the first row if it reaches the end. The state remains unchanged if the incoming bit is `0`.\\n\\n```\\nresults [0] [1] ... [K-1]\\n         0   0  ...   0\\n\\t\\t 1   0  ...   0\\n\\t\\t 0   1  ...   0\\n\\t\\t        ...\\n\\t\\t 0   0  ...   1\\n```\\n\\nSince we need an array of size `K`, the memory cost of the below code is O(`K`). The code is shown below:\\n\\n\\n```cpp\\nclass Solution {\\n    template <std::size_t K, std::size_t M, \\n              typename Container, \\n              typename Integral = typename Container::value_type>\\n    static typename std::enable_if<M < K, Integral>::type\\n    singleNumberTemplate(const Container &nums) {\\n        std::array<Integral, K> results{};\\n        for (const Integral x : nums)\\n            for (auto &res_i : results) {\\n                Integral flip = x;\\n                for (const auto res_j : results)\\n                    // if res[j] == res[i] but j != i, \\n                    // then res[j] == res[i] == 0\\n                    if (res_j != res_i)\\n                        flip &= ~res_j;\\n                res_i ^= flip;\\n            }\\n        return results[M];\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        return singleNumberTemplate<2, 0>(nums);\\n    }\\n};\\n```\\n\\nThis generalized code runs 8 ms and beats 98%. The runtime and memory usage is exactly the same as the normal approach (shown below) with two int varables.\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\t\\tint one = 0, two = 0;\\n        for (const int x : nums) {\\n            one ^= x & ~two;\\n            two ^= x & ~one;\\n        }\\n        return one;\\n    }\\n};\\n```\\n\\nNote: there is an alternative approach which has O(log(`K`)) memory complexity. It treats every bit of the input `Integral` type in seperate variables. Therefore, for a 32-bit `int`, you need an array of size 32. For each bit, you have `K + 1` states, which requires O(log(`K`)) memory. But for small `K`, the presented code seems to be more efficient.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nresults [0] [1] ... [K-1]\\n         0   0  ...   0\\n\\t\\t 1   0  ...   0\\n\\t\\t 0   1  ...   0\\n\\t\\t        ...\\n\\t\\t 0   0  ...   1\\n```\n```cpp\\nclass Solution {\\n    template <std::size_t K, std::size_t M, \\n              typename Container, \\n              typename Integral = typename Container::value_type>\\n    static typename std::enable_if<M < K, Integral>::type\\n    singleNumberTemplate(const Container &nums) {\\n        std::array<Integral, K> results{};\\n        for (const Integral x : nums)\\n            for (auto &res_i : results) {\\n                Integral flip = x;\\n                for (const auto res_j : results)\\n                    // if res[j] == res[i] but j != i, \\n                    // then res[j] == res[i] == 0\\n                    if (res_j != res_i)\\n                        flip &= ~res_j;\\n                res_i ^= flip;\\n            }\\n        return results[M];\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        return singleNumberTemplate<2, 0>(nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\t\\tint one = 0, two = 0;\\n        for (const int x : nums) {\\n            one ^= x & ~two;\\n            two ^= x & ~one;\\n        }\\n        return one;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244184,
                "title": "c-12ms-beats-99-26",
                "content": "## Single Number II\\n\\n### Approach: 12ms, faster than 99.62%\\nThere are 32 bit positions in an integer. We take the sum of all the 1\\'s that are at the ith bit position and take modulo 3. This way we get the ith bit of the single number. We do this for i=31 to i=0.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0,ans_final=0;\\n        for(int j=31;j>=0;j--)\\n        {\\n            ans=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                ans+=(nums[i]>>j)&1;\\n            }\\n            ans=(ans%3);\\n            ans_final=ans_final<<1;\\n            ans_final+=ans;\\n        }\\n        return ans_final;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0,ans_final=0;\\n        for(int j=31;j>=0;j--)\\n        {\\n            ans=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                ans+=(nums[i]>>j)&1;\\n            }\\n            ans=(ans%3);\\n            ans_final=ans_final<<1;\\n            ans_final+=ans;\\n        }\\n        return ans_final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212365,
                "title": "python-solution",
                "content": "Time complexity: `O(33n) = O(n)`, space complexity: `O(33) = O(1)`.\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def num2bin(num):\\n            i = 0\\n            if num < 0:\\n                num = -num\\n                count[32] += 1\\n            while num > 0:\\n                num, r = divmod(num, 2)\\n                count[i] += r\\n                i += 1\\n                \\n        def bin2num(binary):\\n            mult = 1\\n            ans = 0\\n            for i in range(len(binary)-1):\\n                ans += mult*binary[i]\\n                mult *= 2\\n            return ans\\n        \\n        count = [0]*33\\n        for n in nums:\\n            num2bin(n)\\n        for i in range(len(count)):\\n            count[i] %= 3\\n        res = bin2num(count)\\n        return res if count[-1] == 0 else -res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def num2bin(num):\\n            i = 0\\n            if num < 0:\\n                num = -num\\n                count[32] += 1\\n            while num > 0:\\n                num, r = divmod(num, 2)\\n                count[i] += r\\n                i += 1\\n                \\n        def bin2num(binary):\\n            mult = 1\\n            ans = 0\\n            for i in range(len(binary)-1):\\n                ans += mult*binary[i]\\n                mult *= 2\\n            return ans\\n        \\n        count = [0]*33\\n        for n in nums:\\n            num2bin(n)\\n        for i in range(len(count)):\\n            count[i] %= 3\\n        res = bin2num(count)\\n        return res if count[-1] == 0 else -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43310,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ones = 0\\n        var twos = 0\\n        \\n        for num in nums {\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        }\\n        \\n        return ones\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ones = 0\\n        var twos = 0\\n        \\n        for num in nums {\\n            ones = (ones ^ num) & ~twos\\n            twos = (twos ^ num) & ~ones\\n        }\\n        \\n        return ones\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43452,
                "title": "a-clean-state-machine-solution",
                "content": "    def singleNumber(self, A):\\n        # we need a state transfer machine:\\n        # from (bit2, bit1)  0,0->0,1->1,0->0,0\\n        bit1=0\\n        bit2=0\\n        for i in A:\\n            oldbit1=bit1\\n            bit1=bit1^(i&(~bit2))\\n            bit2=(oldbit1&i)|(bit2&(~i))\\n        \\n        return bit1\\n\\nSo only numbers appeared N (N ==1 mod 3) times are recorded in bit1.",
                "solutionTags": [],
                "code": "    def singleNumber(self, A):\\n        # we need a state transfer machine:\\n        # from (bit2, bit1)  0,0->0,1->1,0->0,0\\n        bit1=0\\n        bit2=0\\n        for i in A:\\n            oldbit1=bit1\\n            bit1=bit1^(i&(~bit2))\\n            bit2=(oldbit1&i)|(bit2&(~i))\\n        \\n        return bit1\\n\\nSo only numbers appeared N (N ==1 mod 3) times are recorded in bit1.",
                "codeTag": "Python3"
            },
            {
                "id": 43455,
                "title": "c-o-n-complex-solution-easy-to-understand",
                "content": "    class Solution{\\n    public:\\n    \\tint singleNumber(int A[], int n){\\n    \\t\\tint oneNum = 0;\\n    \\t\\tint twoNum = 0;\\n    \\t\\tint threeNum = 0;\\n    \\t\\tfor(int i = 0 ; i < n ;i++){\\n    \\t\\t\\tthreeNum = twoNum & A[i];\\n    \\t\\t\\ttwoNum = oneNum & A[i] | twoNum;\\n    \\t\\t\\toneNum = oneNum | A[i];\\n    \\t\\t\\toneNum = oneNum &(~threeNum);\\n    \\t\\t\\ttwoNum = twoNum & (~threeNum);\\n    \\t\\t\\tthreeNum = 0;\\n     \\t\\t}\\n    \\t\\treturn oneNum;\\n    \\t}\\n    };\\n\\neasy to understand this solution\\n\\n\\n    ----------\\n    \\n    \\n    oneNum means A[i] contains one bit 1\\n    towNum means A[i] contains two bit 1\\n    threeNum means A[i] contains three bit 1\\n    if three bit 1 occurs than flip oneNum to 0 and twoNum to 0 and threeNum to 0\\n    so the step will be like this\\n    bit in oneNum will change  like this 0-1-1-0\\n    bit in twoNum will change like this 0-0-1-0\\n    bit int threeNum will change like this 0 -1-0\\n    \\n    and it is easy to expand to other situations like four same num and so on",
                "solutionTags": [],
                "code": "class Solution{\\n    public:\\n    \\tint singleNumber(int A[], int n){\\n    \\t\\tint oneNum = 0;\\n    \\t\\tint twoNum = 0;\\n    \\t\\tint threeNum = 0;\\n    \\t\\tfor(int i = 0 ; i < n ;i++){\\n    \\t\\t\\tthreeNum = twoNum & A[i];\\n    \\t\\t\\ttwoNum = oneNum & A[i] | twoNum;\\n    \\t\\t\\toneNum = oneNum | A[i];\\n    \\t\\t\\toneNum = oneNum &(~threeNum);\\n    \\t\\t\\ttwoNum = twoNum & (~threeNum);\\n    \\t\\t\\tthreeNum = 0;\\n     \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3918083,
                "title": "java-o-n-o-1-ez-solution-everyone-can-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the array, if there is only one element in nums then just return nums[0], which is the only element in nums.\\nThen loop through the array, starting from index 1, and end at nums.length - 2, if nums[i] is not equals to nums[i-1] and is not equal to nums[i+1] then return nums[i](for example: 1,1,1,2,3,3,3, we return 2).\\nAfter the loop if we still haven\\'t find out the wanted element, we will see if nums[nums.length-1] is equal to the previous element, then decide if we should return nums[nums.length-1], after we loop through everything if we still haven\\'t find out the answer, return nums[0] since that\\'s the only one left, therefore it must be the answer.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length == 1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i = 1; i < nums.length-1; i++)\\n        {\\n            if(nums[i] != nums[i+1] && nums[i] != nums[i-1])\\n            {\\n                return nums[i];\\n            }\\n        }\\n        if(nums[nums.length-1]!=nums[nums.length-2])\\n        {\\n            return nums[nums.length-1];\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length == 1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i = 1; i < nums.length-1; i++)\\n        {\\n            if(nums[i] != nums[i+1] && nums[i] != nums[i-1])\\n            {\\n                return nums[i];\\n            }\\n        }\\n        if(nums[nums.length-1]!=nums[nums.length-2])\\n        {\\n            return nums[nums.length-1];\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718094,
                "title": "c-easy-solution-using-hashmap",
                "content": "\\n\\n# Approach\\nThe approach in this code is to use a hashmap to count the frequency of each number in the vector. Then, iterate through the vector again to find the number with a frequency of 1, which is the single number. Finally, return the single number found or 0 if none is found.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m[nums[i]]==1)\\n            {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nPLEASE DO UPVOTE IF YOU FOUND IT HELPFUL!",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m[nums[i]]==1)\\n            {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717166,
                "title": "python-elegant-short-one-line-counter",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return next(num for num, cnt in Counter(nums).items() if cnt == 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return next(num for num, cnt in Counter(nums).items() if cnt == 1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1955336,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955398,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1571297,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1808199,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955593,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1565005,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955422,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955356,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1572305,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1571299,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955336,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955398,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1571297,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1808199,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955593,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1565005,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955422,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1955356,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1572305,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1571299,
                "content": [
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Some   comments  added in  2013,2014  and   I was doing shit on facebook at that time And these guys were doing Bit manipulation.** "
                    },
                    {
                        "username": "ahmednazir333",
                        "content": "Leetcode was Founded 13 February 2010 . source : wikipedia"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "[@Dhananjay40](/Dhananjay40) Us bro us"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Us bro us"
                    },
                    {
                        "username": "motralk",
                        "content": "[@irfan7junior](/irfan7junior) someone finally broke the second law of thermodynamics"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "bro I was playing clash of clans"
                    },
                    {
                        "username": "irfan7junior",
                        "content": "LeetCode itself was founded in 2015, but yeah I can see the comments from 2013 and 2014 too."
                    },
                    {
                        "username": "aceanojjj",
                        "content": "I was like \\'aha a piece of cake\\', until I read the last requirement \\uD83E\\uDD79"
                    },
                    {
                        "username": "puri_puri_puririn",
                        "content": "So relatable lol."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "haha, me too\\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "So was I ... \\n"
                    },
                    {
                        "username": "stephen18961",
                        "content": "METOO BUDDY"
                    },
                    {
                        "username": "avinashrajraj628",
                        "content": "so true"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "\\uD83D\\uDE02True\\n"
                    },
                    {
                        "username": "robotqueen",
                        "content": "If this is not a hard question, I dont know what is. I don`t think anyone less than an expert on bit manipulations can fully code this solution in a white board interview (talking about solving it at linear time and constant space of course)."
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "[@abhi02leetcode](/abhi02leetcode)  looks like one of those guyz who is active  at \\n leetcode just for copy/pasting other solutions and maintaining his profile..rather  than actually understanding the concepts"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@abhi02leetcode](/abhi02leetcode) dumbass sorting takes O(NLOGN) t c, can\\'t you read the question "
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro you could have posted your solution without the first two lines and ppl would\\'ve helped you. Try being a bit humble, everyone is supportive here"
                    },
                    {
                        "username": "dumb_me",
                        "content": "[@abhi02leetcode](/abhi02leetcode) bro dou even realize tc of your solution\\n"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@abhi02leetcode](/abhi02leetcode) The irony of \"idk what will actual hard problem look to you\" when you haven\\'t even solved 5% of the Hard problems on LC. That\\'s on top of the fact that 1) you posted a solution with loglinear time complexity (even though the problem description states **linear** time complexity) and 2) you posted a solution in the discussion when the Discussion Rules **first** rule clearly states not to post any solutions."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this doesn't require bit manipulation.  WARNING HINT SPOILER: ............................... o(3n) is still linear"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@abhi02leetcode](/abhi02leetcode) taking a condescending tone to someone who found the problem hard, only to reveal that you only found it easy cause you didn\\'t understand the problem at all is a bit embarassing"
                    },
                    {
                        "username": "jespinos08",
                        "content": "[@droningNM](/droningNM) I can\\'t find any good examples on how to know WHEN to use bitwise operators. I know how they affect binary numbers, but I never know when they should be used on a specific problem :/"
                    },
                    {
                        "username": "RayanYI",
                        "content": "[@abhi02leetcode](/abhi02leetcode) You have\\'d used Sort Function your solution is not linear time complexity that\\'s log linear O(n.log(n))"
                    },
                    {
                        "username": "mkaypl",
                        "content": "[@abhi02leetcode](/abhi02leetcode) It\\'s also not linear time"
                    },
                    {
                        "username": "abhi02leetcode",
                        "content": "if this is hard for you, idk what will actual hard problem look to you. see my solution without any map, or bit manipulation.\\n\\nSOLUTION:\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int i =0;\\n        Arrays.sort(nums);\\n        while(i< nums.length){\\n            if(i == nums.length - 1) return nums[i];\\n            if(nums[i] == nums[i+1] && nums[i] == nums[i+2]) i = i+3;\\n            else return nums[i];\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "RegexSage",
                        "content": "If u have a practice on BM ,u just need to set the bits and convert your binary ans to decimal to get the answer."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "My First Approach was counting set bits :-\\nEg :- [2,2,2,3,4,4,4]\\nbinary form :- 010\\n                       010\\n                       010\\n                       011\\n                       100\\n                       100 \\n                       100\\nTotal :-            3 4 1\\nSo, 3 is divisible by 3 hence \"0\" but four is not divisible \"1\" and same with \"1\" . The final answer will be \"011\" = 3."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "This is more difficult than single number iii\\n"
                    },
                    {
                        "username": "dgcrensh",
                        "content": "[@JS00](/JS00) It doesn\\'t have to be. Kernighan\\'s algorithm only runs one iteration per set bit, instead of 32 to check each bit. So it would actually run in \\u0398(n) with k-values of 1 and 32."
                    },
                    {
                        "username": "Tushxr",
                        "content": "Can someone explain how will it work when the sum of set digits at a given position exceed 9. will we make it 0 and carry forward 1 or what? Wierd edge-case."
                    },
                    {
                        "username": "JS00",
                        "content": "[@anuron_das](/anuron_das) I agree the solution is clever and satisfies the constraints put up by the question. I was just stating an observation."
                    },
                    {
                        "username": "EdwardLeeMacau",
                        "content": "[@SahilNikam](/SahilNikam) Treating all numbers as unsigned integer might help?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "[@JS00](/JS00) That may be true, but his approach is so smart. Let's face it, at least I couldn't come up with that."
                    },
                    {
                        "username": "JS00",
                        "content": "That is O(32*N) which is actually worse running time than O(N*lg(N)) for array of length smaller than 4,294,967,296. For the given constraints you are better off implementing the sorting approach. "
                    },
                    {
                        "username": "mayankg1908",
                        "content": "can you explain the intuition behind this approach?"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "how it\\'s working for negative numbers ,I also tried this approach"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I HATE BIT-MANIPULATION"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "I Love Bit-Manipulation! It\\'s just a little hard to observe in beginning."
                    },
                    {
                        "username": "nguyendaithanh0612",
                        "content": "me too"
                    },
                    {
                        "username": "noobtuber",
                        "content": "MNC\\'s will hate you "
                    },
                    {
                        "username": "AryanP45",
                        "content": "\\uD83D\\uDE16"
                    },
                    {
                        "username": "shivansh157",
                        "content": " i guess most of us begginers do lol."
                    },
                    {
                        "username": "saadtaame",
                        "content": "Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@godshiva](/godshiva)  he wont look at ur solution bro he might have retired by now"
                    },
                    {
                        "username": "dopingcode",
                        "content": "bro you must married now, in 2013 I was just a kid enjoying my childhood"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "for each bit position you count all numbers which have that bit pos turned 1. Now, if that count is not a multiple of 3, then that bit must also be present in the non-repeating number. as simple as that."
                    },
                    {
                        "username": "aayush7511",
                        "content": "I\\'m trying to solve this using counting bits method but my code does not work for negative numbers. I don\\'t think any method using bitwise operators will work on negative numbers. "
                    },
                    {
                        "username": "godshiva",
                        "content": "Yes, take a look at my solution, it\\'s the most recent as of me posting this. "
                    },
                    {
                        "username": "MahekSavani",
                        "content": "Easier to solve from maths perspective:\nFind all the distinct numbers (set), multiply by 3 (because all the other number repeats 3 time), so the sum of that set will have total of original nums + 2*(number which is repeating only once)"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@orl0](/orl0) of course using set violates the space constraint but this solution is just to show that if space constraint is not there, there is possibility to approach this type of problem using mathematical equation, but having said that probability of this type of questions being asked in interview or in real life anywhere is zero, so its probably useless."
                    },
                    {
                        "username": "orl0",
                        "content": "Think twice. If you use any hash-like structure (set or map) there is no need to multiply anything. But constant space restriction means you can\\'t use set!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Agreed, the approach is good by using mathematical equation."
                    },
                    {
                        "username": "abhisekmohantychinua",
                        "content": "Great approach"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "I think space complexity will not be constant in this approach."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@prathmesh_24](/prathmesh_24) of course, all you need to do is just make one mathematical equation in return statement, to perform sum, subtraction, and division"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "So all this can wrap in Linear Time Complexity?"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "[@Hokuszpok](/Hokuszpok) what if we release the memory of set in the end\\uD83D\\uDE02"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@Hokuszpok](/Hokuszpok) set uses O(n), but works for this particular problem"
                    },
                    {
                        "username": "MahekSavani",
                        "content": "[@yale3450](/yale3450) It works for this particular problem due to the constraints, space set would take in worst case is 10,000 (10^4)"
                    },
                    {
                        "username": "yale3450",
                        "content": "sets are O(N) space not constant so this solution wouldn\\'t work "
                    },
                    {
                        "username": "Hokuszpok",
                        "content": "I\\'m wondering if `set` uses constant extra space only?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reason xor works for the case of every element appear twice and only element appear once is that the xor function is \"bit\"-wise annihilating for when applied to the same element twice, commutative and associative.\\n\\nWhat kind of operator can do \"tri\"-wise, annihilating for when apply to the same element 3 times, commutative and associative? What is \"tri\"-wise anyway?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "This hint is quite misleading from the solution. Here is maybe a better one:\\nThe reason XOR works is great, but why we need XOR in the first place? Imagine, you have a bucket for every BIT of the number (32 bits for integer). If you had only pairs of numbers - some buckets will have 2 zeroes, while other buckets may have 2 ones (for number 5 you have 0101 and repeat it twice). If you add another single number, what are possible combinations(to 5 and 5, add 12)?\\nbucket a 0 0 1\\nbucket b 1 1 1\\nbucket c 0 0 0\\nbucket d 1 1 0\\nFrom here you can reconstruct the answer, since it\\'s clear that whenever you have odd number of 1s in the bucket, it\\'s the BIT which should survive/contribute to an answer.\\n\\nNow, how do we count? \\nEvery time we see bit a first time, it\\'s OK.\\nEvery time we see bit a second time, it should be dropped and become zero. Kinda modular division by 2.\\nThe reason XOR works is because it annihilates the bit when we see it second time.\\n\\nNow, what if we have numbers which can exist three/four/etc times?\\nWell, you have the same buckets, it\\'s just the counting part which changes.\\n\\nThree numbers(same 5) + last single number (12)\\nbucket a 0 0 0 1\\nbucket b 1 1 1 1\\nbucket c 0 0 0 0\\nbucket d 1 1 1 0\\n\\nEvery time we see 1 bit a first time, it\\'s OK.\\nEvery time we see 1 bit a second time, it\\'s OK.\\nEvery time we see 1 bit a third time, it should be dropped and become zero. Kinda modular division by 3.\\n\\nWe can\\'t use neither modular division as is (requires to keep counts), nor XOR (doesn\\'t help with division by 3).\\nNow, the question - how can we count then?\\n\\nThe answer is - we shouldn\\'t do a REAL count as in 1,2,3,4,5. Instead we may want to have COUNTING buckets (at this point forget the buckets we\\'ve been talking before, as they just illustrate disassemble/assemble part at a low level). We need to count for each BIT, right? And we have 32 bits total. So, if we use another integer as a COUNTING bucket, we can use its own bits to COUNT! But since it\\'s not used as integer anymore, it\\'s just a set of 32 buckets which can have 0 or 1 as value. That helps to count from 0 to 1 only... And we need to count more. Remember:\\n0 - OK - one integer is enough\\n1 - OK - one integer is enough\\n2 - OK - one integer is not enough\\n3 - DROP - equivalent to 0 - OK\\n\\nOnce you figured out how many 32-bit buckets/integers you need, the fun part starts. You need to come up with BIT operations (multiple) to MOVE BITS from one COUNTER to another COUNTER.\\n\\nXOR was enough just for \\n0 - OK\\n1 - OK\\n2 - DROP - equivalent to 0 - OK.\\n\\n"
                    },
                    {
                        "username": "Yeder_Runn",
                        "content": "The concept of \"tri\"-wise is not a standard mathematical or logical term. It is used here to imply an operation that can be applied to three operands simultaneously. While there are operations in mathematics and logic that work with three operands (e.g., ternary operations), they do not possess the same properties as the XOR operator., you might find this helpful."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "bitwise mod 3 addition, right?"
                    },
                    {
                        "username": "Hudsone",
                        "content": "1. Choose a number x in the list NUMS\\n2. Partition the list to 2 parts: A, B for:\\n\\tAll members in A <= x\\n\\tAll members in B > x\\n3. If |A| % 3 == 1:\\n\\t\\tNUMS = A\\n\\telse:\\n\\t\\tNUMS = B\\n4. Repeat 1 ~ 3 until there is only 1 left in NUMS\\n\\nPros: Easy to extend to 4, 5, 6, 7,... duplicates"
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s linear in the best case, but n\\xB2 in the worst case"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "I think this is nlogn and not linear, please correct me if i\\'m wrong"
                    },
                    {
                        "username": "AutomnePAN",
                        "content": "not linear time actually "
                    },
                    {
                        "username": "yinjiecheng",
                        "content": "From the [best answer][1] i'v known how to solve the problem \"every element appears N times except for one\", but what if the opposite?\\n\\nEvery element appears only one time except for one, how to find the only one element that appears 2(and 3 to N) times? Also requires a linear runtime complexity, and a linear runtime complexity.\\n\\n\\n  [1]: http://oj.leetcode.com/discuss/857/constant-space-solution"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\nThere is an approach for this problem as Floyd\\'s Cycle Detection (Tortoise Hare) Algorithm, taken from the concept of Linked List Cycle Detection which works in linear time and constant space. See Approach 7 of Editorial."
                    }
                ]
            },
            {
                "id": 1956051,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1955860,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1955378,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1571298,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1955572,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1955507,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1795212,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1695852,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1568958,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1570899,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I have a bit that needs to be manipulated."
                    },
                    {
                        "username": "Yan-Zhelanov",
                        "content": "1. Keep two variables, `ones` and `twos`, to hold the bits that have appeared one time and two times, respectively. Iterate through the array. For each number:\\n- Update twos with bits that have appeared two times now. These are the bits which were in ones earlier and in the current number.\\n- Update ones with bits that have appeared one time. However, you need to remove those bits which are in twos.\\n2. If a bit is present in twos, it means it has already appeared two times, so remove these bits from ones and twos.\\n3. After the end of array traversal, ones will hold the bits of the number that appears exactly once in the array. Other numbers\\' bits will get cancelled out as we remove them when they appear the third time."
                    },
                    {
                        "username": "sm-onk",
                        "content": "would this cover negative numbers also? when i implement this i get the answer as positive for negative numbers. like for example if -4 is the number that appears only once, my answer is 4."
                    },
                    {
                        "username": "divy_kant",
                        "content": "i thought it is a super easy Ques. but it turned out to be a BIT Ques. "
                    },
                    {
                        "username": "SunnyMonk",
                        "content": "is the count of single number is 2 or can it be any number?"
                    },
                    {
                        "username": "amanchandna",
                        "content": "To find the unique element if all the other numbers are appearing even number of times, then simply use the property of XOR and find the result.\\n\\nbut if other numbers are appearing odd number of times then count the number of bits: if `bitsCount % k == 1` then that particular bit is contributing to the final answer.\\nwhere `k is the appearance of repeated numbers.`\\n[Solution](https://leetcode.com/problems/single-number-ii/solutions/3715542/java-solution-with-constant-space/)"
                    },
                    {
                        "username": "thisannie",
                        "content": "hint: you need `O(k)` space where k= 32. and time Complexity 32*nums.length which is still linear :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "It can be solved with `O(1)` space. Tip: root iterator: 32 bits, nested iterator: `nums`."
                    },
                    {
                        "username": "RushikaK",
                        "content": "```\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int num = 0;\n        for( int i  = 0; i < 32; i++) {\n            int count = 0;\n            for( int data : nums) {\n                if( isNumSet(data, i)) {\n                    ++count;\n                }\n            }\n            if( count%3 != 0) {\n                num = num + (1 << i);\n            }\n        }\n        return num;\n    }\n\n    private boolean isNumSet(int num, int count) {\n        return (num & (1 << count)) != 0;\n    }\n}\n```\n-->\n1. count thr total number of bits set for 3 bits\n2. check the bit count set is divisible by 3\n3. if the number of bits was divisible by 3 then set the bit in the result.\nTime Complexity: o(n)\nSpace Complexity: 1"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "That\\'s actually a good solution one can come up with on the interview. The other solution with single traversal is much harder to come up with if you haven\\'t seen it before."
                    },
                    {
                        "username": "__Satyam__",
                        "content": "All the numbers appearing 3 times so the number of setbits at the ith bits will be always 3 or multiple of 3 so if for any ith bit the number is not multiple of 3 it means the number which appears only once the setbit is of that number only so simply add the 2^i to ans and check for all bits form 0 - 31 and return the ans."
                    },
                    {
                        "username": "riverwave",
                        "content": "I submitted a solution, it went through \"pending ... judging ... accepted\", but back to check the submission and it's not there?  System problem?  Thanks."
                    },
                    {
                        "username": "sagarhasan273",
                        "content": "\\tfor k, v in Counter(nums).items():\\n\\t\\tif v == 1: return k"
                    },
                    {
                        "username": "AshminJ",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh)  That isn\\'t how you calculate space complexity, constant space complexity means that the space taken should not depend on the input, in this case the size of the counter will be equal to the number of distinct items in the input, which again is a violation."
                    },
                    {
                        "username": "serkora",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) That's not how time complexity works. Of course for any single run the input size is constant, but the point is that your solution has to have the same space usage for an array of size 5 and of size 1000, i.e. it's independent of the input size. The size of your Counter(nums) varies from run to run and depends on the size of nums, i.e. it scales with n (precisely what O(n) means), so it's not constant."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "[@aserian](/aserian) Actually it is according to the question because the array size is constant and there will be only two key-value pairs in the hash"
                    },
                    {
                        "username": "aserian",
                        "content": "This is not constant space"
                    }
                ]
            },
            {
                "id": 1956306,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955954,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955715,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955592,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955508,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1955388,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1683000,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1575710,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1568959,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 1575196,
                "content": [
                    {
                        "username": "niranjank2022",
                        "content": "Is this Medium for its requirement of O(1) space complexity!"
                    },
                    {
                        "username": "JV_004",
                        "content": "*HARD*"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "New Topic discovered to practice :-Bit Manupulation"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s not even contest time, but leetcode is down, or is it just for me????"
                    },
                    {
                        "username": "user8416g",
                        "content": "yeah, its down today"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bits give me trauma fr \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "divy_kant",
                        "content": "I CAN BOIL DOWN TILL:\\n*TC->O(N^2) , SC->O(1)\\n*TC->O(N) , SC->O(N)\\n*TC->O(NlogN) , SC->O(1)\\n\\nBUT O(1) WOOOOOOOF !!"
                    },
                    {
                        "username": "arirarahma",
                        "content": "if single number-i is easy, surely this one must be one as well"
                    },
                    {
                        "username": "iamarkaj",
                        "content": "![image](https://assets.leetcode.com/users/images/84b84624-2bac-439c-ba7d-d843348cb0d8_1630618988.263892.png)\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for that. I knew that the solution had to do with bit manipulations but I doubt that I could have come up with the correct manipulations on my own."
                    },
                    {
                        "username": "uyouyou9",
                        "content": "Given an array of data(maybe not interger , for example\\uff1astring type), every element appears twice except for one. Find that single one.\\n\\nNote:\\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\\n\\nRemark:\\nI don't know whether this problem has an answer, if have, please  tell me"
                    },
                    {
                        "username": "arttkach",
                        "content": "\\nreturn (3*sum(set(nums)) - sum(nums))/2\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Jiganesh](/Jiganesh) he knows. It\\'s a one-liner, it\\'s made to look pretty, not to be optimal"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "This is not constant_space\\n"
                    }
                ]
            },
            {
                "id": 2069358,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 2062529,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 2046330,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1999301,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1990890,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1973523,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1973238,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1956644,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1956443,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1956439,
                "content": [
                    {
                        "username": "srijadhar",
                        "content": "Bit manipulation is not my cup of tea.\\n"
                    },
                    {
                        "username": "Meowcolm024",
                        "content": "The true counting bits question lol"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number III](https://leetcode.com/problems/single-number-iii/description/) now. All the best \\u2728"
                    },
                    {
                        "username": "neel19",
                        "content": "1. `ans += pow(2, i) `This doesn\\'t work but\\n2. `ans = ans | (1 << i )` This works\\nWhy?\\n`(1 << 31) `is still out of range of maximum integer possible, then why 2nd works and first doesn\\'t? "
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, you are talking about C++ (BTW, you should mention the language when asking questions, as these operations will work differently in e.g. Python). In C++, `pow()` is a function on floating point values, not integers. It may work fine for small integers, but will most likely cause errors when `int` domain limits are overstepped (as in `pow(2, 32)`)."
                    },
                    {
                        "username": "vinodkumar127",
                        "content": "the code written below worked perfectly in online gdb c++ compiler, but in leetcode the result is getting runtime error.\\nCan anyone please understand the problem and help me correct myself please?\\n\\n\\nCode:\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]!=nums[i+1] || i==nums.size()-1)\\n            {\\n                return nums[i];\\n            }\\n            i=i+3;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "Also, Your code runs from index i = 0 to i < nums.size(), here you will get out of bounds error because of line 12, that is i = i + 3. If your logic is correct replace while condition with while(i<nums.size()-3). Also, it will generate a wrong output due to more logical errors."
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "You have made an error in the function parameters. It should be `singleNumber(vector<int>& nums)`{ } .. instead of (vector& nums) "
                    },
                    {
                        "username": "anuragak021",
                        "content": "At first I thought it was similar to problem [136.Single Number](https://leetcode.com/problems/single-number/description/) then realized I was wrong then solved it"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "bro i can\\'t believe this question is medium \\uD83D\\uDE25"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "so meanwhile, I thought pff, easy , chose -1 as masking, then read -2^31 <= nums[i] <= 2^31 - 1.\\nintmax-min goner!\\nThen literally hardcoded masking value as 173652 blindly that runs !! haha don\\'t do it guys.\\nPS: Don\\'t add this as a new testcase :)"
                    },
                    {
                        "username": "pranjalpratapsingh1",
                        "content": "[@orl0](/orl0) Yes it does and one must go through bit manipulation method which wasn\\'t intuitive at all."
                    },
                    {
                        "username": "orl0",
                        "content": "Nice try, but you used sort which violates linear time constraint"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Tip :- maintain 32 bit array and convert number into binary . for negative numbers you can maintain another array. do arr[i]%3 on array and convert remaining bits into number and you got the ans :)"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "many accepted solution are just sorting and finding answer but why leetcode is accepting these solutions I mean even best sorting algorithm use O(nlog(n)) time complexity."
                    },
                    {
                        "username": "tifv",
                        "content": "$O(n \\cdot \\log n)$ vs $O(n)$ does not make that much difference in practice, and LeetCode cannot realistically filter out slightly super-linear solutions based on time limit. Some solutions with sorting will likely still do better that some not-quite-optimized solutions with linear complexity (like, I think I have seen linear solutions that iterate through the array 32 times; you could sort the array in this time, I reckon).\n\nWhat really surprised me is that quadratic time solutions are also getting accepted."
                    },
                    {
                        "username": "AshminJ",
                        "content": "Even answers that involved a HashMap with linear space complexity were accepted."
                    }
                ]
            },
            {
                "id": 1956278,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1956196,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1956151,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1956061,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955923,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955879,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955852,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955829,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955816,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955786,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "I was little confident but then i saw linear TC"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Hmmm making us do bit manipulation on the Independence Day does not seem very fitting.\\nI was expecting something a bit more thematic, like [2164. Sort Even and Odd Indices Independently\\n](https://leetcode.com/problems/sort-even-and-odd-indices-independently/) or [1276. Number of Burgers with No Waste of Ingredients](https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/) \\xAF\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![Love XOR operator](https://cdn.getmidnight.com/84f7b02a8128f5f5775611244c24b941/2021/02/ezgif.com-gif-maker--6-.gif)"
                    },
                    {
                        "username": "ac1dloop",
                        "content": "where every element appears three times \\nTHREE, CARL!\\nand how comes length of 1,2 with three elements?\\n1 <= nums.length <= 3 * 104"
                    },
                    {
                        "username": "tifv",
                        "content": "The purpose of constraint is not to represent the actual range of possibilities, but to be satisfied.\n\nBTW, input sequence containing exactly one element is very much compatible with the problem statement."
                    },
                    {
                        "username": "eduard92",
                        "content": "Using dictionary TLE? Why is this a medium.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "cuz it needs O(n) time actually"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me no tle with map"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "just sort in place guys\\nand with a single variable that hold the unique it is easy \\n\\ndef singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        unique = nums[0]\\n        n = len(nums)\\n\\n        repeated = False\\n\\n        for i in range(1, n):\\n            if unique == nums[i]:\\n                repeated = True\\n            else:\\n                if repeated == True:\\n                    unique = nums[i]\\n                    repeated = False\\n\\n        return unique"
                    },
                    {
                        "username": "mahmoudghareeb11111",
                        "content": "[@Finesse](/Finesse) solutions require $$o(n)$$ always pass with $$o(n log(n))$$ time complexity"
                    },
                    {
                        "username": "Finesse",
                        "content": "Sorting takes `O(n*ln(n))` time, which violates the rule. Usually, sorting takes `O(ln(n))` space, but Heap Sort takes a constant space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Whats wong with the constraints? Alot people use O(n) space and get accepted?\\nIts the wrong answere, they wanted O(1) space...."
                    },
                    {
                        "username": "jblanks",
                        "content": "A hashmap using O(n) extra space will pass all the test cases, but solving it without using extra memory is another story P_P"
                    },
                    {
                        "username": "chenon",
                        "content": "Easy question. Easy medium. Much easier than yesterday's easy question https://leetcode.com/problems/buddy-strings/  with many checks \n\nEasy question with Map O(n) space.\nMedium level with O(1) space involving bit manipulation."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "jUst uSE a hAsH mAP"
                    },
                    {
                        "username": "psionl0",
                        "content": "But then you wont get O(1) space complexity."
                    }
                ]
            },
            {
                "id": 1955781,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955774,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955765,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955758,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955742,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955737,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955678,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955663,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955648,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955563,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "I repeat, I HATE BIT-MANIPULATION "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "![gif](https://y.yarn.co/b0f7deec-f239-4a5a-ab8e-143b9632964f_text.gif)"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![gonna cry.jpg](https://assets.leetcode.com/users/images/af73ef49-7068-4d71-8941-461ccd023f18_1688467454.1093514.jpeg)"
                    },
                    {
                        "username": "chandramani_lc",
                        "content": "I guess Problems difficulty gets updated every now and then depending on the submission trends of the users. Since it\\'s constraint allow O(N) space approach as well, many correct submissions are there with very less wrong submissions from the individuals. "
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "For those who are wondering about the negative cases, count the set bits same as positives but, after you have added all non multiple set bits to `answer`, check if the last bit is set or not, if it is then perform 2\\'s compliment as `(1 << 32) - answer` and multiply it by -1."
                    },
                    {
                        "username": "breathermachine",
                        "content": "You don\\'t need to do this. Same code will run for both positives and negatives. If there are 3n + 1 sign bits, the value we\\'re looking for is negative, if there are 3n sign bits, then it\\'s positive (or zero)."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Brute-force works , tho that's not how it asked to be solved"
                    },
                    {
                        "username": "anand_083",
                        "content": "I don\\'t know why question said that you must implement a solution with a linear runtime complexity and use only constant extra space. however this  question is  also done in O(n^2) and accepted also  :)))"
                    },
                    {
                        "username": "Finesse",
                        "content": "You should challenge yourself, not the test cases"
                    },
                    {
                        "username": "prodonik",
                        "content": "how many problems are available in leetcode ?\\n"
                    },
                    {
                        "username": "kylez77",
                        "content": "Does an array of size 30 qualifies as \"constant\" space ?"
                    },
                    {
                        "username": "kylez77",
                        "content": "[@JS00](/JS00) cool , thanks a lot . "
                    },
                    {
                        "username": "JS00",
                        "content": "Yes, because it does not grow with length of the array."
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "First i thought just to find the remainder of the sum then realised it is wrong and saw the bit wise solution ..... so clooose"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can O(32) be considered as constant extra space here?"
                    },
                    {
                        "username": "tifv",
                        "content": "There is no conceptual difference between $O(32)$ and $O(1)$. Both imply that the requirement (memory, in this case) does not depend on the parameter, and nothing else. And yes, this is called \\u201Cconstant space\\u201D."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This should be marked as easy!"
                    }
                ]
            },
            {
                "id": 1955539,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955511,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955484,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955439,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955425,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955413,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955384,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955366,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1955307,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1914395,
                "content": [
                    {
                        "username": "dikshawali",
                        "content": "is it only me who is finding this problem extremely easy. Not even worth easy problem. Have I done something wrong. \\ndistNum=set(nums)\\n        for i in distNum:\\n            if(nums.count(i)==1):\\n                return i"
                    },
                    {
                        "username": "tifv",
                        "content": "Besides using non-constant extra space, your algorithm also has quadratic time complexity, not linear."
                    },
                    {
                        "username": "MahekSavani",
                        "content": "For one of my early solution I also used set to solve mathematically, but in problem statement it says that it should use only constant extra memory, and sets space complexity in worst case would be O(n), so technically the solution using set is wrong, but works on leetcode so that why it seems easy"
                    },
                    {
                        "username": "adarsh1919",
                        "content": "we have to use constant extra space..."
                    },
                    {
                        "username": "Arthur-H",
                        "content": "Is it linear runtime complexity if you iterate through the numbers and count if each appears only once? I feel like that would be O(n^2) because you iterate through every element and for each element you need to iterate the entire list again to count how many times it appears. I'm seeing some solutions that use this approach."
                    },
                    {
                        "username": "maamounhn",
                        "content": "use hash table"
                    },
                    {
                        "username": "tifv",
                        "content": "This algorithm indeed has quadratic time complexity, not linear. I would say that the fact that is still passes the tests says that LeetCode had set the time limit for this problem too lax (or gave not enough large test cases)."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is difficult. If the constraint was relaxed to \"appears twice\" except one that appears once you could just use xor. But this requires some weird maths."
                    },
                    {
                        "username": "ritiksjadhav",
                        "content": "Solved this question using HashMap but it takes extra space, need to learn the bit manipulation concept."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "First time got the daily problem solved already"
                    },
                    {
                        "username": "asdfghjklll123",
                        "content": "I wrote a linear space solution and it also passed"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, LeetCode doesn\\'t technically enforce memory and time constraints to such strictness. This is more about what will be expected from your solution if you encounter this problem in a job interview."
                    },
                    {
                        "username": "ks404536",
                        "content": "Here comes the problem where you think that you can definitely solve it easily, but you just can\\'t seem to reach a solution."
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "This should be easy level problem!!!!"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is easy only if you ignore the time and space requirements of the question."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "Read question properly ..you have to solve using constant extra space but you are using a map which is O(n) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Got as best as O(NlogN) and O(1) space solution. \nHad the thought that it has to do with bit manipulation due to a classic find the single number with others being twice and you do XOR of all and you'll get the ans, but couldn't think of how to apply it here :/ "
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@tifv](/tifv) Yup, makes sense when you finally think that all it needs is summation of each set bit of the nums modulo 3 which would simply set the bits of the answer we need. Tho, this intuition didn\\'t cross my mind at first, O(32n) seems plausible now."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea with XOR is a good lead. XOR is in fact the bitwise modulo 2 addition. What you need here should be similar, but work a different modulo."
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "why I am getting error on parsing this string \"11111111111111111111111111111100\" as Integer in java using Integer.parseInt(binarystring, 2) ? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because it is bigger than the max value a 32 bit int can hold, in Java :)"
                    }
                ]
            },
            {
                "id": 1861219,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1853857,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1846521,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1820298,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1780982,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1767555,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1761815,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1751544,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1706930,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            },
            {
                "id": 1700760,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Is it me or the guy who decided to include negative numbers was a twisted man who hates python users?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I thought of doing this with a hashing function. Go through the array and hash every number (key) to an index of the array. Then flag the element you find at this hashed index without destroying it (turn it into a string or something like that) to indicate that the key pointing to it has been encountered. Once you are done, you can go through the array a second time, check if the element corresponding to every key has been flagged twice or more. If not, this key is the unique value.\nDealing with collisions would be a pain (the flagging is gonna have to be more complicated and involve lists) , and in the worst case, could make both space and time complexity degenerate. But we usually ignore that when using hashmaps and hashsets, so I guess it is deemed acceptable\nIt seems very messy and quite complicated to implement but do you think the basic idea is viable, given enough time to implement it?\n\nP.S: in what world is this problem a medium one? It is a lot harder than most hard problems I have seen. More and more confused by difficulty tags these days"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "I'm trying to solve this problem by using bit manipulation .\nworking fine for positive numbers but not working for negative numbers , so I tried to convert negative number into binary form using 2's compliment method .\nat the end I'm getting my right ans but in 2,s compliment form and I'm stuck here I don't know how to convert that into decimal.\ncan anyone help me with this?\ncode is big sorry in advance.\n\n\n    public int singleNumber(int[] nums) {\n       int[] arr = new int[32];\n       boolean neg = false;\n       for(int i=0;i<nums.length;i++){\n           int copy = nums[i];\n           if(copy<0){ // if the number is negative\n              StringBuilder sb = new StringBuilder();\n              copy = -nums[i];\n              int len =0;\n              while(copy>0){\n                len++;\n                int num = copy&1;\n                copy>>=1;\n              if(num==1){\n                  sb.append(0);\n              }\n              else{\n                  sb.append(1);\n              }\n           }\n          while(len%4!=0){\n              sb.append(1);\n              len++;\n          }\n          int carry =1;\n          int k =0;\n          for(int j=0;j<sb.length();j++){\n              if((int)sb.charAt(j)-'0'==1 && carry ==1){\n                  arr[k]+=0;\n              }\n              else if((int)sb.charAt(j)-'0'==0 && carry ==1){\n                  arr[k]+=1;\n                  carry = 0;\n              }\n              else{\n                  arr[k]+=sb.charAt(j)-'0';\n              }\n              k++;\n          }\n          if(carry==1){\n              arr[k]+=1;\n          }\n\n           }\n\n\n           else{ //  if number is positive\n               int k =0;\n           while(copy>0){\n               int num = copy&1;\n               copy= copy>>1;\n               if(num==1){\n                   arr[k]++;\n               }\n               k++;\n           }\n           }\n       }\n       for(int i=0;i<arr.length;i++){\n           arr[i] = arr[i]%3;\n       }\n       int index =0;\n       for(int i=arr.length-1;i>=0;i--){\n           if(arr[i]==1){\n               i = index;\n               break;\n           }\n       }\n       if(index+1 % 4 == 0){\n          neg = true;\n          negative(arr);\n       }\n       int ans =0;\n       int mul =1;\n       for(int i=0;i<arr.length;i++){\n           if(arr[i]==1){\n               ans = ans + mul;\n           }\n           mul = mul + mul;\n       }\n       if(neg == true){\n           return -ans;\n       }\n       return ans;\n    } \n    public static void negative(int[] arr){\n        for(int i=0;i<arr.length;i++){\n            arr[i]= arr[i] ^ 1;\n        }\n        int carry =1;\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==1 && carry ==1){\n                arr[i] = 0;\n            }\n            else if(arr[i]==0 && carry == 1){\n                carry = 0;\n                arr[i] =1;\n                break;\n            }\n        }\n    }\n}"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "today 4 july after seeing my solution again for 5 minutes finally I figured it out .\\nlooks like my point of view has changed little bit. some things just take some time just don\\'t give up."
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "Popular Facebook interview question "
                    },
                    {
                        "username": "Sir_BG",
                        "content": "here is my solution using constant space \\nclass Solution {\\n    void update(vector<int> &sum,int x){\\n        for(int i=0;i<32;i++){\\n            int last=(x&(1<<i));\\n            if(last){\\n                sum[i]++;\\n            }\\n        }\\n        return;\\n    }\\n    int getnumber(vector<int> &sum){\\n        for(int i=0;i<sum.size();i++){\\n            sum[i]=sum[i]%3;\\n        }\\n        int num=0;\\n        for(int i=0;i<32;i++){\\n            num=num+(sum[i]*(1<<i));\\n        }\\n        return num;\\n    }\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int>sum(32,0);\\n        for(auto &x:nums){\\n            update(sum,x);\\n        }\\n        return getnumber(sum);\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/137_single_num_2.cpp"
                    },
                    {
                        "username": "Aakhila_Hayathunisa",
                        "content": "class Solution(object):\\n    def singleNumber(self, a):\\n        n=len(a)\\n        max_ele = max(a)\\n        min_ele = min(a)\\n        count=[]\\n        end=max_ele+1\\n\\n        for i in range(min_ele,end):\\n            count.append(0)\\n        for i in range(0, n):\\n            count[a[i]] = count[a[i]]+1\\n        for i in range(min_ele, end):\\n            print(count[i])  \\n        for i in range(min_ele, end):\\n            if count[i]==1 :\\n                return i\\n        return -1; \\n\\n\\n\\nthis code works completely fine in other compiler but error in leetcode. "
                    },
                    {
                        "username": "Msey",
                        "content": " is that possible to solve in O(1) space witout bit manipulation?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kylecrowley](/kylecrowley) Quicksort has a O(N log N) time complexity (unless you are sorting a sorted list and choose your pivots badly)."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "You can sort the input first, but you\\'ll have to choose a sorting algorithm that uses constant space. The problem there is you sacrifice space for time, so the sorting algorithms that use constant space have a quadratic runtime (see [here](https://www.bigocheatsheet.com/)).\\n\\nSo yes, you can solve this problem with constant space and w/o bit manipulation, but you\\'ll need quadratic runtime when the problem asks for linear runtime, constant space."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is prime number"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I have figured out 3 different solutions to this problem but still am not able to figure out the solution which takes O(n) time and O(1) space. \\n\\nThree solutions that I thought of are : \\n\\n1. Traversing the entire array and checking the conditions - O(n^2) time and O(1) space\\n2. Hashmap to store number and its frequency - O(n) time and O(n) space\\n3. Sorting and checking for integer that have just 1 occurence - O(nlogn) time and O(1) space\\n\\nCan someone guide me in the right direction or provide some insights?"
                    }
                ]
            }
        ]
    }
]