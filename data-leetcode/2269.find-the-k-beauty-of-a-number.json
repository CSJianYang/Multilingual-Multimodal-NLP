[
    {
        "title": "Minimum Number of Keypresses",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1635358,
                "content": [
                    {
                        "username": "AbyzzGazer",
                        "content": "Why this problem is marked as \"medium\"?"
                    },
                    {
                        "username": "yuedai",
                        "content": "Should be easy."
                    },
                    {
                        "username": "anvnguyen",
                        "content": "Same question, this should be easy level. "
                    },
                    {
                        "username": "adu-darkwa",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "koko2003",
                        "content": "The test verifier for this problem is wrong:\\nExample 1 - for `\"ab\"` the expected result is `2`, whereas for whom wrote text messages in the 2000\\'s, the correct result is 3! :D"
                    },
                    {
                        "username": "koko2003",
                        "content": "[@ursachu](/ursachu) \\nI don\\'t think the keypad format will change for every input: where is that stated?\\n\\nThe input is the string you need to write only, and does not include the keyboard mapping (int minimumKeypresses(string s)):\\n\\n1- \"You can choose which characters each button is matched to as long as: ...\"\\n2- \"Note that the characters mapped to by each button, and the order they are mapped in cannot be changed.\"\\n\\nThe question is: \"Given a string s, return the minimum number of keypresses needed to type s using your keypad.\"\\nNOTE: **\"using your keypad\"**, i.e. which you are allowed to *arbitrarily* choose as per point 1.\\n\\nNow, let\\'s say your function implements the following key mapping (which accounts all rules on point 1), and is the first example:\\n\\nint minimumKeypresses(string s) {\\n        vector<string> keypad = {\"abc\", \"df\", \"eij\", \"gqs\", \"lkx\", \"ptu\", \"mnr\", \"hyz\", \"ovw\"};\\n        ....\\n}\\n\\nHow do 2 key presses get you to type s=\"ab\"?\\n\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@koko2003](/koko2003) Bruh the keypad format will change for every input. For \"ab\", I will put acd on 1 and bef on 2 just to make it 2 presses "
                    },
                    {
                        "username": "koko2003",
                        "content": "[@ursachu](/ursachu) can you help me understand what exactly I may have misinterpreted?\\n\\nButton with \"abc\":\\n\\n[Press][wait]-> \"a\"\\n[Press][Press][wait]-> \"b\"\\n\\nThat\\'s 3 presses, bro\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "I think you misinterpreted the question, bruh"
                    },
                    {
                        "username": "Msey",
                        "content": "Amazon mfa question"
                    },
                    {
                        "username": "dpnkishore",
                        "content": "the ide is stuck, could not write anything .It says , \"this language is not supported \" and also I couldn\\u2019t change the language "
                    }
                ]
            },
            {
                "id": 1899220,
                "content": [
                    {
                        "username": "AbyzzGazer",
                        "content": "Why this problem is marked as \"medium\"?"
                    },
                    {
                        "username": "yuedai",
                        "content": "Should be easy."
                    },
                    {
                        "username": "anvnguyen",
                        "content": "Same question, this should be easy level. "
                    },
                    {
                        "username": "adu-darkwa",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "koko2003",
                        "content": "The test verifier for this problem is wrong:\\nExample 1 - for `\"ab\"` the expected result is `2`, whereas for whom wrote text messages in the 2000\\'s, the correct result is 3! :D"
                    },
                    {
                        "username": "koko2003",
                        "content": "[@ursachu](/ursachu) \\nI don\\'t think the keypad format will change for every input: where is that stated?\\n\\nThe input is the string you need to write only, and does not include the keyboard mapping (int minimumKeypresses(string s)):\\n\\n1- \"You can choose which characters each button is matched to as long as: ...\"\\n2- \"Note that the characters mapped to by each button, and the order they are mapped in cannot be changed.\"\\n\\nThe question is: \"Given a string s, return the minimum number of keypresses needed to type s using your keypad.\"\\nNOTE: **\"using your keypad\"**, i.e. which you are allowed to *arbitrarily* choose as per point 1.\\n\\nNow, let\\'s say your function implements the following key mapping (which accounts all rules on point 1), and is the first example:\\n\\nint minimumKeypresses(string s) {\\n        vector<string> keypad = {\"abc\", \"df\", \"eij\", \"gqs\", \"lkx\", \"ptu\", \"mnr\", \"hyz\", \"ovw\"};\\n        ....\\n}\\n\\nHow do 2 key presses get you to type s=\"ab\"?\\n\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@koko2003](/koko2003) Bruh the keypad format will change for every input. For \"ab\", I will put acd on 1 and bef on 2 just to make it 2 presses "
                    },
                    {
                        "username": "koko2003",
                        "content": "[@ursachu](/ursachu) can you help me understand what exactly I may have misinterpreted?\\n\\nButton with \"abc\":\\n\\n[Press][wait]-> \"a\"\\n[Press][Press][wait]-> \"b\"\\n\\nThat\\'s 3 presses, bro\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "I think you misinterpreted the question, bruh"
                    },
                    {
                        "username": "Msey",
                        "content": "Amazon mfa question"
                    },
                    {
                        "username": "dpnkishore",
                        "content": "the ide is stuck, could not write anything .It says , \"this language is not supported \" and also I couldn\\u2019t change the language "
                    }
                ]
            },
            {
                "id": 1781136,
                "content": [
                    {
                        "username": "AbyzzGazer",
                        "content": "Why this problem is marked as \"medium\"?"
                    },
                    {
                        "username": "yuedai",
                        "content": "Should be easy."
                    },
                    {
                        "username": "anvnguyen",
                        "content": "Same question, this should be easy level. "
                    },
                    {
                        "username": "adu-darkwa",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "koko2003",
                        "content": "The test verifier for this problem is wrong:\\nExample 1 - for `\"ab\"` the expected result is `2`, whereas for whom wrote text messages in the 2000\\'s, the correct result is 3! :D"
                    },
                    {
                        "username": "koko2003",
                        "content": "[@ursachu](/ursachu) \\nI don\\'t think the keypad format will change for every input: where is that stated?\\n\\nThe input is the string you need to write only, and does not include the keyboard mapping (int minimumKeypresses(string s)):\\n\\n1- \"You can choose which characters each button is matched to as long as: ...\"\\n2- \"Note that the characters mapped to by each button, and the order they are mapped in cannot be changed.\"\\n\\nThe question is: \"Given a string s, return the minimum number of keypresses needed to type s using your keypad.\"\\nNOTE: **\"using your keypad\"**, i.e. which you are allowed to *arbitrarily* choose as per point 1.\\n\\nNow, let\\'s say your function implements the following key mapping (which accounts all rules on point 1), and is the first example:\\n\\nint minimumKeypresses(string s) {\\n        vector<string> keypad = {\"abc\", \"df\", \"eij\", \"gqs\", \"lkx\", \"ptu\", \"mnr\", \"hyz\", \"ovw\"};\\n        ....\\n}\\n\\nHow do 2 key presses get you to type s=\"ab\"?\\n\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@koko2003](/koko2003) Bruh the keypad format will change for every input. For \"ab\", I will put acd on 1 and bef on 2 just to make it 2 presses "
                    },
                    {
                        "username": "koko2003",
                        "content": "[@ursachu](/ursachu) can you help me understand what exactly I may have misinterpreted?\\n\\nButton with \"abc\":\\n\\n[Press][wait]-> \"a\"\\n[Press][Press][wait]-> \"b\"\\n\\nThat\\'s 3 presses, bro\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "I think you misinterpreted the question, bruh"
                    },
                    {
                        "username": "Msey",
                        "content": "Amazon mfa question"
                    },
                    {
                        "username": "dpnkishore",
                        "content": "the ide is stuck, could not write anything .It says , \"this language is not supported \" and also I couldn\\u2019t change the language "
                    }
                ]
            },
            {
                "id": 1688218,
                "content": [
                    {
                        "username": "AbyzzGazer",
                        "content": "Why this problem is marked as \"medium\"?"
                    },
                    {
                        "username": "yuedai",
                        "content": "Should be easy."
                    },
                    {
                        "username": "anvnguyen",
                        "content": "Same question, this should be easy level. "
                    },
                    {
                        "username": "adu-darkwa",
                        "content": "It should be easy?"
                    },
                    {
                        "username": "koko2003",
                        "content": "The test verifier for this problem is wrong:\\nExample 1 - for `\"ab\"` the expected result is `2`, whereas for whom wrote text messages in the 2000\\'s, the correct result is 3! :D"
                    },
                    {
                        "username": "koko2003",
                        "content": "[@ursachu](/ursachu) \\nI don\\'t think the keypad format will change for every input: where is that stated?\\n\\nThe input is the string you need to write only, and does not include the keyboard mapping (int minimumKeypresses(string s)):\\n\\n1- \"You can choose which characters each button is matched to as long as: ...\"\\n2- \"Note that the characters mapped to by each button, and the order they are mapped in cannot be changed.\"\\n\\nThe question is: \"Given a string s, return the minimum number of keypresses needed to type s using your keypad.\"\\nNOTE: **\"using your keypad\"**, i.e. which you are allowed to *arbitrarily* choose as per point 1.\\n\\nNow, let\\'s say your function implements the following key mapping (which accounts all rules on point 1), and is the first example:\\n\\nint minimumKeypresses(string s) {\\n        vector<string> keypad = {\"abc\", \"df\", \"eij\", \"gqs\", \"lkx\", \"ptu\", \"mnr\", \"hyz\", \"ovw\"};\\n        ....\\n}\\n\\nHow do 2 key presses get you to type s=\"ab\"?\\n\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@koko2003](/koko2003) Bruh the keypad format will change for every input. For \"ab\", I will put acd on 1 and bef on 2 just to make it 2 presses "
                    },
                    {
                        "username": "koko2003",
                        "content": "[@ursachu](/ursachu) can you help me understand what exactly I may have misinterpreted?\\n\\nButton with \"abc\":\\n\\n[Press][wait]-> \"a\"\\n[Press][Press][wait]-> \"b\"\\n\\nThat\\'s 3 presses, bro\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "I think you misinterpreted the question, bruh"
                    },
                    {
                        "username": "Msey",
                        "content": "Amazon mfa question"
                    },
                    {
                        "username": "dpnkishore",
                        "content": "the ide is stuck, could not write anything .It says , \"this language is not supported \" and also I couldn\\u2019t change the language "
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the K-Beauty of a Number",
        "question_content": "<p>The <strong>k-beauty</strong> of an integer <code>num</code> is defined as the number of <strong>substrings</strong> of <code>num</code> when it is read as a string that meet the following conditions:</p>\n\n<ul>\n\t<li>It has a length of <code>k</code>.</li>\n\t<li>It is a divisor of <code>num</code>.</li>\n</ul>\n\n<p>Given integers <code>num</code> and <code>k</code>, return <em>the k-beauty of </em><code>num</code>.</p>\n\n<p>Note:</p>\n\n<ul>\n\t<li><strong>Leading zeros</strong> are allowed.</li>\n\t<li><code>0</code> is not a divisor of any value.</li>\n</ul>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 240, k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The following are the substrings of num of length k:\n- &quot;24&quot; from &quot;<strong><u>24</u></strong>0&quot;: 24 is a divisor of 240.\n- &quot;40&quot; from &quot;2<u><strong>40</strong></u>&quot;: 40 is a divisor of 240.\nTherefore, the k-beauty is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 430043, k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The following are the substrings of num of length k:\n- &quot;43&quot; from &quot;<u><strong>43</strong></u>0043&quot;: 43 is a divisor of 430043.\n- &quot;30&quot; from &quot;4<u><strong>30</strong></u>043&quot;: 30 is not a divisor of 430043.\n- &quot;00&quot; from &quot;43<u><strong>00</strong></u>43&quot;: 0 is not a divisor of 430043.\n- &quot;04&quot; from &quot;430<u><strong>04</strong></u>3&quot;: 4 is not a divisor of 430043.\n- &quot;43&quot; from &quot;4300<u><strong>43</strong></u>&quot;: 43 is a divisor of 430043.\nTherefore, the k-beauty is 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= num.length</code> (taking <code>num</code> as a string)</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2038555,
                "title": "numeric-sliding-window",
                "content": "The solution can be simpler, but the goal here is to avoid string conversions.\\n\\nWe build `cur` going right-to-left. We add `k`-th number by multiplying it by `pow(10, k - 1)`. When the window length exceeds `k`, we just divide `cur` by 10.\\n\\n**C++**\\n```cpp\\nint divisorSubstrings(int num, int k) {\\n    int res = 0, cur = 0, pow = 1;\\n    for (int n = num; n > 0; n /= 10) {\\n        cur += (n % 10) * pow;\\n        if (--k > 0)\\n            pow *= 10;\\n        else {\\n            res += cur && !(num % cur);\\n            cur /= 10;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint divisorSubstrings(int num, int k) {\\n    int res = 0, cur = 0, pow = 1;\\n    for (int n = num; n > 0; n /= 10) {\\n        cur += (n % 10) * pow;\\n        if (--k > 0)\\n            pow *= 10;\\n        else {\\n            res += cur && !(num % cur);\\n            cur /= 10;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038650,
                "title": "c-sliding-window-easy-to-understand-2-pointers",
                "content": "# 2269. Find the K-Beauty of a Number\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n```\\nUSING SLIDING WINDOW TECHNIQUE\\n```\\n\\n\\n* **Convert the number into String.**\\n* Now take **two pointer i & j.**\\n* run a while loop till **j < string.length()**\\n* now **till we do not get the window size increment j;**\\n* as we get the window size i.e **j - i + 1 == k;**\\n* **extract the string using substr()** func and then c**onvert that string to integer using stoi() func .**\\n* **Check whether that number is divisible by k.**\\n* If **yes increase the count.**\\n* **return cnt.**\\n``` ```\\n\\n**CODE WITH EXPLANATION**\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int i = 0, j = 0, n = str.length();\\n        int ind = 0;\\n        \\n        while(j < n)\\n        {\\n            if(j - i + 1 < k)\\n            {\\n\\t\\t\\t// increment j till we get the window size\\n                ++j;\\n            }\\n            else if(j - i + 1 == k)\\n            {\\n\\t\\t\\t// on hiting the window size\\n\\t\\t\\t// extract window string and convert to int\\n\\t\\t\\t// check if it follows the given condition\\n                string s = str.substr(i,k);\\n                int n = stoi(s);\\n                if(n != 0 && num % n == 0 )\\n                    ++ind;\\n                \\n\\t\\t\\t\\t// shift the window by ++j;\\n\\t\\t\\t\\t// remove previous calculation by ++i\\n                ++i;\\n                ++j;\\n            }\\n                \\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\nUSING SLIDING WINDOW TECHNIQUE\\n```\n``` ```\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int i = 0, j = 0, n = str.length();\\n        int ind = 0;\\n        \\n        while(j < n)\\n        {\\n            if(j - i + 1 < k)\\n            {\\n\\t\\t\\t// increment j till we get the window size\\n                ++j;\\n            }\\n            else if(j - i + 1 == k)\\n            {\\n\\t\\t\\t// on hiting the window size\\n\\t\\t\\t// extract window string and convert to int\\n\\t\\t\\t// check if it follows the given condition\\n                string s = str.substr(i,k);\\n                int n = stoi(s);\\n                if(n != 0 && num % n == 0 )\\n                    ++ind;\\n                \\n\\t\\t\\t\\t// shift the window by ++j;\\n\\t\\t\\t\\t// remove previous calculation by ++i\\n                ++i;\\n                ++j;\\n            }\\n                \\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038366,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String str=String.valueOf(num); // to covert integer to String\\n        int count=0;   // count of ans..\\n        for(int i=0;i<str.length()-k+1;i++)  // deciding the starting index of window\\n        {\\n            String temp=str.substring(i,i+k);    // storing string till window length\\n            int n1=Integer.valueOf(temp);       // converting string to integer\\n            if(n1==0)     // to avoid division error\\n            {\\n                continue;\\n            }\\n            if(num%n1==0)      // if it is divisible then increase the count\\n            {\\n                count++;\\n            }\\n        }\\n        return count;  // lastly return our count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String str=String.valueOf(num); // to covert integer to String\\n        int count=0;   // count of ans..\\n        for(int i=0;i<str.length()-k+1;i++)  // deciding the starting index of window\\n        {\\n            String temp=str.substring(i,i+k);    // storing string till window length\\n            int n1=Integer.valueOf(temp);       // converting string to integer\\n            if(n1==0)     // to avoid division error\\n            {\\n                continue;\\n            }\\n            if(num%n1==0)      // if it is divisible then increase the count\\n            {\\n                count++;\\n            }\\n        }\\n        return count;  // lastly return our count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038409,
                "title": "python-explained-approach-with-time-and-space-complexity-analysis",
                "content": "1. **Generate all possible substrings** of the given number(convert it to string) **of length k**.\\n2. **Divide the number by each of the substrings** and increment **count if** the remainder of the division is zero (**perfectly divisible**). Also, check that the integer value of the **resultant substring is** **not zero**, as division by zero is invalid. \\n\\n**Example:**\\n```\\nnum = 430043\\nk = 2\\n\\nStep 1: Generate all substings of len = 2.\\n\\t\\t\\t=> [43, 30, 00, 04, 43]\\nStep 2: Divide and increment count if perfectly divisible.\\n\\t\\t\\tintially count = 0\\n\\t\\t\\titeration 1 => 430043%43 == 0 ; count += 1\\n\\t\\t\\titeration 1 => 430043%30 != 0 ; count += 0\\n\\t\\t\\titeration 1 => 430043% 00 = > integer value of substring == 00 ; count += 0\\n\\t\\t\\titeration 1 => 430043%30 != 0 ; count += 0\\n\\t\\t\\titeration 1 => 430043%43 == 0 ; count += 1\\n\\t\\t\\t\\n```\\n\\n**Time and space complexity analysis:**\\nThe whole list of size **n** is traversed only once and we strip substring of size **k** from nums. Both these operations are nested (done simultanesously). Hence, **Time complexity = O(nk)**.\\n\\nAlso, We do not use any extra space, except for storing the stripped substring of size k. Hence, **space complexity = O(k)**.\\n\\nThe full code (***written during the contest***) is given below:\\n\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n\\t\\t#slide a window of size \\'k\\' => sliding window approach\\n        for i in range(len(str(num)) - k + 1):\\n            n = str(num)\\n            val = (int(n[i: i + k]))\\n            if val and num%val == 0:\\n                count += 1\\n        return count\\n```\\n\\n**EDIT:** The corresponding one-liner pythonic version of the above code:\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        s = str(num)\\n        return sum( int(s[i:i+k]) != 0 and num % int(s[i:i+k]) == 0 for i in range(len(s)-k+1) )\\n```\\n\\nDo Upvote, if helpful. \\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nnum = 430043\\nk = 2\\n\\nStep 1: Generate all substings of len = 2.\\n\\t\\t\\t=> [43, 30, 00, 04, 43]\\nStep 2: Divide and increment count if perfectly divisible.\\n\\t\\t\\tintially count = 0\\n\\t\\t\\titeration 1 => 430043%43 == 0 ; count += 1\\n\\t\\t\\titeration 1 => 430043%30 != 0 ; count += 0\\n\\t\\t\\titeration 1 => 430043% 00 = > integer value of substring == 00 ; count += 0\\n\\t\\t\\titeration 1 => 430043%30 != 0 ; count += 0\\n\\t\\t\\titeration 1 => 430043%43 == 0 ; count += 1\\n\\t\\t\\t\\n```\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n\\t\\t#slide a window of size \\'k\\' => sliding window approach\\n        for i in range(len(str(num)) - k + 1):\\n            n = str(num)\\n            val = (int(n[i: i + k]))\\n            if val and num%val == 0:\\n                count += 1\\n        return count\\n```\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        s = str(num)\\n        return sum( int(s[i:i+k]) != 0 and num % int(s[i:i+k]) == 0 for i in range(len(s)-k+1) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038169,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string x = to_string(num);\\n        int n = x.length();\\n        int ans = 0;\\n        for(int i = 0;i<=(n-k);i++){\\n            if(stoi(x.substr(i,k)) != 0)\\n            if(num % stoi(x.substr(i,k)) == 0 )\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string x = to_string(num);\\n        int n = x.length();\\n        int ans = 0;\\n        for(int i = 0;i<=(n-k);i++){\\n            if(stoi(x.substr(i,k)) != 0)\\n            if(num % stoi(x.substr(i,k)) == 0 )\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765372,
                "title": "sliding-window",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n    String nums = String.valueOf(num);\\n    int left = 0;\\n    int count = 0;\\n    String s = \"\";\\n    for(int i = 0; i < nums.length(); i++){\\n        s = s+nums.charAt(i);\\n        if(i-left == k-1){\\n            if(Integer.valueOf(s) == 0){\\n                if(s.length() != 0){\\n                    s = s.substring(1);\\n                    left++;\\n                }\\n                else left++;\\n            }\\n          else{  \\n           if(num%Integer.valueOf(s) == 0){\\n             count++;\\n       }\\n               left++;\\n             s = s.substring(1);\\n          }\\n        }\\n    }    \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n    String nums = String.valueOf(num);\\n    int left = 0;\\n    int count = 0;\\n    String s = \"\";\\n    for(int i = 0; i < nums.length(); i++){\\n        s = s+nums.charAt(i);\\n        if(i-left == k-1){\\n            if(Integer.valueOf(s) == 0){\\n                if(s.length() != 0){\\n                    s = s.substring(1);\\n                    left++;\\n                }\\n                else left++;\\n            }\\n          else{  \\n           if(num%Integer.valueOf(s) == 0){\\n             count++;\\n       }\\n               left++;\\n             s = s.substring(1);\\n          }\\n        }\\n    }    \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038166,
                "title": "python-straightforward-with-left-and-right-pointers-sliding-window",
                "content": "```\\ndef divisorSubstrings(self, num: int, k: int) -> int:\\n    l = 0\\n    r = k\\n\\n    num = str(num)\\n    count = 0\\n    while r <= len(num):            \\n        n = int(num[l: r])\\n\\n        # handle case where n could be \\'0\\'. \\n        if not n:\\n            l += 1\\n            r += 1\\n            continue\\n\\n        if int(num) % n == 0:\\n            count += 1   \\n\\t\\t\\t\\n\\t\\t# slide window\\n        l += 1\\n        r += 1\\n\\n    return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef divisorSubstrings(self, num: int, k: int) -> int:\\n    l = 0\\n    r = k\\n\\n    num = str(num)\\n    count = 0\\n    while r <= len(num):            \\n        n = int(num[l: r])\\n\\n        # handle case where n could be \\'0\\'. \\n        if not n:\\n            l += 1\\n            r += 1\\n            continue\\n\\n        if int(num) % n == 0:\\n            count += 1   \\n\\t\\t\\t\\n\\t\\t# slide window\\n        l += 1\\n        r += 1\\n\\n    return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2039542,
                "title": "short-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar divisorSubstrings = (num, k) => {\\n    let numToString = num.toString()\\n    let count = 0;\\n\\n    for (let i = 0; i <= numToString.length - k; i++) {\\n        let subNum = parseInt(numToString.slice(i, k + i))\\n        if (num % subNum === 0) count++\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar divisorSubstrings = (num, k) => {\\n    let numToString = num.toString()\\n    let count = 0;\\n\\n    for (let i = 0; i <= numToString.length - k; i++) {\\n        let subNum = parseInt(numToString.slice(i, k + i))\\n        if (num % subNum === 0) count++\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2444267,
                "title": "brute-force-optimal-solution-java-sliding-window",
                "content": "**Brute force**\\n\\nSliding Window\\n\\n**making string of length k everytime and check if it divisible by num and keep in check if the s value is not 0.**\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n    String nums = String.valueOf(num);\\n    int left = 0;\\n    int count = 0;\\n    String s = \"\";\\n    for(int i = 0; i < nums.length(); i++){\\n        s = s+nums.charAt(i);\\n        if(i-left == k-1){\\n            if(Integer.valueOf(s) == 0){\\n                if(s.length() != 0){\\n                    s = s.substring(1);\\n                    left++;\\n                }\\n                else left++;\\n            }\\n          else{  \\n           if(num%Integer.valueOf(s) == 0){\\n             count++;\\n       }\\n               left++;\\n             s = s.substring(1);\\n          }\\n        }\\n    }    \\n        return count;\\n    }\\n}\\n\\n```\\n**Optimal (Sliding Window but better)**\\n```\\n\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n    String s = String.valueOf(num);\\n    int count = 0;\\n    for(int i = 0; i <= s.length()-k; i++){\\n\\t// Integer.parseInt --> change any string or any other datatype into int.\\n\\t// String.substring(start,end) --> will give string part from main string \\n\\t// in range of start to end.\\n        int number = Integer.parseInt(s.substring(i,i+k));\\n        if(number > 0 && num%number==0){\\n            count++;\\n        }\\n    }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n    String nums = String.valueOf(num);\\n    int left = 0;\\n    int count = 0;\\n    String s = \"\";\\n    for(int i = 0; i < nums.length(); i++){\\n        s = s+nums.charAt(i);\\n        if(i-left == k-1){\\n            if(Integer.valueOf(s) == 0){\\n                if(s.length() != 0){\\n                    s = s.substring(1);\\n                    left++;\\n                }\\n                else left++;\\n            }\\n          else{  \\n           if(num%Integer.valueOf(s) == 0){\\n             count++;\\n       }\\n               left++;\\n             s = s.substring(1);\\n          }\\n        }\\n    }    \\n        return count;\\n    }\\n}\\n\\n```\n```\\n\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n    String s = String.valueOf(num);\\n    int count = 0;\\n    for(int i = 0; i <= s.length()-k; i++){\\n\\t// Integer.parseInt --> change any string or any other datatype into int.\\n\\t// String.substring(start,end) --> will give string part from main string \\n\\t// in range of start to end.\\n        int number = Integer.parseInt(s.substring(i,i+k));\\n        if(number > 0 && num%number==0){\\n            count++;\\n        }\\n    }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231535,
                "title": "sliding-window-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Iteration over all the digits of the number takes O(N) time.\\nSpace Complexity - Since we haven\\'t used any extra space, space complexity is O(1).\\nSolution - We take each substring using sliding window and check if they are divisors of the given number.\\nTip - If you are having difficulty understanding the algorithm, try learning the sliding window algorithm first, and then come back to this problem.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isBeauty(string s1, string s2){\\n        int n1 = stoi(s1);\\n        int n2 = stoi(s2);\\n        if(n2) return !(n1 % n2);\\n        return false;\\n    }\\n    \\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size();\\n        if(!n) return 0;\\n        int i = 0, j = 0, beautyCount = 0;\\n        // At any given moment, for any particular values of i and j, (j - i + 1) gives us the window size\\n        \\n        while(j < n){\\n            // Calculation\\n            string window = s.substr(i, j - i + 1);\\n            \\n            // Window size not reached yet\\n            if(j - i + 1 < k){\\n                j++;\\n            }\\n            \\n\\t\\t\\t// Window size reached\\n            else if(j - i + 1 == k){\\n                // Find the answer\\n                if(isBeauty(s, window)) beautyCount++;\\n                \\n                // Slide the window\\n                i++;\\n                j++;\\n            }\\n        }\\n        return beautyCount;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBeauty(string s1, string s2){\\n        int n1 = stoi(s1);\\n        int n2 = stoi(s2);\\n        if(n2) return !(n1 % n2);\\n        return false;\\n    }\\n    \\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size();\\n        if(!n) return 0;\\n        int i = 0, j = 0, beautyCount = 0;\\n        // At any given moment, for any particular values of i and j, (j - i + 1) gives us the window size\\n        \\n        while(j < n){\\n            // Calculation\\n            string window = s.substr(i, j - i + 1);\\n            \\n            // Window size not reached yet\\n            if(j - i + 1 < k){\\n                j++;\\n            }\\n            \\n\\t\\t\\t// Window size reached\\n            else if(j - i + 1 == k){\\n                // Find the answer\\n                if(isBeauty(s, window)) beautyCount++;\\n                \\n                // Slide the window\\n                i++;\\n                j++;\\n            }\\n        }\\n        return beautyCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100121,
                "title": "easy-python-solution",
                "content": "```\\ndef divisorSubstrings(self, num: int, k: int) -> int:\\n        s=str(num)\\n        c=0\\n        for i in range(k,len(s)+1):\\n            x=int(s[i-k:i])\\n            if x!=0 and num%x==0:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef divisorSubstrings(self, num: int, k: int) -> int:\\n        s=str(num)\\n        c=0\\n        for i in range(k,len(s)+1):\\n            x=int(s[i-k:i])\\n            if x!=0 and num%x==0:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2611592,
                "title": "python-elegant-short-sliding-window-o-log10-n-time-o-1-memory",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(log10(n)*k)\\n    Memory: O(log10(n))\\n    \"\"\"\\n\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        str_num = str(num)\\n        return sum(\\n            num % int(str_num[i - k:i]) == 0\\n            for i in range(k, len(str_num) + 1)\\n            if int(str_num[i - k:i]) != 0\\n        )\\n```\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(log10(n))\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        power = 10 ** (k - 1)\\n        tmp, window = divmod(num, 10 * power)\\n\\n        count = int(window and not num % window)\\n        while tmp:\\n            tmp, digit = divmod(tmp, 10)\\n            window = digit * power + window // 10\\n            count += window and not num % window\\n\\n        return count\\n\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(log10(n)*k)\\n    Memory: O(log10(n))\\n    \"\"\"\\n\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        str_num = str(num)\\n        return sum(\\n            num % int(str_num[i - k:i]) == 0\\n            for i in range(k, len(str_num) + 1)\\n            if int(str_num[i - k:i]) != 0\\n        )\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(log10(n))\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        power = 10 ** (k - 1)\\n        tmp, window = divmod(num, 10 * power)\\n\\n        count = int(window and not num % window)\\n        while tmp:\\n            tmp, digit = divmod(tmp, 10)\\n            window = digit * power + window // 10\\n            count += window and not num % window\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038496,
                "title": "c-easy-math-comments-added-short-simple",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) \\n    {\\n        int beauty=0;\\n        long long temp = num;\\n        int divisor;\\n        \\n        // till our temp size is equal or greater than the given k\\n        while(temp!=0 && to_string(temp).size() >= k)\\n        {\\n            // getting the value that will help us to find the divisor using (10 to the power k)\\n            long long val = pow(10, k); \\n            \\n            //getting the divisor of length k\\n            divisor = temp%val;               \\n            \\n            // if it satisfy both the conditions then increase beauty by one\\n            if(divisor!=0 && num%divisor==0) \\n                beauty++;\\n            \\n            // each time update our temp \\n            temp = temp/10; \\n        }\\n        return beauty;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) \\n    {\\n        int beauty=0;\\n        long long temp = num;\\n        int divisor;\\n        \\n        // till our temp size is equal or greater than the given k\\n        while(temp!=0 && to_string(temp).size() >= k)\\n        {\\n            // getting the value that will help us to find the divisor using (10 to the power k)\\n            long long val = pow(10, k); \\n            \\n            //getting the divisor of length k\\n            divisor = temp%val;               \\n            \\n            // if it satisfy both the conditions then increase beauty by one\\n            if(divisor!=0 && num%divisor==0) \\n                beauty++;\\n            \\n            // each time update our temp \\n            temp = temp/10; \\n        }\\n        return beauty;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830154,
                "title": "java-find-the-k-beauty-of-a-number",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String str=String.valueOf(num);\\n        int c=0;\\n        for(int i=0;i<=str.length()-k;i++)\\n        {\\n            int val=Integer.parseInt(str.substring(i,i+k));\\n            if(val!=0&&num%val==0)c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String str=String.valueOf(num);\\n        int c=0;\\n        for(int i=0;i<=str.length()-k;i++)\\n        {\\n            int val=Integer.parseInt(str.substring(i,i+k));\\n            if(val!=0&&num%val==0)c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038211,
                "title": "c-2-approaches-use-divide-and-modulus-string-o-n-k-solution-easy-to-understand",
                "content": "**Please upvote if you find this solution helpful :)**\\n\\n**TC- O(N-K), SC-O(1)**\\n**Approach-1:** Use divide and modulus operation\\n```\\nclass Solution {\\npublic:\\n    \\n    //we just find divisor of size k by doing modulus operation on num with 10^k\\n    //and check whether nums%divisor gives 0 if it gives then we increase k_beauty by 1\\n    //then we reduce num by dividing it by 10.\\n    int divisorSubstrings(int num, int k) \\n    {\\n        int beauty=0;\\n        long long temp = num;\\n        int divisor;\\n        \\n        //when temp==0 or temp length < k, we stop\\n        while(temp!=0 && to_string(temp).size() >= k)\\n        {\\n            long long p = pow(10, k); \\n            divisor = temp%p; //get divisor of length k\\n            \\n            if(divisor!=0 && num%divisor==0) //if divisor perfectly divide num, we increse k_beauty\\n                beauty++;\\n            \\n            temp = temp/10; //reduce the length of num\\n        }\\n        return beauty;\\n    }\\n};\\n```\\n\\n**TC- O((N-K)* K), SC-O(1)**\\n**Approach-2:** Use string \\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num); //make string of num\\n        int n = str.size();\\n        int ans = 0;\\n        for(int i = 0;i<=(n-k);i++)\\n\\t\\t{\\n            if(stoi(str.substr(i,k)) != 0) //insure that divisor is not 0 \\n\\t\\t\\t\\tif(num % stoi(str.substr(i,k)) == 0 ) //when remainder is 0 increase ans by 1.\\n\\t\\t\\t\\t\\tans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //we just find divisor of size k by doing modulus operation on num with 10^k\\n    //and check whether nums%divisor gives 0 if it gives then we increase k_beauty by 1\\n    //then we reduce num by dividing it by 10.\\n    int divisorSubstrings(int num, int k) \\n    {\\n        int beauty=0;\\n        long long temp = num;\\n        int divisor;\\n        \\n        //when temp==0 or temp length < k, we stop\\n        while(temp!=0 && to_string(temp).size() >= k)\\n        {\\n            long long p = pow(10, k); \\n            divisor = temp%p; //get divisor of length k\\n            \\n            if(divisor!=0 && num%divisor==0) //if divisor perfectly divide num, we increse k_beauty\\n                beauty++;\\n            \\n            temp = temp/10; //reduce the length of num\\n        }\\n        return beauty;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num); //make string of num\\n        int n = str.size();\\n        int ans = 0;\\n        for(int i = 0;i<=(n-k);i++)\\n\\t\\t{\\n            if(stoi(str.substr(i,k)) != 0) //insure that divisor is not 0 \\n\\t\\t\\t\\tif(num % stoi(str.substr(i,k)) == 0 ) //when remainder is 0 increase ans by 1.\\n\\t\\t\\t\\t\\tans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088078,
                "title": "beats-100-easiest-explanation-sliding-window-c",
                "content": "# Approach\\n- To make it easier problem, as simple as sliding window in array\\n- We convert it into the string.\\n- Now extracting the substrings from the string s, again convert it into number.\\n- case 1 : Is it equal to zero ? (Y/N) Y-> reject,\\n- if case 1 is false, check whether this number is divisible by k, Y-> count++;\\n- At last return count.\\n-----\\n# Complexity\\n- Time complexity: O(log10(num))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n----\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        const string s = to_string(num);\\n        int answer = 0;\\n\\n        for(int i = 0;i + k <= s.length();i ++) {\\n            int x = stoi(s.substr(i, k));\\n            if(x != 0 && num % x == 0)\\n                answer ++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        const string s = to_string(num);\\n        int answer = 0;\\n\\n        for(int i = 0;i + k <= s.length();i ++) {\\n            int x = stoi(s.substr(i, k));\\n            if(x != 0 && num % x == 0)\\n                answer ++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618382,
                "title": "c-sliding-window-beats-100-runtime",
                "content": "# Code\\n```\\n// Not space optimized, beats 100% runtime\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int result = 0;\\n        string num_str = to_string(num);\\n        int sub_num = 0;\\n\\n        for (int i = 0; i < num_str.size(); i++) {\\n            if (i < k) {\\n                sub_num = sub_num * 10 + (num_str[i] - \\'0\\');\\n                continue;\\n            }\\n            if (sub_num != 0 && num % sub_num == 0) result++;\\n            // remove the most significant digit\\n            sub_num = sub_num % (int)pow(10, k-1);\\n            sub_num = sub_num * 10 + (num_str[i] - \\'0\\');\\n        }\\n        if (sub_num != 0 && num % sub_num == 0) result++;\\n\\n        return result;\\n    }\\n};\\n\\n\\n```\\n# Code\\n```\\n// Space optimized (credit: votrubac)\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int result = 0, curr = 0, pow = 1;\\n\\n        // building number from right to left\\n        for (int n = num; n > 0; n /= 10) {\\n            curr += (n % 10) * pow;\\n            if (--k > 0) {\\n                pow *= 10;\\n            } else {\\n                if (curr != 0 && num % curr == 0) result++;\\n                curr /= 10; \\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\nCredits: [votrubac](https://leetcode.com/problems/find-the-k-beauty-of-a-number/solutions/2038555/numeric-sliding-window/)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\n// Not space optimized, beats 100% runtime\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int result = 0;\\n        string num_str = to_string(num);\\n        int sub_num = 0;\\n\\n        for (int i = 0; i < num_str.size(); i++) {\\n            if (i < k) {\\n                sub_num = sub_num * 10 + (num_str[i] - \\'0\\');\\n                continue;\\n            }\\n            if (sub_num != 0 && num % sub_num == 0) result++;\\n            // remove the most significant digit\\n            sub_num = sub_num % (int)pow(10, k-1);\\n            sub_num = sub_num * 10 + (num_str[i] - \\'0\\');\\n        }\\n        if (sub_num != 0 && num % sub_num == 0) result++;\\n\\n        return result;\\n    }\\n};\\n\\n\\n```\n```\\n// Space optimized (credit: votrubac)\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int result = 0, curr = 0, pow = 1;\\n\\n        // building number from right to left\\n        for (int n = num; n > 0; n /= 10) {\\n            curr += (n % 10) * pow;\\n            if (--k > 0) {\\n                pow *= 10;\\n            } else {\\n                if (curr != 0 && num % curr == 0) result++;\\n                curr /= 10; \\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193822,
                "title": "c-beats-100-of-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- SLIDING WINDOW :-)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- My code uses a sliding window approach to iterate over all substrings of length k in num.\\n\\n- Initially, div is set to the first k characters of ref, which is the string representation of num. Then convert div to an integer check using stoi, and check if it is a divisor of num. If it is, increment count by 1.\\n\\n- Next, enter a loop where you can iterate over all the remaining substrings of length k in num. The loop starts at index k in the string ref.\\n\\n- For each iteration of the loop, update div to be the next substring of length k. To do this, first remove the leftmost character from div, which is the character at index i-k in ref. You then add the next character in ref to the right end of div, which is the character at index i. ( {div = div.substr(1) + ref[i];}This part is tricky though.. \\uD83E\\uDD28)\\n\\n- Then convert the new div to an integer check using stoi, and check if it is a divisor of num. If it is, increment count by 1.\\n\\n- Finally, return the value of count, which is the number of substrings of length k in num that are divisors of num.\\n\\n# Complexity\\nTime complexity: O(n*k)\\n- This is because you iterate over all substrings of length k in num, and for each substring, you perform constant-time operations such as string concatenation and integer conversion. Therefore, the time complexity is proportional to the number of substrings, which is n*k.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nSpace complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-  Because you only need to store one substring of length k at a time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) \\n    {\\n        string ref = to_string(num);\\n        int n = ref.size();\\n        string div = \"\";\\n        \\n        for(int i = 0; i < k; i++)\\n            div += ref[i];\\n        \\n        int count = 0;\\n        int check = stoi(div);\\n        \\n        if(num % check == 0)\\n            count++;\\n        \\n        for(int i = k; i < n; i++)\\n        {\\n            div = div.substr(1) + ref[i];\\n            check = abs(stoi(div));\\n\\n            if(check == 0)\\n               continue;\\n            \\n            if(num % check == 0)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) \\n    {\\n        string ref = to_string(num);\\n        int n = ref.size();\\n        string div = \"\";\\n        \\n        for(int i = 0; i < k; i++)\\n            div += ref[i];\\n        \\n        int count = 0;\\n        int check = stoi(div);\\n        \\n        if(num % check == 0)\\n            count++;\\n        \\n        for(int i = k; i < n; i++)\\n        {\\n            div = div.substr(1) + ref[i];\\n            check = abs(stoi(div));\\n\\n            if(check == 0)\\n               continue;\\n            \\n            if(num % check == 0)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001445,
                "title": "c-100-faster-two-methods-sliding-window-and-basic-substring",
                "content": "# Please Upvote if you find this helpful\\uD83D\\uDE4F\\n#### Thank you in advance ;)\\n<B></B>\\n<B></B>\\n<B></B>\\n\\n# 100% faster Substring method\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int ans=0;\\n        string str=to_string(num);\\n        int n=str.length();\\n        if(n==k) return 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(n-i>=k)\\n            {\\n                string s=str.substr(i-1,k);\\n                int val=stoll(s);\\n                if(val!=0)  if(num%val==0)  ans++;\\n            }\\n            \\n        }\\n        string s=str.substr(n-k,k);\\n        int val=stoll(s);\\n        if(val!=0)  if(num%val==0)  ans++;\\n        return ans;\\n    }\\n};\\n```\\n<B></B>\\n<B></B>\\n<B></B>\\n\\n# Sliding Window\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int i=0,j=0,ans=0;\\n        string str = to_string(num);\\n\\n        string wndw = \"\";\\n        while(j<str.size()){\\n            wndw += str[j];\\n            if((j-i+1)<k){\\n                j++;\\n            }else{\\n                if(stoi(wndw) != 0 && num%(stoi(wndw)) == 0)\\n                    ans++;\\n                wndw = wndw.substr(1);\\n                i++;j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int ans=0;\\n        string str=to_string(num);\\n        int n=str.length();\\n        if(n==k) return 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(n-i>=k)\\n            {\\n                string s=str.substr(i-1,k);\\n                int val=stoll(s);\\n                if(val!=0)  if(num%val==0)  ans++;\\n            }\\n            \\n        }\\n        string s=str.substr(n-k,k);\\n        int val=stoll(s);\\n        if(val!=0)  if(num%val==0)  ans++;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int i=0,j=0,ans=0;\\n        string str = to_string(num);\\n\\n        string wndw = \"\";\\n        while(j<str.size()){\\n            wndw += str[j];\\n            if((j-i+1)<k){\\n                j++;\\n            }else{\\n                if(stoi(wndw) != 0 && num%(stoi(wndw)) == 0)\\n                    ans++;\\n                wndw = wndw.substr(1);\\n                i++;j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857886,
                "title": "beats-99-9-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        i = 0\\n        count = 0\\n        number = str(num)\\n        while i < len(number):\\n            if i + k <= len(number):\\n                s = number[i: i + k]\\n                if int(s) != 0 and num % int(s) == 0:\\n                    count += 1\\n                i += 1\\n            else:\\n                break\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        i = 0\\n        count = 0\\n        number = str(num)\\n        while i < len(number):\\n            if i + k <= len(number):\\n                s = number[i: i + k]\\n                if int(s) != 0 and num % int(s) == 0:\\n                    count += 1\\n                i += 1\\n            else:\\n                break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775956,
                "title": "c-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int i = 0, j = 0, n = str.length();\\n        int ind = 0;\\n        \\n        while(j < n)\\n        {\\n            if(j - i + 1 < k)\\n            {\\n                ++j;\\n            }\\n            else if(j - i + 1 == k)\\n            {\\n                string s = str.substr(i,k);\\n                int n = stoi(s);\\n                if(n != 0 && num % n == 0 )\\n                    ++ind;\\n                \\n                ++i;\\n                ++j;\\n            }\\n                \\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int i = 0, j = 0, n = str.length();\\n        int ind = 0;\\n        \\n        while(j < n)\\n        {\\n            if(j - i + 1 < k)\\n            {\\n                ++j;\\n            }\\n            else if(j - i + 1 == k)\\n            {\\n                string s = str.substr(i,k);\\n                int n = stoi(s);\\n                if(n != 0 && num % n == 0 )\\n                    ++ind;\\n                \\n                ++i;\\n                ++j;\\n            }\\n                \\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767792,
                "title": "super-easy-c-solution",
                "content": "The idea is to first convert num into a string and traverse it according to sliding window and then convert that into a number and divide the given number by the number we form from each window and see if a divisor or not..   PLSSSSS VOTE !!!\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int count=0;\\n        for(int i=0;i<s.length()-k+1;i++){\\n            string key = \"\";\\n            for(int j=i;j<i+k;j++){\\n                key += s[j];\\n            }\\n            int div = stoi(key);\\n            if(div!=0 && num%div == 0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int count=0;\\n        for(int i=0;i<s.length()-k+1;i++){\\n            string key = \"\";\\n            for(int j=i;j<i+k;j++){\\n                key += s[j];\\n            }\\n            int div = stoi(key);\\n            if(div!=0 && num%div == 0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371614,
                "title": "java-easy-understanding-sliding-window",
                "content": "```class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        // convert the num to String\\n        String numStr = String.valueOf(num);\\n        int k_beauty = 0;\\n        // we need to have a window of size k which moves by 1\\n        int w_start = 0;\\n        int w_end = w_start + k - 1;\\n        // we need to slide the window till end of the window reaches str length\\n        while(w_end < numStr.length()) {\\n            // get the substring\\n            int subnum = Integer.parseInt(numStr.substring(w_start,w_end+1));\\n            // check for k beauty\\n            if(subnum != 0 && num%subnum==0) {\\n                k_beauty++;\\n            }\\n            // move the window\\n            w_start += 1;\\n            w_end = w_start + k - 1;\\n        }\\n        return k_beauty;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        // convert the num to String\\n        String numStr = String.valueOf(num);\\n        int k_beauty = 0;\\n        // we need to have a window of size k which moves by 1\\n        int w_start = 0;\\n        int w_end = w_start + k - 1;\\n        // we need to slide the window till end of the window reaches str length\\n        while(w_end < numStr.length()) {\\n            // get the substring\\n            int subnum = Integer.parseInt(numStr.substring(w_start,w_end+1));\\n            // check for k beauty\\n            if(subnum != 0 && num%subnum==0) {\\n                k_beauty++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2090001,
                "title": "c-2-approaches-sliding-window-substring-method",
                "content": "**1. Sliding window**\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s= to_string(num);\\n        int i=0,j=0,cnt=0, tmp=0;\\n        while(j<s.size()){\\n            tmp = (tmp*10) + (s[j]-\\'0\\');\\n            if(j-i+1<k) //window length less than K \\n                j++;\\n            else if(j-i+1==k) { // window length equal k\\n                if(tmp!=0 && num%tmp==0){ // if conditon satisfied, cnt++\\n                    cnt++;\\n                }\\n                tmp-=((s[i]-\\'0\\')*pow(10,k-1)); // substruct the i-th value\\n                i++;\\n                j++;\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**2. Using substring method**\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s= to_string(num);\\n        int cnt=0;\\n        for(int i=0;i<=s.size()-k;i++){\\n            int tmp=stoi(s.substr(i,k));\\n            if(tmp!=0 and num%tmp==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Do upvote, if you like it!**",
                "solutionTags": [
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s= to_string(num);\\n        int i=0,j=0,cnt=0, tmp=0;\\n        while(j<s.size()){\\n            tmp = (tmp*10) + (s[j]-\\'0\\');\\n            if(j-i+1<k) //window length less than K \\n                j++;\\n            else if(j-i+1==k) { // window length equal k\\n                if(tmp!=0 && num%tmp==0){ // if conditon satisfied, cnt++\\n                    cnt++;\\n                }\\n                tmp-=((s[i]-\\'0\\')*pow(10,k-1)); // substruct the i-th value\\n                i++;\\n                j++;\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s= to_string(num);\\n        int cnt=0;\\n        for(int i=0;i<=s.size()-k;i++){\\n            int tmp=stoi(s.substr(i,k));\\n            if(tmp!=0 and num%tmp==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038388,
                "title": "c-sliding-windows-detailed-explanation-tc-o-n-n-numberofdigits-space-o-1",
                "content": "**Goal**\\nFinding number of substring of size k that divide number nums\\n\\n**Identifying Problem**\\nThis problem is of sliding window by following identification:\\n1) You are given window size that is K\\n2) It is substring / subarray question , and sliding windows concept apply in substring or subarray questions\\n3) If You are at windows [i , i+k] having substring 4512...till k digit , then for next window [i+1, i+k+1] , to compute substring you need to drop 4, that can be done by taking modulus of current substring with k-1 And then add digit i+k+1 on right side by multiplying substring *10 + i+k+1 digit\\n\\nTime Complexity : O(N)  Where N is number of digit in number, Because we using each digit just once time.\\nSpace Complexity : O(1) No extra sace used here\\n\\n```\\nclass Solution {\\n public:\\n  int divisorSubstrings(int num, int k) {\\n    // Converting number to string to apply sliding windows\\n    string val = to_string(num);\\n\\n    // Calculate value for window size K ,with start point 0\\n    long long int sum = 0, i;\\n    for (i = 0; i < k; i++) {\\n      sum = sum * 10 + (val[i] - \\'0\\');\\n    }\\n    \\n    \\n    int ans = 0;\\n    \\n    // now slide windows, and remove first digit of windows \\n    while (i < val.size()) {\\n        \\n      // check whether current value (ie sum) divide num , and also value not 0 else division error\\n      if (sum != 0 and num % sum == 0) {\\n        ans += 1;\\n      }\\n    \\n     // drop first digit of value. As our value have K digit ,to drop first digit use Value % (10^k-1)\\n      sum = sum % (int)(pow(10, k - 1));\\n        \\n     // add current digit to last of value, that means value becomes value*10 + current digit\\n      sum = sum * 10 + (val[i] - \\'0\\');\\n      i += 1;\\n    \\n    }\\n      \\n    // check when we reach end of windows;\\n    if (sum != 0 and num % sum == 0) {\\n      ans += 1;\\n    }\\n      \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int divisorSubstrings(int num, int k) {\\n    // Converting number to string to apply sliding windows\\n    string val = to_string(num);\\n\\n    // Calculate value for window size K ,with start point 0\\n    long long int sum = 0, i;\\n    for (i = 0; i < k; i++) {\\n      sum = sum * 10 + (val[i] - \\'0\\');\\n    }\\n    \\n    \\n    int ans = 0;\\n    \\n    // now slide windows, and remove first digit of windows \\n    while (i < val.size()) {\\n        \\n      // check whether current value (ie sum) divide num , and also value not 0 else division error\\n      if (sum != 0 and num % sum == 0) {\\n        ans += 1;\\n      }\\n    \\n     // drop first digit of value. As our value have K digit ,to drop first digit use Value % (10^k-1)\\n      sum = sum % (int)(pow(10, k - 1));\\n        \\n     // add current digit to last of value, that means value becomes value*10 + current digit\\n      sum = sum * 10 + (val[i] - \\'0\\');\\n      i += 1;\\n    \\n    }\\n      \\n    // check when we reach end of windows;\\n    if (sum != 0 and num % sum == 0) {\\n      ans += 1;\\n    }\\n      \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436788,
                "title": "simple-sliding-window-method-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need all the sub string of k length and then just check for the is it divisible of not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two pointer \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    // in the start count is 0 \\n    let count=0;\\n    // we need substring length of k so we have to convert number to string;\\n    let val= num+\"\";\\n    if(val.length<k){\\n        // if val.length is less then k so we return 0\\n        return 0\\n    }\\n    //first substr \\n    let fsub= \"\"\\n    for(let i=0;i<k;i++){\\nfsub+= val[i];\\n    }\\n    if(num%(+fsub)==0){\\n        count++;\\n    }\\n\\nfor(let i=k;i<val.length;i++){\\n    fsub= fsub.slice(1);\\n    fsub+=val[i];\\n    if(num%(+fsub)==0){\\n        count++;\\n    }\\n}\\nreturn count\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    // in the start count is 0 \\n    let count=0;\\n    // we need substring length of k so we have to convert number to string;\\n    let val= num+\"\";\\n    if(val.length<k){\\n        // if val.length is less then k so we return 0\\n        return 0\\n    }\\n    //first substr \\n    let fsub= \"\"\\n    for(let i=0;i<k;i++){\\nfsub+= val[i];\\n    }\\n    if(num%(+fsub)==0){\\n        count++;\\n    }\\n\\nfor(let i=k;i<val.length;i++){\\n    fsub= fsub.slice(1);\\n    fsub+=val[i];\\n    if(num%(+fsub)==0){\\n        count++;\\n    }\\n}\\nreturn count\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3029337,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func divisorSubstrings(_ num: Int, _ k: Int) -> Int {\\n        \\n        let s = String(num)\\n        \\n        var i = 0\\n        var res = 0\\n        \\n        while i <= s.count - k {\\n            let n = Int(String(s.dropFirst(i).prefix(k)))!\\n            if n != 0, num % n == 0 { res += 1 }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func divisorSubstrings(_ num: Int, _ k: Int) -> Int {\\n        \\n        let s = String(num)\\n        \\n        var i = 0\\n        var res = 0\\n        \\n        while i <= s.count - k {\\n            let n = Int(String(s.dropFirst(i).prefix(k)))!\\n            if n != 0, num % n == 0 { res += 1 }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977719,
                "title": "find-the-k-beauty-of-a-number-100-faster-and-0-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nlong N\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int n =num;\\n        long mod=pow(10,k);\\n        int count =0;\\n        while(n>=mod/10)\\n        {\\n            int div= n % mod;\\n            if(div !=0 && num % div==0)\\n            count++;\\n            n=n/10;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int n =num;\\n        long mod=pow(10,k);\\n        int count =0;\\n        while(n>=mod/10)\\n        {\\n            int div= n % mod;\\n            if(div !=0 && num % div==0)\\n            count++;\\n            n=n/10;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902033,
                "title": "0-ms-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int ans=0;\\n        string str=to_string(num);\\n        int n=str.length();\\n        if(n==k) return 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(n-i>=k)\\n            {\\n                string s=str.substr(i-1,k);\\n                int val=stoll(s);\\n                if(val!=0)  if(num%val==0)  ans++;\\n            }\\n            \\n        }\\n        string s=str.substr(n-k,k);\\n        int val=stoll(s);\\n        if(val!=0)  if(num%val==0)  ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int ans=0;\\n        string str=to_string(num);\\n        int n=str.length();\\n        if(n==k) return 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(n-i>=k)\\n            {\\n                string s=str.substr(i-1,k);\\n                int val=stoll(s);\\n                if(val!=0)  if(num%val==0)  ans++;\\n            }\\n            \\n        }\\n        string s=str.substr(n-k,k);\\n        int val=stoll(s);\\n        if(val!=0)  if(num%val==0)  ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830497,
                "title": "very-easy-explantion-in-hindi-c-reverse-sliding-window",
                "content": "*If anyone gets any doubt feel free ask in the comment section*\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int res = 0, cur = 0, pow = 1;\\n        for (int n = num; n > 0; n /= 10) {\\n            // cursor me first new digit add krte hue as we are going in reverse\\n            // to peeche jaate hue last digit remove krna hai jo neeche kiya and \\n            // first digit add krna hai\\n            cur += (n % 10) * pow;\\n            // yha pr hum power ki value dhoondh rhe hai jisse multiply krke add krne pr hum\\n            // apne first digit of window ko bana paaye\\n            if (--k > 0)\\n                pow *= 10;\\n            // jab huk us pow ki value ko dhoondh chuke tab hume window ka last digit hatana hai\\n            // hatane ke liye usko 10 se divide kr diya cur /= 10\\n            else {\\n                // adding it to ans\\n                // 1st condition cur != 0 and num%cur == 0 tabhi usko ! krke 1 banega\\n                res += cur && !(num % cur);\\n                cur /= 10;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int res = 0, cur = 0, pow = 1;\\n        for (int n = num; n > 0; n /= 10) {\\n            // cursor me first new digit add krte hue as we are going in reverse\\n            // to peeche jaate hue last digit remove krna hai jo neeche kiya and \\n            // first digit add krna hai\\n            cur += (n % 10) * pow;\\n            // yha pr hum power ki value dhoondh rhe hai jisse multiply krke add krne pr hum\\n            // apne first digit of window ko bana paaye\\n            if (--k > 0)\\n                pow *= 10;\\n            // jab huk us pow ki value ko dhoondh chuke tab hume window ka last digit hatana hai\\n            // hatane ke liye usko 10 se divide kr diya cur /= 10\\n            else {\\n                // adding it to ans\\n                // 1st condition cur != 0 and num%cur == 0 tabhi usko ! krke 1 banega\\n                res += cur && !(num % cur);\\n                cur /= 10;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830312,
                "title": "c-sliding-window-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int power (int num, int k){\\n        int ans = 1;\\n        for (int i = 1; i <= k; i++){\\n            ans *= num;\\n        }\\n        return ans;\\n    }\\n    int divisorSubstrings(int num, int k) {\\n        int count = 0;\\n        string s = to_string(num);\\n        int i = 0, j = 0;\\n        while (j < s.size()){\\n            if (j - i + 1 < k){\\n                j++;\\n            }\\n            else if (j - i + 1 == k){\\n                string subs = s.substr(i, k);\\n                int nums = 0;\\n                for (int ele = 0; ele < k; ele++){\\n                    int temp = subs[ele] - 48;\\n                    nums += temp*power(10, k-ele-1);\\n                }\\n                if (nums != 0 && num % nums == 0){\\n                    count++;\\n                }\\n                j++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int power (int num, int k){\\n        int ans = 1;\\n        for (int i = 1; i <= k; i++){\\n            ans *= num;\\n        }\\n        return ans;\\n    }\\n    int divisorSubstrings(int num, int k) {\\n        int count = 0;\\n        string s = to_string(num);\\n        int i = 0, j = 0;\\n        while (j < s.size()){\\n            if (j - i + 1 < k){\\n                j++;\\n            }\\n            else if (j - i + 1 == k){\\n                string subs = s.substr(i, k);\\n                int nums = 0;\\n                for (int ele = 0; ele < k; ele++){\\n                    int temp = subs[ele] - 48;\\n                    nums += temp*power(10, k-ele-1);\\n                }\\n                if (nums != 0 && num % nums == 0){\\n                    count++;\\n                }\\n                j++;\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605454,
                "title": "python-well-commented-solution-without-string-conversion",
                "content": "```\\ndef divisorSubstrings(self, num: int, k: int) -> int: \\n        \\n        # if we want substrings of size 2 that means we need to do num % 100 \\n        # if we want substrings of size 3 that means we need to do num % 1000\\n        # So if we want substring of size k then we need to mod by 10^k\\n        p = pow(10, k)\\n        \\n        count = 0\\n        temp = num\\n        \\n        # If we want substring of size 1, that means number should be greater than or equal to 1\\n        # If we want substring of size 2, that means number should be greater than or equal to 10\\n        # If we want substring of size 3, that means number should be greater than or equal to 100\\n        # So that means, if we want substring of size k, then the number should be greater than or equal to 10 ^ k - 1\\n        min = pow(10,k-1)\\n        while temp >= min:\\n            # Get a number of size k of out the given number\\n            n = temp % p\\n            \\n            # Check the condition\\n            if n > 0 and num % n == 0: count += 1\\n                \\n            # And now move to next substring\\n            temp = int(temp/10)\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef divisorSubstrings(self, num: int, k: int) -> int: \\n        \\n        # if we want substrings of size 2 that means we need to do num % 100 \\n        # if we want substrings of size 3 that means we need to do num % 1000\\n        # So if we want substring of size k then we need to mod by 10^k\\n        p = pow(10, k)\\n        \\n        count = 0\\n        temp = num\\n        \\n        # If we want substring of size 1, that means number should be greater than or equal to 1\\n        # If we want substring of size 2, that means number should be greater than or equal to 10\\n        # If we want substring of size 3, that means number should be greater than or equal to 100\\n        # So that means, if we want substring of size k, then the number should be greater than or equal to 10 ^ k - 1\\n        min = pow(10,k-1)\\n        while temp >= min:\\n            # Get a number of size k of out the given number\\n            n = temp % p\\n            \\n            # Check the condition\\n            if n > 0 and num % n == 0: count += 1\\n                \\n            # And now move to next substring\\n            temp = int(temp/10)\\n            \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2578387,
                "title": "java-runtime-1ms-sliding-window",
                "content": "Java solution:\\n```\\npublic int divisorSubstrings(int num, int k) {\\n        int cur=0,ans=0;\\n        String sb=String.valueOf(num);\\n        for(int i=0;i<k;i++){\\n            cur=cur*10+(sb.charAt(i)-\\'0\\');      //to find the value of first num of length k\\n        }\\n        if(num%cur==0){\\n            ans++;\\n        }\\n        int div=(int)(Math.pow(10,k-1));\\n        for(int i=k;i<sb.length();i++){\\n            cur%=div;      //for removing 1st digit\\n            cur*=10;\\n            cur+=(sb.charAt(i)-\\'0\\');      //adding the new digit\\n            if(cur!=0&&num%cur==0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int divisorSubstrings(int num, int k) {\\n        int cur=0,ans=0;\\n        String sb=String.valueOf(num);\\n        for(int i=0;i<k;i++){\\n            cur=cur*10+(sb.charAt(i)-\\'0\\');      //to find the value of first num of length k\\n        }\\n        if(num%cur==0){\\n            ans++;\\n        }\\n        int div=(int)(Math.pow(10,k-1));\\n        for(int i=k;i<sb.length();i++){\\n            cur%=div;      //for removing 1st digit\\n            cur*=10;\\n            cur+=(sb.charAt(i)-\\'0\\');      //adding the new digit\\n            if(cur!=0&&num%cur==0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354427,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int ans = 0;\\n        String n = String.valueOf(num);\\n        for(int i=0;i<n.length();i++){\\n            try{\\n                if(num%Integer.valueOf(n.substring(i,i+k))==0){\\n                    ans++;\\n                }\\n                // System.out.println(Integer.valueOf(n.substring(i,i+k)));                \\n            }catch(Exception e){\\n                \\n            }\\n\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int ans = 0;\\n        String n = String.valueOf(num);\\n        for(int i=0;i<n.length();i++){\\n            try{\\n                if(num%Integer.valueOf(n.substring(i,i+k))==0){\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2041275,
                "title": "java-100-speed-100-space-1-ms",
                "content": "**O(n)**\\n\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String s = String.valueOf(num);\\n        int count = 0;\\n        for (int i = 0; i <= s.length() - k; i++) {\\n            String x = s.substring(i, i + k);\\n            if (Integer.parseInt(x) != 0 && num % Integer.parseInt(x) == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String s = String.valueOf(num);\\n        int count = 0;\\n        for (int i = 0; i <= s.length() - k; i++) {\\n            String x = s.substring(i, i + k);\\n            if (Integer.parseInt(x) != 0 && num % Integer.parseInt(x) == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038922,
                "title": "c-easy-to-understand-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num); //converting the num in the string first using the inbuilt function\\n        int n = str.size();\\n        int ans = 0;\\n        for(int i = 0;i<=(n-k);i++)\\n\\t\\t{\\n            if(stoi(str.substr(i,k)) != 0) // converting string into integer\\n\\t\\t\\t\\tif(num % stoi(str.substr(i,k)) == 0 ) //when remainder is 0 increament the counter\\n\\t\\t\\t\\t\\tans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num); //converting the num in the string first using the inbuilt function\\n        int n = str.size();\\n        int ans = 0;\\n        for(int i = 0;i<=(n-k);i++)\\n\\t\\t{\\n            if(stoi(str.substr(i,k)) != 0) // converting string into integer\\n\\t\\t\\t\\tif(num % stoi(str.substr(i,k)) == 0 ) //when remainder is 0 increament the counter\\n\\t\\t\\t\\t\\tans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038913,
                "title": "go-golang-time-o-n-0-ms-100-space-o-n-2-mb-100",
                "content": "```\\nfunc divisorSubstrings(num int, k int) int {\\n    result, s := 0, strconv.Itoa(num)\\n    \\n    for i := k - 1; i < len(s); i++ {\\n        sub := s[i - k + 1:i + 1]\\n        subNum, _ := strconv.Atoi(sub)\\n        if subNum > 0 && num % subNum == 0 {\\n            result++\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc divisorSubstrings(num int, k int) int {\\n    result, s := 0, strconv.Itoa(num)\\n    \\n    for i := k - 1; i < len(s); i++ {\\n        sub := s[i - k + 1:i + 1]\\n        subNum, _ := strconv.Atoi(sub)\\n        if subNum > 0 && num % subNum == 0 {\\n            result++\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038123,
                "title": "0ms-100-faster-solution-with-substring",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int cnt = 0;\\n        for(int i = 0 ; i <= s.size() - k ; i++){\\n            string div = s.substr(i,k);\\n            if(stoi(div) != 0 and num % stoi(div) == 0) cnt++; \\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/022ea897-d3af-4956-8c13-f40f14b8e210_1652544368.5496807.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int cnt = 0;\\n        for(int i = 0 ; i <= s.size() - k ; i++){\\n            string div = s.substr(i,k);\\n            if(stoi(div) != 0 and num % stoi(div) == 0) cnt++; \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038096,
                "title": "easy-approach-deal-with-strings",
                "content": "```cpp\\nclass Solution {  \\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size(), ans = 0;\\n        for(int i = 0; i <= n-k; i++) {\\n            int cur = stoi(s.substr(i, k));\\n            if(cur && num % cur == 0)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {  \\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size(), ans = 0;\\n        for(int i = 0; i <= n-k; i++) {\\n            int cur = stoi(s.substr(i, k));\\n            if(cur && num % cur == 0)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972512,
                "title": "aditya-verma-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0,j=0;\\n        int count=0;\\n        string res=\"\";\\n        int n=s.size();\\n        while(j<n){\\n            res+=s[j];\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                int nums=stoi(res);\\n                if(nums!=0 && num%nums==0){\\n                    count++;\\n                }\\n                res.erase(res.begin());\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0,j=0;\\n        int count=0;\\n        string res=\"\";\\n        int n=s.size();\\n        while(j<n){\\n            res+=s[j];\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                int nums=stoi(res);\\n                if(nums!=0 && num%nums==0){\\n                    count++;\\n                }\\n                res.erase(res.begin());\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933207,
                "title": "0-ms-run-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/b3720927-0a5a-467f-a177-9dd0830d1ed6_1692472668.8823497.png)\\n\\nTo solve this problem, I was essentially checking every substring of length k in the given number to determine if it\\'s a divisor of the original number. The idea is to iteratively extract each substring, convert it to an integer, and then check if it divides the original number without any remainder.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the original number num to a string using sprintf in C to work with individual digits.\\n2. Iterate through the string representation of the number, considering each substring of length k.\\n3. For each substring, use strncpy to extract the substring and then add a null-terminator to create a valid C string.\\n4. Convert the extracted substring to an integer using atoi.\\nCheck if the extracted integer is not zero (to avoid division by zero) and is a divisor of the original number using the modulo operator.\\n5. If both conditions are met, increment the k_beauty count to track the number of k-beautiful substrings found.\\n\\nBy applying this approach, you\\'re efficiently examining all possible substrings of length k within the given number, verifying whether they are divisors of the original number. \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n![photo_2023-08-19_22-24-23.jpg](https://assets.leetcode.com/users/images/a63c034c-6637-40c5-8c23-8521e839a65e_1692473096.0499556.jpeg)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint divisorSubstrings(int num, int k) {\\n    char string_num[20];  // Assuming a maximum of 20 digits for the number\\n    sprintf(string_num, \"%d\", num);\\n    int k_beauty = 0;\\n\\n    for (int i = 0; i <= strlen(string_num) - k; i++) {\\n        char sub_num_str[20];\\n        strncpy(sub_num_str, string_num + i, k);\\n        sub_num_str[k] = \\'\\\\0\\';\\n        int sub_num = atoi(sub_num_str);\\n\\n        if (sub_num && num % sub_num == 0) {\\n            k_beauty++;\\n        }\\n    }\\n\\n    return k_beauty;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint divisorSubstrings(int num, int k) {\\n    char string_num[20];  // Assuming a maximum of 20 digits for the number\\n    sprintf(string_num, \"%d\", num);\\n    int k_beauty = 0;\\n\\n    for (int i = 0; i <= strlen(string_num) - k; i++) {\\n        char sub_num_str[20];\\n        strncpy(sub_num_str, string_num + i, k);\\n        sub_num_str[k] = \\'\\\\0\\';\\n        int sub_num = atoi(sub_num_str);\\n\\n        if (sub_num && num % sub_num == 0) {\\n            k_beauty++;\\n        }\\n    }\\n\\n    return k_beauty;\\n}\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3930803,
                "title": "beats-90-cpp-sol",
                "content": "# Simple Sliding Window Problem !\\n**Just go Through the code you will definately understand the logic**\\n\\n\\n# **Pls upvote me if you found this Helpful \\uD83E\\uDD79**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int front = 0;\\n        int back = 0;\\n        string str = to_string(num);\\n        int count = 0;\\n\\n        while(front < str.size()){\\n            if(front-back+1 == k){\\n                string temp = str.substr(back, k);\\n                int no = stoi(temp);\\n                if(no!=0 && num%no==0){\\n                    count++;\\n                }\\n                front++;\\n                back++;\\n                continue;\\n            }\\n            front++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int front = 0;\\n        int back = 0;\\n        string str = to_string(num);\\n        int count = 0;\\n\\n        while(front < str.size()){\\n            if(front-back+1 == k){\\n                string temp = str.substr(back, k);\\n                int no = stoi(temp);\\n                if(no!=0 && num%no==0){\\n                    count++;\\n                }\\n                front++;\\n                back++;\\n                continue;\\n            }\\n            front++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905456,
                "title": "java-fast-solution",
                "content": "\\n# Code\\n```\\nclass Solution{\\n    public int divisorSubstrings(int num, int k){\\n        StringBuilder s = new StringBuilder(\"\");\\n        s.append(num);\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i=0; i<=n-k; i++){\\n            String t = s.substring(i, i+k).toString();\\n            int x = Integer.parseInt(t);\\n            if(x!=0 && num%x==0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int divisorSubstrings(int num, int k){\\n        StringBuilder s = new StringBuilder(\"\");\\n        s.append(num);\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i=0; i<=n-k; i++){\\n            String t = s.substring(i, i+k).toString();\\n            int x = Integer.parseInt(t);\\n            if(x!=0 && num%x==0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893136,
                "title": "simple-easy-cpp-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n\\n        int ans = 0, i = 0, j = 0;\\n        int n = str.length();\\n        string curr = \"\";\\n        while(j<n){\\n            curr.push_back(str[j]);\\n\\n            if(j-i+1 < k){\\n                j++;\\n            }\\n            else{\\n                int div = stoi(curr);\\n                if(div != 0 ){\\n                    if( (num % div) == 0 ){\\n                        ans++;\\n                    }\\n                }\\n                j++;\\n                // curr.erase(curr.begin());// or\\n                curr = curr.substr(1, curr.length()-1);\\n                cout<<curr<<\" \";\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n\\n        int ans = 0, i = 0, j = 0;\\n        int n = str.length();\\n        string curr = \"\";\\n        while(j<n){\\n            curr.push_back(str[j]);\\n\\n            if(j-i+1 < k){\\n                j++;\\n            }\\n            else{\\n                int div = stoi(curr);\\n                if(div != 0 ){\\n                    if( (num % div) == 0 ){\\n                        ans++;\\n                    }\\n                }\\n                j++;\\n                // curr.erase(curr.begin());// or\\n                curr = curr.substr(1, curr.length()-1);\\n                cout<<curr<<\" \";\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3838016,
                "title": "0ms-beats-100-using-sliding-window",
                "content": "# Intuition\\nAs the size of k is fixed we can easily maintain a sliding wndow of length k.\\n\\n# Approach\\nStart from position 0 with a length of k. convert them to number,then divide the given number with this converted number, just check one number that if you find the number 0, skip it.\\n\\n# Complexity\\n- Time complexity:\\nTime Complesity : O(num.length(as a string)+k)\\n\\n- Space complexity:\\nO(num.length(as a string))\\n![Screenshot from 2023-07-30 17-01-19.png](https://assets.leetcode.com/users/images/c8fdfd92-a70e-418a-9bff-3e3dbb29a5b3_1690715028.179495.png)\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        char [] s = String.valueOf(num).toCharArray();\\n        int count = 0;\\n        for(int i = 0 ; i<=s.length - k; i++){\\n            int divisor = getNumber(k,s,i);\\n            if(divisor != 0 && num%divisor== 0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private int getNumber(int k, char [] s, int start){\\n        int num = 0;\\n        while(k >0){\\n            num = num*10;\\n            num = (s[start]-\\'0\\')+num;\\n            start++;\\n            k--;\\n        }\\n        return num;\\n    }\\n}\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        char [] s = String.valueOf(num).toCharArray();\\n        int count = 0;\\n        for(int i = 0 ; i<=s.length - k; i++){\\n            int divisor = getNumber(k,s,i);\\n            if(divisor != 0 && num%divisor== 0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private int getNumber(int k, char [] s, int start){\\n        int num = 0;\\n        while(k >0){\\n            num = num*10;\\n            num = (s[start]-\\'0\\')+num;\\n            start++;\\n            k--;\\n        }\\n        return num;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827104,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing substring approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String S = Integer.toString(num);\\n        String str=\"\";\\n        int count=0;\\n        int n=0;\\n        for(int i=0;i<=S.length()-k;i++){\\n            str=S.substring(i,i+k);\\n            n = Integer.parseInt(str);\\n            if(n!=0 && num%n==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String S = Integer.toString(num);\\n        String str=\"\";\\n        int count=0;\\n        int n=0;\\n        for(int i=0;i<=S.length()-k;i++){\\n            str=S.substring(i,i+k);\\n            n = Integer.parseInt(str);\\n            if(n!=0 && num%n==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824429,
                "title": "beats-100-of-c-solution-simple-approach",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k)\\n    {\\n        vector<int> ans;\\n        string number=to_string(num);\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        string str=\"\";\\n        while(j<number.size())\\n        {\\n            str=str+number[j];\\n            if(j-i+1<k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                int a=stoi(str);\\n                if(a!=0 && num%a==0)count++;\\n                str.erase(0,1);\\n                i++;\\n                j++;\\n\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```****Bold****",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k)\\n    {\\n        vector<int> ans;\\n        string number=to_string(num);\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        string str=\"\";\\n        while(j<number.size())\\n        {\\n            str=str+number[j];\\n            if(j-i+1<k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                int a=stoi(str);\\n                if(a!=0 && num%a==0)count++;\\n                str.erase(0,1);\\n                i++;\\n                j++;\\n\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800539,
                "title": "very-very-simple-approach-to-resolve-the-problem-in-javascript-in-o-b-beats-90-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is constant size of window just slide the window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply slide the window of size k with just 1 pointer p  tile length-k\\nIf its divisible incement the counter\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n![image.png](https://assets.leetcode.com/users/images/6a7d128c-1b66-459f-8948-a7cda21e426d_1690023618.6268067.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n 4-08 - 4:23 perfect in 1 shot\\n */\\nvar divisorSubstrings = function(num, k) {\\n\\n    num = num.toString();\\n    let subStr, ctr=0; \\n    for(let p=0; p<= num.length-k ; p++){\\n        subStr = num.slice(p, p+k);\\n        if(num%subStr === 0 ){\\n            ctr++;\\n        }\\n    }\\n\\n    return ctr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n 4-08 - 4:23 perfect in 1 shot\\n */\\nvar divisorSubstrings = function(num, k) {\\n\\n    num = num.toString();\\n    let subStr, ctr=0; \\n    for(let p=0; p<= num.length-k ; p++){\\n        subStr = num.slice(p, p+k);\\n        if(num%subStr === 0 ){\\n            ctr++;\\n        }\\n    }\\n\\n    return ctr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791698,
                "title": "easy-java-solution-clean-code-sliding-window",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n        String s = num + \"\";\\n\\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        String temp = \"\";\\n\\n        while(end < s.length()) {\\n\\n            temp += s.charAt(end);\\n            if(end - start + 1 == k) {\\n                int n = Integer.parseInt(temp);\\n                if(n != 0 && num % n == 0) {\\n                    ans++;\\n                }\\n                temp = temp.substring(1);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/97caa70e-de68-4d77-9c56-04080a6dc99d_1689845289.8739185.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n        String s = num + \"\";\\n\\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        String temp = \"\";\\n\\n        while(end < s.length()) {\\n\\n            temp += s.charAt(end);\\n            if(end - start + 1 == k) {\\n                int n = Integer.parseInt(temp);\\n                if(n != 0 && num % n == 0) {\\n                    ans++;\\n                }\\n                temp = temp.substring(1);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724459,
                "title": "easy-sliding-window-js-solution",
                "content": "```\\nvar divisorSubstrings = function(num, k) {\\n\\n    let numArray =  num.toString().split(\"\")\\n    let k_interval = \"\";\\n    let ris = 0;\\n\\n    for (i = 0; i < numArray.length; i++) {\\n      k_interval = k_interval + numArray[i]\\n      if (i >= k - 1) {\\n        if (num % parseInt(k_interval) === 0){ris++}\\n        k_interval = k_interval.slice(1);\\n      }\\n\\n    }\\n    \\n    return ris;\\n  };\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar divisorSubstrings = function(num, k) {\\n\\n    let numArray =  num.toString().split(\"\")\\n    let k_interval = \"\";\\n    let ris = 0;\\n\\n    for (i = 0; i < numArray.length; i++) {\\n      k_interval = k_interval + numArray[i]\\n      if (i >= k - 1) {\\n        if (num % parseInt(k_interval) === 0){ris++}\\n        k_interval = k_interval.slice(1);\\n      }\\n\\n    }\\n    \\n    return ris;\\n  };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3639737,
                "title": "easy-to-understand-c-solution-sliding-window-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size();\\n        int winSize = 0;\\n        int ans = 0;\\n        int i = 0;\\n        for(int j=0; j<n; j++){\\n            if(winSize < k){\\n                winSize++;\\n                continue;\\n            }\\n            string temp = s.substr(i,k);\\n            int x = stoi(temp);\\n            if(x!=0 && num%x == 0) ans++;\\n            i++;\\n        }\\n        int x = stoi(s.substr(i,k));\\n        if(x!=0 && num%x == 0) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size();\\n        int winSize = 0;\\n        int ans = 0;\\n        int i = 0;\\n        for(int j=0; j<n; j++){\\n            if(winSize < k){\\n                winSize++;\\n                continue;\\n            }\\n            string temp = s.substr(i,k);\\n            int x = stoi(temp);\\n            if(x!=0 && num%x == 0) ans++;\\n            i++;\\n        }\\n        int x = stoi(s.substr(i,k));\\n        if(x!=0 && num%x == 0) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315589,
                "title": "c-beats-100-of-solution-using-substr",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the substring size is constant substr function is more suitable to fetch all possible substrings.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconvert num to string.Then use substr function to fetch the substrings and convert them to numbers and store them in vectors. Then test each number in vector is divisible by the original number or not.\\n\\n# Complexity\\n- Time complexity:    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:   O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0;\\n        int count=0;\\n        vector<int> v;\\n        for(i=0;i<=s.size()-k;i++)\\n        {\\n            v.push_back(stoi(s.substr(i,k)));\\n        }\\n        for(i=0;i<v.size();i++)\\n        {\\n            if(v[i]!=0 && num%v[i]==0 )\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0;\\n        int count=0;\\n        vector<int> v;\\n        for(i=0;i<=s.size()-k;i++)\\n        {\\n            v.push_back(stoi(s.substr(i,k)));\\n        }\\n        for(i=0;i<v.size();i++)\\n        {\\n            if(v[i]!=0 && num%v[i]==0 )\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302537,
                "title": "find-the-k-beauty-of-a-number-java-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code counts the number of k-beauty numbers in an integer, where a k-beauty number is defined as a number that is divisible by every k-digit substring of the number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code converts the given integer into a string and then iterates over each k-digit substring of the string. For each substring, the code checks if it is a divisor of the given number and increments the counter if it is. The code also checks if the substring is not equal to zero to avoid division by zero errors.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n*k), where n is the number of digits in the given number and k is the length of the k-digit substring. This is because the code iterates over each k-digit substring of the string and performs a constant amount of operations on each substring.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n*k), where n is the number of digits in the given number and k is the length of the k-digit substring. This is because the code iterates over each k-digit substring of the string and performs a constant amount of operations on each substring.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int counter = 0 ;\\n        String numStr = Integer.toString(num);\\n        for(int i = 0 ; i <= numStr.length()- k ; i++)\\n        {\\n            String substring = numStr.substring(i , i + k);\\n            int divisor = Integer.parseInt(substring);\\n            if(divisor != 0  && num % divisor == 0)\\n            {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int counter = 0 ;\\n        String numStr = Integer.toString(num);\\n        for(int i = 0 ; i <= numStr.length()- k ; i++)\\n        {\\n            String substring = numStr.substring(i , i + k);\\n            int divisor = Integer.parseInt(substring);\\n            if(divisor != 0  && num % divisor == 0)\\n            {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296679,
                "title": "k-beauty-of-a-number-javascript-convert-number-to-string",
                "content": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {    \\n    num = num.toString()    \\n    count = 0\\n\\n    for (let i = 0; i <= num.length - k; i++) {        \\n        +num % +num.substring(i, i+k) == 0 && count ++\\n    }\\n    \\n    return count\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {    \\n    num = num.toString()    \\n    count = 0\\n\\n    for (let i = 0; i <= num.length - k; i++) {        \\n        +num % +num.substring(i, i+k) == 0 && count ++\\n    }\\n    \\n    return count\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260633,
                "title": "rust-without-converting-to-string",
                "content": "Could be better, but the point is to not convert `num` to a string.\\n```\\nimpl Solution {\\n    pub fn divisor_substrings(num: i32, k: i32) -> i32 {\\n        let mut n = num;\\n        let window = 10_i32.pow(k as u32);\\n        let mut ans = 0;\\n\\n        while n >= (window / 10) {\\n            let t = n % window;\\n            if t != 0 && num % t == 0 {\\n                ans += 1;\\n            }\\n            n /= 10\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn divisor_substrings(num: i32, k: i32) -> i32 {\\n        let mut n = num;\\n        let window = 10_i32.pow(k as u32);\\n        let mut ans = 0;\\n\\n        while n >= (window / 10) {\\n            let t = n % window;\\n            if t != 0 && num % t == 0 {\\n                ans += 1;\\n            }\\n            n /= 10\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3191518,
                "title": "100-faster-code-c-and-python-sliding-window-string-handling",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**C++ Solution:-**\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int divisor = num;\\n        string str_div = to_string(num);\\n        int i = 0;\\n        int beauty = 0;\\n        while (i < str_div.size() - k + 1) {\\n            int dividend = stoi(str_div.substr(i, k));\\n            if(dividend > 0) {\\n                if( divisor % dividend == 0) beauty++;\\n            }\\n            i++;\\n        }\\n        return beauty;\\n    }\\n};\\n```\\n**Python Solution:-**\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        beauty = 0\\n        divisor = num\\n        i = 0\\n        j = k\\n        str_div = str(num)\\n        n = len(str_div)\\n        while j <= n:\\n            dividend = int(str_div[i:j])\\n            print(dividend)\\n            if dividend > 0:\\n                if divisor % dividend == 0:\\n                    beauty += 1\\n            i += 1\\n            j += 1\\n        return beauty\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int divisor = num;\\n        string str_div = to_string(num);\\n        int i = 0;\\n        int beauty = 0;\\n        while (i < str_div.size() - k + 1) {\\n            int dividend = stoi(str_div.substr(i, k));\\n            if(dividend > 0) {\\n                if( divisor % dividend == 0) beauty++;\\n            }\\n            i++;\\n        }\\n        return beauty;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        beauty = 0\\n        divisor = num\\n        i = 0\\n        j = k\\n        str_div = str(num)\\n        n = len(str_div)\\n        while j <= n:\\n            dividend = int(str_div[i:j])\\n            print(dividend)\\n            if dividend > 0:\\n                if divisor % dividend == 0:\\n                    beauty += 1\\n            i += 1\\n            j += 1\\n        return beauty\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140565,
                "title": "python-math-calculations-remainders-without-converting-to-string",
                "content": "First we need to get mult number, which is pow(10, k) \\n```\\nmult = 1\\nfor i in range(k):\\n\\tmult *= 10\\n```\\n\\nWe will go from right to left ( right -> left) to get a last K digits\\n```n = num % mult``` - This will give K last digits\\nNext, we need to remove last digit from number ```num //= 10 ```\\n\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        \\n        mult = 1\\n        for i in range(k):\\n            mult *= 10\\n        \\n        counter = 0\\n        or_num = num\\n        while num >= mult / 10:\\n            n = num % mult\\n            \\n            if n and or_num % n == 0:\\n                counter += 1\\n            \\n            num //= 10\\n            \\n        return counter\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nmult = 1\\nfor i in range(k):\\n\\tmult *= 10\\n```\n```n = num % mult```\n```num //= 10 ```\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        \\n        mult = 1\\n        for i in range(k):\\n            mult *= 10\\n        \\n        counter = 0\\n        or_num = num\\n        while num >= mult / 10:\\n            n = num % mult\\n            \\n            if n and or_num % n == 0:\\n                counter += 1\\n            \\n            num //= 10\\n            \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059846,
                "title": "two-methods-javascript-solution",
                "content": "\\n# Approach 1\\n```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    let count = 0;\\n    // create a variable to store the substring\\n    let substring = num % (10 ** k);\\n    let current = num;\\n    // iterate through the number\\n    for (let i = 0; i <= num.toString().length - k; i++) {\\n        // check if the substring is a divisor\\n        if (num % substring === 0) {\\n            count++;\\n        }\\n        // remove the last k digits and add the next\\n        current = Math.floor(current / 10);\\n        substring = (current % (10 ** k))\\n    }\\n    return count;\\n};\\n\\n```\\n# Approach 2\\n```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    const numStr = num.toString();\\n    const N = numStr.length\\n    let str = \\'\\', count = 0\\n\\n    for(let i=0; i<N; i++){\\n        str = str + numStr[i]\\n\\n        if(i >= k-1){\\n            if(num % parseInt(str) === 0) count++;\\n            str = str.slice(1)\\n        }\\n        \\n    }\\n    return count\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    let count = 0;\\n    // create a variable to store the substring\\n    let substring = num % (10 ** k);\\n    let current = num;\\n    // iterate through the number\\n    for (let i = 0; i <= num.toString().length - k; i++) {\\n        // check if the substring is a divisor\\n        if (num % substring === 0) {\\n            count++;\\n        }\\n        // remove the last k digits and add the next\\n        current = Math.floor(current / 10);\\n        substring = (current % (10 ** k))\\n    }\\n    return count;\\n};\\n\\n```\n```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    const numStr = num.toString();\\n    const N = numStr.length\\n    let str = \\'\\', count = 0\\n\\n    for(let i=0; i<N; i++){\\n        str = str + numStr[i]\\n\\n        if(i >= k-1){\\n            if(num % parseInt(str) === 0) count++;\\n            str = str.slice(1)\\n        }\\n        \\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2865686,
                "title": "python-only-slicing-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOnly slicing and some concept of sliding window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        x=str(num)\\n        c=0\\n        for i in range(len(x)-k+1):\\n            y=int(x[i:i+k])\\n            print(y)\\n            if y==0:\\n                continue\\n            if num%y==0:\\n                c+=1\\n        return c        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        x=str(num)\\n        c=0\\n        for i in range(len(x)-k+1):\\n            y=int(x[i:i+k])\\n            print(y)\\n            if y==0:\\n                continue\\n            if num%y==0:\\n                c+=1\\n        return c        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819560,
                "title": "idiomatic-rust-one-liner-0ms-runtime-100-2-2mb-memory-44",
                "content": "# Intuition\\nSlide window of size k throughout the digits of the number, incrementing our total if the number within the window is not 0 and is a divisor of num.\\n\\n# Approach\\nConvert num to string byte iterator, turn that into a window iterator of size k, mapping each `&[u8; k]` slice of digits to `i32` , filtering by if the number is not 0 and a divisor of num and finally counting the remaining numbers in the iterator.\\n\\nBonus speed gain for using an unsafe block to use `std::str::from_utf8_unchecked` to avoid some overhead.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where n is the number of digits\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn divisor_substrings(num: i32, k: i32) -> i32 {\\n        unsafe {\\n            num.to_string()\\n                .as_bytes()\\n                .windows(k as usize)\\n                .map(|x| std::str::from_utf8_unchecked(x).parse::<i32>().unwrap())\\n                .filter(|&x| x != 0 && num % x == 0)\\n                .count() as i32\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn divisor_substrings(num: i32, k: i32) -> i32 {\\n        unsafe {\\n            num.to_string()\\n                .as_bytes()\\n                .windows(k as usize)\\n                .map(|x| std::str::from_utf8_unchecked(x).parse::<i32>().unwrap())\\n                .filter(|&x| x != 0 && num % x == 0)\\n                .count() as i32\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798642,
                "title": "java-linear-solution-2ms",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n        String str = num+\"\";\\n        int count=0;\\n        for(int i=0;i<=str.length()-k;i++){\\n            String temp = str.substring(i,i+k);\\n            int a = Integer.parseInt(temp);\\n            if(a!=0 && num%a==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/7a13617a-4e7d-40e4-b819-c53d868dd5cb_1668055646.5569034.png)\\n**Any Doubt ask down below :-D**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n        String str = num+\"\";\\n        int count=0;\\n        for(int i=0;i<=str.length()-k;i++){\\n            String temp = str.substring(i,i+k);\\n            int a = Integer.parseInt(temp);\\n            if(a!=0 && num%a==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723711,
                "title": "easy-javascript-solution",
                "content": "Quick and easy solution. \\n```\\nvar divisorSubstrings = function(num, k) {\\n    const numString = num.toString()    \\n    count = 0\\n\\n    for ( i = 0; i < numString.length; i++){\\n        let temp = numString.slice(i, i+k)\\n        if (temp.length < k) break\\n        if (num % Number(temp) === 0){\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar divisorSubstrings = function(num, k) {\\n    const numString = num.toString()    \\n    count = 0\\n\\n    for ( i = 0; i < numString.length; i++){\\n        let temp = numString.slice(i, i+k)\\n        if (temp.length < k) break\\n        if (num % Number(temp) === 0){\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631701,
                "title": "python-easy-solution",
                "content": "n=str(num)\\n        cnt=0\\n        ws=0\\n        for we in range(len(n)):\\n            s=\\n            if s!=0 and num%s==0:\\n                cnt+=1\\n        return cnt",
                "solutionTags": [],
                "code": "n=str(num)\\n        cnt=0\\n        ws=0\\n        for we in range(len(n)):\\n            s=\\n            if s!=0 and num%s==0:\\n                cnt+=1\\n        return cnt",
                "codeTag": "Unknown"
            },
            {
                "id": 2626435,
                "title": "python-sliding-window-faster-than-97",
                "content": "def divisorSubstrings(self, num: int, k: int) -> int:\\n        my_num=num\\n        ans=0\\n    \\n        lst=list(map(int,str(my_num)))\\n        \\n        ws=0\\n        we=0\\n        number=0\\n        while we<len(lst):\\n            number=number*10+lst[we]\\n            \\n            if we-ws+1==k:\\n                if number!=0:\\n                    if num%number==0:\\n                        ans+=1\\n                number=number%(10**(k-1))\\n                ws+=1\\n            we+=1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "def divisorSubstrings(self, num: int, k: int) -> int:\\n        my_num=num\\n        ans=0\\n    \\n        lst=list(map(int,str(my_num)))\\n        \\n        ws=0\\n        we=0\\n        number=0\\n        while we<len(lst):\\n            number=number*10+lst[we]\\n            \\n            if we-ws+1==k:\\n                if number!=0:\\n                    if num%number==0:\\n                        ans+=1\\n                number=number%(10**(k-1))\\n                ws+=1\\n            we+=1\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2619884,
                "title": "substr-works-like-charm",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        \\n        string s = to_string(num);\\n        int n = s.length();\\n        int res = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string temp = s.substr(i,k);\\n            if(temp.length() == k)\\n            {\\n                int val = stoi(temp);\\n                if(val!=0 && num%val == 0)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        \\n        string s = to_string(num);\\n        int n = s.length();\\n        int res = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string temp = s.substr(i,k);\\n            if(temp.length() == k)\\n            {\\n                int val = stoi(temp);\\n                if(val!=0 && num%val == 0)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587750,
                "title": "javascript-solution-sliding-window-o-n",
                "content": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    let windowStart = 0, result = 0, windowStr = \\'\\'\\n    \\n    const n = num.toString()\\n    for (let windowEnd = 0; windowEnd < n.length; windowEnd++) {\\n        windowStr += n[windowEnd]\\n        \\n        if (windowEnd >= k - 1) {\\n            if (num % Number(windowStr) === 0) result++\\n            windowStr = windowStr.substr(1, windowStr.length)\\n            windowStart++\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    let windowStart = 0, result = 0, windowStr = \\'\\'\\n    \\n    const n = num.toString()\\n    for (let windowEnd = 0; windowEnd < n.length; windowEnd++) {\\n        windowStr += n[windowEnd]\\n        \\n        if (windowEnd >= k - 1) {\\n            if (num % Number(windowStr) === 0) result++\\n            windowStr = windowStr.substr(1, windowStr.length)\\n            windowStart++\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568679,
                "title": "simple-python-solution-sliding-window-detailed-explanation",
                "content": "```\\nclass Solution(object):\\n    def divisorSubstrings(self, num, k):\\n        \"\"\"\\n        :type num: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        #This is a classic Sliding Window question\\n        \\n        #What is sliding window?\\n            #It is essentially where we have a window of values, and if the values inside that window meets certian conditions, we perform an action. \\n            \\n            #we also need to change the starting and ending points of the window in order for us to process new values\\n            \\n            #the window can be of fixed or dynamic size(the size can be variable) but for this problem, assume the window is of fixed size\\n        \\n        #Approach:\\n            #1) initialize the start and end points of the window to 0 and k respectively(remember k signifies the size of the window)\\n            \\n            #2) initialize a count variable and also store the string conversion of num into a variable called st\\n            \\n            #3) while the end pointer is less than or equal to the end of the string(this enables us to iterate over the entire string)\\n            \\n                #4) check if the values in the window is a factor of num\\n                    #How would we do that? Good question, we first need to check if the conversion of the values in the window isn\\'t equal to 0.\\n                    \\n                    #This is important because the final check is to see if num % the values in the window == 0, that is, if the values in the window are truly a divisor to nums. If the value was 0, we would have got a ZeroDivisionError because nums/0 isn\\'t possible\\n                    \\n                #5) If the check was true, then increment count\\n                \\n                #6) remember to update the window, so increment both start and end pointers\\n                \\n                #7) Finally, return the count :)\\n                \\n        #the code\\n        start,end = 0, k\\n        \\n        count = 0\\n        \\n        st = str(num)\\n        \\n        while end <= len(st):\\n            \\n            if int(st[start:end]) != 0 and num % int(st[start:end]) == 0:\\n                count+=1\\n                \\n            start+=1\\n            \\n            end+=1\\n            \\n        return count\\n        \\n        \\n        #Hopefully this solution is very easy to understand. Let me know if I can improve on any explanations and such.\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def divisorSubstrings(self, num, k):\\n        \"\"\"\\n        :type num: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        #This is a classic Sliding Window question\\n        \\n        #What is sliding window?\\n            #It is essentially where we have a window of values, and if the values inside that window meets certian conditions, we perform an action. \\n            \\n            #we also need to change the starting and ending points of the window in order for us to process new values\\n            \\n            #the window can be of fixed or dynamic size(the size can be variable) but for this problem, assume the window is of fixed size\\n        \\n        #Approach:\\n            #1) initialize the start and end points of the window to 0 and k respectively(remember k signifies the size of the window)\\n            \\n            #2) initialize a count variable and also store the string conversion of num into a variable called st\\n            \\n            #3) while the end pointer is less than or equal to the end of the string(this enables us to iterate over the entire string)\\n            \\n                #4) check if the values in the window is a factor of num\\n                    #How would we do that? Good question, we first need to check if the conversion of the values in the window isn\\'t equal to 0.\\n                    \\n                    #This is important because the final check is to see if num % the values in the window == 0, that is, if the values in the window are truly a divisor to nums. If the value was 0, we would have got a ZeroDivisionError because nums/0 isn\\'t possible\\n                    \\n                #5) If the check was true, then increment count\\n                \\n                #6) remember to update the window, so increment both start and end pointers\\n                \\n                #7) Finally, return the count :)\\n                \\n        #the code\\n        start,end = 0, k\\n        \\n        count = 0\\n        \\n        st = str(num)\\n        \\n        while end <= len(st):\\n            \\n            if int(st[start:end]) != 0 and num % int(st[start:end]) == 0:\\n                count+=1\\n                \\n            start+=1\\n            \\n            end+=1\\n            \\n        return count\\n        \\n        \\n        #Hopefully this solution is very easy to understand. Let me know if I can improve on any explanations and such.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560753,
                "title": "java-easy-to-understand-solution-string-methods",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int n=num,i=k,c=0;\\n        String s=Integer.toString(num);\\n        while(i<=s.length())\\n        {\\n            String sub=s.substring(i-k,i);\\n            int subn=Integer.parseInt(sub);\\n            if(subn!=0 && n%subn==0)c+=1;\\n            i+=1;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int n=num,i=k,c=0;\\n        String s=Integer.toString(num);\\n        while(i<=s.length())\\n        {\\n            String sub=s.substring(i-k,i);\\n            int subn=Integer.parseInt(sub);\\n            if(subn!=0 && n%subn==0)c+=1;\\n            i+=1;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535123,
                "title": "c-sliding-window-simple-solution-100-faster",
                "content": "Using Function:- 100%faster solution\\n\\n```\\nclass Solution {\\npublic:\\n    int kBeauty(int num,int k)\\n    {\\n        string s=to_string(num);         //converting from integer to string\\n        int i=0,j=0,count=0;               // i and j are start and end of our sliding window ,  count variable is to count the number of substrings of num which satisfies the given conditions.\\n        string ch=\"\";\\n        while(j<s.size())\\n        {\\n            ch+=s[j];\\n            if((j-i+1)==k)                 //if we found a subseq of length k then we are going to check whether it satisfies our given condition or not\\n            {\\n                int subseq = stoi(ch);     //converting the current subsequence into integer\\n                if( subseq!=0 && (num%subseq)==0) count++;      //if the current subsequence is not zero and if it multiple of given number \\'num\\' then we can increment our count by 1\\n                ch[i]=\\'0\\';                 //here we are reseting the first integer to zero , since our sliding window has to be moved.\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n    int divisorSubstrings(int num, int k) {\\n        return kBeauty(num,k);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/2352c555-c857-41dd-b08e-ea2e63ab326c_1662388069.8345811.png)\\n\\n99% space optimized solution:-\\n\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0,j=0,count=0;\\n        string ch=\"\";\\n        while(j<s.size())\\n        {\\n            ch+=s[j];\\n            if((j-i+1)==k)                  //if we found a subseq of length k then we are going to check whether it satisfies our given condition or not\\n            {\\n                int subseq = stoi(ch);      //converting the current subsequence into integer\\n                if( subseq!=0 && (num%subseq)==0) count++;      //if the current subsequence is not zero and if it multiple of given number \\'num\\' then we can increment our count by 1\\n                ch[i]=\\'0\\';                 //here we are reseting the first integer to zero , since our sliding window has to be moved.\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;                     //returning the final count\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/d29762ff-e71b-4472-8c86-8c8b9ce015cf_1662388472.395634.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kBeauty(int num,int k)\\n    {\\n        string s=to_string(num);         //converting from integer to string\\n        int i=0,j=0,count=0;               // i and j are start and end of our sliding window ,  count variable is to count the number of substrings of num which satisfies the given conditions.\\n        string ch=\"\";\\n        while(j<s.size())\\n        {\\n            ch+=s[j];\\n            if((j-i+1)==k)                 //if we found a subseq of length k then we are going to check whether it satisfies our given condition or not\\n            {\\n                int subseq = stoi(ch);     //converting the current subsequence into integer\\n                if( subseq!=0 && (num%subseq)==0) count++;      //if the current subsequence is not zero and if it multiple of given number \\'num\\' then we can increment our count by 1\\n                ch[i]=\\'0\\';                 //here we are reseting the first integer to zero , since our sliding window has to be moved.\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n    int divisorSubstrings(int num, int k) {\\n        return kBeauty(num,k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0,j=0,count=0;\\n        string ch=\"\";\\n        while(j<s.size())\\n        {\\n            ch+=s[j];\\n            if((j-i+1)==k)                  //if we found a subseq of length k then we are going to check whether it satisfies our given condition or not\\n            {\\n                int subseq = stoi(ch);      //converting the current subsequence into integer\\n                if( subseq!=0 && (num%subseq)==0) count++;      //if the current subsequence is not zero and if it multiple of given number \\'num\\' then we can increment our count by 1\\n                ch[i]=\\'0\\';                 //here we are reseting the first integer to zero , since our sliding window has to be moved.\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;                     //returning the final count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484107,
                "title": "beat-100-easy-c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int divisorSubstrings(int num, int k) {\\n        int n=num;\\n        int count=0;\\n        long mod=pow(10,k);\\n        while(n>=mod/10){\\n            int div=n%mod;\\n            if(div!=0 && num%div==0)count++;\\n            n=n/10;\\n        }\\n        return count;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int divisorSubstrings(int num, int k) {\\n        int n=num;\\n        int count=0;\\n        long mod=pow(10,k);\\n        while(n>=mod/10){\\n            int div=n%mod;\\n            if(div!=0 && num%div==0)count++;\\n            n=n/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2472283,
                "title": "k-beauty-of-a-number",
                "content": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        c=0\\n        s = str(num)\\n        for i in range(len(s)-k+1):\\n            t = int(s[i:k+i])\\n            if t!=0 and num%t==0:\\n                c+=1\\n        return c",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        c=0\\n        s = str(num)\\n        for i in range(len(s)-k+1):\\n            t = int(s[i:k+i])\\n            if t!=0 and num%t==0:\\n                c+=1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 2425794,
                "title": "java-using-integer-tostring-integer-valueof-and-string-substring-methods",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int beauty = 0;\\n        String numString = Integer.toString(num);\\n        for(int i=0; i<=numString.length()-k; i++) {\\n            int n = Integer.valueOf(numString.substring(i, i+k));\\n            // System.out.printf(\"%d\\\\t\", n);\\n            if(n > 0 && num % n == 0) {\\n                beauty++;\\n            }\\n        }\\n        return beauty;\\n    }\\n}\\n```\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/discuss/2038555/Numeric-Sliding-Window/1544348\\n\\nArithmatic version\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int beauty = 0, pow10 = 1, divisor = 0;\\n        for(int i = num; i >0;  i/=10) {\\n            divisor += (i % 10) * pow10;\\n            if(--k > 0) {\\n                pow10 *= 10;\\n            }\\n            else  {\\n                beauty += (divisor > 0) && (num % divisor == 0) ? 1 : 0;\\n                divisor /= 10;\\n            }\\n        }\\n        return beauty;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int beauty = 0;\\n        String numString = Integer.toString(num);\\n        for(int i=0; i<=numString.length()-k; i++) {\\n            int n = Integer.valueOf(numString.substring(i, i+k));\\n            // System.out.printf(\"%d\\\\t\", n);\\n            if(n > 0 && num % n == 0) {\\n                beauty++;\\n            }\\n        }\\n        return beauty;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int beauty = 0, pow10 = 1, divisor = 0;\\n        for(int i = num; i >0;  i/=10) {\\n            divisor += (i % 10) * pow10;\\n            if(--k > 0) {\\n                pow10 *= 10;\\n            }\\n            else  {\\n                beauty += (divisor > 0) && (num % divisor == 0) ? 1 : 0;\\n                divisor /= 10;\\n            }\\n        }\\n        return beauty;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395148,
                "title": "typescript-sliding-window-with-comments",
                "content": "```\\nfunction divisorSubstrings(num: number, k: number): number {\\n    let divisor = \"\";\\n    let numberOfBeauties = 0;\\n    let stringifiedNum = String(num);\\n    \\n    for(let windowEnd = 0 ; windowEnd < stringifiedNum.length ; windowEnd++){\\n        divisor = `${divisor}${stringifiedNum[windowEnd]}`;\\n        \\n        // if reached wanted substring length\\n        if(windowEnd >= k - 1){\\n            const divisorAsNumber = Number(divisor);\\n            numberOfBeauties = divisorAsNumber !== 0 && num % divisorAsNumber === 0 ? \\n                numberOfBeauties + 1 : numberOfBeauties\\n            \\n            // only remove first number from divisor\\n            divisor = divisor.substring(1);\\n        }\\n    }\\n    return numberOfBeauties;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sliding Window"
                ],
                "code": "```\\nfunction divisorSubstrings(num: number, k: number): number {\\n    let divisor = \"\";\\n    let numberOfBeauties = 0;\\n    let stringifiedNum = String(num);\\n    \\n    for(let windowEnd = 0 ; windowEnd < stringifiedNum.length ; windowEnd++){\\n        divisor = `${divisor}${stringifiedNum[windowEnd]}`;\\n        \\n        // if reached wanted substring length\\n        if(windowEnd >= k - 1){\\n            const divisorAsNumber = Number(divisor);\\n            numberOfBeauties = divisorAsNumber !== 0 && num % divisorAsNumber === 0 ? \\n                numberOfBeauties + 1 : numberOfBeauties\\n            \\n            // only remove first number from divisor\\n            divisor = divisor.substring(1);\\n        }\\n    }\\n    return numberOfBeauties;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307576,
                "title": "beats-100-other-solutions",
                "content": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        \\n        \\n        result, num_str = 0, str(num)\\n        \\n        for i in range(len(num_str) - k + 1):\\n            \\n            check = int(num_str[i : i + k])\\n            \\n            if check != 0 and not num % check:\\n                result += 1\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        \\n        \\n        result, num_str = 0, str(num)\\n        \\n        for i in range(len(num_str) - k + 1):\\n            \\n            check = int(num_str[i : i + k])\\n            \\n            if check != 0 and not num % check:\\n                result += 1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290642,
                "title": "74-76-faster-python-easy-approach",
                "content": "# \\u271474.76% FASTER\\uD83D\\uDC0DPYTHON EASY APPROACH.\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        # since integer has no length function, we convert our num into a str.\\n        # Then we run a loop that goes until i+k-1 < len(numStr) and take\\n        # n = int(numStr[i: i+k]); and if n!=0 and num%n==0 meaning \\n\\t\\t# num is divisible by n so we add 1 to k_beauty and return it in the end.\\n\\t\\t\\n        numStr = str(num)\\n        i, k_beauty = 0, 0\\n        \\n        while i+k-1 < len(numStr):\\n            n = int(numStr[i: i+k])\\n            if n!=0 and num%n==0:\\n                k_beauty += 1\\n                \\n            i += 1\\n        \\n        return k_beauty\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        # since integer has no length function, we convert our num into a str.\\n        # Then we run a loop that goes until i+k-1 < len(numStr) and take\\n        # n = int(numStr[i: i+k]); and if n!=0 and num%n==0 meaning \\n\\t\\t# num is divisible by n so we add 1 to k_beauty and return it in the end.\\n\\t\\t\\n        numStr = str(num)\\n        i, k_beauty = 0, 0\\n        \\n        while i+k-1 < len(numStr):\\n            n = int(numStr[i: i+k])\\n            if n!=0 and num%n==0:\\n                k_beauty += 1\\n                \\n            i += 1\\n        \\n        return k_beauty\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276709,
                "title": "java-1ms-solution-sliding-window-better-than-95",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n        int windowStart = 0;\\n        int windowEnd = k-1;\\n        int count = 0;\\n        \\n        String s = Integer.toString(num);\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while(windowEnd < s.length())  {\\n            StringBuilder temp = new StringBuilder();\\n            for(int i = windowStart;i<=windowEnd;i++) {\\n                temp.append(sb.charAt(i));\\n                // temp += s.charAt(i);\\n            }    \\n            String check = temp.toString();\\n            int test = Integer.parseInt(check);\\n           \\n            if(test != 0 && num % test == 0) count++;\\n            windowStart++;\\n            windowEnd++;\\n        }\\n        \\n        return count;\\n        \\n        \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "String",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n        int windowStart = 0;\\n        int windowEnd = k-1;\\n        int count = 0;\\n        \\n        String s = Integer.toString(num);\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while(windowEnd < s.length())  {\\n            StringBuilder temp = new StringBuilder();\\n            for(int i = windowStart;i<=windowEnd;i++) {\\n                temp.append(sb.charAt(i));\\n                // temp += s.charAt(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2273447,
                "title": "java-sliding-window-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n         String n = Integer.toString(num);\\n        int ws = 0, count = 0;\\n        for (int we =k ; we <= n.length(); we++) {\\n            int divisor = Integer.parseInt(n.substring(ws, we));\\n            ws++;\\n            if (divisor != 0 && num % divisor == 0) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\nMy attempt to solve the problem, beats 95.11% , any suggestions to improve is appreciated",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n         String n = Integer.toString(num);\\n        int ws = 0, count = 0;\\n        for (int we =k ; we <= n.length(); we++) {\\n            int divisor = Integer.parseInt(n.substring(ws, we));\\n            ws++;\\n            if (divisor != 0 && num % divisor == 0) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171491,
                "title": "c-sliding-window-t-n-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int x, int k) {\\n        long long int i=0,j=0,sum=0,z=0;\\n        string num=to_string(x);\\n        long long int n=num.size();\\n        while(j<n)\\n        {\\n            sum=(sum*10)+(num[j]-\\'0\\');\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(sum!=0 and x%sum==0)\\n                    z++;\\n                sum-=(num[i]-\\'0\\')*pow(10,k-1);\\n                i++;j++;\\n            }\\n        }\\n        return z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int x, int k) {\\n        long long int i=0,j=0,sum=0,z=0;\\n        string num=to_string(x);\\n        long long int n=num.size();\\n        while(j<n)\\n        {\\n            sum=(sum*10)+(num[j]-\\'0\\');\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(sum!=0 and x%sum==0)\\n                    z++;\\n                sum-=(num[i]-\\'0\\')*pow(10,k-1);\\n                i++;j++;\\n            }\\n        }\\n        return z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154900,
                "title": "c-easy-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0,j=0;\\n        int cnt=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                string ss=s.substr(i,k);\\n                int n=stoi(ss);\\n                if(n!=0&&num%n==0)\\n                    cnt++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0,j=0;\\n        int cnt=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                string ss=s.substr(i,k);\\n                int n=stoi(ss);\\n                if(n!=0&&num%n==0)\\n                    cnt++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154047,
                "title": "c-sliding-window",
                "content": "\\t\\t           please upvote if you like*******\\n\\t\\t\\n\\t\\tclass Solution {\\n\\tpublic:\\n   \\n    int divisorSubstrings(int num, int k) {\\n        string s1=to_string(num);\\n        int i=0,j=0;\\n        int n=s1.size();\\n        string temp=\"\";\\n        int c=0;\\n        while(j<n){\\n           temp+=s1[j];\\n           if(j-i+1==k){\\n               int x=stoi(temp);\\n               if(x){\\n               \\n                   if(num%x==0) \\n                       c++;\\n               }\\n               temp.erase(0,1);\\n               i++;\\n               j++;\\n           }\\n           else \\n               j++;\\n        }\\n        return c;\\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n   \\n    int divisorSubstrings(int num, int k) {\\n        string s1=to_string(num);\\n        int i=0,j=0;\\n        int n=s1.size();\\n        string temp=\"\";\\n        int c=0;\\n        while(j<n){\\n           temp+=s1[j];\\n           if(j-i+1==k){\\n               int x=stoi(temp);\\n               if(x){\\n               \\n                   if(num%x==0) \\n                       c++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2120899,
                "title": "c-window-technique-with-explanation",
                "content": "Take two pointers **i** and **j** which is always the length of **k**\\nMove through the entire num (converted to string) and check for divisor eligibility. Increase the counter.\\n\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int i = 0, j = i + k - 1;\\n        string st = to_string(num);\\n        int size = st.size();\\n        int c = 0;\\n        \\n        while(j++ < size) {\\n            string cur = st.substr(i, k);\\n            if(stoi(cur) > 0 && num % stoi(cur) == 0 ) c++;\\n            i++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int i = 0, j = i + k - 1;\\n        string st = to_string(num);\\n        int size = st.size();\\n        int c = 0;\\n        \\n        while(j++ < size) {\\n            string cur = st.substr(i, k);\\n            if(stoi(cur) > 0 && num % stoi(cur) == 0 ) c++;\\n            i++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094890,
                "title": "simple-python-solution",
                "content": "```python\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        s, cnt = str(num), 0\\n        for n in [s[i:i+k] for i in range(len(s)-k+1)]:\\n            val = int(n)\\n            if val and num % val == 0:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        s, cnt = str(num), 0\\n        for n in [s[i:i+k] for i in range(len(s)-k+1)]:\\n            val = int(n)\\n            if val and num % val == 0:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051172,
                "title": "python-faster-than-99-1-liner-and-expanded-version-beginner-friendly",
                "content": "\\t\\tl = str(num)\\n\\t\\tcount = 0\\n        \\n        for i in range(len(l)-k+1):\\n            if int(l[i:i+k]) != 0 and num % int(l[i:i+k]) == 0:\\n                count += 1\\n                \\n        return count\\n\\n    # the equivalent code from above in one line:\\n    \\n        return sum( (int(str(num)[i:i+k]) != 0 and num % int(str(num)[i:i+k]) == 0) for i in range(len(str(num))-k+1) )",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\t\\tl = str(num)\\n\\t\\tcount = 0\\n        \\n        for i in range(len(l)-k+1):\\n            if int(l[i:i+k]) != 0 and num % int(l[i:i+k]) == 0:\\n                count += 1\\n                \\n        return count\\n\\n    # the equivalent code from above in one line:\\n    \\n        return sum( (int(str(num)[i:i+k]) != 0 and num % int(str(num)[i:i+k]) == 0) for i in range(len(str(num))-k+1) )",
                "codeTag": "Unknown"
            },
            {
                "id": 2050190,
                "title": "java-solution-without-string-beats-100",
                "content": "class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n\\t\\tint changedNum = num;\\n        int len = (int) Math.pow(10, k);\\n        \\n        int div = 0;\\n        int res = 0;\\n        \\n        while(changedNum >= len / 10){\\n            div = changedNum % len;\\n            \\n            if(div != 0 && num % div == 0)\\n                res++;\\n            changedNum /= 10;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        \\n\\t\\tint changedNum = num;\\n        int len = (int) Math.pow(10, k);\\n        \\n        int div = 0;\\n        int res = 0;\\n        \\n        while(changedNum >= len / 10){\\n            div = changedNum % len;\\n            \\n            if(div != 0 && num % div == 0)\\n                res++;\\n            changedNum /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2046646,
                "title": "c-simple-iterative-approach-100-faster",
                "content": "class Solution {\\npublic:\\n    \\n    int A(int i,int k,vector<int>a){\\n        int num=0;\\n        int x=k;\\n        for(int j=0;j<k;j++){\\n            num+=(a[i]*pow(10,x-1));\\n            i++;\\n            \\n            x--;\\n        }\\n        \\n        cout<<num;\\n        \\n        return num;\\n    }\\n    int divisorSubstrings(int num, int k) {\\n        vector<int>v;\\n        int x=num;\\n        while(x>0){\\n            int ld=x%10;\\n            v.push_back(ld);\\n            x/=10;\\n        }\\n        vector<int>a;\\n        \\n        for(int i=v.size()-1;i>=0;i--){\\n            a.push_back(v[i]);\\n        }\\n        int count=0;\\n        for(int i=0;i<=a.size()-k;i++){\\n            int v=A(i,k,a);\\n            \\n            if(v!=0&&(num%v)==0){\\n                \\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int A(int i,int k,vector<int>a){\\n        int num=0;\\n        int x=k;\\n        for(int j=0;j<k;j++){\\n            num+=(a[i]*pow(10,x-1));\\n            i++;\\n            \\n            x--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2044533,
                "title": "simple-java-solution-1ms",
                "content": "```\\npublic int divisorSubstrings(int num, int k) {\\n   String s= String.valueOf(num); //convert num to string for making substrings\\n\\tint count=0; //keeps track of k-beauty\\n\\t for(int i=0;i<s.length()-k+1;i++){ \\n\\t\\tint str = Integer.parseInt(s.substring(i,i+k));\\n\\t\\tif(str != 0 && num % str == 0){  // checks for k-beauty no\\n\\t\\t\\tcount++;   //increment if no is found\\n\\t\\t}      \\n\\t}  \\n\\treturn count;\\n}\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int divisorSubstrings(int num, int k) {\\n   String s= String.valueOf(num); //convert num to string for making substrings\\n\\tint count=0; //keeps track of k-beauty\\n\\t for(int i=0;i<s.length()-k+1;i++){ \\n\\t\\tint str = Integer.parseInt(s.substring(i,i+k));\\n\\t\\tif(str != 0 && num % str == 0){  // checks for k-beauty no\\n\\t\\t\\tcount++;   //increment if no is found\\n\\t\\t}      \\n\\t}  \\n\\treturn count;\\n}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2042445,
                "title": "python-solution-100-faster",
                "content": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        a=str(num)\\n        b=0\\n        for i in range(len(a)):\\n            x=(a[i:i+k])\\n            if int(x)!=0 and num%int(x)==0 and (len(x))==k:\\n                b+=1\\n        return b\\n```\\n![image](https://assets.leetcode.com/users/images/6da82116-057e-40a1-a853-13ef82d04221_1652634345.5882797.png)\\n\\n                \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        a=str(num)\\n        b=0\\n        for i in range(len(a)):\\n            x=(a[i:i+k])\\n            if int(x)!=0 and num%int(x)==0 and (len(x))==k:\\n                b+=1\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040559,
                "title": "c-solution-no-string-conversion-easy-intuitive-code",
                "content": "* Splitter function to get the digits of the number\\n* the nested for loop to make the divisors\\n\\n```\\nclass Solution {\\npublic:\\n    vector <int> digits;\\n    void splitter (int num)\\n    {\\n         \\n        while (num>0)\\n        {\\n            digits.push_back(num%10);\\n            num = num/10;\\n        }\\n    }\\n    int divisorSubstrings(int num, int k) {\\n        int temp = num,count=0,divisor=0;\\n        splitter(num);\\n        \\n        reverse(digits.begin(),digits.end());\\n        for (int i =0;i<digits.size()-k+1;i++)\\n        {\\n            divisor = digits[i];\\n            for (int j=1;j<k;j++)\\n            {\\n                divisor = divisor*10+digits[i+j];\\n            }\\n            if(divisor==0)\\n                continue;\\n            if (temp%divisor==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> digits;\\n    void splitter (int num)\\n    {\\n         \\n        while (num>0)\\n        {\\n            digits.push_back(num%10);\\n            num = num/10;\\n        }\\n    }\\n    int divisorSubstrings(int num, int k) {\\n        int temp = num,count=0,divisor=0;\\n        splitter(num);\\n        \\n        reverse(digits.begin(),digits.end());\\n        for (int i =0;i<digits.size()-k+1;i++)\\n        {\\n            divisor = digits[i];\\n            for (int j=1;j<k;j++)\\n            {\\n                divisor = divisor*10+digits[i+j];\\n            }\\n            if(divisor==0)\\n                continue;\\n            if (temp%divisor==0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038728,
                "title": "java-easy",
                "content": "````\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String str=\"\";\\n        str+=num;\\n        int c=0;\\n        int m=0;\\n        for(int i=0;i<str.length()-k+1;i++){\\n            \\n            String ans=str.substring(i,i+k);\\n           if(Integer.parseInt(ans)!=0 && num%Integer.parseInt(ans)==0)c++;\\n        }\\n        return c;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String str=\"\";\\n        str+=num;\\n        int c=0;\\n        int m=0;\\n        for(int i=0;i<str.length()-k+1;i++){\\n            \\n            String ans=str.substring(i,i+k);\\n           if(Integer.parseInt(ans)!=0 && num%Integer.parseInt(ans)==0)c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2038697,
                "title": "go-way-beats-100-runtime",
                "content": "```\\nfunc divisorSubstrings(num int, k int) int {\\n    var str = strconv.Itoa(num)\\n    var n = len(str)\\n    var res = 0\\n    \\n    for i:=0; i <= n-k; i++ {\\n        var sub = str[i:i+k]\\n        var m, _ = strconv.Atoi(sub)\\n        \\n        if m != 0 && num % m == 0 {\\n            res += 1\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc divisorSubstrings(num int, k int) int {\\n    var str = strconv.Itoa(num)\\n    var n = len(str)\\n    var res = 0\\n    \\n    for i:=0; i <= n-k; i++ {\\n        var sub = str[i:i+k]\\n        var m, _ = strconv.Atoi(sub)\\n        \\n        if m != 0 && num % m == 0 {\\n            res += 1\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038548,
                "title": "java-simple-o-n-substring-easy",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int count=0;\\n        String str=Integer.toString(num);\\n        for(int i=0;i<str.length();i++){\\n            if(i+k>str.length()){ //This condition is used because if it picks substring bigger than string length then it will give StringOutOfBoundsException so to avoid that we have used that statement. Also if its bigger than string length then in that case is never possible as its always less than k so we go out of loop in that part.\\n                break;\\n            }\\n            String substr=str.substring(i,i+k);\\n            int convertsubstr=Integer.parseInt(substr);\\n            if(convertsubstr!=0){ // to only allow non zero elements\\n                if(num%convertsubstr==0 && convertsubstr>0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        int count=0;\\n        String str=Integer.toString(num);\\n        for(int i=0;i<str.length();i++){\\n            if(i+k>str.length()){ //This condition is used because if it picks substring bigger than string length then it will give StringOutOfBoundsException so to avoid that we have used that statement. Also if its bigger than string length then in that case is never possible as its always less than k so we go out of loop in that part.\\n                break;\\n            }\\n            String substr=str.substring(i,i+k);\\n            int convertsubstr=Integer.parseInt(substr);\\n            if(convertsubstr!=0){ // to only allow non zero elements\\n                if(num%convertsubstr==0 && convertsubstr>0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038432,
                "title": "c-very-easy-solution-greedy",
                "content": "class Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        \\n        string str=to_string(num);\\n        int ans=0;\\n        for(int i=0;i<=str.size()-k;i++)\\n        {\\n            string s=str.substr(i,k);\\n            int b=stoi(s);\\n            if(b!=0)\\n                if(num%b==0)\\n                    ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        \\n        string str=to_string(num);\\n        int ans=0;\\n        for(int i=0;i<=str.size()-k;i++)\\n        {\\n            string s=str.substr(i,k);\\n            int b=stoi(s);\\n            if(b!=0)\\n                if(num%b==0)\\n                    ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2038415,
                "title": "java-easy-solution-o-n-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String str=Integer.toString(num);\\n        int count=0;\\n        for(int i=0;i<str.length()-k+1;i++){\\n            String temp=str.substring(i,i+k);\\n            int divisor=Integer.valueOf(temp);\\n            if(divisor==0) continue;\\n            if(num%divisor==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String str=Integer.toString(num);\\n        int count=0;\\n        for(int i=0;i<str.length()-k+1;i++){\\n            String temp=str.substring(i,i+k);\\n            int divisor=Integer.valueOf(temp);\\n            if(divisor==0) continue;\\n            if(num%divisor==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038361,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n\\t    // Convert num into string\\n        string s = to_string(num);\\n        int count = 0;\\n        \\n        for(int i = 0; i <= s.size()-k; i++) {\\n            string str = s.substr(i, k);\\n\\t\\t\\t// Convert the substring (string) into integer\\n            int temp = stoi(str);\\n\\t\\t\\t// Check for conditions if satisfied\\n            if(temp > 0 and num % temp == 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n\\t    // Convert num into string\\n        string s = to_string(num);\\n        int count = 0;\\n        \\n        for(int i = 0; i <= s.size()-k; i++) {\\n            string str = s.substr(i, k);\\n\\t\\t\\t// Convert the substring (string) into integer\\n            int temp = stoi(str);\\n\\t\\t\\t// Check for conditions if satisfied\\n            if(temp > 0 and num % temp == 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038320,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int kk  = num ;\\n        long long int n = pow(10 ,k);\\n        vector<int> v ;\\n        while(num/n != 0){ \\n            v.push_back(num%n) ;\\n            num/= 10 ;\\n        }\\n        v.push_back(num) ;\\n        \\n        int ans = 0 ;\\n        for(auto &c: v){\\n            // cout<<c<<\" \" ;\\n            if(c != 0 && kk%c == 0){\\n                ans ++ ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int kk  = num ;\\n        long long int n = pow(10 ,k);\\n        vector<int> v ;\\n        while(num/n != 0){ \\n            v.push_back(num%n) ;\\n            num/= 10 ;\\n        }\\n        v.push_back(num) ;\\n        \\n        int ans = 0 ;\\n        for(auto &c: v){\\n            // cout<<c<<\" \" ;\\n            if(c != 0 && kk%c == 0){\\n                ans ++ ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2038312,
                "title": "easy-peasy-cpp-iterative-sum-100-faster-string-to-int-int-to-string-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s , sub_string ;\\n        int sub_int ,count =0;\\n        s = to_string(num);\\n        for(int i =0 ; i<= (s.size()-k) ; i++){\\n            sub_string = s.substr(i , k);\\n            sub_int = stoi( sub_string);\\n            // cout<<\"int\"<<sub_int<<\"i\"<<i<<endl;\\n            if(sub_int ==0){continue;}\\n            if(num % sub_int == 0 ){ count ++ ;}\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s , sub_string ;\\n        int sub_int ,count =0;\\n        s = to_string(num);\\n        for(int i =0 ; i<= (s.size()-k) ; i++){\\n            sub_string = s.substr(i , k);\\n            sub_int = stoi( sub_string);\\n            // cout<<\"int\"<<sub_int<<\"i\"<<i<<endl;\\n            if(sub_int ==0){continue;}\\n            if(num % sub_int == 0 ){ count ++ ;}\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2038301,
                "title": "divide-and-modulus",
                "content": "class Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int n = str.size();\\n        int ans = 0;\\n        for(int i = 0; i <= n - k; i++)\\n        {\\n            string temp = str.substr(i, k);\\n            int value = stoi(temp);\\n            if(value != 0)\\n                ans += (num % value == 0);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int n = str.size();\\n        int ans = 0;\\n        for(int i = 0; i <= n - k; i++)\\n        {\\n            string temp = str.substr(i, k);\\n            int value = stoi(temp);\\n            if(value != 0)\\n                ans += (num % value == 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2038270,
                "title": "python3-very-clear-and-easy-to-understand-pythonic-solution-also-1-liner",
                "content": "\\n\\n```\\n    @timeit\\n    def divisor_substrings2(self, num: int, k: int) -> int:\\n        set_k = [int(str(num)[i:i+k]) for i in range(0, len(str(num))-(k-1))]\\n        return sum(1 for e in set_k if e != 0 and num % e == 0)\\n```\\n\\n\\nCan do 1 line but it is ugly and just pedantic\\n\\n```\\nreturn sum(1 for e in [int(str(num)[i:i+k]) for i in range(0, len(str(num))-(k-1))] if e != 0 and num % e == 0)\\n```\\n\\nor for a more broken out understanding:\\n\\n```\\n        s, res = str(num), 0\\n        set_k = [int(s[i:i+k]) for i in range(0, len(s)-(k-1))]\\n        for e in set_k:\\n            if e != 0:\\n                if num % e == 0:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    @timeit\\n    def divisor_substrings2(self, num: int, k: int) -> int:\\n        set_k = [int(str(num)[i:i+k]) for i in range(0, len(str(num))-(k-1))]\\n        return sum(1 for e in set_k if e != 0 and num % e == 0)\\n```\n```\\nreturn sum(1 for e in [int(str(num)[i:i+k]) for i in range(0, len(str(num))-(k-1))] if e != 0 and num % e == 0)\\n```\n```\\n        s, res = str(num), 0\\n        set_k = [int(s[i:i+k]) for i in range(0, len(s)-(k-1))]\\n        for e in set_k:\\n            if e != 0:\\n                if num % e == 0:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2038126,
                "title": "java-brute-force-easy-solution",
                "content": "```java\\nclass Solution {\\n\\n    public int divisorSubstrings(int num, int k) {\\n        String s = num + \"\";\\n        int count = 0;\\n        for (int i = 0; i < s.length() - k+1; i++) {\\n            int div = Integer.parseInt(s.substring(i, i + k));\\n            if (div == 0) {\\n                continue;\\n            }\\n            if (num % div == 0) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n\\n    public int divisorSubstrings(int num, int k) {\\n        String s = num + \"\";\\n        int count = 0;\\n        for (int i = 0; i < s.length() - k+1; i++) {\\n            int div = Integer.parseInt(s.substring(i, i + k));\\n            if (div == 0) {\\n                continue;\\n            }\\n            if (num % div == 0) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086718,
                "title": "simole-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String s=\"\"+num;\\n        int i=0;\\n        int j=k;\\n        int ans=0;\\n        int n=s.length();\\n        while(j<=n){\\n            int x=Integer.parseInt(s.substring(i++,j++));\\n                if(x!=0 && num%x==0)ans++;\\n                \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String s=\"\"+num;\\n        int i=0;\\n        int j=k;\\n        int ans=0;\\n        int n=s.length();\\n        while(j<=n){\\n            int x=Integer.parseInt(s.substring(i++,j++));\\n                if(x!=0 && num%x==0)ans++;\\n                \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085400,
                "title": "beasts-100-c-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*K)\\n\\n- Space complexity:\\nO(K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int count = 0;\\n        string s = to_string(num);\\n        int n = s.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            string S = s.substr(i, k);\\n            if (S.size() == k) {\\n                int num1 = stoi(S);\\n                if (num1) {\\n                    if (num % num1 == 0) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int count = 0;\\n        string s = to_string(num);\\n        int n = s.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            string S = s.substr(i, k);\\n            if (S.size() == k) {\\n                int num1 = stoi(S);\\n                if (num1) {\\n                    if (num % num1 == 0) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084971,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k)\\n     {\\n        String S = Integer.toString(num);\\n        String str=\"\";\\n        int count=0;\\n        int n=0;\\n        for(int i=0;i<=S.length()-k;i++){\\n            str=S.substring(i,i+k);\\n            n = Integer.parseInt(str);\\n            if(n!=0 && num%n==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k)\\n     {\\n        String S = Integer.toString(num);\\n        String str=\"\";\\n        int count=0;\\n        int n=0;\\n        for(int i=0;i<=S.length()-k;i++){\\n            str=S.substring(i,i+k);\\n            n = Integer.parseInt(str);\\n            if(n!=0 && num%n==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082655,
                "title": "0ms-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        if(num < k) return 0;\\n        String str = String.valueOf(num);\\n\\n        int i = 0;\\n        int j = i + k - 1;\\n        int count = 0;\\n\\n        // 2 4 0\\n        // 0 1 2\\n        //   i j\\n\\n        while(j != str.length()){\\n            int number = Integer.parseInt(str.substring(i,j+1));\\n\\n            if((number != 0) && (num % number == 0)){\\n                count += 1;\\n            }\\n\\n            i++;\\n            j++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        if(num < k) return 0;\\n        String str = String.valueOf(num);\\n\\n        int i = 0;\\n        int j = i + k - 1;\\n        int count = 0;\\n\\n        // 2 4 0\\n        // 0 1 2\\n        //   i j\\n\\n        while(j != str.length()){\\n            int number = Integer.parseInt(str.substring(i,j+1));\\n\\n            if((number != 0) && (num % number == 0)){\\n                count += 1;\\n            }\\n\\n            i++;\\n            j++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081715,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        num1=str(num)\\n        count=0\\n        for i in range(len(str(num))-k+1):\\n            if int(num1[i:k+i]) and num % int(num1[i:k+i])==0:\\n                count +=1\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        num1=str(num)\\n        count=0\\n        for i in range(len(str(num))-k+1):\\n            if int(num1[i:k+i]) and num % int(num1[i:k+i])==0:\\n                count +=1\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079372,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        final String s = String.valueOf(num);\\n        int ans = 0;\\n\\n        for (int i = 0; i + k <= s.length(); ++i) {\\n        final int x = Integer.parseInt(s.substring(i, i + k));\\n        if (x != 0 && num % x == 0)\\n            ++ans;\\n        }\\n\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        final String s = String.valueOf(num);\\n        int ans = 0;\\n\\n        for (int i = 0; i + k <= s.length(); ++i) {\\n        final int x = Integer.parseInt(s.substring(i, i + k));\\n        if (x != 0 && num % x == 0)\\n            ++ans;\\n        }\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078349,
                "title": "c-simple-iterative-approach-time-complexity-o-length-nums-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. convert given num to string using to_string in O(n) space complexity\\n2. will having total (length of string-k+1) substrings.\\n3. start with i = 0 and iterate till (length of string-k+1)\\n4. fetch substring of length k from ith index\\n5. then check num is divisible by stoi(substring)(which convert str to int).\\n6. if num is divisible then increase the count and finally return count.\\n\\n# Complexity\\n- Time complexity: O(length(nums)*k)\\n\\n\\n- Space complexity: 0(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string temp = to_string(num);\\n        int kcount = 0;\\n        int m = temp.length();\\n        for(int i=0;i<m-k+1;i++){\\n            string bstr = temp.substr(i,k);\\n            int n = stoi(bstr);\\n            if(n!=0 and num%n==0) kcount++;\\n        }\\n        return kcount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string temp = to_string(num);\\n        int kcount = 0;\\n        int m = temp.length();\\n        for(int i=0;i<m-k+1;i++){\\n            string bstr = temp.substr(i,k);\\n            int n = stoi(bstr);\\n            if(n!=0 and num%n==0) kcount++;\\n        }\\n        return kcount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078257,
                "title": "8-lines-of-c-code",
                "content": "# Intuition\\nUsing string\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO((N-k)k)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int cnt = 0;\\n        for(int i = 0; i <= str.length()-k; i++){\\n            string res = str.substr(i,k);\\n            int n = stoi(res);\\n            if(n != 0 and num%n == 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int cnt = 0;\\n        for(int i = 0; i <= str.length()-k; i++){\\n            string res = str.substr(i,k);\\n            int n = stoi(res);\\n            if(n != 0 and num%n == 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076712,
                "title": "c-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int DivisorSubstrings(int num, int k) {\\n        string str = num.ToString();\\n        int i = 0, res = 0, cur = 0;\\n        int pow = (int)Math.Pow(10,k);\\n        while(i < str.Length){\\n            int d = str[i] - \\'0\\';\\n            cur = cur * 10 + d;\\n            if(i >= k){\\n                int x = str[i - k] - \\'0\\';\\n                cur-= (x * pow);\\n            }\\n            if(cur != 0 && i + 1 >= k && num % cur == 0) res++;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int DivisorSubstrings(int num, int k) {\\n        string str = num.ToString();\\n        int i = 0, res = 0, cur = 0;\\n        int pow = (int)Math.Pow(10,k);\\n        while(i < str.Length){\\n            int d = str[i] - \\'0\\';\\n            cur = cur * 10 + d;\\n            if(i >= k){\\n                int x = str[i - k] - \\'0\\';\\n                cur-= (x * pow);\\n            }\\n            if(cur != 0 && i + 1 >= k && num % cur == 0) res++;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073361,
                "title": "here-is-my-solution-just-10-minutes",
                "content": "# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n      cnt = 0\\n      num_ = list(str(num))\\n      for i in range(len(num_)+1):\\n        if len(num_[i:k+i]) == k:\\n          try:\\n            if num % int(\\'\\'.join(num_[i:k+i])) == 0:\\n              cnt += 1\\n          except:\\n            pass\\n      return cnt\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n      cnt = 0\\n      num_ = list(str(num))\\n      for i in range(len(num_)+1):\\n        if len(num_[i:k+i]) == k:\\n          try:\\n            if num % int(\\'\\'.join(num_[i:k+i])) == 0:\\n              cnt += 1\\n          except:\\n            pass\\n      return cnt\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071243,
                "title": "beats-100-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) \\n    {\\n        string a=to_string(num);\\n        int cnt=0;\\n        for(int i=0;i<=a.size()-k;i++)\\n        {\\n            string y=a.substr(i,k);\\n            int x=stoi(y);\\n            if(x!=0&&num%x==0)\\n            cnt++;\\n        }\\n        return cnt;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) \\n    {\\n        string a=to_string(num);\\n        int cnt=0;\\n        for(int i=0;i<=a.size()-k;i++)\\n        {\\n            string y=a.substr(i,k);\\n            int x=stoi(y);\\n            if(x!=0&&num%x==0)\\n            cnt++;\\n        }\\n        return cnt;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070664,
                "title": "simple-implementation",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        number = str(num)\\n        l, r = 0, k\\n        res = 0\\n\\n        while r <= len(number):\\n            val = number[l : r]\\n            \\n            #\\n            # Edge Case: 0 is not a divisor of any value\\n            if (int(val) != 0) and (num % int(val) == 0):\\n                res += 1\\n            \\n            l += 1\\n            r += 1\\n\\n        return res\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        number = str(num)\\n        l, r = 0, k\\n        res = 0\\n\\n        while r <= len(number):\\n            val = number[l : r]\\n            \\n            #\\n            # Edge Case: 0 is not a divisor of any value\\n            if (int(val) != 0) and (num % int(val) == 0):\\n                res += 1\\n            \\n            l += 1\\n            r += 1\\n\\n        return res\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063516,
                "title": "easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int count=0;\\n        string str=to_string(num);\\n        int n = str.length();\\n        for(int i=0;i<=n-k;i++){\\n            string d = str.substr(i,k);\\n            int div = stoll(d);\\n            if(div!=0 and num%div==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int count=0;\\n        string str=to_string(num);\\n        int n = str.length();\\n        for(int i=0;i<=n-k;i++){\\n            string d = str.substr(i,k);\\n            int div = stoll(d);\\n            if(div!=0 and num%div==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053272,
                "title": "divisorsubstrings-js-ts-noodkhannavin",
                "content": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\n```\\n```\\nvar divisorSubstrings = function(num, k) {\\n    num = num.toString() ;\\n    let count = 0 ;  \\n    for(let i = 0 ; i < num.length - k + 1; ++i){\\n        let value = [] ; \\n       for(let j = 0 ; j < k ; ++j){\\n           value.push(num[i + j]) ; \\n       }\\n       let val = +value.join(\\'\\') ;\\n       let cur = (num / val);\\n       let remainder = Math.floor(cur) ; \\n       var res = cur - remainder ; \\n      if(res == 0){\\n          ++count; \\n       }\\n    }\\n    return count; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\n```\n```\\nvar divisorSubstrings = function(num, k) {\\n    num = num.toString() ;\\n    let count = 0 ;  \\n    for(let i = 0 ; i < num.length - k + 1; ++i){\\n        let value = [] ; \\n       for(let j = 0 ; j < k ; ++j){\\n           value.push(num[i + j]) ; \\n       }\\n       let val = +value.join(\\'\\') ;\\n       let cur = (num / val);\\n       let remainder = Math.floor(cur) ; \\n       var res = cur - remainder ; \\n      if(res == 0){\\n          ++count; \\n       }\\n    }\\n    return count; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044967,
                "title": "easy-and-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def divisorSubstrings(self, num, k):\\n        \"\"\"\\n        :type num: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        string = str(num)\\n        count = 0\\n        for i in range(len(string)-k+1):\\n            ref = string[i:i+k]\\n            if int(ref) != 0:\\n                if num % int(ref) == 0:\\n                    count =count+1 \\n        \\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def divisorSubstrings(self, num, k):\\n        \"\"\"\\n        :type num: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        string = str(num)\\n        count = 0\\n        for i in range(len(string)-k+1):\\n            ref = string[i:i+k]\\n            if int(ref) != 0:\\n                if num % int(ref) == 0:\\n                    count =count+1 \\n        \\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044029,
                "title": "just-8-lines-of-code",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.length(), cnt = 0;\\n        for (int i = 0; i <= n-k; ++i) {\\n            string temp = s.substr(i, k);\\n            int x = stoi(temp);\\n            if (x != 0 && num%x == 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.length(), cnt = 0;\\n        for (int i = 0; i <= n-k; ++i) {\\n            string temp = s.substr(i, k);\\n            int x = stoi(temp);\\n            if (x != 0 && num%x == 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043094,
                "title": "k-beauty-of-a-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    num = String(num);\\n    let temp = \\'\\';\\n    let startpoint = 0;\\n    let kbeauty = 0;\\n    for(let i =0; i < num.length; i++){\\n        temp = temp + num[i];\\n        if(i-startpoint+1 == k){\\n            if(num%temp == 0){\\n                kbeauty++;\\n            }\\n            temp = temp.slice(1);\\n            startpoint++\\n        }\\n    }\\n    return kbeauty;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    num = String(num);\\n    let temp = \\'\\';\\n    let startpoint = 0;\\n    let kbeauty = 0;\\n    for(let i =0; i < num.length; i++){\\n        temp = temp + num[i];\\n        if(i-startpoint+1 == k){\\n            if(num%temp == 0){\\n                kbeauty++;\\n            }\\n            temp = temp.slice(1);\\n            startpoint++\\n        }\\n    }\\n    return kbeauty;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034861,
                "title": "python3-clean-sliding-window",
                "content": "# Intuition\\nSliding window on k values\\n\\n# Approach\\nConvert the number to string and slide\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        l = 0\\n        ans = 0\\n        s = str(num)\\n        for r in range(len(s)):\\n            \\n            if (r - l + 1) == k:\\n                val = int(s[l:r+1])\\n                l += 1\\n\\n                if val == 0:\\n                    continue\\n\\n                if (num % val) == 0:\\n                    ans += 1\\n                \\n                \\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        l = 0\\n        ans = 0\\n        s = str(num)\\n        for r in range(len(s)):\\n            \\n            if (r - l + 1) == k:\\n                val = int(s[l:r+1])\\n                l += 1\\n\\n                if val == 0:\\n                    continue\\n\\n                if (num % val) == 0:\\n                    ans += 1\\n                \\n                \\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032223,
                "title": "easy-java-solution-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String s=Integer.toString(num);\\n        int c=0;\\n        for(int i=0;i<s.length()-k+1;i++){\\n            if(Integer.parseInt(s.substring(i,i+k))!=0 && num%Integer.parseInt(s.substring(i,i+k))==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String s=Integer.toString(num);\\n        int c=0;\\n        for(int i=0;i<s.length()-k+1;i++){\\n            if(Integer.parseInt(s.substring(i,i+k))!=0 && num%Integer.parseInt(s.substring(i,i+k))==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030716,
                "title": "sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str=to_string(num);\\n        int i=0,j=0;\\n        int n=str.size();\\n        int count=0;\\n        string s=\"\";\\n        \\n        while(j<n)\\n        {\\n              s+=str[j];\\n              if((j-i+1)<k)\\n              {\\n                  j++;\\n              }\\n              else if((j-i+1)==k)\\n              {\\n                 int p=stoi(s);\\n                 if(p!=0&&num%p==0)\\n                 count++;\\n                 s.erase(s.begin()); \\n                 i++;\\n                 j++;\\n              }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str=to_string(num);\\n        int i=0,j=0;\\n        int n=str.size();\\n        int count=0;\\n        string s=\"\";\\n        \\n        while(j<n)\\n        {\\n              s+=str[j];\\n              if((j-i+1)<k)\\n              {\\n                  j++;\\n              }\\n              else if((j-i+1)==k)\\n              {\\n                 int p=stoi(s);\\n                 if(p!=0&&num%p==0)\\n                 count++;\\n                 s.erase(s.begin()); \\n                 i++;\\n                 j++;\\n              }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030466,
                "title": "beginner-level-c-code",
                "content": "# \\u2705Easy To Understand | C++ \\n\\n# Complexity\\n- Time complexity:\\nO(n*k)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int n, int k) {\\n        int c = 0;\\n        string str = to_string(n);\\n        \\n        for (int i = 0; i <= str.length() - k; i++) {\\n            string substr = str.substr(i, k);\\n            int num = stoi(substr);\\n            if (num != 0 && n % num == 0) {\\n                c++;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int n, int k) {\\n        int c = 0;\\n        string str = to_string(n);\\n        \\n        for (int i = 0; i <= str.length() - k; i++) {\\n            string substr = str.substr(i, k);\\n            int num = stoi(substr);\\n            if (num != 0 && n % num == 0) {\\n                c++;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028022,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsed simple fixed size sliding window approach to find the divisor count.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n      public int divisorSubstrings(int num, int k) {\\n        int i=0;\\n        int j =0;\\n        int count =0;\\n        StringBuilder sb = new StringBuilder();\\n        String numString = Integer.toString(num);\\n        while(j< numString.length()) {\\n            sb.append(numString.charAt(j));\\n            if(j-i+1<k) {\\n                j++;\\n            } else if (j-i+1 == k) {\\n                int numDig = Integer.parseInt(sb.toString());\\n                if(numDig !=0 && num%numDig ==0) {\\n                    count +=1;\\n                }\\n                sb.deleteCharAt(0);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public int divisorSubstrings(int num, int k) {\\n        int i=0;\\n        int j =0;\\n        int count =0;\\n        StringBuilder sb = new StringBuilder();\\n        String numString = Integer.toString(num);\\n        while(j< numString.length()) {\\n            sb.append(numString.charAt(j));\\n            if(j-i+1<k) {\\n                j++;\\n            } else if (j-i+1 == k) {\\n                int numDig = Integer.parseInt(sb.toString());\\n                if(numDig !=0 && num%numDig ==0) {\\n                    count +=1;\\n                }\\n                sb.deleteCharAt(0);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025538,
                "title": "c-easy-beats-100-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s= to_string(num);\\n        int i=0;\\n        int ans=0;\\n        for(int i=0;i<=(s.size()-k);++i){\\n            if(stoi(s.substr(i,k))!=0)\\n            if(num%stoi(s.substr(i,k))==0){\\n                ans++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s= to_string(num);\\n        int i=0;\\n        int ans=0;\\n        for(int i=0;i<=(s.size()-k);++i){\\n            if(stoi(s.substr(i,k))!=0)\\n            if(num%stoi(s.substr(i,k))==0){\\n                ans++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025535,
                "title": "c-easy-to-understand-sliding-windows-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0,j=0;\\n        int count=0;\\n        string res=\"\";\\n\\n        while(j<s.size())\\n        {\\n            res+=s[j];\\n            if(j-i+1<k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                int sum=stoi(res);\\n                if(sum!=0 && num%sum==0)\\n                {\\n                    count++;\\n                }\\n                res.erase(res.begin());\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s=to_string(num);\\n        int i=0,j=0;\\n        int count=0;\\n        string res=\"\";\\n\\n        while(j<s.size())\\n        {\\n            res+=s[j];\\n            if(j-i+1<k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                int sum=stoi(res);\\n                if(sum!=0 && num%sum==0)\\n                {\\n                    count++;\\n                }\\n                res.erase(res.begin());\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023608,
                "title": "fundamental-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString and sliding \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        nums_str = str(num)\\n        for i in range(len(nums_str)-k+1):\\n            val = int(nums_str[i: i+k])\\n            if val != 0:\\n                if num % val ==0:\\n                    count+= 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        nums_str = str(num)\\n        for i in range(len(nums_str)-k+1):\\n            val = int(nums_str[i: i+k])\\n            if val != 0:\\n                if num % val ==0:\\n                    count+= 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010724,
                "title": "python-90-runtime-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        \\n        #PLAN\\n        # - Sliding window\\n\\n        #CODE\\n\\n        res = left = 0  \\n        string = str(num)\\n\\n        for right in range(k, len(string)+1):\\n            divisor = int(string[left:right])\\n            \\n            if divisor != 0 and num%divisor == 0:\\n                res += 1\\n\\n            left += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        \\n        #PLAN\\n        # - Sliding window\\n\\n        #CODE\\n\\n        res = left = 0  \\n        string = str(num)\\n\\n        for right in range(k, len(string)+1):\\n            divisor = int(string[left:right])\\n            \\n            if divisor != 0 and num%divisor == 0:\\n                res += 1\\n\\n            left += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008134,
                "title": "easiest-solution-using-c",
                "content": "Time complexity : O(log(num) + k)\\nCode:\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s= to_string(num);\\n        int count=0,n;\\n        n= s.length();\\n        for(int i=0;i+k<=n;i++){\\n            string temp=\"\";\\n            temp= s.substr(i,k);\\n            int con= stoi(temp);\\n            if(con>0&& num%con==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s= to_string(num);\\n        int count=0,n;\\n        n= s.length();\\n        for(int i=0;i+k<=n;i++){\\n            string temp=\"\";\\n            temp= s.substr(i,k);\\n            int con= stoi(temp);\\n            if(con>0&& num%con==0){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3998634,
                "title": "a-solution-you-ll-love",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int n =num;\\n        long mod=pow(10,k);\\n        int count =0;\\n        while(n>=mod/10)\\n        {\\n            int div= n % mod;\\n            if(div !=0 && num % div==0)\\n            count++;\\n            n=n/10;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        int n =num;\\n        long mod=pow(10,k);\\n        int count =0;\\n        while(n>=mod/10)\\n        {\\n            int div= n % mod;\\n            if(div !=0 && num % div==0)\\n            count++;\\n            n=n/10;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998146,
                "title": "most-intuitive-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n * k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size();\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n - k + 1; i++) {\\n            string str = s.substr(i, k);\\n            int cur = stoi(str);\\n            if (cur != 0 && num % cur == 0) ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size();\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n - k + 1; i++) {\\n            string str = s.substr(i, k);\\n            int cur = stoi(str);\\n            if (cur != 0 && num % cur == 0) ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993931,
                "title": "sliding-window-python-solution-beats-84-53-in-runtime-and-68-09-in-memory",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        cur = []\\n        for i in iter(str(num)):\\n            cur.append(i)\\n\\n            if len(cur) >= k:\\n                print(cur)\\n                if int(\\'\\'.join(map(str,cur))) == 0:\\n                    pass\\n                elif num % int(\\'\\'.join(map(str,cur))) == 0:\\n                    count += 1\\n                cur.pop(0)\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        cur = []\\n        for i in iter(str(num)):\\n            cur.append(i)\\n\\n            if len(cur) >= k:\\n                print(cur)\\n                if int(\\'\\'.join(map(str,cur))) == 0:\\n                    pass\\n                elif num % int(\\'\\'.join(map(str,cur))) == 0:\\n                    count += 1\\n                cur.pop(0)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987739,
                "title": "very-easy-beats-90-percent-simple-for-beginners-using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        x=str(num)\\n        b=0\\n        i=0\\n        j=k-1\\n        while j<len(x):\\n            a=\\'\\'\\n            for m in range(i,j+1):\\n                a=a+x[m]\\n            i+=1\\n            j+=1\\n            if int(a)!=0 and num%(int(a))==0:\\n                b+=1\\n        return(b)\\n\\n                \\n\\n                \\n               \\n           \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        x=str(num)\\n        b=0\\n        i=0\\n        j=k-1\\n        while j<len(x):\\n            a=\\'\\'\\n            for m in range(i,j+1):\\n                a=a+x[m]\\n            i+=1\\n            j+=1\\n            if int(a)!=0 and num%(int(a))==0:\\n                b+=1\\n        return(b)\\n\\n                \\n\\n                \\n               \\n           \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978528,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse Slidling Window of size K , for each window number check if modulus is zero \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String number = String.valueOf(num);\\n        String s = number.substring(0,k);\\n        int numberOfDivisors = 0;\\n        if((Integer.parseInt(s) != 0) && num%(Integer.parseInt(s)) == 0) {\\n            numberOfDivisors++;\\n        }\\n        for(int i=k;i<number.length();i++) {\\n            s = s.substring(1)+String.valueOf(number.charAt(i));\\n            if(Integer.parseInt(s) == 0) {\\n                continue;\\n            }\\n            if(num%(Integer.parseInt(s))==0) {\\n                numberOfDivisors++;\\n            }\\n        }\\n        return numberOfDivisors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String number = String.valueOf(num);\\n        String s = number.substring(0,k);\\n        int numberOfDivisors = 0;\\n        if((Integer.parseInt(s) != 0) && num%(Integer.parseInt(s)) == 0) {\\n            numberOfDivisors++;\\n        }\\n        for(int i=k;i<number.length();i++) {\\n            s = s.substring(1)+String.valueOf(number.charAt(i));\\n            if(Integer.parseInt(s) == 0) {\\n                continue;\\n            }\\n            if(num%(Integer.parseInt(s))==0) {\\n                numberOfDivisors++;\\n            }\\n        }\\n        return numberOfDivisors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977305,
                "title": "python-solution-sliding-window",
                "content": "# Intuition\\nSliding Window\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        res = str(num)\\n        \\n        for i in range(len(res)-k+1):\\n            nums = int(res[i:i+k])\\n            print(nums)\\n            \\n            if nums != 0 and num % nums == 0:\\n                count += 1\\n\\n        \\n        return count\\n\\n        \\n\\n       \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        res = str(num)\\n        \\n        for i in range(len(res)-k+1):\\n            nums = int(res[i:i+k])\\n            print(nums)\\n            \\n            if nums != 0 and num % nums == 0:\\n                count += 1\\n\\n        \\n        return count\\n\\n        \\n\\n       \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973542,
                "title": "sliding-window-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n=s.size();\\n        int ans=0,i=0,j=0;\\n        string temp=\"\";\\n        while(j<n)\\n        {\\n            temp +=s[j];\\n            if(j-i+1 < k) j++;\\n            else if(j-i+1 == k)\\n            {\\n                int a = stoi(temp);\\n                if( a!=0 && num % a == 0) ans++;\\n                temp=temp.substr(1);\\n                i++;\\n                j++; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n=s.size();\\n        int ans=0,i=0,j=0;\\n        string temp=\"\";\\n        while(j<n)\\n        {\\n            temp +=s[j];\\n            if(j-i+1 < k) j++;\\n            else if(j-i+1 == k)\\n            {\\n                int a = stoi(temp);\\n                if( a!=0 && num % a == 0) ans++;\\n                temp=temp.substr(1);\\n                i++;\\n                j++; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970463,
                "title": "optimized-solution-in-java",
                "content": "# Intuition- Easy\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach- Sliding window approach\\nRemember the loop has to end in len-(k-1) and not len-k-1 these are two different things\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String strValue = String.valueOf(num);\\n        int len = strValue.length();\\n        int count = 0;\\n        for(int i=0;i<len-(k-1);i++){\\n            String tempNum = strValue.substring(i,i+k);\\n            int subDigit = Integer.parseInt(tempNum);\\n            if(subDigit!=0 && num%subDigit == 0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String strValue = String.valueOf(num);\\n        int len = strValue.length();\\n        int count = 0;\\n        for(int i=0;i<len-(k-1);i++){\\n            String tempNum = strValue.substring(i,i+k);\\n            int subDigit = Integer.parseInt(tempNum);\\n            if(subDigit!=0 && num%subDigit == 0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968312,
                "title": "c-sliding-window-easy-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose we have \\nnum = 120, and k = 2.\\n\\nExplanation\\n\\nThe goal of this code is to find the number of substrings of length k in the given number num such that the substring is a divisor of the original number.\\n\\nConvert the number to a string:\\n\\n1. Initialize pointers and counters:\\n\\nint i = 0; // Starting index of substring\\nint j = 0; // Ending index of substring\\nint count = 0; // Counter for valid substrings\\nint n = str.length(); // Length of the number string (3 in this case)\\n2. Iterate through the string:\\n3. The code uses a SLIDNG WINDOW approach to consider all possible substrings of length k.\\n\\n4. i and j initially point to the beginning of the string.\\n5. The loop continues until j reaches the end of the string.\\n6. Check the length of the substring:\\n\\n7. If the length of the substring j - i + 1 is less than k, move the end pointer j to the right.\\n8. If the length of the substring is equal to k, perform the following steps:\\n9. Extract the substring:\\n\\n10. Convert the substring to an integer:\\n\\n11. Check if the substring is a divisor of the original number:\\n\\n12. If the extracted integer n1 is not zero and the original number num is divisible by n1, increment the count variable.\\n13. Move the pointers:\\n\\n14. Increment both i and j to consider the next substring.\\nRepeat the above steps until the end of the string is reached.\\n\\nFor the given example (num = 120, k = 2):\\n\\nThe substring \"12\" is extracted and converted to an integer (n1 = 12).\\nSince 120 is divisible by 12, increment the count to 1.\\nThe final value of count would be 1, indicating that there is 1 valid substring of length 2 that is a divisor of the number 120.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(d) where d is the number of digits in the input number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int n = str.length();\\n        while(j < n)\\n        {\\n            if(j-i+1 < k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1 == k)\\n            {\\n                string sr = str.substr(i,k);\\n                int n1 = stoi(sr);\\n                if(n1 !=0 && num% n1==0) count++;\\n\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int n = str.length();\\n        while(j < n)\\n        {\\n            if(j-i+1 < k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1 == k)\\n            {\\n                string sr = str.substr(i,k);\\n                int n1 = stoi(sr);\\n                if(n1 !=0 && num% n1==0) count++;\\n\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965563,
                "title": "python3-very-short-efficient-and-clean-code-working",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        strNum = str(num)\\n        k_beauty = 0\\n        for i in range(len(strNum)-k+1):\\n            temp = int(strNum[i:i+k])\\n            if temp !=0:\\n                if num % temp ==0:\\n                    k_beauty +=1\\n        return k_beauty\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        strNum = str(num)\\n        k_beauty = 0\\n        for i in range(len(strNum)-k+1):\\n            temp = int(strNum[i:i+k])\\n            if temp !=0:\\n                if num % temp ==0:\\n                    k_beauty +=1\\n        return k_beauty\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963937,
                "title": "in-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size();\\n        int count = 0;\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            string temp = s.substr(i,k);\\n            int x = stoi(temp);\\n            if(x != 0 && num%x == 0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string s = to_string(num);\\n        int n = s.size();\\n        int count = 0;\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            string temp = s.substr(i,k);\\n            int x = stoi(temp);\\n            if(x != 0 && num%x == 0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960594,
                "title": "0ms-1-97mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc divisorSubstrings(num int, k int) int {\\n\\ta, res := strconv.Itoa(num), 0\\n\\n\\tfor i := 0; i < len(a)-k+1; i++ {\\n\\t\\tstr := a[i : i+k]\\n\\t\\tsub, _ := strconv.Atoi(str)\\n\\t\\tif sub != 0 && num%sub == 0 {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc divisorSubstrings(num int, k int) int {\\n\\ta, res := strconv.Itoa(num), 0\\n\\n\\tfor i := 0; i < len(a)-k+1; i++ {\\n\\t\\tstr := a[i : i+k]\\n\\t\\tsub, _ := strconv.Atoi(str)\\n\\t\\tif sub != 0 && num%sub == 0 {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958049,
                "title": "no-strings-used-o-n-solution-most-optimized-o-n-beats-100-0-ms-solution-trivial",
                "content": "# Approach\\n1. Check if num is equal to 1000000000. If true, return 1.\\n\\n2. Initialize d to count the number of digits in num, and kbeauty to count the k-beautiful substrings.\\n\\n3. Calculate n as 10^k.\\n\\n4. Loop through the digits of num using a sliding window approach:\\n\\n5. Extract the last k digits using nn = temp % n.\\nIf nn is not 0 and num % nn is 0, increment kbeauty.\\nSlide the window by dividing temp by 10 and decrement d by 1.\\nReturn the value of kbeauty, which represents the count of k-beautiful substrings.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        if (num == 1000000000) return 1;\\n        int kbeauty = 0, n = int(pow(10, k));\\n        int d = 0;\\n        int temp = num;\\n        for (int t = num; t > 0; t /= 10) d++;\\n        while (temp > 0 && d>=k) {\\n            int nn = temp%n;\\n            if (nn != 0 && num%nn == 0) kbeauty++;\\n            temp /= 10;\\n            d -= 1;\\n        }\\n        return kbeauty;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        if (num == 1000000000) return 1;\\n        int kbeauty = 0, n = int(pow(10, k));\\n        int d = 0;\\n        int temp = num;\\n        for (int t = num; t > 0; t /= 10) d++;\\n        while (temp > 0 && d>=k) {\\n            int nn = temp%n;\\n            if (nn != 0 && num%nn == 0) kbeauty++;\\n            temp /= 10;\\n            d -= 1;\\n        }\\n        return kbeauty;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957874,
                "title": "the-most-easiest-solution-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int count = 0;\\n        int n = str.length();\\n        \\n        for (int i = 0; i <= n - k; ++i) {\\n            string s = str.substr(i, k);\\n            int m = stoi(s);\\n            \\n            if (m != 0 && num % m == 0) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int count = 0;\\n        int n = str.length();\\n        \\n        for (int i = 0; i <= n - k; ++i) {\\n            string s = str.substr(i, k);\\n            int m = stoi(s);\\n            \\n            if (m != 0 && num % m == 0) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956776,
                "title": "beats-95",
                "content": "# Approach\\nUsed String Operations\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution(object):\\n    def divisorSubstrings(self, num, k):\\n        number = str(num)\\n        count = 0\\n        for i in range(len(number)):\\n            try:\\n                if len(number[i:i+k])==k and num%(int(number[i:i+k]))==0:\\n#                         print(number[i:i+k])\\n                        count+=1\\n            except: \\n                continue\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def divisorSubstrings(self, num, k):\\n        number = str(num)\\n        count = 0\\n        for i in range(len(number)):\\n            try:\\n                if len(number[i:i+k])==k and num%(int(number[i:i+k]))==0:\\n#                         print(number[i:i+k])\\n                        count+=1\\n            except: \\n                continue\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954184,
                "title": "using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        str1 = str(num)\\n        i=0\\n        j = k\\n        count = 0\\n        while i <= len(str1)-j:\\n            b = int(str1[i:k])\\n#         print(b)\\n            i += 1\\n            k +=1\\n            if b == 0:\\n                continue\\n            elif num % b == 0:\\n                count = count + 1\\n            else:\\n                pass\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        str1 = str(num)\\n        i=0\\n        j = k\\n        count = 0\\n        while i <= len(str1)-j:\\n            b = int(str1[i:k])\\n#         print(b)\\n            i += 1\\n            k +=1\\n            if b == 0:\\n                continue\\n            elif num % b == 0:\\n                count = count + 1\\n            else:\\n                pass\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954138,
                "title": "fixed-sliding-window-space-complexity-o-1-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    let beauty = 0;\\n    let numArr = num.toString()\\n    for(let i = 0; i <= numArr.length -k;i++){\\n        let trial = numArr.substring(i, i+k);\\n        if(parseInt(trial) && !(num % parseInt(trial))){\\n            beauty++;\\n        }\\n    }\\n    return beauty;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar divisorSubstrings = function(num, k) {\\n    let beauty = 0;\\n    let numArr = num.toString()\\n    for(let i = 0; i <= numArr.length -k;i++){\\n        let trial = numArr.substring(i, i+k);\\n        if(parseInt(trial) && !(num % parseInt(trial))){\\n            beauty++;\\n        }\\n    }\\n    return beauty;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952113,
                "title": "java-0ms-simple-solution-without-converting-num-to-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int n, int k) {\\n        int x=1, y, w, a=0;\\n        for(int i=0; i<k; i++)x*=10;\\n        y=x/10;\\n\\n        for(int z=n; z>=y; z/=10){\\n            w=z%x;\\n            if(w>0 && n%w==0)a++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int n, int k) {\\n        int x=1, y, w, a=0;\\n        for(int i=0; i<k; i++)x*=10;\\n        y=x/10;\\n\\n        for(int z=n; z>=y; z/=10){\\n            w=z%x;\\n            if(w>0 && n%w==0)a++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948335,
                "title": "java-fastest",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String s = String.valueOf(num);\\n        int count = 0;\\n\\n        for(int i = 0; i <= s.length()-k; i++){\\n            int divisor = Integer.valueOf(s.substring(i, i + k));\\n            \\n            if(divisor == 0) continue;\\n            \\n            if(num % divisor == 0)\\n               count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divisorSubstrings(int num, int k) {\\n        String s = String.valueOf(num);\\n        int count = 0;\\n\\n        for(int i = 0; i <= s.length()-k; i++){\\n            int divisor = Integer.valueOf(s.substring(i, i + k));\\n            \\n            if(divisor == 0) continue;\\n            \\n            if(num % divisor == 0)\\n               count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947792,
                "title": "c-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int i = 0;\\n        int j = k-1;\\n        int count = 0;\\n        while(j<str.length()){\\n            string a = str.substr(i,j-i+1);\\n            int n = stoi(a);\\n            if(n!=0 && num%n==0) count++;\\n            i++;\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divisorSubstrings(int num, int k) {\\n        string str = to_string(num);\\n        int i = 0;\\n        int j = k-1;\\n        int count = 0;\\n        while(j<str.length()){\\n            string a = str.substr(i,j-i+1);\\n            int n = stoi(a);\\n            if(n!=0 && num%n==0) count++;\\n            i++;\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947782,
                "title": "simple-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def divisorSubstrings(self, num, k):\\n        \"\"\"\\n        :type num: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        self.num = str(num)\\n        self.k = k\\n\\n        k_beauty = 0\\n\\n        for i in range(len(self.num) - (k - 1)):\\n            test_num = int(self.num[i:i + k])\\n            if test_num != 0:    \\n                if int(self.num) % test_num == 0:\\n                    k_beauty += 1\\n        \\n        return k_beauty\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def divisorSubstrings(self, num, k):\\n        \"\"\"\\n        :type num: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        self.num = str(num)\\n        self.k = k\\n\\n        k_beauty = 0\\n\\n        for i in range(len(self.num) - (k - 1)):\\n            test_num = int(self.num[i:i + k])\\n            if test_num != 0:    \\n                if int(self.num) % test_num == 0:\\n                    k_beauty += 1\\n        \\n        return k_beauty\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942993,
                "title": "easy-sliding-window-javascript-solution",
                "content": "**SLIDING WINDOW**\\n\\n> Time: O(n) | Space: O(1)\\n> \\n\\n```jsx\\nvar divisorSubstrings = function(num, k) {\\n  let stringNum = String(num); // turn number into string\\n  let count = 0; \\n  let left = 0;\\n  \\n  // start at k-1 because zero-based indexing\\n  for (let right = k-1; right < stringNum.length; right++) {\\n    let currNum = Number(stringNum.slice(left, right + 1)); // right + 1 because slice() extracts up to but not including end\\n    if (num % currNum === 0) count++; // if original num is divisible by current num substring, increment count\\n    left++; // shift left pointer for next iteration\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```jsx\\nvar divisorSubstrings = function(num, k) {\\n  let stringNum = String(num); // turn number into string\\n  let count = 0; \\n  let left = 0;\\n  \\n  // start at k-1 because zero-based indexing\\n  for (let right = k-1; right < stringNum.length; right++) {\\n    let currNum = Number(stringNum.slice(left, right + 1)); // right + 1 because slice() extracts up to but not including end\\n    if (num % currNum === 0) count++; // if original num is divisible by current num substring, increment count\\n    left++; // shift left pointer for next iteration\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942521,
                "title": "python-solution-o-n",
                "content": "\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        for i in range(len(str(num))-k+1):\\n            subnum = int(str(num)[i:i+k])\\n            if subnum == 0: continue\\n            if num % subnum == 0: count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        for i in range(len(str(num))-k+1):\\n            subnum = int(str(num)[i:i+k])\\n            if subnum == 0: continue\\n            if num % subnum == 0: count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942520,
                "title": "python-solution-o-n",
                "content": "\\n```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        for i in range(len(str(num))-k+1):\\n            subnum = int(str(num)[i:i+k])\\n            if subnum == 0: continue\\n            if num % subnum == 0: count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divisorSubstrings(self, num: int, k: int) -> int:\\n        count = 0\\n        for i in range(len(str(num))-k+1):\\n            subnum = int(str(num)[i:i+k])\\n            if subnum == 0: continue\\n            if num % subnum == 0: count+=1\\n        return count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1673179,
                "content": [
                    {
                        "username": "samarths",
                        "content": "This should be medium question."
                    },
                    {
                        "username": "Akshay75287",
                        "content": "This is so easy what are you talking about"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "That\\'s an easy one. Even if you don\\'t apply sliding window."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "no it shouldn\\'t !!! what part u found difficult in this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Only if you solve it without using ``string``. Otherwise, easy."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Programmers have to find beauty in numbers. Sighs for the actual beautiful things in nature."
                    },
                    {
                        "username": "eduard92",
                        "content": "So.. I am going on a Sliding Window spree... this is the third question in row when somebody in discussions saying it should be medium, makes my day as I feel I get better, in reality I still feel at an easy level."
                    },
                    {
                        "username": "f20200445",
                        "content": "In C++ time complexity of substr() is O(k), and if we call substring for each iteration dosent that make the time complexity O(n*k) where n is string length and k is window size. So dosent that defeat the whole point of using sliding window because we dont get a O(n) complexity?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "the essence is that you don\\'t really use the substring function each time you have a valid window to check whether the number represented by the current window is a divisor of the original \\'num\\' number or not. You can think in the direction of maintaining a single integer variable which represents the number in the current valid window, i.e., if a valid window is \"123\" the variable, let us say curr should be 123 (integer), How do we do that? think in terms of bases and how the base 10 number system works, more specifically, If I were to ask you to print the individual digits of a number, how would you do that? Also what do we do when the window gets invalid, well just remove the invalid number from the current number, i.e., if k = 2, just remove 1 from 123 to get 23. How do we do that now? the answer again is pretty similar to the logic that will be used above!"
                    },
                    {
                        "username": "JV_004",
                        "content": "definitely not an easy one."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "How come?"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "It is a eay problem ,convert the number into vector,then use sliding window ,in the sliding window convert the vector elements of length k into a number ,after completion of inner loop check the divisilibity condition if the number is non-zero,for better understanding check my solution in solution tab\n"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "JAVA HELP!!\\nI don\\'t know why my code gives arithemetic exception in leetcode compiler at line no. 9, I run my same code in Online Java compiler where it was execute completely without any error with correct output.\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/"
                    },
                    {
                        "username": "Ayush-Vardhan-03",
                        "content": "Because in here input also includes \\'zero\\', and if you divide any number by zero you will get an error, while in online java compiler you probably aren\\'t giving such input which will throw you an arithmetic error."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "How are we supposed to guess what\\'s in line#9 of your code, dude? ;)"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Use a normal sliding window and increment the count only if the number generated by the sliding window(fixed size of k) is not zero and a divisor.. Check out my solution in solutions tab -->"
                    }
                ]
            },
            {
                "id": 1835941,
                "content": [
                    {
                        "username": "samarths",
                        "content": "This should be medium question."
                    },
                    {
                        "username": "Akshay75287",
                        "content": "This is so easy what are you talking about"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "That\\'s an easy one. Even if you don\\'t apply sliding window."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "no it shouldn\\'t !!! what part u found difficult in this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Only if you solve it without using ``string``. Otherwise, easy."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Programmers have to find beauty in numbers. Sighs for the actual beautiful things in nature."
                    },
                    {
                        "username": "eduard92",
                        "content": "So.. I am going on a Sliding Window spree... this is the third question in row when somebody in discussions saying it should be medium, makes my day as I feel I get better, in reality I still feel at an easy level."
                    },
                    {
                        "username": "f20200445",
                        "content": "In C++ time complexity of substr() is O(k), and if we call substring for each iteration dosent that make the time complexity O(n*k) where n is string length and k is window size. So dosent that defeat the whole point of using sliding window because we dont get a O(n) complexity?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "the essence is that you don\\'t really use the substring function each time you have a valid window to check whether the number represented by the current window is a divisor of the original \\'num\\' number or not. You can think in the direction of maintaining a single integer variable which represents the number in the current valid window, i.e., if a valid window is \"123\" the variable, let us say curr should be 123 (integer), How do we do that? think in terms of bases and how the base 10 number system works, more specifically, If I were to ask you to print the individual digits of a number, how would you do that? Also what do we do when the window gets invalid, well just remove the invalid number from the current number, i.e., if k = 2, just remove 1 from 123 to get 23. How do we do that now? the answer again is pretty similar to the logic that will be used above!"
                    },
                    {
                        "username": "JV_004",
                        "content": "definitely not an easy one."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "How come?"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "It is a eay problem ,convert the number into vector,then use sliding window ,in the sliding window convert the vector elements of length k into a number ,after completion of inner loop check the divisilibity condition if the number is non-zero,for better understanding check my solution in solution tab\n"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "JAVA HELP!!\\nI don\\'t know why my code gives arithemetic exception in leetcode compiler at line no. 9, I run my same code in Online Java compiler where it was execute completely without any error with correct output.\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/"
                    },
                    {
                        "username": "Ayush-Vardhan-03",
                        "content": "Because in here input also includes \\'zero\\', and if you divide any number by zero you will get an error, while in online java compiler you probably aren\\'t giving such input which will throw you an arithmetic error."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "How are we supposed to guess what\\'s in line#9 of your code, dude? ;)"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Use a normal sliding window and increment the count only if the number generated by the sliding window(fixed size of k) is not zero and a divisor.. Check out my solution in solutions tab -->"
                    }
                ]
            },
            {
                "id": 1987242,
                "content": [
                    {
                        "username": "samarths",
                        "content": "This should be medium question."
                    },
                    {
                        "username": "Akshay75287",
                        "content": "This is so easy what are you talking about"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "That\\'s an easy one. Even if you don\\'t apply sliding window."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "no it shouldn\\'t !!! what part u found difficult in this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Only if you solve it without using ``string``. Otherwise, easy."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Programmers have to find beauty in numbers. Sighs for the actual beautiful things in nature."
                    },
                    {
                        "username": "eduard92",
                        "content": "So.. I am going on a Sliding Window spree... this is the third question in row when somebody in discussions saying it should be medium, makes my day as I feel I get better, in reality I still feel at an easy level."
                    },
                    {
                        "username": "f20200445",
                        "content": "In C++ time complexity of substr() is O(k), and if we call substring for each iteration dosent that make the time complexity O(n*k) where n is string length and k is window size. So dosent that defeat the whole point of using sliding window because we dont get a O(n) complexity?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "the essence is that you don\\'t really use the substring function each time you have a valid window to check whether the number represented by the current window is a divisor of the original \\'num\\' number or not. You can think in the direction of maintaining a single integer variable which represents the number in the current valid window, i.e., if a valid window is \"123\" the variable, let us say curr should be 123 (integer), How do we do that? think in terms of bases and how the base 10 number system works, more specifically, If I were to ask you to print the individual digits of a number, how would you do that? Also what do we do when the window gets invalid, well just remove the invalid number from the current number, i.e., if k = 2, just remove 1 from 123 to get 23. How do we do that now? the answer again is pretty similar to the logic that will be used above!"
                    },
                    {
                        "username": "JV_004",
                        "content": "definitely not an easy one."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "How come?"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "It is a eay problem ,convert the number into vector,then use sliding window ,in the sliding window convert the vector elements of length k into a number ,after completion of inner loop check the divisilibity condition if the number is non-zero,for better understanding check my solution in solution tab\n"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "JAVA HELP!!\\nI don\\'t know why my code gives arithemetic exception in leetcode compiler at line no. 9, I run my same code in Online Java compiler where it was execute completely without any error with correct output.\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/"
                    },
                    {
                        "username": "Ayush-Vardhan-03",
                        "content": "Because in here input also includes \\'zero\\', and if you divide any number by zero you will get an error, while in online java compiler you probably aren\\'t giving such input which will throw you an arithmetic error."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "How are we supposed to guess what\\'s in line#9 of your code, dude? ;)"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Use a normal sliding window and increment the count only if the number generated by the sliding window(fixed size of k) is not zero and a divisor.. Check out my solution in solutions tab -->"
                    }
                ]
            },
            {
                "id": 1857251,
                "content": [
                    {
                        "username": "samarths",
                        "content": "This should be medium question."
                    },
                    {
                        "username": "Akshay75287",
                        "content": "This is so easy what are you talking about"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "That\\'s an easy one. Even if you don\\'t apply sliding window."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "no it shouldn\\'t !!! what part u found difficult in this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Only if you solve it without using ``string``. Otherwise, easy."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Programmers have to find beauty in numbers. Sighs for the actual beautiful things in nature."
                    },
                    {
                        "username": "eduard92",
                        "content": "So.. I am going on a Sliding Window spree... this is the third question in row when somebody in discussions saying it should be medium, makes my day as I feel I get better, in reality I still feel at an easy level."
                    },
                    {
                        "username": "f20200445",
                        "content": "In C++ time complexity of substr() is O(k), and if we call substring for each iteration dosent that make the time complexity O(n*k) where n is string length and k is window size. So dosent that defeat the whole point of using sliding window because we dont get a O(n) complexity?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "the essence is that you don\\'t really use the substring function each time you have a valid window to check whether the number represented by the current window is a divisor of the original \\'num\\' number or not. You can think in the direction of maintaining a single integer variable which represents the number in the current valid window, i.e., if a valid window is \"123\" the variable, let us say curr should be 123 (integer), How do we do that? think in terms of bases and how the base 10 number system works, more specifically, If I were to ask you to print the individual digits of a number, how would you do that? Also what do we do when the window gets invalid, well just remove the invalid number from the current number, i.e., if k = 2, just remove 1 from 123 to get 23. How do we do that now? the answer again is pretty similar to the logic that will be used above!"
                    },
                    {
                        "username": "JV_004",
                        "content": "definitely not an easy one."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "How come?"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "It is a eay problem ,convert the number into vector,then use sliding window ,in the sliding window convert the vector elements of length k into a number ,after completion of inner loop check the divisilibity condition if the number is non-zero,for better understanding check my solution in solution tab\n"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "JAVA HELP!!\\nI don\\'t know why my code gives arithemetic exception in leetcode compiler at line no. 9, I run my same code in Online Java compiler where it was execute completely without any error with correct output.\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/"
                    },
                    {
                        "username": "Ayush-Vardhan-03",
                        "content": "Because in here input also includes \\'zero\\', and if you divide any number by zero you will get an error, while in online java compiler you probably aren\\'t giving such input which will throw you an arithmetic error."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "How are we supposed to guess what\\'s in line#9 of your code, dude? ;)"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Use a normal sliding window and increment the count only if the number generated by the sliding window(fixed size of k) is not zero and a divisor.. Check out my solution in solutions tab -->"
                    }
                ]
            },
            {
                "id": 1756256,
                "content": [
                    {
                        "username": "samarths",
                        "content": "This should be medium question."
                    },
                    {
                        "username": "Akshay75287",
                        "content": "This is so easy what are you talking about"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "That\\'s an easy one. Even if you don\\'t apply sliding window."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "no it shouldn\\'t !!! what part u found difficult in this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Only if you solve it without using ``string``. Otherwise, easy."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Programmers have to find beauty in numbers. Sighs for the actual beautiful things in nature."
                    },
                    {
                        "username": "eduard92",
                        "content": "So.. I am going on a Sliding Window spree... this is the third question in row when somebody in discussions saying it should be medium, makes my day as I feel I get better, in reality I still feel at an easy level."
                    },
                    {
                        "username": "f20200445",
                        "content": "In C++ time complexity of substr() is O(k), and if we call substring for each iteration dosent that make the time complexity O(n*k) where n is string length and k is window size. So dosent that defeat the whole point of using sliding window because we dont get a O(n) complexity?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "the essence is that you don\\'t really use the substring function each time you have a valid window to check whether the number represented by the current window is a divisor of the original \\'num\\' number or not. You can think in the direction of maintaining a single integer variable which represents the number in the current valid window, i.e., if a valid window is \"123\" the variable, let us say curr should be 123 (integer), How do we do that? think in terms of bases and how the base 10 number system works, more specifically, If I were to ask you to print the individual digits of a number, how would you do that? Also what do we do when the window gets invalid, well just remove the invalid number from the current number, i.e., if k = 2, just remove 1 from 123 to get 23. How do we do that now? the answer again is pretty similar to the logic that will be used above!"
                    },
                    {
                        "username": "JV_004",
                        "content": "definitely not an easy one."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "How come?"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "It is a eay problem ,convert the number into vector,then use sliding window ,in the sliding window convert the vector elements of length k into a number ,after completion of inner loop check the divisilibity condition if the number is non-zero,for better understanding check my solution in solution tab\n"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "JAVA HELP!!\\nI don\\'t know why my code gives arithemetic exception in leetcode compiler at line no. 9, I run my same code in Online Java compiler where it was execute completely without any error with correct output.\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/"
                    },
                    {
                        "username": "Ayush-Vardhan-03",
                        "content": "Because in here input also includes \\'zero\\', and if you divide any number by zero you will get an error, while in online java compiler you probably aren\\'t giving such input which will throw you an arithmetic error."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "How are we supposed to guess what\\'s in line#9 of your code, dude? ;)"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Use a normal sliding window and increment the count only if the number generated by the sliding window(fixed size of k) is not zero and a divisor.. Check out my solution in solutions tab -->"
                    }
                ]
            },
            {
                "id": 1995290,
                "content": [
                    {
                        "username": "samarths",
                        "content": "This should be medium question."
                    },
                    {
                        "username": "Akshay75287",
                        "content": "This is so easy what are you talking about"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "That\\'s an easy one. Even if you don\\'t apply sliding window."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "no it shouldn\\'t !!! what part u found difficult in this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Only if you solve it without using ``string``. Otherwise, easy."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Programmers have to find beauty in numbers. Sighs for the actual beautiful things in nature."
                    },
                    {
                        "username": "eduard92",
                        "content": "So.. I am going on a Sliding Window spree... this is the third question in row when somebody in discussions saying it should be medium, makes my day as I feel I get better, in reality I still feel at an easy level."
                    },
                    {
                        "username": "f20200445",
                        "content": "In C++ time complexity of substr() is O(k), and if we call substring for each iteration dosent that make the time complexity O(n*k) where n is string length and k is window size. So dosent that defeat the whole point of using sliding window because we dont get a O(n) complexity?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "the essence is that you don\\'t really use the substring function each time you have a valid window to check whether the number represented by the current window is a divisor of the original \\'num\\' number or not. You can think in the direction of maintaining a single integer variable which represents the number in the current valid window, i.e., if a valid window is \"123\" the variable, let us say curr should be 123 (integer), How do we do that? think in terms of bases and how the base 10 number system works, more specifically, If I were to ask you to print the individual digits of a number, how would you do that? Also what do we do when the window gets invalid, well just remove the invalid number from the current number, i.e., if k = 2, just remove 1 from 123 to get 23. How do we do that now? the answer again is pretty similar to the logic that will be used above!"
                    },
                    {
                        "username": "JV_004",
                        "content": "definitely not an easy one."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "How come?"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "It is a eay problem ,convert the number into vector,then use sliding window ,in the sliding window convert the vector elements of length k into a number ,after completion of inner loop check the divisilibity condition if the number is non-zero,for better understanding check my solution in solution tab\n"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "JAVA HELP!!\\nI don\\'t know why my code gives arithemetic exception in leetcode compiler at line no. 9, I run my same code in Online Java compiler where it was execute completely without any error with correct output.\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/"
                    },
                    {
                        "username": "Ayush-Vardhan-03",
                        "content": "Because in here input also includes \\'zero\\', and if you divide any number by zero you will get an error, while in online java compiler you probably aren\\'t giving such input which will throw you an arithmetic error."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "How are we supposed to guess what\\'s in line#9 of your code, dude? ;)"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Use a normal sliding window and increment the count only if the number generated by the sliding window(fixed size of k) is not zero and a divisor.. Check out my solution in solutions tab -->"
                    }
                ]
            },
            {
                "id": 1758737,
                "content": [
                    {
                        "username": "samarths",
                        "content": "This should be medium question."
                    },
                    {
                        "username": "Akshay75287",
                        "content": "This is so easy what are you talking about"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "That\\'s an easy one. Even if you don\\'t apply sliding window."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "no it shouldn\\'t !!! what part u found difficult in this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Only if you solve it without using ``string``. Otherwise, easy."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Programmers have to find beauty in numbers. Sighs for the actual beautiful things in nature."
                    },
                    {
                        "username": "eduard92",
                        "content": "So.. I am going on a Sliding Window spree... this is the third question in row when somebody in discussions saying it should be medium, makes my day as I feel I get better, in reality I still feel at an easy level."
                    },
                    {
                        "username": "f20200445",
                        "content": "In C++ time complexity of substr() is O(k), and if we call substring for each iteration dosent that make the time complexity O(n*k) where n is string length and k is window size. So dosent that defeat the whole point of using sliding window because we dont get a O(n) complexity?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "the essence is that you don\\'t really use the substring function each time you have a valid window to check whether the number represented by the current window is a divisor of the original \\'num\\' number or not. You can think in the direction of maintaining a single integer variable which represents the number in the current valid window, i.e., if a valid window is \"123\" the variable, let us say curr should be 123 (integer), How do we do that? think in terms of bases and how the base 10 number system works, more specifically, If I were to ask you to print the individual digits of a number, how would you do that? Also what do we do when the window gets invalid, well just remove the invalid number from the current number, i.e., if k = 2, just remove 1 from 123 to get 23. How do we do that now? the answer again is pretty similar to the logic that will be used above!"
                    },
                    {
                        "username": "JV_004",
                        "content": "definitely not an easy one."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "How come?"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "It is a eay problem ,convert the number into vector,then use sliding window ,in the sliding window convert the vector elements of length k into a number ,after completion of inner loop check the divisilibity condition if the number is non-zero,for better understanding check my solution in solution tab\n"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "JAVA HELP!!\\nI don\\'t know why my code gives arithemetic exception in leetcode compiler at line no. 9, I run my same code in Online Java compiler where it was execute completely without any error with correct output.\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/"
                    },
                    {
                        "username": "Ayush-Vardhan-03",
                        "content": "Because in here input also includes \\'zero\\', and if you divide any number by zero you will get an error, while in online java compiler you probably aren\\'t giving such input which will throw you an arithmetic error."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "How are we supposed to guess what\\'s in line#9 of your code, dude? ;)"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Use a normal sliding window and increment the count only if the number generated by the sliding window(fixed size of k) is not zero and a divisor.. Check out my solution in solutions tab -->"
                    }
                ]
            },
            {
                "id": 1670615,
                "content": [
                    {
                        "username": "samarths",
                        "content": "This should be medium question."
                    },
                    {
                        "username": "Akshay75287",
                        "content": "This is so easy what are you talking about"
                    },
                    {
                        "username": "as_runtime123",
                        "content": "That\\'s an easy one. Even if you don\\'t apply sliding window."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "no it shouldn\\'t !!! what part u found difficult in this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Only if you solve it without using ``string``. Otherwise, easy."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Programmers have to find beauty in numbers. Sighs for the actual beautiful things in nature."
                    },
                    {
                        "username": "eduard92",
                        "content": "So.. I am going on a Sliding Window spree... this is the third question in row when somebody in discussions saying it should be medium, makes my day as I feel I get better, in reality I still feel at an easy level."
                    },
                    {
                        "username": "f20200445",
                        "content": "In C++ time complexity of substr() is O(k), and if we call substring for each iteration dosent that make the time complexity O(n*k) where n is string length and k is window size. So dosent that defeat the whole point of using sliding window because we dont get a O(n) complexity?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "the essence is that you don\\'t really use the substring function each time you have a valid window to check whether the number represented by the current window is a divisor of the original \\'num\\' number or not. You can think in the direction of maintaining a single integer variable which represents the number in the current valid window, i.e., if a valid window is \"123\" the variable, let us say curr should be 123 (integer), How do we do that? think in terms of bases and how the base 10 number system works, more specifically, If I were to ask you to print the individual digits of a number, how would you do that? Also what do we do when the window gets invalid, well just remove the invalid number from the current number, i.e., if k = 2, just remove 1 from 123 to get 23. How do we do that now? the answer again is pretty similar to the logic that will be used above!"
                    },
                    {
                        "username": "JV_004",
                        "content": "definitely not an easy one."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "How come?"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "It is a eay problem ,convert the number into vector,then use sliding window ,in the sliding window convert the vector elements of length k into a number ,after completion of inner loop check the divisilibity condition if the number is non-zero,for better understanding check my solution in solution tab\n"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "JAVA HELP!!\\nI don\\'t know why my code gives arithemetic exception in leetcode compiler at line no. 9, I run my same code in Online Java compiler where it was execute completely without any error with correct output.\\n\\nhttps://leetcode.com/problems/find-the-k-beauty-of-a-number/"
                    },
                    {
                        "username": "Ayush-Vardhan-03",
                        "content": "Because in here input also includes \\'zero\\', and if you divide any number by zero you will get an error, while in online java compiler you probably aren\\'t giving such input which will throw you an arithmetic error."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "How are we supposed to guess what\\'s in line#9 of your code, dude? ;)"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Use a normal sliding window and increment the count only if the number generated by the sliding window(fixed size of k) is not zero and a divisor.. Check out my solution in solutions tab -->"
                    }
                ]
            }
        ]
    }
]