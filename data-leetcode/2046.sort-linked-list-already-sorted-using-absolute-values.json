[
    {
        "title": "Count Number of Maximum Bitwise-OR Subsets",
        "question_content": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).\n&nbsp;\nExample 1:\n\nInput: nums = [3,1]\nOutput: 2\nExplanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]\n\nExample 2:\n\nInput: nums = [2,2,2]\nOutput: 7\nExplanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.\n\nExample 3:\n\nInput: nums = [3,2,1,5]\nOutput: 6\nExplanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 16\n\t1 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 1525309,
                "title": "java-c-python-dp-solution",
                "content": "# **Intuition**\\nSimilar to knapsack problem,\\nbut use bitwise-or sum instead of math sum.\\n\\n# **Explanation**\\n`dp[sum]` means the number of subsets with bitwise-or `sum`.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`, where `m = max(A)`\\nSpace `O(m)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countMaxOrSubsets(int[] A) {\\n        int max = 0, dp[] = new int[1 << 17];\\n        dp[0] = 1;\\n        for (int a : A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int max = 0, dp[1 << 17] = {1};\\n        for (int a: A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countMaxOrSubsets(self, A):\\n        dp = collections.Counter([0])\\n        for a in A:\\n            for k, v in dp.items():\\n                dp[k | a] += v\\n        return dp[max(dp)]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int countMaxOrSubsets(int[] A) {\\n        int max = 0, dp[] = new int[1 << 17];\\n        dp[0] = 1;\\n        for (int a : A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```\n```cpp\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int max = 0, dp[1 << 17] = {1};\\n        for (int a: A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```\n```py\\n    def countMaxOrSubsets(self, A):\\n        dp = collections.Counter([0])\\n        for a in A:\\n            for k, v in dp.items():\\n                dp[k | a] += v\\n        return dp[max(dp)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1525216,
                "title": "c-bitmask-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Bitmask\\n\\n1. Compute `goal` which is the maximum possible bitwise OR of a subset of `nums`, i.e. the bitwise OR of all the numbers in `nums`. \\n2. Enumerate all non-empty subsets of `nums` using bitmask and compute the bitwise OR of each of them. Increment answer if the subset\\'s bitwise OR is the same as `goal`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N * N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int goal = 0, N = A.size(), ans = 0;\\n        for (int n : A) goal |= n;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int x = 0;\\n            for (int i = 0; i < N; ++i) {\\n                if (m >> i & 1) x |= A[i];\\n            }\\n            if (x == goal) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWe can use DP to reduce the time complexity at the cost of space complexity\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int goal = 0, N = A.size(), ans = 0;\\n        vector<int> dp(1 << N);\\n        for (int n : A) goal |= n;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int lowbit = m & -m;\\n            dp[m] = dp[m - lowbit] | A[__builtin_ctz(lowbit)];\\n            if (dp[m] == goal) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N * N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int goal = 0, N = A.size(), ans = 0;\\n        for (int n : A) goal |= n;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int x = 0;\\n            for (int i = 0; i < N; ++i) {\\n                if (m >> i & 1) x |= A[i];\\n            }\\n            if (x == goal) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& A) {\\n        int goal = 0, N = A.size(), ans = 0;\\n        vector<int> dp(1 << N);\\n        for (int n : A) goal |= n;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            int lowbit = m & -m;\\n            dp[m] = dp[m - lowbit] | A[__builtin_ctz(lowbit)];\\n            if (dp[m] == goal) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525211,
                "title": "java-beats-100",
                "content": "Intuition: Accumulate the maximum bitwise value from the array then apply the subset formula to accumulate all subsets that have that value.\\n\\n```\\nclass Solution {\\n    \\n    int res = 0, target = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        for (int num : nums)\\n            target |= num;\\n        \\n        dfs(nums, 0, 0);\\n        return res;\\n    }\\n    \\n    public void dfs(int[] nums, int idx, int mask) {\\n        if (mask == target) res++;\\n        \\n        for (int i = idx; i < nums.length; i++)\\n            dfs(nums, i + 1, mask | nums[i]);\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int res = 0, target = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        for (int num : nums)\\n            target |= num;\\n        \\n        dfs(nums, 0, 0);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1525215,
                "title": "java-subset-problem-beats-100",
                "content": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return count;\\n    }\\n    \\n    int count = 0;\\n    int maxOR = 0;\\n    \\n    private void subsets(int[] arr, int vidx, int OR){\\n        \\n        if(vidx == arr.length){\\n            \\n            if(OR == maxOR){\\n                count ++;\\n            }else if(OR > maxOR){\\n                count = 1;\\n                maxOR = OR;\\n            }\\n            \\n            return;\\n        }\\n        \\n        // include\\n        subsets(arr, vidx+1, OR | arr[vidx]);\\n        \\n        // exclude\\n        subsets(arr, vidx+1, OR);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return count;\\n    }\\n    \\n    int count = 0;\\n    int maxOR = 0;\\n    \\n    private void subsets(int[] arr, int vidx, int OR){\\n        \\n        if(vidx == arr.length){\\n            \\n            if(OR == maxOR){\\n                count ++;\\n            }else if(OR > maxOR){\\n                count = 1;\\n                maxOR = OR;\\n            }\\n            \\n            return;\\n        }\\n        \\n        // include\\n        subsets(arr, vidx+1, OR | arr[vidx]);\\n        \\n        // exclude\\n        subsets(arr, vidx+1, OR);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525206,
                "title": "simple-recursive-solution",
                "content": "**Maximum Bitwise-OR** is possible when we take **bitwise-or of all the numbers.**\\n\\nStep 1: Calculate the bitwise of all the numbers.\\nStep 2: Find all bitwise of all the possible subsets recursively.\\nStep 3: Simply compare the values of step 2 with step 1\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    int subset(vector<int> &nums, int i, int a,int b)\\n    {\\n        int ans =0;\\n        if(i<0)\\n            return 0;\\n        if(a == (b|nums[i]))\\n            ans =1;\\n        return ans + subset(nums,i-1,a,b) + subset(nums,i-1,a,b|nums[i]);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int a=0;\\n        \\n        for(auto i:nums)\\n        {\\n            a = a|i;\\n        }\\n        \\n        int ans = subset(nums,nums.size()-1,a,0);\\n            \\n        return ans ;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int subset(vector<int> &nums, int i, int a,int b)\\n    {\\n        int ans =0;\\n        if(i<0)\\n            return 0;\\n        if(a == (b|nums[i]))\\n            ans =1;\\n        return ans + subset(nums,i-1,a,b) + subset(nums,i-1,a,b|nums[i]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1525200,
                "title": "c-beginner-friendly-bitmask-checking-all-subsets",
                "content": "Feel free to comment \\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int i,j,max_possible_or=0,n=nums.size(),ans=0;\\n        \\n        //maximum possible or=or of all number in array\\n        for(i=0;i<n;i++)\\n        {\\n            max_possible_or=nums[i]|max_possible_or;\\n        }\\n        \\n        //checking all subset \\n        \\n        \\n        for(i=1;i<(1<<n);i++)\\n        {\\n            int p=0;\\n            for(j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    p=p|nums[j];\\n                }\\n            }\\n            //if xor of given subset is equal to maximum possible or\\n\\t\\t\\t\\n            if(p==max_possible_or)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int i,j,max_possible_or=0,n=nums.size(),ans=0;\\n        \\n        //maximum possible or=or of all number in array\\n        for(i=0;i<n;i++)\\n        {\\n            max_possible_or=nums[i]|max_possible_or;\\n        }\\n        \\n        //checking all subset \\n        \\n        \\n        for(i=1;i<(1<<n);i++)\\n        {\\n            int p=0;\\n            for(j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    p=p|nums[j];\\n                }\\n            }\\n            //if xor of given subset is equal to maximum possible or\\n\\t\\t\\t\\n            if(p==max_possible_or)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525225,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target = reduce(or_, nums)\\n        \\n        @cache\\n        def fn(i, mask): \\n            \"\"\"Return number of subsets to get target.\"\"\"\\n            if mask == target: return 2**(len(nums)-i)\\n            if i == len(nums): return 0 \\n            return fn(i+1, mask | nums[i]) + fn(i+1, mask)\\n        \\n        return fn(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target = reduce(or_, nums)\\n        \\n        @cache\\n        def fn(i, mask): \\n            \"\"\"Return number of subsets to get target.\"\"\"\\n            if mask == target: return 2**(len(nums)-i)\\n            if i == len(nums): return 0 \\n            return fn(i+1, mask | nums[i]) + fn(i+1, mask)\\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525274,
                "title": "easy-c-solution-dp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    #define maxN 17\\n    #define maxM (1<<17)\\n\\n    int dp[maxN][maxM];\\n    bool v[maxN][maxM];\\n    int findCnt(vector<int> arr, int start, int curr, int n, int maxor)\\n{\\n    // Base case\\n    if (start == n) {\\n        return (curr == maxor);\\n    }\\n \\n    if (v[start][curr])\\n        return dp[start][curr];\\n \\n    // Setting the state as visited\\n    v[start][curr] = 1;\\n \\n    // adding the counts of including the current element and excluding the current element\\n    dp[start][curr]\\n        = findCnt(arr, start + 1, curr, n, maxor)\\n          + findCnt(arr, start + 1, (curr | arr[start]), n, maxor);\\n \\n    return dp[start][curr];\\n}\\n    \\nint OR(vector<int> data){\\n    int n = data.size();\\n    int mOR = 0;\\n    for (int i = 0; i < n; ++i) {\\n        mOR |= data[i];\\n    }\\n\\n    return mOR;\\n}\\n    \\n    int countMaxOrSubsets(vector<int>& arr) {\\n        int mor = OR(arr);\\n        return findCnt(arr,0,0,arr.size(),mor);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define maxN 17\\n    #define maxM (1<<17)\\n\\n    int dp[maxN][maxM];\\n    bool v[maxN][maxM];\\n    int findCnt(vector<int> arr, int start, int curr, int n, int maxor)\\n{\\n    // Base case\\n    if (start == n) {\\n        return (curr == maxor);\\n    }\\n \\n    if (v[start][curr])\\n        return dp[start][curr];\\n \\n    // Setting the state as visited\\n    v[start][curr] = 1;\\n \\n    // adding the counts of including the current element and excluding the current element\\n    dp[start][curr]\\n        = findCnt(arr, start + 1, curr, n, maxor)\\n          + findCnt(arr, start + 1, (curr | arr[start]), n, maxor);\\n \\n    return dp[start][curr];\\n}\\n    \\nint OR(vector<int> data){\\n    int n = data.size();\\n    int mOR = 0;\\n    for (int i = 0; i < n; ++i) {\\n        mOR |= data[i];\\n    }\\n\\n    return mOR;\\n}\\n    \\n    int countMaxOrSubsets(vector<int>& arr) {\\n        int mor = OR(arr);\\n        return findCnt(arr,0,0,arr.size(),mor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659354,
                "title": "easiest-best-solution-in-c-o-1-sc",
                "content": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void calculate(int ind, vector<int>& nums, int size, int bitOR, int x){\\n        if(ind==size){\\n            if(x==bitOR)\\n                count++;\\n            return;\\n        }\\n        calculate(ind+1, nums, size, bitOR, x | nums[ind]);\\n        calculate(ind+1, nums, size, bitOR, x);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int size=nums.size(),bitOR=0;\\n        for(auto it:nums)\\n            bitOR |= it;\\n        calculate(0, nums, size, bitOR, 0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void calculate(int ind, vector<int>& nums, int size, int bitOR, int x){\\n        if(ind==size){\\n            if(x==bitOR)\\n                count++;\\n            return;\\n        }\\n        calculate(ind+1, nums, size, bitOR, x | nums[ind]);\\n        calculate(ind+1, nums, size, bitOR, x);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int size=nums.size(),bitOR=0;\\n        for(auto it:nums)\\n            bitOR |= it;\\n        calculate(0, nums, size, bitOR, 0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681134,
                "title": "optimized-c-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe bitwise OR operation\\'s result always has ith bit set, whenever any one of the bits is set. Thus, the maximum possible value of the bitwise OR of any subset of array a is the bitwise OR of array a itself!\\nNow the question boils down to the simpler question of \\n\"Given a target t, find the number of subsets in array a whose bitwise OR is equal to t.\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the number of subsets, we can simply follow a two step approach.\\n1. Find the maximum bitwise OR of the array by simply traversing through the array and taking bitwise OR of every element. Store the result in target variable.\\n2. Now we use a Backtracking approach of finding the number of subsets by following the principle of  **\"Take and Not Take\"**.\\n\\n##### RECURSIVE FORMULATION:\\n **DEFINITION :** The function **f(idx, target)** denotes the count of **subsets ranging from index i to n-1** having bitwise OR equal to target\\n1. **Take** : f(idx+1,(curr | nums[idx]));\\n2. **Not Take** : f(idx+1,curr);\\n\\nWe have to take every possible subset into our consideration, therefore,\\n`return f(idx + 1,(curr | nums[idx])) + f(idx + 1,curr));`\\n\\n##### BASE CASE:\\nWe only have a single base case wherein, if we ever reach out of bound i.e., idx == n, then we are simply going to check one thing.\\n> if(curr == target)   return 1;\\n> else return 0;\\n\\nAlthough not in code, but we can simplify the code even further by replacing with a single line:\\n> return (target == curr);\\n\\nHowever, i am suspicious that replacing it might end up using some extra time but anyway :-)\\n\\n# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n# EXPLANATION FOR TIME AND SPACE COMPLEXITY\\n\\n> **TIME COMPLEXITY** : At every index, we have two options, either to take it or not take it. Overall we have n indices (ranging from 0 to n-1), so the overall time taken would be [2 * 2 * ....... * 2] (for n times) => $$O(2^n)$$ \\n\\n\\n> **SPACE COMPLEXITY** : We are not using any extra space, just few variables and further more we have passed almost everything by reference (even target variable). The only thing left is the internal memory used in Stack Space of Recursion. Thus,  linear space complexity!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubsetsTarget(int idx,int curr,int const &target,vector<int> const &nums){\\n        if(idx == nums.size()){\\n            if(target == curr)\\n                return 1;\\n            return 0;\\n        }\\n        return (countSubsetsTarget(idx+1,(curr | nums[idx]),target,nums) + countSubsetsTarget(idx+1,curr,target,nums));\\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int target = 0;\\n        for(auto &x:nums)\\n            target |= x;\\n        return countSubsetsTarget(0,0,target,nums);\\n    }\\n};\\n```\\n\\n**Please Upvote if you liked it!**",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubsetsTarget(int idx,int curr,int const &target,vector<int> const &nums){\\n        if(idx == nums.size()){\\n            if(target == curr)\\n                return 1;\\n            return 0;\\n        }\\n        return (countSubsetsTarget(idx+1,(curr | nums[idx]),target,nums) + countSubsetsTarget(idx+1,curr,target,nums));\\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int target = 0;\\n        for(auto &x:nums)\\n            target |= x;\\n        return countSubsetsTarget(0,0,target,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795558,
                "title": "c-recursion",
                "content": "The **maximum OR value possible for any subset of an array is the OR of all values in the array!**\\nAfter calculating the maximum OR possible, we\\'ll find OR of all subsets & check if it is equal to maximum OR :\\n```\\nint recur(vector<int>&nums,int idx,int currOr,int maxOr){\\n        if(idx < 0){\\n            return currOr == maxOr;\\n        }\\n        return (\\n            recur(nums,idx-1,currOr,maxOr)                  // not-including element at \\'idx\\' in subset\\n            + recur(nums,idx-1,currOr | nums[idx],maxOr)    // including element at \\'idx\\' in subset\\n        );\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int maxOr = 0;\\n        for(auto num:nums){\\n            maxOr |= num;\\n        }\\n        \\n        return recur(nums,nums.size()-1,0,maxOr);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint recur(vector<int>&nums,int idx,int currOr,int maxOr){\\n        if(idx < 0){\\n            return currOr == maxOr;\\n        }\\n        return (\\n            recur(nums,idx-1,currOr,maxOr)                  // not-including element at \\'idx\\' in subset\\n            + recur(nums,idx-1,currOr | nums[idx],maxOr)    // including element at \\'idx\\' in subset\\n        );\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int maxOr = 0;\\n        for(auto num:nums){\\n            maxOr |= num;\\n        }\\n        \\n        return recur(nums,nums.size()-1,0,maxOr);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525389,
                "title": "c-easy-solution-with-explanation-beats-100-cpp-submission",
                "content": "The problem is another version of subset sum. Here, we need to calculate OR of every non empty subset instead of sum.\\n\\n*To generate all possible subset, each step we need to make two decisons. We will take this number to result or leave it. At the end, if at least one number is taken ( no empty subset ), we will check the sum.*\\n\\n**Time Complexity**: O(2^n) ( **Subset Sum problem using a backtracking approach which will take O(2^n)** ).\\n**Space Complexity**: O(1)\\n\\n\\n```\\nclass Solution {\\n    int maxSum;\\n    int maxSumCount;\\n    int length;\\n    \\n    void find(vector<int>& nums, int sum, int taken, int s) {\\n        if (s == length) {\\n            if (taken) {\\n                if (sum == maxSum) maxSumCount++;\\n                else if (sum > maxSum) {\\n                    maxSum = sum;\\n                    maxSumCount = 1;\\n                }\\n            }\\n            return;\\n        }\\n        find(nums, sum | nums[s], taken + 1, s + 1);\\n        find(nums, sum, taken, s + 1);\\n    }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        length = nums.size();\\n        maxSum = INT_MIN;\\n        maxSumCount = 0;\\n        \\n        find(nums, 0, 0, 0);\\n        return maxSumCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int maxSum;\\n    int maxSumCount;\\n    int length;\\n    \\n    void find(vector<int>& nums, int sum, int taken, int s) {\\n        if (s == length) {\\n            if (taken) {\\n                if (sum == maxSum) maxSumCount++;\\n                else if (sum > maxSum) {\\n                    maxSum = sum;\\n                    maxSumCount = 1;\\n                }\\n            }\\n            return;\\n        }\\n        find(nums, sum | nums[s], taken + 1, s + 1);\\n        find(nums, sum, taken, s + 1);\\n    }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        length = nums.size();\\n        maxSum = INT_MIN;\\n        maxSumCount = 0;\\n        \\n        find(nums, 0, 0, 0);\\n        return maxSumCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525311,
                "title": "c-simple-recursion-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        long long bitOr=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            bitOr|=nums[i];\\n        subsets(nums,0,0,bitOr);\\n        return count;\\n    }\\n    void subsets(vector<int>& nums,int i,int now,int bitOr)\\n    {\\n        if(i==nums.size())\\n            return;\\n       \\n        int t=now|nums[i];\\n        if(t==bitOr)\\n            count++;\\n        subsets(nums,i+1,t,bitOr);\\n        subsets(nums,i+1,now,bitOr);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        long long bitOr=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            bitOr|=nums[i];\\n        subsets(nums,0,0,bitOr);\\n        return count;\\n    }\\n    void subsets(vector<int>& nums,int i,int now,int bitOr)\\n    {\\n        if(i==nums.size())\\n            return;\\n       \\n        int t=now|nums[i];\\n        if(t==bitOr)\\n            count++;\\n        subsets(nums,i+1,t,bitOr);\\n        subsets(nums,i+1,now,bitOr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631165,
                "title": "brute-force-2-n-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int x,int k,vector<int> &v,int &ans){\\n        // if(x==k)ans++;\\n        if(i>=v.size()){ans += (x==k);return;}\\n        solve(i+1,x,k|v[i],v,ans);\\n        solve(i+1,x,k,v,ans);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n         int x = 0;\\n         for(auto &i: nums){\\n             x |= i;\\n         }\\n         int ans = 0;\\n         solve(0,x,0,nums,ans);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int x,int k,vector<int> &v,int &ans){\\n        // if(x==k)ans++;\\n        if(i>=v.size()){ans += (x==k);return;}\\n        solve(i+1,x,k|v[i],v,ans);\\n        solve(i+1,x,k,v,ans);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n         int x = 0;\\n         for(auto &i: nums){\\n             x |= i;\\n         }\\n         int ans = 0;\\n         solve(0,x,0,nums,ans);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768108,
                "title": "simple-solution-in-java",
                "content": "**Hints**\\n- The maximum bitwise-OR is the bitwise-OR of the whole array (max)\\n- Use bitwise operation to find all the possible subset of given array\\n- If max==the OR of subset, count++\\n```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0,tmp=0,count=0;\\n        //The maximum bitwise-OR is the bitwise-OR of the whole array\\n        for(int i=0;i<nums.length;i++){\\n            max=max|nums[i];\\n        }\\n        \\n        for(int i=0;i<(1<<nums.length);i++){\\n            tmp=0;\\n            for(int j=0;j<nums.length;j++){\\n                if((i&(1<<j))>0){\\n                    tmp=tmp|nums[j];\\n                }\\n            }\\n            if(tmp==max){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0,tmp=0,count=0;\\n        //The maximum bitwise-OR is the bitwise-OR of the whole array\\n        for(int i=0;i<nums.length;i++){\\n            max=max|nums[i];\\n        }\\n        \\n        for(int i=0;i<(1<<nums.length);i++){\\n            tmp=0;\\n            for(int j=0;j<nums.length;j++){\\n                if((i&(1<<j))>0){\\n                    tmp=tmp|nums[j];\\n                }\\n            }\\n            if(tmp==max){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532642,
                "title": "c-recursive-dp-solution",
                "content": "This Problem is similar to number of subset with given sum.\\nSo the basic approch is that pick one by one element and calculate the OR and check if it equal to resultant OR.\\nFirst try to write recursive code and then do the memorization to reduce the time complexity.\\n\\n``` \\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(int i, vector<int> a, int oor, int xoor) {\\n        if(i == a.size()) {\\n            if(oor == xoor) return 1;\\n            return 0;\\n        }\\n        if(dp[i][oor] != -1)    return dp[i][oor];\\n        dp[i][oor] = solve(i + 1, a, oor | a[i], xoor) + solve(i + 1, a, oor, xoor);\\n        return dp[i][oor];\\n    }\\n    int countMaxOrSubsets(vector<int>& a) {\\n        int all_or = 0;\\n        for(auto i : a) all_or |= i;\\n        dp = vector<vector<int>> (a.size() + 1, vector<int>(all_or + 1, -1));\\n        return solve(0, a, 0, all_or);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(int i, vector<int> a, int oor, int xoor) {\\n        if(i == a.size()) {\\n            if(oor == xoor) return 1;\\n            return 0;\\n        }\\n        if(dp[i][oor] != -1)    return dp[i][oor];\\n        dp[i][oor] = solve(i + 1, a, oor | a[i], xoor) + solve(i + 1, a, oor, xoor);\\n        return dp[i][oor];\\n    }\\n    int countMaxOrSubsets(vector<int>& a) {\\n        int all_or = 0;\\n        for(auto i : a) all_or |= i;\\n        dp = vector<vector<int>> (a.size() + 1, vector<int>(all_or + 1, -1));\\n        return solve(0, a, 0, all_or);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531090,
                "title": "java-dfs-with-pruning-beats-100",
                "content": "A simple DFS solution with prunig. Whenever `preSum` equals `sum`, there\\'s no need to do further recursion calls as all remaining combinations will satisfy the condition. So we can simply add `2^remainCount` will do.\\n\\n```java\\nclass Solution {\\n  int result;\\n  int sum;\\n  public int countMaxOrSubsets(int[] nums) {\\n    result = 0;\\n    sum = 0;\\n    for (int i : nums)\\n      sum |= i;\\n    dfs(0, nums, 0);\\n    return result;\\n  }\\n\\n  private void dfs(int presum, int[] nums, int idx) {\\n    if (presum == sum) {\\n      result += 1 << (nums.length - idx);\\n      return;\\n    }\\n    if (idx == nums.length)\\n      return;\\n    dfs(presum | nums[idx], nums, idx+1);\\n    dfs(presum, nums, idx+1);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  int result;\\n  int sum;\\n  public int countMaxOrSubsets(int[] nums) {\\n    result = 0;\\n    sum = 0;\\n    for (int i : nums)\\n      sum |= i;\\n    dfs(0, nums, 0);\\n    return result;\\n  }\\n\\n  private void dfs(int presum, int[] nums, int idx) {\\n    if (presum == sum) {\\n      result += 1 << (nums.length - idx);\\n      return;\\n    }\\n    if (idx == nums.length)\\n      return;\\n    dfs(presum | nums[idx], nums, idx+1);\\n    dfs(presum, nums, idx+1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525411,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(),ans=0,m = nums[0];\\n        for(int i=1;i<n;i++) m |= nums[i]; // Max-OR : OR of all elements\\n        int k = 1 << n;\\n        for(int i=0;i<k;i++){\\n            int j = i,c=0,l=0;\\n            while(j > 0){\\n                if(j&1){\\n                    c |= nums[l];\\n                }\\n                l++;\\n                j = j>>1;\\n            }\\n            if(c==m) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(),ans=0,m = nums[0];\\n        for(int i=1;i<n;i++) m |= nums[i]; // Max-OR : OR of all elements\\n        int k = 1 << n;\\n        for(int i=0;i<k;i++){\\n            int j = i,c=0,l=0;\\n            while(j > 0){\\n                if(j&1){\\n                    c |= nums[l];\\n                }\\n                l++;\\n                j = j>>1;\\n            }\\n            if(c==m) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307244,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int reach=0,res=0;\\n        for(auto x:nums){\\n            reach|=x;\\n        }\\n        auto Solve=[&](auto Solve,int ind,int val){\\n            if(val>67108864){\\n                return ;\\n            }\\n            if(val==reach){\\n                res++;\\n            }\\n            for(int i=ind;i<(int)nums.size();i++){\\n                Solve(Solve,i+1,val|nums[i]);\\n            }\\n        };\\n        Solve(Solve,0,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int reach=0,res=0;\\n        for(auto x:nums){\\n            reach|=x;\\n        }\\n        auto Solve=[&](auto Solve,int ind,int val){\\n            if(val>67108864){\\n                return ;\\n            }\\n            if(val==reach){\\n                res++;\\n            }\\n            for(int i=ind;i<(int)nums.size();i++){\\n                Solve(Solve,i+1,val|nums[i]);\\n            }\\n        };\\n        Solve(Solve,0,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023645,
                "title": "java-solution-well-explained-easy-to-understand",
                "content": "Hi there ! \\nIdea of this solution could be devided on two parts \\n1. Using backtracking algorithm find all possible subsets. I would highly suggest to solve [```78. Subsets``` ](https://leetcode.com/problems/subsets/)first. \\n2. Use ArrayList to store current betwise OR of subset \\n\\n## Let\\'s take a look at this example\\n**Intput** : ```nums = [1,2,3]```\\nThis is what subsets of nums we will calculate on iteration if we just use the backtracking part\\n```[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]```\\nWhat we also want is to check on each iteration if subset bitwise or is matching maximum possible bitwise-OR\\n1. The maximum bitwise-OR is the bitwise-OR of the whole array. Store that value in ```max```\\n2. We also want to know what is current bitwise-OR of our subset . To do that I\\'m using arrayList ```curr``` Which is kind of like a mapping between subset and betwise-OR of that subset \\nExample: using this ```nums = [1,2,3]``` \\n```[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]``` -  all possible subsets\\n```[[],[1], [3], [3], [2], [3], [3]]``` - ```curr``` will look like that \\n```\\nclass Solution {\\n    int n; // length of nums\\n    int max; // max of betwise-OR of nums\\n    int result = 0; // result\\n    public int countMaxOrSubsets(int[] nums) {\\n        n = nums.length;\\n        max = nums[0]; \\n        for(int i = 1; i < nums.length; i++) //going through nums to find betwise-OR\\n            max = max | nums[i];\\n        backtrack(0,new ArrayList<>(),nums); // call magic function which go over all possible subsets of nums \\n        return result;\\n    }\\n        public void backtrack(int first, ArrayList<Integer> curr, int [] nums){\\n        if(curr.size() > 0 && curr.get(curr.size() - 1) == max) // checking if current betwise-OR  equal the maximum \\n            result++;\\n        for(int i = first; i < n; i++){\\n            if(curr.size() > 0) \\n                curr.add(nums[i] | curr.get(curr.size() - 1)); \\n            else\\n                curr.add(nums[i]);\\n            backtrack(i + 1, curr, nums);\\n\\t//I would highly suggest debug this code to understand how this \"remove\" part works \\n            curr.remove(curr.size() - 1); //important step we removing last element to maintain correct subset on the next iteration\\n        }\\n    }\\n\\n}\\n```\\n\\n## Optimized solution\\nOnce we nailed backtracking and how this useless ArrayList works we can come up with better solution (after looking at defferent solution at Discuss section)\\nIdea: \\n1. We could pass betwise-OR of subset as an argument in backtrack fucntion \\n```\\npublic class Solution {\\n    int count=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for(int i:nums)\\n            max = max | i;\\n        backtrack(nums,0,max, 0);\\n        return count;\\n    }\\n\\n    private void backtrack(int[] nums,int first,int max, int curr){\\n        if(max == curr)\\n            count++;\\n        if(first>=nums.length) return;\\n\\n        for(int i = first;i<nums.length;i++){\\n            backtrack(nums,i+1,max,curr|nums[i]);\\n        }\\n    }\\n}\\n```\\n**Please upvote if you find this solution helpfull.\\nThank you !**",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```78. Subsets```\n```nums = [1,2,3]```\n```[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]```\n```max```\n```curr```\n```nums = [1,2,3]```\n```[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]```\n```[[],[1], [3], [3], [2], [3], [3]]```\n```curr```\n```\\nclass Solution {\\n    int n; // length of nums\\n    int max; // max of betwise-OR of nums\\n    int result = 0; // result\\n    public int countMaxOrSubsets(int[] nums) {\\n        n = nums.length;\\n        max = nums[0]; \\n        for(int i = 1; i < nums.length; i++) //going through nums to find betwise-OR\\n            max = max | nums[i];\\n        backtrack(0,new ArrayList<>(),nums); // call magic function which go over all possible subsets of nums \\n        return result;\\n    }\\n        public void backtrack(int first, ArrayList<Integer> curr, int [] nums){\\n        if(curr.size() > 0 && curr.get(curr.size() - 1) == max) // checking if current betwise-OR  equal the maximum \\n            result++;\\n        for(int i = first; i < n; i++){\\n            if(curr.size() > 0) \\n                curr.add(nums[i] | curr.get(curr.size() - 1)); \\n            else\\n                curr.add(nums[i]);\\n            backtrack(i + 1, curr, nums);\\n\\t//I would highly suggest debug this code to understand how this \"remove\" part works \\n            curr.remove(curr.size() - 1); //important step we removing last element to maintain correct subset on the next iteration\\n        }\\n    }\\n\\n}\\n```\n```\\npublic class Solution {\\n    int count=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for(int i:nums)\\n            max = max | i;\\n        backtrack(nums,0,max, 0);\\n        return count;\\n    }\\n\\n    private void backtrack(int[] nums,int first,int max, int curr){\\n        if(max == curr)\\n            count++;\\n        if(first>=nums.length) return;\\n\\n        for(int i = first;i<nums.length;i++){\\n            backtrack(nums,i+1,max,curr|nums[i]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701379,
                "title": "c-2-solution-backtracking-dp-soln",
                "content": "# Backtracking Soln\\n```\\n\\tint res = 0;\\n    void back(vector<int>nums, int a, int idx, int curr) {\\n        if(curr==a) res+=1;\\n        for(int i=idx; i<nums.size(); i++) {\\n            back(nums, a, i+1, curr|nums[i]);\\n        }\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        long long a = nums[0];\\n        for(int i=1; i<nums.size(); i++) a |= nums[i];\\n        back(nums, a, 0, 0);\\n        return res;\\n    }\\n```\\n\\n# DP Soln\\n```\\n\\tint countMaxOrSubsets(vector<int>& A) {\\n        int max = 0;\\n\\t\\tint dp[1 << 17] = {1};\\n        for (int a: A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\n\\tint res = 0;\\n    void back(vector<int>nums, int a, int idx, int curr) {\\n        if(curr==a) res+=1;\\n        for(int i=idx; i<nums.size(); i++) {\\n            back(nums, a, i+1, curr|nums[i]);\\n        }\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        long long a = nums[0];\\n        for(int i=1; i<nums.size(); i++) a |= nums[i];\\n        back(nums, a, 0, 0);\\n        return res;\\n    }\\n```\n```\\n\\tint countMaxOrSubsets(vector<int>& A) {\\n        int max = 0;\\n\\t\\tint dp[1 << 17] = {1};\\n        for (int a: A) {\\n            for (int i = max; i >= 0; --i)\\n                dp[i | a] += dp[i];\\n            max |= a;\\n        }\\n        return dp[max];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575826,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        def dfs(i,val):\\n            if maxBit == val : return 1<<(len(nums)-i)\\n            if i == len(nums): return 0\\n            return dfs(i+1,val|nums[i]) + dfs(i+1,val)\\n        maxBit = 0\\n        for i in nums: maxBit |= i\\n        return dfs(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        def dfs(i,val):\\n            if maxBit == val : return 1<<(len(nums)-i)\\n            if i == len(nums): return 0\\n            return dfs(i+1,val|nums[i]) + dfs(i+1,val)\\n        maxBit = 0\\n        for i in nums: maxBit |= i\\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525390,
                "title": "java-math-modified-backtracking-3ms-beat-100-after-sort-array-with-detailed-explanation",
                "content": "1. Find the maxOR num \\n2. Sort array for more efficient backtracking latter\\n3. Backtrack the array from the biggest number to smallest one(because the maxOR must be from the biggest one)\\n4. Say the sorted array is `[1,2,3,5]` and we start from the last element 5. when it goes to 2, the `existingOR` is already the maxOR (7 = 5 | 3). So the `remainingElementsNum`  is 2([1,2]).  Combination is C2-0(choose nothing from 2 elements) + C2-1 (choose 1 element from 2 elements) + C2-2(choose 2 from 2 elements) = `Math.pow(2, remainingElementsNum)` The result is `[5,3], [5,3,1], [5,3,2], [5,3,1,2]` . Backtracking(starts with 5) ends. Next round (starts with 3) starts..\\n\\nNotes (Math): Cn0 + Cn1 + Cn2 + ... CnN = 2^n, for n >= 1;\\n\\n\\n```\\n\\nclass Solution {\\n    private int result = 0;\\n    private int maxOR;\\n    private int[] nums;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        if(nums.length == 1){\\n            return 1;\\n        }\\n        \\n        this.nums = nums;\\n\\n\\t\\t// get maxOR \\n        maxOR = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            maxOR = maxOR | nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n\\t\\t// Start from the biggest number\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            backtracking(nums[i], i - 1);\\n        }\\n\\t\\t\\n        return result;\\n    }\\n    \\n    private void backtracking(int existingOR, int index){\\n\\n\\t\\t// it means we can choose (0, 1, ... index + 1) number from the first (index + 1) elements\\n        if(existingOR == maxOR){\\n            int remainingElementsNum = index + 1;\\n            result += Math.pow(2, remainingElementsNum);\\n\\t\\t\\t// Backtracking ends here as we only need to know the combination size instead of the actual combination array\\n            return;\\n        }\\n\\t\\t\\n        for(int i = index; i >= 0; i--){\\n            backtracking(existingOR | nums[i], i - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution {\\n    private int result = 0;\\n    private int maxOR;\\n    private int[] nums;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        if(nums.length == 1){\\n            return 1;\\n        }\\n        \\n        this.nums = nums;\\n\\n\\t\\t// get maxOR \\n        maxOR = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            maxOR = maxOR | nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n\\t\\t// Start from the biggest number\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            backtracking(nums[i], i - 1);\\n        }\\n\\t\\t\\n        return result;\\n    }\\n    \\n    private void backtracking(int existingOR, int index){\\n\\n\\t\\t// it means we can choose (0, 1, ... index + 1) number from the first (index + 1) elements\\n        if(existingOR == maxOR){\\n            int remainingElementsNum = index + 1;\\n            result += Math.pow(2, remainingElementsNum);\\n\\t\\t\\t// Backtracking ends here as we only need to know the combination size instead of the actual combination array\\n            return;\\n        }\\n\\t\\t\\n        for(int i = index; i >= 0; i--){\\n            backtracking(existingOR | nums[i], i - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525352,
                "title": "c-failed-approach-working-one",
                "content": "Code is correct but time complexity is high so below approach failed at last test case :(\\nHere we are generating every possible sub array and doing its OR in base condition.\\n```\\nclass Solution {\\npublic:\\n    int res=0, ans=INT_MIN;\\n    void solve(vector<int> input, vector<int> output)\\n    {\\n        if(input.size() == 0)\\n        {\\n            if(output.size() != 0)\\n            {\\n                int temp_ans = output[0];\\n                for(int i=0; i<output.size(); i++)  \\n                    temp_ans = (temp_ans|output[i]);            \\n                if(temp_ans == ans)\\n                    res++;\\n                if(temp_ans > ans)\\n                    ans = temp_ans;\\n            }\\n            return;\\n        }\\n        \\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);\\n    }\\n    int countMaxOrSubsets(vector<int>& arr) \\n    {\\n        solve(arr, {});\\n        return res+1;\\n    }\\n};\\n```\\nWorking Approach :\\nDoing the OR of entire array first that gives maximum OR and backtracking the array to check current OR == maximum OR\\n```\\nclass Solution {\\n    public:\\n\\tint res = 0;\\n\\tvoid solve(vector<int> &nums, int ind, int max, int curr)\\n\\t{\\n\\t\\tif(ind == nums.size())\\n\\t\\t{\\n\\t\\t\\tif(curr == max)\\n\\t\\t\\t\\tres++;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsolve(nums, ind+1, max,curr);\\n\\t\\tsolve(nums, ind+1, max, curr|nums[ind]);\\n\\t}\\n\\t\\n    int countMaxOrSubsets(vector<int> arr) \\n    {    \\n    \\tint max=0;\\n        for(int i=0; i<arr.size(); i++)\\n    \\t\\tmax = max|arr[i];\\n    \\tsolve(arr, 0, max, 0);\\n    \\treturn res;\\n    }\\n};\\n```\\n**Upvote if you like it**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0, ans=INT_MIN;\\n    void solve(vector<int> input, vector<int> output)\\n    {\\n        if(input.size() == 0)\\n        {\\n            if(output.size() != 0)\\n            {\\n                int temp_ans = output[0];\\n                for(int i=0; i<output.size(); i++)  \\n                    temp_ans = (temp_ans|output[i]);            \\n                if(temp_ans == ans)\\n                    res++;\\n                if(temp_ans > ans)\\n                    ans = temp_ans;\\n            }\\n            return;\\n        }\\n        \\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);\\n    }\\n    int countMaxOrSubsets(vector<int>& arr) \\n    {\\n        solve(arr, {});\\n        return res+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n\\tint res = 0;\\n\\tvoid solve(vector<int> &nums, int ind, int max, int curr)\\n\\t{\\n\\t\\tif(ind == nums.size())\\n\\t\\t{\\n\\t\\t\\tif(curr == max)\\n\\t\\t\\t\\tres++;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsolve(nums, ind+1, max,curr);\\n\\t\\tsolve(nums, ind+1, max, curr|nums[ind]);\\n\\t}\\n\\t\\n    int countMaxOrSubsets(vector<int> arr) \\n    {    \\n    \\tint max=0;\\n        for(int i=0; i<arr.size(); i++)\\n    \\t\\tmax = max|arr[i];\\n    \\tsolve(arr, 0, max, 0);\\n    \\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362662,
                "title": "easy-bit-manipulation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0;\\n        int n=nums.size();\\n        for(auto it:nums){\\n            x|=it;\\n        }\\n        int count=0;\\n        vector<int>arr;\\n        for(int i=0;i<(1<<n);i++){\\n            int y=0;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)){\\n                    y|=nums[j];\\n                }\\n            }\\n            if(y==x){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0;\\n        int n=nums.size();\\n        for(auto it:nums){\\n            x|=it;\\n        }\\n        int count=0;\\n        vector<int>arr;\\n        for(int i=0;i<(1<<n);i++){\\n            int y=0;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)){\\n                    y|=nums[j];\\n                }\\n            }\\n            if(y==x){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351532,
                "title": "bruter-force-2-n-solution-c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int x = 0;\\n    void solve(int s,int k,int &ans,vector<int> &nums){\\n        if(s>=nums.size()){\\n            if(k==x)\\n                ans++;\\n            return;\\n        }\\n        solve(s+1,k|nums[s],ans,nums);\\n        solve(s+1,k,ans,nums);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int ans = 0;\\n        x = 0;\\n        for(auto &i: nums)x |= i;\\n        solve(0,0,ans,nums);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int x = 0;\\n    void solve(int s,int k,int &ans,vector<int> &nums){\\n        if(s>=nums.size()){\\n            if(k==x)\\n                ans++;\\n            return;\\n        }\\n        solve(s+1,k|nums[s],ans,nums);\\n        solve(s+1,k,ans,nums);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int ans = 0;\\n        x = 0;\\n        for(auto &i: nums)x |= i;\\n        solve(0,0,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270953,
                "title": "c-backtracking-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void backtrack(vector<int> &nums,int target,int idx,int curr_xor)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            if(curr_xor==target)\\n            {\\n                ans++;\\n            }\\n            return ;\\n        }\\n        \\n        backtrack(nums,target,idx+1,curr_xor);\\n        backtrack(nums,target,idx+1,nums[idx]|curr_xor);\\n        \\n    }\\n    int countMaxOrSubsets(vector<int>& nums)\\n    {\\n        int target=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            target|=nums[i];\\n        }\\n        backtrack(nums,target,0,0);\\n        return ans;\\n\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    void backtrack(vector<int> &nums,int target,int idx,int curr_xor)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            if(curr_xor==target)\\n            {\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1676190,
                "title": "c-subsets-approach",
                "content": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n        int ans = 0, maxOr = INT_MIN;\\n        int limit = pow(2, nums.size());\\n        for(int i = 0; i < limit; i++) {\\n            int Or = 0;\\n            for(int j = 0; j < nums.size(); j++) { \\n\\t\\t\\t\\tif((i & (1 << j)) == 0) Or |= nums[j];\\n\\t\\t\\t}\\n            if(Or > maxOr) { maxOr = Or; ans = 1; } \\n\\t\\t\\telse if(Or == maxOr) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n        int ans = 0, maxOr = INT_MIN;\\n        int limit = pow(2, nums.size());\\n        for(int i = 0; i < limit; i++) {\\n            int Or = 0;\\n            for(int j = 0; j < nums.size(); j++) { \\n\\t\\t\\t\\tif((i & (1 << j)) == 0) Or |= nums[j];\\n\\t\\t\\t}\\n            if(Or > maxOr) { maxOr = Or; ans = 1; } \\n\\t\\t\\telse if(Or == maxOr) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1526221,
                "title": "c-simple-and-short-solution-no-recursion-faster-than-100",
                "content": "Very similar to https://leetcode.com/problems/subsets/discuss/1333022/C%2B%2B-Simple-and-Short-Solution-No-Recursion-0-ms-Faster-than-100\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int res = 0, mx_or = 0, curr, sz;\\n        vector<int> ors = {0};\\n        \\n        for (auto n : nums) mx_or |= n;\\n        \\n        for (auto num : nums) {\\n            sz = ors.size();\\n            \\n            for (int i = 0; i < sz; i++) {\\n                curr = ors[i] | num;\\n                ors.push_back(curr);\\n                if (curr == mx_or) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int res = 0, mx_or = 0, curr, sz;\\n        vector<int> ors = {0};\\n        \\n        for (auto n : nums) mx_or |= n;\\n        \\n        for (auto num : nums) {\\n            sz = ors.size();\\n            \\n            for (int i = 0; i < sz; i++) {\\n                curr = ors[i] | num;\\n                ors.push_back(curr);\\n                if (curr == mx_or) res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525839,
                "title": "easy-c-solution-o-2-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int cnt[300005];\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int len=(1<<(int)nums.size());\\n        int ans=0;\\n        for(int i=0; i<len; i++) {\\n             int z=i,pos=0,orr=0;\\n             while(z) {\\n                if((z&1)==1) {\\n                    orr|=nums[pos]; \\n                }\\n                 pos++;\\n                 z>>=1;\\n             }\\n              cnt[orr]++;\\n              ans=max(ans,cnt[orr]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt[300005];\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int len=(1<<(int)nums.size());\\n        int ans=0;\\n        for(int i=0; i<len; i++) {\\n             int z=i,pos=0,orr=0;\\n             while(z) {\\n                if((z&1)==1) {\\n                    orr|=nums[pos]; \\n                }\\n                 pos++;\\n                 z>>=1;\\n             }\\n              cnt[orr]++;\\n              ans=max(ans,cnt[orr]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525686,
                "title": "python3-bitmask-dp",
                "content": "See more similar `bitmask dp` type questions here:  https://leetcode.com/discuss/general-discussion/1125779/Dynamic-programming-on-subsets-with-examples-explained\\n\\n``` py\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        dp = [-1] * (1<<N)\\n        dp[0] = 0\\n        for mask in range(1<<N):\\n            for j in range(N):\\n                if mask & (1<<j):\\n                    neib = dp[mask ^ (1<<j)]\\n                    dp[mask] = neib|nums[j]\\n        return dp.count(max(dp))\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "``` py\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        dp = [-1] * (1<<N)\\n        dp[0] = 0\\n        for mask in range(1<<N):\\n            for j in range(N):\\n                if mask & (1<<j):\\n                    neib = dp[mask ^ (1<<j)]\\n                    dp[mask] = neib|nums[j]\\n        return dp.count(max(dp))\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525361,
                "title": "100-fast-easy-python-solution-using-combinations-from-itertools",
                "content": "Combination returns tuples as output thats why make sure to convert it to list before append in a array because tuples does not supports OR Operation.\\n```\\nclass Solution:\\n    from itertools import combinations \\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        d = {}\\n        o = 0\\n        arr = []\\n        for i in range(1,len(nums)+1):\\n            comb = combinations(nums,i)\\n            for i in comb:\\n                arr.append(list(i))\\n        for i in arr:\\n            x = o|i[0]\\n            for j in i:\\n                x = x|j\\n            if x not in d:\\n                d[x] = 1\\n            else:\\n                d[x] += 1\\n        return d[max(d)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    from itertools import combinations \\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1525249,
                "title": "c-2044-count-number-of-maximum-bitwise-or-subsets",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int target = 0, n = nums.size(); \\n        for (auto& x : nums) target |= x; \\n        \\n        map<pair<int, int>, int> memo; \\n        function<int(int, int)> fn = [&](int i, int mask) -> int {\\n            if (mask == target) return pow(2, n-i); \\n            if (i == n) return 0; \\n            if (memo.count({i, mask}) == 0) \\n                memo[{i, mask}] = fn(i+1, mask | nums[i]) + fn(i+1, mask); \\n            return memo[{i, mask}]; \\n        }; \\n        \\n        return fn(0, 0); \\n    }\\n};\\n```\\n\\nAdding a solution inspired by @lee215\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int most = 0; \\n        unordered_map<int, int> mp = {{0, 1}}; \\n        for (int x : nums) {\\n            most |= x; \\n            unordered_map<int, int> tmp = mp; \\n            for (auto& [k, v] : tmp) mp[x | k] += v; \\n        }\\n        return mp[most]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int target = 0, n = nums.size(); \\n        for (auto& x : nums) target |= x; \\n        \\n        map<pair<int, int>, int> memo; \\n        function<int(int, int)> fn = [&](int i, int mask) -> int {\\n            if (mask == target) return pow(2, n-i); \\n            if (i == n) return 0; \\n            if (memo.count({i, mask}) == 0) \\n                memo[{i, mask}] = fn(i+1, mask | nums[i]) + fn(i+1, mask); \\n            return memo[{i, mask}]; \\n        }; \\n        \\n        return fn(0, 0); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int most = 0; \\n        unordered_map<int, int> mp = {{0, 1}}; \\n        for (int x : nums) {\\n            most |= x; \\n            unordered_map<int, int> tmp = mp; \\n            for (auto& [k, v] : tmp) mp[x | k] += v; \\n        }\\n        return mp[most]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525155,
                "title": "c-dp-bitwise-o-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(), mx = 0, ans = 0;\\n        int dp[1 << 17]{};\\n        for (auto t : nums) mx |= t;\\n        for (int i = 1, j = 1; i < (1 << n); i++) {\\n            j += (i == (1 << j));\\n            dp[i] = dp[i ^ (1 << (j - 1))] | nums[j - 1];\\n            ans += dp[i] == mx;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(), mx = 0, ans = 0;\\n        int dp[1 << 17]{};\\n        for (auto t : nums) mx |= t;\\n        for (int i = 1, j = 1; i < (1 << n); i++) {\\n            j += (i == (1 << j));\\n            dp[i] = dp[i ^ (1 << (j - 1))] | nums[j - 1];\\n            ans += dp[i] == mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859702,
                "title": "similar-to-subset-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& a, int ind, int s, int t, vector<vector<int>> &v)\\n    {\\n        int n  = a.size();\\n        if(ind == n)\\n        {\\n           if(t == s)\\n               return 1;\\n            return 0;\\n        }\\n        \\n        if(v[ind][s] != -1)\\n            return v[ind][s];\\n        \\n        int in = solve(a,ind+1, s|a[ind],t,v);\\n        int out = solve(a,ind+1, s,t,v);\\n        \\n        return v[ind][s] = in+out;\\n        \\n        \\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& a) {\\n        \\n        int t = 0;\\n        for(auto h : a)\\n        {\\n            t|=h;\\n        }\\n        \\n        int n = a.size();\\n        \\n        vector<vector<int>> v(n, vector<int>(1000000,-1));\\n        \\n        int ans = solve(a,0,0,t,v);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& a, int ind, int s, int t, vector<vector<int>> &v)\\n    {\\n        int n  = a.size();\\n        if(ind == n)\\n        {\\n           if(t == s)\\n               return 1;\\n            return 0;\\n        }\\n        \\n        if(v[ind][s] != -1)\\n            return v[ind][s];\\n        \\n        int in = solve(a,ind+1, s|a[ind],t,v);\\n        int out = solve(a,ind+1, s,t,v);\\n        \\n        return v[ind][s] = in+out;\\n        \\n        \\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& a) {\\n        \\n        int t = 0;\\n        for(auto h : a)\\n        {\\n            t|=h;\\n        }\\n        \\n        int n = a.size();\\n        \\n        vector<vector<int>> v(n, vector<int>(1000000,-1));\\n        \\n        int ans = solve(a,0,0,t,v);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644425,
                "title": "simple-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet every possible sub sequence calculate frequency of each sequence, return freq of max value \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse through vector of int, at each position add and not add the number at position, when it reaches the end increase frequency of that value, and maintain a var to store max value. return the frequency of max value\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you like it \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; int ml = -1; \\n    void fun( vector<int> &nums, int val, int pos){\\n        if(nums.size() == pos) {if(ml < val) ml = val;   m[val]++; return; }\\n        fun(nums, val, pos+1); \\n       val  = val | nums[pos]; \\n        fun(nums, val, pos+1); \\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        fun(nums,0, 0 ); \\n\\n        return m[ml]; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; int ml = -1; \\n    void fun( vector<int> &nums, int val, int pos){\\n        if(nums.size() == pos) {if(ml < val) ml = val;   m[val]++; return; }\\n        fun(nums, val, pos+1); \\n       val  = val | nums[pos]; \\n        fun(nums, val, pos+1); \\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        fun(nums,0, 0 ); \\n\\n        return m[ml]; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465235,
                "title": "count-number-of-maximum-bitwise-or-subsets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void subsetsUtil(vector<int>& A, vector<vector<int> >& res,vector<int>& subset, int index)\\n    {\\n        res.push_back(subset);\\n        for (int i = index; i < A.size(); i++) {\\n            subset.push_back(A[i]);\\n            subsetsUtil(A, res, subset, i + 1);\\n            subset.pop_back();\\n        }\\n    \\n        return;\\n    }\\n\\n    vector<vector<int> > subsets(vector<int>& A)\\n    {\\n        vector<int> subset;\\n        vector<vector<int> > res;\\n        int index = 0;\\n        subsetsUtil(A, res, subset, index);\\n    \\n        return res;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int i, j, x_or=0, max=0, count=0;\\n        vector<vector<int> > res = subsets(nums);\\n        for(i=0 ; i<res.size() ; i++)\\n        {\\n            x_or = 0;\\n            for(j=0 ; j<res[i].size() ; j++)\\n            {\\n                x_or |=res[i][j];\\n            }\\n            if(x_or>max)\\n            {\\n                max = x_or;\\n                count=1;\\n            }\\n            else if(x_or==max)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n![upvote new.jpg](https://assets.leetcode.com/users/images/60790a23-b1a7-4d9f-9dc6-e76135ef408d_1682746923.505644.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subsetsUtil(vector<int>& A, vector<vector<int> >& res,vector<int>& subset, int index)\\n    {\\n        res.push_back(subset);\\n        for (int i = index; i < A.size(); i++) {\\n            subset.push_back(A[i]);\\n            subsetsUtil(A, res, subset, i + 1);\\n            subset.pop_back();\\n        }\\n    \\n        return;\\n    }\\n\\n    vector<vector<int> > subsets(vector<int>& A)\\n    {\\n        vector<int> subset;\\n        vector<vector<int> > res;\\n        int index = 0;\\n        subsetsUtil(A, res, subset, index);\\n    \\n        return res;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int i, j, x_or=0, max=0, count=0;\\n        vector<vector<int> > res = subsets(nums);\\n        for(i=0 ; i<res.size() ; i++)\\n        {\\n            x_or = 0;\\n            for(j=0 ; j<res[i].size() ; j++)\\n            {\\n                x_or |=res[i][j];\\n            }\\n            if(x_or>max)\\n            {\\n                max = x_or;\\n                count=1;\\n            }\\n            else if(x_or==max)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438499,
                "title": "easy-python-solution-using-recursion-and-backtracking",
                "content": "# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        def subs(idx,nums,N,lst,l):\\n            if idx>=N:\\n                val=0\\n                for i in lst:\\n                    val |= i\\n                l.append(val)\\n                return\\n            lst.append(nums[idx])\\n            subs(idx+1,nums,N,lst,l)\\n            lst.pop()\\n            subs(idx+1,nums,N,lst,l)\\n            return \\n            \\n        lst=[]\\n        l=[]\\n        subs(0,nums,len(nums),lst,l)\\n        cnt=Counter(l)\\n        return max([i for i in cnt.values()])\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        def subs(idx,nums,N,lst,l):\\n            if idx>=N:\\n                val=0\\n                for i in lst:\\n                    val |= i\\n                l.append(val)\\n                return\\n            lst.append(nums[idx])\\n            subs(idx+1,nums,N,lst,l)\\n            lst.pop()\\n            subs(idx+1,nums,N,lst,l)\\n            return \\n            \\n        lst=[]\\n        l=[]\\n        subs(0,nums,len(nums),lst,l)\\n        cnt=Counter(l)\\n        return max([i for i in cnt.values()])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394402,
                "title": "hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254101,
                "title": "simple-recursion-solution-analogy-to-subsets-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the intution is to caluclate ***OR*** val of each subset while generating them , and storing these values into a list.\\nAfter storing these values and finding out largest or value.\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer> or = new ArrayList<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        helper(0,nums,0);\\n        Collections.sort(or,Collections.reverseOrder());\\n        int max = or.get(0);\\n        int answer = 0;\\n        for(Integer i:or){\\n            if(max==i) answer++;\\n            else break;\\n        }\\n        return answer;\\n    }\\n    public void helper(int index,int[] nums,int sum){\\n        if(index==nums.length){\\n            or.add(sum);\\n            return;\\n        }\\n        int val = (sum|nums[index]);\\n        helper(index+1,nums,val);\\n        helper(index+1,nums,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> or = new ArrayList<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        helper(0,nums,0);\\n        Collections.sort(or,Collections.reverseOrder());\\n        int max = or.get(0);\\n        int answer = 0;\\n        for(Integer i:or){\\n            if(max==i) answer++;\\n            else break;\\n        }\\n        return answer;\\n    }\\n    public void helper(int index,int[] nums,int sum){\\n        if(index==nums.length){\\n            or.add(sum);\\n            return;\\n        }\\n        int val = (sum|nums[index]);\\n        helper(index+1,nums,val);\\n        helper(index+1,nums,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969014,
                "title": "efficient-javascript-backtracking-built-on-90-subsets-problem",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst countMaxOrSubsets = (nums) => {\\n  // Calculate the maximum bitwise OR of nums\\n  const maxOR = nums.reduce((a, b) => a | b, 0);\\n\\n  let result = 0;\\n\\n  // generate all subsets of nums\\n  const backtrack = (nums, start, subset) => {\\n    // If the current subset has a bitwise OR equal to the maximum bitwise OR, increment the result\\n    if (subset.length) {\\n        const subsetOR = subset.reduce((a, b) => a | b, 0);\\n        if (subsetOR === maxOR) {\\n            result++;\\n        }\\n    }\\n\\n    for (let i = start; i < nums.length; i++) {\\n      subset.push(nums[i]);\\n      backtrack(nums, i + 1, subset);\\n      subset.pop();\\n    }\\n  }\\n\\n  // Start the backtracking with an empty subset\\n  backtrack(nums, 0, []);\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst countMaxOrSubsets = (nums) => {\\n  // Calculate the maximum bitwise OR of nums\\n  const maxOR = nums.reduce((a, b) => a | b, 0);\\n\\n  let result = 0;\\n\\n  // generate all subsets of nums\\n  const backtrack = (nums, start, subset) => {\\n    // If the current subset has a bitwise OR equal to the maximum bitwise OR, increment the result\\n    if (subset.length) {\\n        const subsetOR = subset.reduce((a, b) => a | b, 0);\\n        if (subsetOR === maxOR) {\\n            result++;\\n        }\\n    }\\n\\n    for (let i = start; i < nums.length; i++) {\\n      subset.push(nums[i]);\\n      backtrack(nums, i + 1, subset);\\n      subset.pop();\\n    }\\n  }\\n\\n  // Start the backtracking with an empty subset\\n  backtrack(nums, 0, []);\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715609,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int val;\\n    map<int,int>mp;\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {   \\n         val=INT_MIN;\\n         int idx=0;\\n         fun(nums,idx,0);\\n         return mp[val];\\n    }\\n    void fun(vector<int>&nums,int idx,int ele)\\n    {\\n        if(idx >= nums.size())\\n        {\\n            val=max(val,ele);\\n            mp[ele]++;\\n            return;\\n        }\\n        fun(nums,idx+1,ele|nums[idx]);\\n        fun(nums,idx+1,ele);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int val;\\n    map<int,int>mp;\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {   \\n         val=INT_MIN;\\n         int idx=0;\\n         fun(nums,idx,0);\\n         return mp[val];\\n    }\\n    void fun(vector<int>&nums,int idx,int ele)\\n    {\\n        if(idx >= nums.size())\\n        {\\n            val=max(val,ele);\\n            mp[ele]++;\\n            return;\\n        }\\n        fun(nums,idx+1,ele|nums[idx]);\\n        fun(nums,idx+1,ele);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583743,
                "title": "c-bit-manipulation-backtracking-recursion",
                "content": "\\n__Algorithm__\\n\\n- Here we will first find the max OR => which is the OR of the whole array( maxOr)\\n\\n- Now in an subarray with OR of that array == maxOr an element with index i may or may not be present so we will use recursion \\n\\n- Here we will run recursion for when an element is in that subarray and then when that element is not in that subarray \\n\\n- At the end when all elements have been covered we will check is the OR == maxOR and increment answer accordingly\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int currIndex , vector<int>& nums , int maxOr , int currOr , int& ans){\\n        if(currIndex == nums.size()){\\n            if(currOr == maxOr) ans++;\\n            return;\\n        }\\n        \\n        helper(currIndex+1 , nums , maxOr , currOr , ans);\\n        helper(currIndex+1 , nums , maxOr , currOr|nums[currIndex] , ans);\\n\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0 , ans = 0 ; for(auto a : nums) maxOr |= a;\\n        helper(0 , nums , maxOr , 0 , ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int currIndex , vector<int>& nums , int maxOr , int currOr , int& ans){\\n        if(currIndex == nums.size()){\\n            if(currOr == maxOr) ans++;\\n            return;\\n        }\\n        \\n        helper(currIndex+1 , nums , maxOr , currOr , ans);\\n        helper(currIndex+1 , nums , maxOr , currOr|nums[currIndex] , ans);\\n\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0 , ans = 0 ; for(auto a : nums) maxOr |= a;\\n        helper(0 , nums , maxOr , 0 , ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562376,
                "title": "java-solution-o-n-memory-87-better-no-extra-arrays-lists-used-explanation",
                "content": "\\n\\n```\\nclass Solution {\\n    \\n    static int count;\\n    static int max;\\n    static int[] arr;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        count = 0;\\n        max = 0;\\n        arr = nums;\\n\\t\\t//find max OR value\\n        for (int i = 0; i < nums.length; i++) {\\n            max |= nums[i];\\n        }\\n\\t\\t//starting calculating OR from different numbers\\n        for (int i = 0; i < nums.length; i++) {\\n            findCount(i, 0);\\n        }\\n        return count;\\n    }\\n    \\n    private void findCount(int idxStart, int orResult) {\\n\\t\\t//base condition\\n        if (idxStart >= arr.length) return;\\n\\t\\t\\n        orResult |= arr[idxStart];\\n\\t\\t\\n        if (orResult == max) {\\n            count++;\\n        }\\n        //recursively calculating OR for a sequence until we reach idx\\n        for (int i = idxStart + 1; i < arr.length; i++) {\\n            findCount(i, orResult);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    static int count;\\n    static int max;\\n    static int[] arr;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        count = 0;\\n        max = 0;\\n        arr = nums;\\n\\t\\t//find max OR value\\n        for (int i = 0; i < nums.length; i++) {\\n            max |= nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2446761,
                "title": "python3-solved-using-recursion-backtracking",
                "content": "```\\nclass Solution:\\n    #Let n = len(nums) array!\\n    #Time-Complexity: O(n * 2^n), since we make 2^n rec. calls to generate\\n    #all 2^n different subsets and for each rec. call, we call helper function that\\n    #computes Bitwise Or Lienarly!\\n    #Space-Complexity: O(n), since max stack depth is n!\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        \\n        \\n        #helper function!\\n        def calculate_BWOR(arr):\\n            if(len(arr) == 1):\\n                return arr[0]\\n            else:\\n                n = len(arr)\\n                res = arr[0]\\n                for i in range(1, n):\\n                    #take the bitwise or operation on two integers: ans and i!\\n                    res = res | arr[i]\\n                return res\\n                    \\n        \\n        \\n        \\n        \\n        #Approach: Utilize backtracking to generate all possible subsets!\\n        #Even if two sets contain same elements, it can be considered different\\n        #if we choose elements of differing indices!\\n        \\n        #I can keep track in answer all of the subset(s) that posseses the maximum\\n        #bitwise or!\\n        \\n        #At the end, I simply have to return number of subsets in answer!\\n        \\n        ans = []\\n        n = len(nums)\\n        #since the range of integers in input array nums is at least 1,\\n        #I will initialize maximum bitwise or value to 1!\\n        maximum = 1\\n        #parameters: i -> index that we are considering from\\n        #cur -> array of elements in current subset we built up so far!\\n        def helper(i, cur):\\n            nonlocal nums, ans, maximum, n\\n            #base case -> if index i == n and current subset is not None, we know we made             #decision to include or not include for each and every of the n elements!\\n            if(i == n):\\n                if(not cur):\\n                    return\\n                #once we hit base case, get the bitwise or of cur and compare\\n                #against max!\\n                #1. If it matches max, add it to ans!\\n                #2. If it beats current max, update maximum and update ans to\\n                #have only cur element!\\n                #3. Otherwise, ignore!\\n                current = calculate_BWOR(cur)\\n                if(current > maximum):\\n                    maximum = current\\n                    #make sure to add deep copy!\\n                    ans = [cur[::]]\\n                    return\\n                elif(current == maximum):\\n                    #make sure to add deep copy! Contents of cur might change\\n                    #as we return to parent rec. call from current call to helper!\\n                    ans.append(cur[::])\\n                    return\\n                else:\\n                    return\\n            #if it\\'s not the base case, we have to make 2 rec. calls!\\n            cur.append(nums[i])\\n            helper(i+1, cur)\\n            #once the prev. rec.call finishes, we generated all subsets that\\n            #does contain nums[i]!\\n            \\n            cur.pop()\\n            #this rec. call generates all subsets that do not contain nums[i]\\n            helper(i+1, cur)\\n        \\n        helper(0, [])\\n        return len(ans)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    #Let n = len(nums) array!\\n    #Time-Complexity: O(n * 2^n), since we make 2^n rec. calls to generate\\n    #all 2^n different subsets and for each rec. call, we call helper function that\\n    #computes Bitwise Or Lienarly!\\n    #Space-Complexity: O(n), since max stack depth is n!\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        \\n        \\n        #helper function!\\n        def calculate_BWOR(arr):\\n            if(len(arr) == 1):\\n                return arr[0]\\n            else:\\n                n = len(arr)\\n                res = arr[0]\\n                for i in range(1, n):\\n                    #take the bitwise or operation on two integers: ans and i!\\n                    res = res | arr[i]\\n                return res\\n                    \\n        \\n        \\n        \\n        \\n        #Approach: Utilize backtracking to generate all possible subsets!\\n        #Even if two sets contain same elements, it can be considered different\\n        #if we choose elements of differing indices!\\n        \\n        #I can keep track in answer all of the subset(s) that posseses the maximum\\n        #bitwise or!\\n        \\n        #At the end, I simply have to return number of subsets in answer!\\n        \\n        ans = []\\n        n = len(nums)\\n        #since the range of integers in input array nums is at least 1,\\n        #I will initialize maximum bitwise or value to 1!\\n        maximum = 1\\n        #parameters: i -> index that we are considering from\\n        #cur -> array of elements in current subset we built up so far!\\n        def helper(i, cur):\\n            nonlocal nums, ans, maximum, n\\n            #base case -> if index i == n and current subset is not None, we know we made             #decision to include or not include for each and every of the n elements!\\n            if(i == n):\\n                if(not cur):\\n                    return\\n                #once we hit base case, get the bitwise or of cur and compare\\n                #against max!\\n                #1. If it matches max, add it to ans!\\n                #2. If it beats current max, update maximum and update ans to\\n                #have only cur element!\\n                #3. Otherwise, ignore!\\n                current = calculate_BWOR(cur)\\n                if(current > maximum):\\n                    maximum = current\\n                    #make sure to add deep copy!\\n                    ans = [cur[::]]\\n                    return\\n                elif(current == maximum):\\n                    #make sure to add deep copy! Contents of cur might change\\n                    #as we return to parent rec. call from current call to helper!\\n                    ans.append(cur[::])\\n                    return\\n                else:\\n                    return\\n            #if it\\'s not the base case, we have to make 2 rec. calls!\\n            cur.append(nums[i])\\n            helper(i+1, cur)\\n            #once the prev. rec.call finishes, we generated all subsets that\\n            #does contain nums[i]!\\n            \\n            cur.pop()\\n            #this rec. call generates all subsets that do not contain nums[i]\\n            helper(i+1, cur)\\n        \\n        helper(0, [])\\n        return len(ans)",
                "codeTag": "Java"
            },
            {
                "id": 2405609,
                "title": "java-simple-recursive-solution",
                "content": "```\\nclass Solution \\n{\\n    int count=0;\\n    int MaxOR=0;\\n    private void findSubsets(int ind,List<Integer> ds,int[] arr,int currentOR)\\n    {\\n        if(ind==arr.length)\\n        {\\n            if(currentOR>MaxOR)\\n            {\\n                MaxOR=currentOR;\\n                count=0;\\n            }\\n            else if(currentOR==MaxOR)\\n                count++;\\n            return;\\n        }\\n        ds.add(arr[ind]);\\n        findSubsets(ind+1,ds,arr,currentOR|arr[ind]);\\n        ds.remove(ds.size()-1);\\n        findSubsets(ind+1,ds,arr,currentOR);\\n    }\\n    public int countMaxOrSubsets(int[] nums) \\n    {\\n        findSubsets(0,new ArrayList<>(),nums,0);\\n        return count+1;//+1 for first element\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    int count=0;\\n    int MaxOR=0;\\n    private void findSubsets(int ind,List<Integer> ds,int[] arr,int currentOR)\\n    {\\n        if(ind==arr.length)\\n        {\\n            if(currentOR>MaxOR)\\n            {\\n                MaxOR=currentOR;\\n                count=0;\\n            }\\n            else if(currentOR==MaxOR)\\n                count++;\\n            return;\\n        }\\n        ds.add(arr[ind]);\\n        findSubsets(ind+1,ds,arr,currentOR|arr[ind]);\\n        ds.remove(ds.size()-1);\\n        findSubsets(ind+1,ds,arr,currentOR);\\n    }\\n    public int countMaxOrSubsets(int[] nums) \\n    {\\n        findSubsets(0,new ArrayList<>(),nums,0);\\n        return count+1;//+1 for first element\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299623,
                "title": "or-subset-generation-backtracking-clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> &nums, int index, int &maxi, int val ,int &count)\\n    {\\n        if(index == nums.size()){\\n            if(val >= maxi){\\n                maxi = val;\\n                count++;\\n            }\\n            return;\\n        }\\n        dfs(nums, index + 1, maxi, val | nums[index], count);\\n        dfs(nums, index + 1, maxi, val, count);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int count = 0;\\n        dfs(nums, 0 , maxi, 0, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> &nums, int index, int &maxi, int val ,int &count)\\n    {\\n        if(index == nums.size()){\\n            if(val >= maxi){\\n                maxi = val;\\n                count++;\\n            }\\n            return;\\n        }\\n        dfs(nums, index + 1, maxi, val | nums[index], count);\\n        dfs(nums, index + 1, maxi, val, count);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int count = 0;\\n        dfs(nums, 0 , maxi, 0, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241861,
                "title": "easy-to-read-c-brute-force-bit-masking",
                "content": "\\t\\t// Basically if there is any way, such we can generate every possible subset of the given array\\n\\t\\t//then  we can solve this question easily\\n\\t\\t// also maximum or for any given no. of elements can be obtained by doing bitwise or of all the elements\\n\\t\\t// Time - Complexity O(2^n * nums.size())\\n\\t\\t// Space-Complexity O(1)\\n\\t\\tint total_subset = 1 << nums.size(), subset(0);\\n        int max_r(0);\\n        for(auto i : nums){max_r |= i; } // now max_r stores maximum bitwise or of all elements\\n        \\n        for(int i = 1; i <= total_subset; i++) // total subsets would be 2^nums.size()\\n        {\\n            int running_r(0);\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(i >> j & 1){running_r  |= nums[j]; }\\n            }\\n            \\n            if(running_r == max_r){subset++;}\\n        }\\n        \\n        return subset;\\n\\t\\t\\n\\t\\t//  \\uD83D\\uDE04 \\uD83D\\uDE04 \\uD83D\\uDE04PLEASE DO UPVOTE IF YOU UNDERSTOOD THE CODE AND THE EXPLANATION \\uD83D\\uDE04 \\uD83D\\uDE04 \\uD83D\\uDE04",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "\\t\\t// Basically if there is any way, such we can generate every possible subset of the given array\\n\\t\\t//then  we can solve this question easily\\n\\t\\t// also maximum or for any given no. of elements can be obtained by doing bitwise or of all the elements\\n\\t\\t// Time - Complexity O(2^n * nums.size())\\n\\t\\t// Space-Complexity O(1)\\n\\t\\tint total_subset = 1 << nums.size(), subset(0);\\n        int max_r(0);\\n        for(auto i : nums){max_r |= i; } // now max_r stores maximum bitwise or of all elements\\n        \\n        for(int i = 1; i <= total_subset; i++) // total subsets would be 2^nums.size()\\n        {\\n            int running_r(0);\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(i >> j & 1){running_r  |= nums[j]; }\\n            }\\n            \\n            if(running_r == max_r){subset++;}\\n        }\\n        \\n        return subset;\\n\\t\\t\\n\\t\\t//  \\uD83D\\uDE04 \\uD83D\\uDE04 \\uD83D\\uDE04PLEASE DO UPVOTE IF YOU UNDERSTOOD THE CODE AND THE EXPLANATION \\uD83D\\uDE04 \\uD83D\\uDE04 \\uD83D\\uDE04",
                "codeTag": "Unknown"
            },
            {
                "id": 2175662,
                "title": "c-recursion",
                "content": "class Solution {\\npublic:\\n    int maxor=0, res=0;\\n    \\n    void f(vector<int>&n, int i, int s){\\n        if(s == maxor and i==n.size())res++;\\n        if(i == n.size()) return;\\n        \\n        f(n, i+1, s|n[i]);\\n        // cout<<s;\\n        f(n, i+1, s);\\n        return;\\n    }\\n    int countMaxOrSubsets(vector<int>& n) {\\n        for(auto i : n)maxor |= i;\\n        f(n, 0, 0);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxor=0, res=0;\\n    \\n    void f(vector<int>&n, int i, int s){\\n        if(s == maxor and i==n.size())res++;\\n        if(i == n.size()) return;\\n        \\n        f(n, i+1, s|n[i]);\\n        // cout<<s;\\n        f(n, i+1, s);\\n        return;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2083222,
                "title": "easy-recursive-approach-take-or-not-take",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0, mxorGlobal;\\n    void solve(vector<int> &nums, int n, int mxor) {\\n        if(n == 0) {\\n            if(mxorGlobal == mxor) ans++;\\n            else if(mxorGlobal < mxor) {\\n                mxorGlobal = mxor;\\n                ans = 1;\\n            }\\n            return;\\n        }\\n        //or\\n        solve(nums, n-1, mxor|nums[n-1]);\\n        // skip\\n        solve(nums, n-1, mxor);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        solve(nums, nums.size(), 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0, mxorGlobal;\\n    void solve(vector<int> &nums, int n, int mxor) {\\n        if(n == 0) {\\n            if(mxorGlobal == mxor) ans++;\\n            else if(mxorGlobal < mxor) {\\n                mxorGlobal = mxor;\\n                ans = 1;\\n            }\\n            return;\\n        }\\n        //or\\n        solve(nums, n-1, mxor|nums[n-1]);\\n        // skip\\n        solve(nums, n-1, mxor);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        solve(nums, nums.size(), 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069996,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n     void f(vector<int>&nums,int i,vector<int>&v,int xr)\\n    { \\n        if(i>=nums.size())\\n        { \\n            v.push_back(xr);\\n            return ;\\n        }\\n        int k=xr;\\n        xr=xr|nums[i];\\n        f(nums,i+1,v,xr);\\n        xr=k;\\n        f(nums,i+1,v,xr);\\n        \\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vector<int>v;\\n        int xr=nums[0];\\n        f(nums,0,v,0);\\n        int ans=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        return count(v.begin(),v.end(),v[0]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void f(vector<int>&nums,int i,vector<int>&v,int xr)\\n    { \\n        if(i>=nums.size())\\n        { \\n            v.push_back(xr);\\n            return ;\\n        }\\n        int k=xr;\\n        xr=xr|nums[i];\\n        f(nums,i+1,v,xr);\\n        xr=k;\\n        f(nums,i+1,v,xr);\\n        \\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vector<int>v;\\n        int xr=nums[0];\\n        f(nums,0,v,0);\\n        int ans=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        return count(v.begin(),v.end(),v[0]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958671,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int num: nums) max |= num;\\n        dfs(nums, 0, max, 0);\\n        return result;\\n    }\\n    \\n    private void dfs(int[] nums, int start, int max, int curOr) {\\n        if (start == nums.length && curOr == max) {\\n            result++;\\n            return;\\n        }\\n        \\n        if(start < nums.length) {\\n            dfs(nums, start + 1, max, curOr | nums[start]);\\n            dfs(nums, start + 1, max, curOr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int num: nums) max |= num;\\n        dfs(nums, 0, max, 0);\\n        return result;\\n    }\\n    \\n    private void dfs(int[] nums, int start, int max, int curOr) {\\n        if (start == nums.length && curOr == max) {\\n            result++;\\n            return;\\n        }\\n        \\n        if(start < nums.length) {\\n            dfs(nums, start + 1, max, curOr | nums[start]);\\n            dfs(nums, start + 1, max, curOr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870018,
                "title": "java-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution {\\n    int key=0,val=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        int or = 0;\\n        recursion(nums,0,or);\\n        \\n        return val;\\n    }\\n    void recursion(int[] nums,int curr,int total)\\n    {\\n        if(curr == nums.length)\\n        {\\n            if(key == 0 || total > key)\\n            {\\n                key = total;\\n                val =1;\\n            }\\n            else if(total == key)   val++;\\n            return;\\n        }\\n        recursion(nums,curr+1,total|nums[curr]);\\n        recursion(nums,curr+1,total);\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int key=0,val=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        \\n        int or = 0;\\n        recursion(nums,0,or);\\n        \\n        return val;\\n    }\\n    void recursion(int[] nums,int curr,int total)\\n    {\\n        if(curr == nums.length)\\n        {\\n            if(key == 0 || total > key)\\n            {\\n                key = total;\\n                val =1;\\n            }\\n            else if(total == key)   val++;\\n            return;\\n        }\\n        recursion(nums,curr+1,total|nums[curr]);\\n        recursion(nums,curr+1,total);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742852,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mx;\\n    int res;\\n    int n;\\n    void solve(vector<int>& nums, int i, int oR){\\n        //base case\\n        if(i==n){\\n            if(oR == mx) res++;\\n            return;\\n        }\\n        //recursive case\\n        solve(nums, i+1, oR|nums[i]);\\n        solve(nums, i+1, oR);\\n        return;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        // int n=nums.size();\\n        // int a=0,mx=0;\\n        // for(int &x:nums) mx|=x;\\n        // // //subset generation using bitmask\\n        // int res = 0;\\n        // int s_ct=(1<<n);//no of subsets\\n        // for(int i=0;i<s_ct;i++){\\n        //     int oR=0;\\n        //     for(int j=0;j<n;j++){\\n        //         if(i&(1<<j))//means bit is set\\n        //             oR|=nums[j];\\n        //     }\\n        //     if(mx == oR) res++;   \\n        // }\\n        // return res;\\n        mx = 0;\\n        res = 0;\\n        n = nums.size();\\n        for(int &x:nums) mx|=x;\\n        solve(nums, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx;\\n    int res;\\n    int n;\\n    void solve(vector<int>& nums, int i, int oR){\\n        //base case\\n        if(i==n){\\n            if(oR == mx) res++;\\n            return;\\n        }\\n        //recursive case\\n        solve(nums, i+1, oR|nums[i]);\\n        solve(nums, i+1, oR);\\n        return;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        // int n=nums.size();\\n        // int a=0,mx=0;\\n        // for(int &x:nums) mx|=x;\\n        // // //subset generation using bitmask\\n        // int res = 0;\\n        // int s_ct=(1<<n);//no of subsets\\n        // for(int i=0;i<s_ct;i++){\\n        //     int oR=0;\\n        //     for(int j=0;j<n;j++){\\n        //         if(i&(1<<j))//means bit is set\\n        //             oR|=nums[j];\\n        //     }\\n        //     if(mx == oR) res++;   \\n        // }\\n        // return res;\\n        mx = 0;\\n        res = 0;\\n        n = nums.size();\\n        for(int &x:nums) mx|=x;\\n        solve(nums, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742300,
                "title": "another-worst-solution",
                "content": "```\\n\\nclass Solution {\\n    public int countMaxOrSubsets(int[] arr) {\\n        int mxOr = Integer.MIN_VALUE;\\n    \\tint limit = 1<<arr.length ;\\n    \\tint temp =0 ;\\n    \\tfor(int i =0 ;i<arr.length ;i++) {\\n    \\t\\ttemp|=arr[i] ;\\n    \\t\\tmxOr = Math.max(mxOr,temp) ;\\n    \\t}\\n    \\tint cnt = 0 ;\\n    \\tfor(int i=0 ;i<limit ;i++) {\\n    \\t\\tint  num = i ;\\n    \\t\\tint sum = 0 ;\\n    \\t\\tfor(int j=arr.length-1 ;j>=0 ;j--) {\\n    \\t\\t\\tif((num% 2)==1) {\\n    \\t\\t\\t\\tsum|=arr[j] ;\\n    \\t\\t\\t}\\n    \\t\\t\\tnum/=2 ;\\n    \\t\\t}\\n    \\t\\tif(sum==mxOr)cnt++ ;\\n    \\t}\\n    \\treturn cnt ;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int countMaxOrSubsets(int[] arr) {\\n        int mxOr = Integer.MIN_VALUE;\\n    \\tint limit = 1<<arr.length ;\\n    \\tint temp =0 ;\\n    \\tfor(int i =0 ;i<arr.length ;i++) {\\n    \\t\\ttemp|=arr[i] ;\\n    \\t\\tmxOr = Math.max(mxOr,temp) ;\\n    \\t}\\n    \\tint cnt = 0 ;\\n    \\tfor(int i=0 ;i<limit ;i++) {\\n    \\t\\tint  num = i ;\\n    \\t\\tint sum = 0 ;\\n    \\t\\tfor(int j=arr.length-1 ;j>=0 ;j--) {\\n    \\t\\t\\tif((num% 2)==1) {\\n    \\t\\t\\t\\tsum|=arr[j] ;\\n    \\t\\t\\t}\\n    \\t\\t\\tnum/=2 ;\\n    \\t\\t}\\n    \\t\\tif(sum==mxOr)cnt++ ;\\n    \\t}\\n    \\treturn cnt ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726013,
                "title": "c-bitmask-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,ans;\\n        // //subset generation using bitmask\\n        map<int,int>mp;\\n        int s_ct=(1<<n);//no of subsets\\n        for(int i=0;i<s_ct;i++){\\n            \\n            int oR=0;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j))//means bit is set\\n                {\\n                    \\n                    oR|=nums[j];\\n                }\\n            }\\n            mp[oR]++;\\n           \\n        }\\n        return mp.rbegin()->second;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,ans;\\n        // //subset generation using bitmask\\n        map<int,int>mp;\\n        int s_ct=(1<<n);//no of subsets\\n        for(int i=0;i<s_ct;i++){\\n            \\n            int oR=0;\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j))//means bit is set\\n                {\\n                    \\n                    oR|=nums[j];\\n                }\\n            }\\n            mp[oR]++;\\n           \\n        }\\n        return mp.rbegin()->second;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628507,
                "title": "java-dfs-or-dp",
                "content": "DFS with backtracking by checking all possible subsets for OR mask (beats 85%)\\n```\\n    public int countMaxOrSubsets(int[] nums) {\\n        int or = 0;\\n        for(int i=0;i<nums.length;i++)\\n            or |= nums[i];\\n        return dfs(nums, or, 0,0);\\n    }\\n    private int dfs(int[] nums, int or, int currOr, int pos){\\n        if(pos==nums.length)\\n            return or==currOr ? 1 : 0;\\n        return dfs(nums, or, currOr, pos+1) + dfs(nums, or, currOr|nums[pos],pos+1);\\n    }\\n```\\n\\nDP with buffer of OR-size and checking in  how many ways we can reach OR value (beats 52%)\\n```\\n    public int countMaxOrSubsets(int[] nums) {\\n        int or = 0;\\n        for(int i=0;i<nums.length;i++)\\n            or |= nums[i];\\n\\n        int[] dp = new int[or];\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=or-1;j>=0;j--){\\n                if(dp[j] != 0){\\n                    int nextOr = (j+1) | nums[i];\\n                    dp[nextOr-1] += dp[j];\\n                }\\n            }\\n            dp[nums[i]-1]++;\\n        }\\n        return dp[or-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countMaxOrSubsets(int[] nums) {\\n        int or = 0;\\n        for(int i=0;i<nums.length;i++)\\n            or |= nums[i];\\n        return dfs(nums, or, 0,0);\\n    }\\n    private int dfs(int[] nums, int or, int currOr, int pos){\\n        if(pos==nums.length)\\n            return or==currOr ? 1 : 0;\\n        return dfs(nums, or, currOr, pos+1) + dfs(nums, or, currOr|nums[pos],pos+1);\\n    }\\n```\n```\\n    public int countMaxOrSubsets(int[] nums) {\\n        int or = 0;\\n        for(int i=0;i<nums.length;i++)\\n            or |= nums[i];\\n\\n        int[] dp = new int[or];\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=or-1;j>=0;j--){\\n                if(dp[j] != 0){\\n                    int nextOr = (j+1) | nums[i];\\n                    dp[nextOr-1] += dp[j];\\n                }\\n            }\\n            dp[nums[i]-1]++;\\n        }\\n        return dp[or-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546909,
                "title": "c-similar-to-subset-problem",
                "content": "Extremely similar to subset problem !!!\\n\\nOne big difference is that backtrack is needed if dfs call is adding new item to a list/collector during each level, we need to remove last item from the list/collector while exiting the previous dfs call (leetcode 78)\\n\\nHowever, if the dfs argument is a value, then no backtrack is needed (current problem, leetcode 2044)\\n```\\npublic class Solution {\\n    public int CountMaxOrSubsets(int[] nums) {\\n        int target = 0, count = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0foreach(var num in nums) \\xA0target |= num;\\n\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0dfs(nums, 0, 0, target, ref count);\\n        return count;\\n    }\\n    \\n    private void dfs(int[] nums, int idx, int xor, int target, ref int count) {\\n        if(target == xor) count++;\\n        \\n        for(int i = idx; i < nums.Length; i++)\\n            dfs(nums, i + 1, xor | nums[i], target, ref count);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int CountMaxOrSubsets(int[] nums) {\\n        int target = 0, count = 0;\\n \\xA0 \\xA0 \\xA0 \\xA0foreach(var num in nums) \\xA0target |= num;\\n\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0dfs(nums, 0, 0, target, ref count);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1530535,
                "title": "simple-dfs-like-backtrack-without-back",
                "content": "```\\nclass Solution {\\n    int cnt = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = max | num;\\n        }\\n        dfs(max, 0, 0, nums);\\n        return cnt;\\n    }\\n    \\n    private void dfs(int max, int start, int curr, int[] nums) {\\n        if (curr == max) {\\n            cnt++;\\n        }\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            dfs(max, i + 1, curr | nums[i], nums);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cnt = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int num : nums) {\\n            max = max | num;\\n        }\\n        dfs(max, 0, 0, nums);\\n        return cnt;\\n    }\\n    \\n    private void dfs(int max, int start, int curr, int[] nums) {\\n        if (curr == max) {\\n            cnt++;\\n        }\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            dfs(max, i + 1, curr | nums[i], nums);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529695,
                "title": "java-short-solution-with-dfs-and-pruning-beats-100",
                "content": "The idea is simple - generate all subsets from the beginning of the array. When the bitwise sum gets max, dont enumerate sybsets further, just count all subsets of the remaining elements.\\n\\n```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int x: nums) max |= x;\\n        return checkSubsets(nums, 0, 0, max);\\n    }\\n    \\n    private int checkSubsets(int[] nums, int idx, int curr, int target) {\\n        if (curr == target) return 1 << (nums.length - idx);\\n        if (idx >= nums.length) return 0;\\n        return checkSubsets(nums, idx + 1, curr, target) + checkSubsets(nums, idx + 1, curr | nums[idx], target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for (int x: nums) max |= x;\\n        return checkSubsets(nums, 0, 0, max);\\n    }\\n    \\n    private int checkSubsets(int[] nums, int idx, int curr, int target) {\\n        if (curr == target) return 1 << (nums.length - idx);\\n        if (idx >= nums.length) return 0;\\n        return checkSubsets(nums, idx + 1, curr, target) + checkSubsets(nums, idx + 1, curr | nums[idx], target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529060,
                "title": "brute-force-c-solution",
                "content": "```\\nvoid subsetsUtil(vector<int>& A, vector<vector<int> >& res,vector<int>& subset, int index)\\n    {\\n        res.push_back(subset);\\n        for (int i = index; i < A.size(); i++) {\\n\\n            // include the A[i] in subset.\\n            subset.push_back(A[i]);\\n\\n            // move onto the next element.\\n            subsetsUtil(A, res, subset, i + 1);\\n\\n            // exclude the A[i] from subset and triggers\\n            // backtracking.\\n            subset.pop_back();\\n        }\\n\\n        return;\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) \\n    {\\n         vector<int> subset;\\n         vector<vector<int> > res;\\n         int index = 0;\\n         subsetsUtil(nums, res, subset, index);\\n         int maxi=0; \\n         unordered_map<int,int>m;\\n         for(int i=0;i<res.size();++i)\\n         {\\n             int ans=0;\\n            for(int j=0;j<res[i].size();++j)\\n            {\\n                ans|=res[i][j];\\n            }\\n             maxi=max(maxi,ans);\\n             m[ans]++;\\n         }\\n         return m[maxi];\\n         \\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvoid subsetsUtil(vector<int>& A, vector<vector<int> >& res,vector<int>& subset, int index)\\n    {\\n        res.push_back(subset);\\n        for (int i = index; i < A.size(); i++) {\\n\\n            // include the A[i] in subset.\\n            subset.push_back(A[i]);\\n\\n            // move onto the next element.\\n            subsetsUtil(A, res, subset, i + 1);\\n\\n            // exclude the A[i] from subset and triggers\\n            // backtracking.\\n            subset.pop_back();\\n        }\\n\\n        return;\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) \\n    {\\n         vector<int> subset;\\n         vector<vector<int> > res;\\n         int index = 0;\\n         subsetsUtil(nums, res, subset, index);\\n         int maxi=0; \\n         unordered_map<int,int>m;\\n         for(int i=0;i<res.size();++i)\\n         {\\n             int ans=0;\\n            for(int j=0;j<res[i].size();++j)\\n            {\\n                ans|=res[i][j];\\n            }\\n             maxi=max(maxi,ans);\\n             m[ans]++;\\n         }\\n         return m[maxi];\\n         \\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1528335,
                "title": "python-easy-solution-with-7-lines-beats-100",
                "content": "We can compute the target sum first. Then we need to compute all the separate subsets and check if we obtain a sum that is equal to the target. So we need to keep track of the sum during the recursion. We sum all the possible subsets. O(N\\\\*2^N) time complexity.\\n```\\ndef countMaxOrSubsets(self, nums: List[int]) -> int:\\n    @lru_cache(None)\\n    def dfs(i, csum=0):\\n        if i < 0: return 1 if csum == self.target else 0\\n        return dfs(i-1, csum) + dfs(i-1, csum | nums[i])\\n    self.target = 0\\n    for n in nums: self.target |= n\\n    return dfs(len(nums)-1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countMaxOrSubsets(self, nums: List[int]) -> int:\\n    @lru_cache(None)\\n    def dfs(i, csum=0):\\n        if i < 0: return 1 if csum == self.target else 0\\n        return dfs(i-1, csum) + dfs(i-1, csum | nums[i])\\n    self.target = 0\\n    for n in nums: self.target |= n\\n    return dfs(len(nums)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1526544,
                "title": "c-using-subsets",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxBit=0;\\n        int counter=0;\\n        for(int i=0;i<nums.size();++i)\\n            maxBit=maxBit | nums[i]; \\n        vector<vector<int>> v;\\n        for(int x=0;x<nums.size();++x){\\n            int len=v.size();\\n            for(int i=0;i<len;++i){\\n                vector<int> t;\\n                t=v[i];\\n                t.push_back(nums[x]);\\n                v.push_back(t);\\n            }\\n            vector<int> t2;t2.push_back(nums[x]);\\n            v.push_back(t2);\\n        }\\n        \\n                for(int i=0;i<v.size();++i){\\n                    int temp=0;\\n                    for(int j=0;j<v[i].size();++j)\\n                        temp = temp | v[i][j];\\n                    if(temp == maxBit) counter++;\\n                }   \\n        return counter;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxBit=0;\\n        int counter=0;\\n        for(int i=0;i<nums.size();++i)\\n            maxBit=maxBit | nums[i]; \\n        vector<vector<int>> v;\\n        for(int x=0;x<nums.size();++x){\\n            int len=v.size();\\n            for(int i=0;i<len;++i){\\n                vector<int> t;\\n                t=v[i];\\n                t.push_back(nums[x]);\\n                v.push_back(t);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1526478,
                "title": "c-simple-solution-recursion-map",
                "content": "**Find or of all the subsets and store them in a map;\\nreturn last value of map**\\n\\n```\\nclass Solution {\\n    map <int, int> m;\\npublic:\\n    \\n    void subsets(vector<int>& nums, int i, int value) {\\n        \\n        m[value]++;\\n        for (int j=i; j<nums.size(); j++)\\n            subsets(nums, j+1, value | nums[j]);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return m.rbegin()->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    map <int, int> m;\\npublic:\\n    \\n    void subsets(vector<int>& nums, int i, int value) {\\n        \\n        m[value]++;\\n        for (int j=i; j<nums.size(); j++)\\n            subsets(nums, j+1, value | nums[j]);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        subsets(nums, 0, 0);\\n        return m.rbegin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525991,
                "title": "python-100-faster",
                "content": "```\\ndef countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target=0\\n        for n in nums:\\n            target|=n\\n        self.ans=set()\\n        def helper(i,curr,arr):\\n            if curr==target:\\n                self.ans.add(tuple(arr.copy()))\\n            if i==len(nums):\\n                return\\n            helper(i+1,curr,arr)\\n            helper(i+1,curr|nums[i],arr+[i])\\n            \\n        helper(0,0,[])\\n        return len(self.ans)",
                "solutionTags": [],
                "code": "```\\ndef countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target=0\\n        for n in nums:\\n            target|=n\\n        self.ans=set()\\n        def helper(i,curr,arr):\\n            if curr==target:\\n                self.ans.add(tuple(arr.copy()))\\n            if i==len(nums):\\n                return\\n            helper(i+1,curr,arr)\\n            helper(i+1,curr|nums[i],arr+[i])\\n            \\n        helper(0,0,[])\\n        return len(self.ans)",
                "codeTag": "Python3"
            },
            {
                "id": 1525767,
                "title": "java-simple-solution",
                "content": "```\\nimport java.util.stream.Collectors;\\nclass Solution {\\n    \\n    static List<Integer> list = new ArrayList<Integer>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        list = new ArrayList<Integer>();\\n        int max = 0;\\n        for(int p : nums) max = max | p;\\n        go(nums,0,max);\\n       // System.out.println(list.toString());\\n        return Collections.frequency(list,max);\\n    }\\n    \\n    private void go(int[] nums,int idx,int max){\\n        if(idx == nums.length-1){\\n            list.add(nums[idx]);\\n            return;\\n        }\\n        \\n        go(nums,idx+1,max);\\n        int curr = nums[idx];\\n        List<Integer> buffer = new ArrayList<>();\\n        for(int p : list) buffer.add(p);\\n        \\n        List<Integer> sups = new ArrayList<Integer>();\\n        \\n        sups = list.stream().map(x -> {\\n            if(x < max) return x | curr;\\n            else return x;\\n        }).collect(Collectors.toList());\\n        \\n        for(int p : buffer) sups.add(p);\\n        sups.add(curr);\\n        \\n        list.clear();\\n        for(int p : sups) list.add(p);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.stream.Collectors;\\nclass Solution {\\n    \\n    static List<Integer> list = new ArrayList<Integer>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        list = new ArrayList<Integer>();\\n        int max = 0;\\n        for(int p : nums) max = max | p;\\n        go(nums,0,max);\\n       // System.out.println(list.toString());\\n        return Collections.frequency(list,max);\\n    }\\n    \\n    private void go(int[] nums,int idx,int max){\\n        if(idx == nums.length-1){\\n            list.add(nums[idx]);\\n            return;\\n        }\\n        \\n        go(nums,idx+1,max);\\n        int curr = nums[idx];\\n        List<Integer> buffer = new ArrayList<>();\\n        for(int p : list) buffer.add(p);\\n        \\n        List<Integer> sups = new ArrayList<Integer>();\\n        \\n        sups = list.stream().map(x -> {\\n            if(x < max) return x | curr;\\n            else return x;\\n        }).collect(Collectors.toList());\\n        \\n        for(int p : buffer) sups.add(p);\\n        sups.add(curr);\\n        \\n        list.clear();\\n        for(int p : sups) list.add(p);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525592,
                "title": "c-simple-recursive-solution",
                "content": "\\tclass Solution {\\n\\t\\tint target = 0;\\n\\tpublic:\\n\\t\\tint  help(vector<int>& nums,int i, int curr){\\n\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\tif(curr==target) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn help(nums,i+1,curr|nums[i]) + help(nums,i+1,curr);\\n\\t\\t}\\n\\t\\tint countMaxOrSubsets(vector<int>& nums) {\\n\\t\\t\\tint val = 0;\\n\\t\\t\\tfor(auto x:nums) target = max(target,val|=x);\\n\\t\\t\\treturn help(nums,0,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint target = 0;\\n\\tpublic:\\n\\t\\tint  help(vector<int>& nums,int i, int curr){\\n\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\tif(curr==target) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1525455,
                "title": "python3-beats-100-solution-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        ans = {}\\n        subSet = [[]]\\n        max_or = 0\\n        for i in range(len(nums)):\\n            for j in range(len(subSet)):\\n                new = [nums[i]] + subSet[j]\\n                # print(new)\\n                x = new[0]\\n                for k in range(1, len(new)):\\n                    x |= new[k]\\n                x = max(max_or, x)\\n                if x in ans:\\n                    ans[x] += 1\\n                else:\\n                    ans[x] = 1\\n                subSet.append(new)\\n        return ans[x]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        ans = {}\\n        subSet = [[]]\\n        max_or = 0\\n        for i in range(len(nums)):\\n            for j in range(len(subSet)):\\n                new = [nums[i]] + subSet[j]\\n                # print(new)\\n                x = new[0]\\n                for k in range(1, len(new)):\\n                    x |= new[k]\\n                x = max(max_or, x)\\n                if x in ans:\\n                    ans[x] += 1\\n                else:\\n                    ans[x] = 1\\n                subSet.append(new)\\n        return ans[x]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525391,
                "title": "easy-swift-solution",
                "content": "My swift solution \\n\\n```\\nclass Solution {\\nvar dict = [Int: Int]()\\n\\nfunc OR(_ arr: [Int]) -> Int\\n{\\n    var mOR = 0;\\n    for i in 0...arr.count - 1 {\\n         mOR |= arr[i]\\n    }\\n    return mOR\\n}\\n\\nfunc addtoDict(_ arr: [Int]) {\\n    let xOR = OR(arr)\\n       if dict[xOR] != nil {\\n           dict[xOR]! += 1\\n       } else {\\n           dict[xOR] = 1\\n       }\\n   }\\n\\n    func countMaxOrSubsets(_ nums: [Int]) -> Int {\\n        var result = [[Int]]()\\n        for elem in nums {\\n            for subarray in result {\\n                result.append(subarray + [elem])\\n                addtoDict(subarray + [elem])\\n            }\\n            result.append([elem])\\n            addtoDict([elem])\\n        }\\n        result.append([])\\n        \\n        var maxKey = -1\\n        var maxValue = -1\\n        \\n        for (key, value) in dict {\\n            if key > maxKey {\\n                maxKey = key\\n                maxValue = value\\n            }\\n        }\\n        return maxValue\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nvar dict = [Int: Int]()\\n\\nfunc OR(_ arr: [Int]) -> Int\\n{\\n    var mOR = 0;\\n    for i in 0...arr.count - 1 {\\n         mOR |= arr[i]\\n    }\\n    return mOR\\n}\\n\\nfunc addtoDict(_ arr: [Int]) {\\n    let xOR = OR(arr)\\n       if dict[xOR] != nil {\\n           dict[xOR]! += 1\\n       } else {\\n           dict[xOR] = 1\\n       }\\n   }\\n\\n    func countMaxOrSubsets(_ nums: [Int]) -> Int {\\n        var result = [[Int]]()\\n        for elem in nums {\\n            for subarray in result {\\n                result.append(subarray + [elem])\\n                addtoDict(subarray + [elem])\\n            }\\n            result.append([elem])\\n            addtoDict([elem])\\n        }\\n        result.append([])\\n        \\n        var maxKey = -1\\n        var maxValue = -1\\n        \\n        for (key, value) in dict {\\n            if key > maxKey {\\n                maxKey = key\\n                maxValue = value\\n            }\\n        }\\n        return maxValue\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525332,
                "title": "simple-backtrack-100",
                "content": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxVal = reduce(lambda a, b: a | b, nums)\\n        nums.sort(reverse = True)\\n        n = len(nums)\\n        self.ans = 0\\n        def backtrack(curr, i):\\n            if curr==maxVal:\\n                self.ans+=2**(n-i)\\n                return\\n            if i==n:\\n                return\\n            backtrack(curr, i+1)\\n            backtrack(curr | nums[i],i+1)\\n        backtrack(0,0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxVal = reduce(lambda a, b: a | b, nums)\\n        nums.sort(reverse = True)\\n        n = len(nums)\\n        self.ans = 0\\n        def backtrack(curr, i):\\n            if curr==maxVal:\\n                self.ans+=2**(n-i)\\n                return\\n            if i==n:\\n                return\\n            backtrack(curr, i+1)\\n            backtrack(curr | nums[i],i+1)\\n        backtrack(0,0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525275,
                "title": "c-subsets-unordered-map-tc-o-2-n-sc-o-n-aux-o-n",
                "content": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n        unordered_map<int,int> bORfreq;\\n        int maxOR = INT_MIN;\\n        for (int i = 0; i < (int) pow(2, nums.size()); i++) {\\n            int tempOR = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n                if ((i & (1 << j)) != 0)\\n                    tempOR |= nums[j];\\n            bORfreq[tempOR]++;\\n            if(tempOR != 0)\\n                maxOR = max(maxOR,tempOR);\\n        }    \\n        return bORfreq[maxOR];\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n        unordered_map<int,int> bORfreq;\\n        int maxOR = INT_MIN;\\n        for (int i = 0; i < (int) pow(2, nums.size()); i++) {\\n            int tempOR = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n                if ((i & (1 << j)) != 0)\\n                    tempOR |= nums[j];\\n            bORfreq[tempOR]++;\\n            if(tempOR != 0)\\n                maxOR = max(maxOR,tempOR);\\n        }    \\n        return bORfreq[maxOR];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525214,
                "title": "simple-recursive-solution-c-with-diagram",
                "content": "**Inital Thought:**\\nSeeing the problem statement the initial thought was this being a dp problem. But looking at the constraints figured that it could be done via recursion itself.\\n\\n**Algorithm:**\\n1) for generating subsets each element has a choice, if it wants to be part of current subset or not.\\n\\n2) So two recursive calls for each element:\\n\\t2.1) include it as a part of current subset (so include it in the **\"or\"** result of current subset).\\n\\t2.2) exclude it (so don\\'t add it in **\"or\"** result of current subset).\\n\\n3) at base cases we have all generated subsets.  \\n\\n**Pictorial Representation Of Subset Genration**\\n\\n![image](https://assets.leetcode.com/users/images/ffc5f497-4f9a-4a88-8de1-effe820b6924_1634444916.133533.jpeg)\\n\\nwhere arrow on element\\'s top indicates decision is being taken for it.\\nelements in square bracket represent current subset.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int max_or=-1;\\n    void count_helper(vector<int> & nums,int curr_or,int idx,unordered_map <int,int> & freq){\\n        \\n        int size=nums.size();\\n        \\n        // one subset has been created\\n        if(idx==size){\\n            // maximum bitwise or we can create\\n            max_or=max(max_or,curr_or);\\n            // updating how many times we saw this \"or\" result\\n            freq[curr_or]++;\\n            return;\\n        }    \\n        \\n        // exclude current element\\n        count_helper(nums,curr_or,idx+1,freq);\\n        // include current element\\n        count_helper(nums,curr_or | nums[idx],idx+1,freq);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        unordered_map <int,int> freq;\\n        count_helper(nums,0,0,freq);\\n        \\n        // max or contains the maximum or value we can get\\n       // freq contains the frequency of every or result\\n        return freq[max_or];\\n    }\\n};\\n```\\n\\n**Time Complexity** : O(2^n)\\n**Space Complexity** : O(n)\\n\\nwhere n -> number of elements in array\\n\\nI hope this was helpful!\\nIf there are any suggestions or optimisations do tell. If this helped somehow do consider upvoting :) .",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int max_or=-1;\\n    void count_helper(vector<int> & nums,int curr_or,int idx,unordered_map <int,int> & freq){\\n        \\n        int size=nums.size();\\n        \\n        // one subset has been created\\n        if(idx==size){\\n            // maximum bitwise or we can create\\n            max_or=max(max_or,curr_or);\\n            // updating how many times we saw this \"or\" result\\n            freq[curr_or]++;\\n            return;\\n        }    \\n        \\n        // exclude current element\\n        count_helper(nums,curr_or,idx+1,freq);\\n        // include current element\\n        count_helper(nums,curr_or | nums[idx],idx+1,freq);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        unordered_map <int,int> freq;\\n        count_helper(nums,0,0,freq);\\n        \\n        // max or contains the maximum or value we can get\\n       // freq contains the frequency of every or result\\n        return freq[max_or];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525179,
                "title": "simple-search",
                "content": "We can add memoisation, but it is easy to verify that we do not need it. The runtime is just a few ms already.\\n\\n**C++**\\n```cpp\\nint dfs(vector<int>& n, int i, int cur_or, int max_or) {\\n    if (i >= n.size())\\n        return max_or == cur_or;\\n    else\\n        return dfs(n, i + 1, cur_or, max_or) + dfs(n, i + 1, cur_or | n[i], max_or);\\n}\\nint countMaxOrSubsets(vector<int>& n) {\\n    return dfs(n, 0, 0, accumulate(begin(n), end(n), 0, bit_or<int>()));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dfs(vector<int>& n, int i, int cur_or, int max_or) {\\n    if (i >= n.size())\\n        return max_or == cur_or;\\n    else\\n        return dfs(n, i + 1, cur_or, max_or) + dfs(n, i + 1, cur_or | n[i], max_or);\\n}\\nint countMaxOrSubsets(vector<int>& n) {\\n    return dfs(n, 0, 0, accumulate(begin(n), end(n), 0, bit_or<int>()));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525157,
                "title": "c-bitmask-solution-brute-force",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int all = 1 << n;\\n        int ans = 0;\\n        int mx = 0;\\n        for(int i = 1; i < all; i++) {\\n            int val = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((1 << j) & i) {\\n                    val |= nums[j];\\n                }\\n            }\\n            if(val >= mx) {\\n                if(val == mx) {\\n                    ++ans;\\n                } else {\\n                    ans = 1;\\n                    mx = val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int all = 1 << n;\\n        int ans = 0;\\n        int mx = 0;\\n        for(int i = 1; i < all; i++) {\\n            int val = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((1 << j) & i) {\\n                    val |= nums[j];\\n                }\\n            }\\n            if(val >= mx) {\\n                if(val == mx) {\\n                    ++ans;\\n                } else {\\n                    ans = 1;\\n                    mx = val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084820,
                "title": "backtrack-simple-python",
                "content": "just use backtrack as constraint is so small\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        max_or = 0\\n        for num in nums:max_or |= num\\n        self.res = 0\\n        def backtrack(ind,pref):\\n            if pref == max_or:self.res += 1\\n            if ind >= len(nums):return \\n            for i in range(ind,len(nums)):backtrack(i+1,pref|nums[i])\\n        backtrack(0,0)\\n        return self.res",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "just use backtrack as constraint is so small\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        max_or = 0\\n        for num in nums:max_or |= num\\n        self.res = 0\\n        def backtrack(ind,pref):\\n            if pref == max_or:self.res += 1\\n            if ind >= len(nums):return \\n            for i in range(ind,len(nums)):backtrack(i+1,pref|nums[i])\\n        backtrack(0,0)\\n        return self.res",
                "codeTag": "Java"
            },
            {
                "id": 4081631,
                "title": "from-78-subsets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all subsets possible using [78. Subsets](https://leetcode.com/problems/subsets/description/).\\n\\nThen find the number of subsets with max OR\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2^n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```python []\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxor=0\\n        subset,res=[],[]\\n        for n in nums:\\n          maxor|=n\\n        \\n        def subsets(nums: List[int]):\\n\\n          def backtrack(i):\\n              if i>=len(nums):\\n                  res.append(subset.copy())\\n                  return\\n              subset.append(nums[i])\\n              backtrack(i+1)\\n              subset.pop()\\n              backtrack(i+1)\\n          \\n          backtrack(0)\\n\\n        subsets(nums)\\n        ans=0\\n        for subset in res:\\n          m=0\\n          for l in subset:\\n            m|=l\\n          if m==maxor:\\n            ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxor=0\\n        subset,res=[],[]\\n        for n in nums:\\n          maxor|=n\\n        \\n        def subsets(nums: List[int]):\\n\\n          def backtrack(i):\\n              if i>=len(nums):\\n                  res.append(subset.copy())\\n                  return\\n              subset.append(nums[i])\\n              backtrack(i+1)\\n              subset.pop()\\n              backtrack(i+1)\\n          \\n          backtrack(0)\\n\\n        subsets(nums)\\n        ans=0\\n        for subset in res:\\n          m=0\\n          for l in subset:\\n            m|=l\\n          if m==maxor:\\n            ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037086,
                "title": "backtracking-c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int> nums ,int index, int temp,int& count,int& maxi){\\n        if(index >=nums.size()){\\n            if(temp == maxi)\\n                count++;\\n            else if(temp>maxi){\\n                maxi = temp;\\n                count = 1;\\n            }\\n            return;\\n        }\\n        solve(nums,index+1,temp,count,maxi);\\n        temp = temp|nums[index];\\n        solve(nums,index+1,temp,count,maxi);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int count = 0;\\n        int maxi = INT_MIN;\\n        solve(nums,0,0,count,maxi);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> nums ,int index, int temp,int& count,int& maxi){\\n        if(index >=nums.size()){\\n            if(temp == maxi)\\n                count++;\\n            else if(temp>maxi){\\n                maxi = temp;\\n                count = 1;\\n            }\\n            return;\\n        }\\n        solve(nums,index+1,temp,count,maxi);\\n        temp = temp|nums[index];\\n        solve(nums,index+1,temp,count,maxi);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int count = 0;\\n        int maxi = INT_MIN;\\n        solve(nums,0,0,count,maxi);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010410,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    int res=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        //By using Backtracking\\n        int p=0;\\n        for(int i=0;i<nums.length;i++){\\n            p|=nums[i];\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        Met(0,list,nums,p);\\n        return res;\\n    }\\n    public void Met(int index,ArrayList<Integer> list,int[] nums,int p){\\n        if(index==nums.length){\\n            int t=0;\\n            for(int i=0;i<list.size();i++){\\n                t|=list.get(i);\\n            }\\n            if(t==p){\\n                res++;\\n            }\\n            return;\\n        }\\n        list.add(nums[index]);\\n        Met(index+1,list,nums,p);\\n        list.remove(list.size()-1);\\n        Met(index+1,list,nums,p);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        //By using Backtracking\\n        int p=0;\\n        for(int i=0;i<nums.length;i++){\\n            p|=nums[i];\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        Met(0,list,nums,p);\\n        return res;\\n    }\\n    public void Met(int index,ArrayList<Integer> list,int[] nums,int p){\\n        if(index==nums.length){\\n            int t=0;\\n            for(int i=0;i<list.size();i++){\\n                t|=list.get(i);\\n            }\\n            if(t==p){\\n                res++;\\n            }\\n            return;\\n        }\\n        list.add(nums[index]);\\n        Met(index+1,list,nums,p);\\n        list.remove(list.size()-1);\\n        Met(index+1,list,nums,p);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007828,
                "title": "2-approaches-i-using-simple-backtracking-ii-backtracking-hashmap",
                "content": "# Intuition\\n1- Problem is similer to subset sum problem, so we can solve it using backtracking.\\n2- We can use the hashmap for storing subset or\\'s.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    - For solution 1 : O(2^n)\\n    - For solution 2 : O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - For solution 1 : O(1)\\n    - For solution 2 : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n__Solution : 1__\\n```\\nclass Solution {\\npublic:\\nint maxor=0;\\nint cnt=0;\\nvoid recursion(vector<int>&nums, int i, int oor){\\n        if(i>=nums.size()){\\n            if(oor>maxor){\\n                cnt=1;\\n                maxor = oor;\\n            }else if(oor==maxor){\\n                cnt++;\\n            }\\n            return;\\n        }\\n        recursion(nums, i+1, oor | nums[i]);\\n        recursion(nums, i+1, oor);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int oor = 0;\\n        recursion(nums, 0, oor);\\n        return cnt;\\n    }\\n};\\n```\\n__Solution : 2__\\n```\\nclass Solution {\\npublic:\\nunordered_map<int, int>umap;\\nvoid recursion(vector<int>&nums, int i, int oor){\\n        if(i>=nums.size()){\\n            umap[oor]++;\\n            return;\\n        }\\n        recursion(nums, i+1, oor | nums[i]);\\n        recursion(nums, i+1, oor);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int oor = 0;\\n        recursion(nums, 0, oor);\\n        int ans=0;\\n        int maxor=0;\\n        for(auto i = umap.begin();i!=umap.end();i++){\\n            if(i->first>maxor){\\n                maxor = i->first;\\n                ans = i->second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxor=0;\\nint cnt=0;\\nvoid recursion(vector<int>&nums, int i, int oor){\\n        if(i>=nums.size()){\\n            if(oor>maxor){\\n                cnt=1;\\n                maxor = oor;\\n            }else if(oor==maxor){\\n                cnt++;\\n            }\\n            return;\\n        }\\n        recursion(nums, i+1, oor | nums[i]);\\n        recursion(nums, i+1, oor);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int oor = 0;\\n        recursion(nums, 0, oor);\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nunordered_map<int, int>umap;\\nvoid recursion(vector<int>&nums, int i, int oor){\\n        if(i>=nums.size()){\\n            umap[oor]++;\\n            return;\\n        }\\n        recursion(nums, i+1, oor | nums[i]);\\n        recursion(nums, i+1, oor);\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int oor = 0;\\n        recursion(nums, 0, oor);\\n        int ans=0;\\n        int maxor=0;\\n        for(auto i = umap.begin();i!=umap.end();i++){\\n            if(i->first>maxor){\\n                maxor = i->first;\\n                ans = i->second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933960,
                "title": "easy-recursion",
                "content": "class Solution {\\npublic:\\n    \\n    int rec1(vector<int>& nums,int n,int i)\\n    {\\n        if(i<0)\\n            return 0;\\n        \\n        int notpick= rec1(nums,n,i-1);\\n        int pick= nums[i] | rec1(nums,n,i-1);\\n        \\n        return max(pick,notpick);\\n    }\\n    \\n    int rec(vector<int>& nums,int n, int i,int maxor,int curror)\\n    {\\n        if(i<0)\\n        {\\n            if(curror==maxor)\\n                return 1;\\n            \\n            return 0;\\n        }\\n        \\n        int notpick= rec(nums,n,i-1,maxor,curror);\\n        int pick= rec(nums,n,i-1,maxor,curror|nums[i]);\\n        \\n        return pick+notpick;\\n    }\\n    \\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n= nums.size();\\n        \\n        int maxor= rec1(nums,n,n-1);\\n        \\n        return rec(nums,n,n-1,maxor,0);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int rec1(vector<int>& nums,int n,int i)\\n    {\\n        if(i<0)\\n            return 0;\\n        \\n        int notpick= rec1(nums,n,i-1);\\n        int pick= nums[i] | rec1(nums,n,i-1);\\n        \\n        return max(pick,notpick);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3927880,
                "title": "short-solution-100",
                "content": "\\n```\\npublic class Solution {\\n    public int run(int val, int i, int[] nums, int max)\\n    {\\n        if (i >= nums.Length)        \\n            return val == max ? 1 : 0;\\n        else\\n            return run(val          , i + 1, nums, max) + \\n                   run(val | nums[i], i + 1, nums, max);\\n    }\\n\\n    public int CountMaxOrSubsets(int[] nums) {       \\n        return run(0, 0, nums, nums.Aggregate(0, (t, n) => t | n));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int run(int val, int i, int[] nums, int max)\\n    {\\n        if (i >= nums.Length)        \\n            return val == max ? 1 : 0;\\n        else\\n            return run(val          , i + 1, nums, max) + \\n                   run(val | nums[i], i + 1, nums, max);\\n    }\\n\\n    public int CountMaxOrSubsets(int[] nums) {       \\n        return run(0, 0, nums, nums.Aggregate(0, (t, n) => t | n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909680,
                "title": "optimal-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&n , int t , int idx , int curr){\\n        if(idx==n.size()){\\n            if(t==curr){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int in = solve(n , t , idx+1 , curr|n[idx]);\\n        int nin = solve(n , t , idx+1 , curr);\\n        return in+nin;\\n    }\\n    int countMaxOrSubsets(vector<int>&n){\\n        int t=0;\\n        for(auto i:n){\\n            t|=i;\\n        }\\n        return solve(n , t , 0 , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&n , int t , int idx , int curr){\\n        if(idx==n.size()){\\n            if(t==curr){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int in = solve(n , t , idx+1 , curr|n[idx]);\\n        int nin = solve(n , t , idx+1 , curr);\\n        return in+nin;\\n    }\\n    int countMaxOrSubsets(vector<int>&n){\\n        int t=0;\\n        for(auto i:n){\\n            t|=i;\\n        }\\n        return solve(n , t , 0 , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866560,
                "title": "easy-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\n    void f(int ind,int orr,int& count,int maxi,int n,vector<int>& nums){\\n        if(ind>=n){\\n            if(maxi==orr) count++;\\n            return ;\\n        }\\n\\n        //pick\\n        int org=orr;\\n        orr|=nums[ind];\\n        f(ind+1,orr,count,maxi,n,nums);\\n        orr=org;\\n\\n        //not pick\\n        f(ind+1,orr,count,maxi,n,nums);\\n\\n    }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi=0;\\n        int count=0;\\n        for(auto i:nums){\\n            maxi|=i;\\n        }\\n        f(0,0,count,maxi,nums.size(),nums);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void f(int ind,int orr,int& count,int maxi,int n,vector<int>& nums){\\n        if(ind>=n){\\n            if(maxi==orr) count++;\\n            return ;\\n        }\\n\\n        //pick\\n        int org=orr;\\n        orr|=nums[ind];\\n        f(ind+1,orr,count,maxi,n,nums);\\n        orr=org;\\n\\n        //not pick\\n        f(ind+1,orr,count,maxi,n,nums);\\n\\n    }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi=0;\\n        int count=0;\\n        for(auto i:nums){\\n            maxi|=i;\\n        }\\n        f(0,0,count,maxi,nums.size(),nums);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864851,
                "title": "backtracking-solution-with-slight-optimization",
                "content": "# Code\\n```\\n\\nfunction countMaxOrSubsets(nums: number[]): number {\\n    let max = nums.reduce((a,b)=>a|b,0);\\n    let count=0;\\n    let subset=[];\\n    dfs(0,0)\\n    return count;\\n\\n    function dfs(idx,bor){\\n        if(bor===max) {\\n            count+=(2**(nums.length-idx)); // here if at any point bitwise OR (bor) is max then all the rest possibilities will also be added to count\\n// all the possible arrays are counted (2**(nums.length-idx)\\n// note this will reduce the runtime in some cases not all\\n//but those particular cases can even cut down runtime to o(n) as in case of [2,2,2,2,2] (best case)\\n            return;\\n            }\\n        for(let i=idx;i<nums.length;i++){\\n           subset.push(nums[i]);\\n            dfs(i+1,bor|nums[i]);\\n            subset.pop();\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nfunction countMaxOrSubsets(nums: number[]): number {\\n    let max = nums.reduce((a,b)=>a|b,0);\\n    let count=0;\\n    let subset=[];\\n    dfs(0,0)\\n    return count;\\n\\n    function dfs(idx,bor){\\n        if(bor===max) {\\n            count+=(2**(nums.length-idx)); // here if at any point bitwise OR (bor) is max then all the rest possibilities will also be added to count\\n// all the possible arrays are counted (2**(nums.length-idx)\\n// note this will reduce the runtime in some cases not all\\n//but those particular cases can even cut down runtime to o(n) as in case of [2,2,2,2,2] (best case)\\n            return;\\n            }\\n        for(let i=idx;i<nums.length;i++){\\n           subset.push(nums[i]);\\n            dfs(i+1,bor|nums[i]);\\n            subset.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851462,
                "title": "solution-in-go-using-backtracking",
                "content": "# Code\\n```\\nfunc countMaxOrSubsets(nums []int) int {\\n    max := findMax(nums)\\n    cnt := 0\\n\\n    var bt func([]int, int, int)\\n    bt = func(nums []int, cur int, index int) {\\n        if index > len(nums) {\\n            return\\n        }\\n        \\n        for i := index; i < len(nums); i ++ {\\n            temp := cur | nums[i]\\n            if temp == max {\\n                cnt ++\\n            }\\n            bt(nums, temp, i+1)\\n        }\\n    }\\n\\n    bt(nums, 0, 0) \\n    return cnt  \\n}\\n\\nfunc findMax(nums []int) int {\\n    max := nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        max |= nums[i]\\n    }\\n    return max\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n    max := findMax(nums)\\n    cnt := 0\\n\\n    var bt func([]int, int, int)\\n    bt = func(nums []int, cur int, index int) {\\n        if index > len(nums) {\\n            return\\n        }\\n        \\n        for i := index; i < len(nums); i ++ {\\n            temp := cur | nums[i]\\n            if temp == max {\\n                cnt ++\\n            }\\n            bt(nums, temp, i+1)\\n        }\\n    }\\n\\n    bt(nums, 0, 0) \\n    return cnt  \\n}\\n\\nfunc findMax(nums []int) int {\\n    max := nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        max |= nums[i]\\n    }\\n    return max\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838955,
                "title": "recursion-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\uD83D\\uDD39 The problem requires counting the number of subsets whose bitwise OR is maximum among all subsets of the given array.\\n\\uD83D\\uDD39 The bitwise OR operation combines bits from different numbers, setting each bit in the result to 1 if it exists in any of the numbers.\\n\\uD83D\\uDD39 We need to explore all possible subsets of the given array to find the maximum OR value and count how many subsets have this maximum value\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD83D\\uDD39 We can use a backtracking algorithm to explore all possible subsets of the array.\\n\\uD83D\\uDD39 The backtracking function helper is used to generate subsets and calculate their bitwise OR.\\n\\uD83D\\uDD39 At each step of the recursion, we have two choices: include the current element in the subset or skip it.\\n\\uD83D\\uDD39 The function keeps track of the current OR value (Total_OR) while generating subsets.\\n\\uD83D\\uDD39 The backtracking function uses a map (MyMap) to store the count of different OR values encountered during exploration.\\n\\uD83D\\uDD39 Finally, we find the maximum OR value and return its count as the answer.\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &nums, int index, int Total_OR, unordered_map<int,int> &MyMap){\\n        // Base Case\\n        if(index >= nums.size()){\\n            MyMap[Total_OR]++;\\n            return ;\\n        }\\n\\n        // Don\\'t Choose current\\n        helper(nums, index + 1, Total_OR, MyMap);\\n\\n        // Choose current\\n        if(Total_OR == INT_MIN){\\n            helper(nums, index + 1, nums[index] , MyMap);\\n        }\\n        else{\\n            helper(nums, index + 1 , Total_OR | nums[index] , MyMap);\\n        }\\n\\n        return ;\\n    };\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        unordered_map<int,int> MyMap;\\n        helper(nums, 0,INT_MIN, MyMap);\\n\\n        int max_output = INT_MIN;\\n        for(auto it = MyMap.begin() ; it != MyMap.end() ; ++it){\\n            max_output = max(max_output , it->first);\\n        }\\n\\n        return MyMap[max_output];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &nums, int index, int Total_OR, unordered_map<int,int> &MyMap){\\n        // Base Case\\n        if(index >= nums.size()){\\n            MyMap[Total_OR]++;\\n            return ;\\n        }\\n\\n        // Don\\'t Choose current\\n        helper(nums, index + 1, Total_OR, MyMap);\\n\\n        // Choose current\\n        if(Total_OR == INT_MIN){\\n            helper(nums, index + 1, nums[index] , MyMap);\\n        }\\n        else{\\n            helper(nums, index + 1 , Total_OR | nums[index] , MyMap);\\n        }\\n\\n        return ;\\n    };\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        unordered_map<int,int> MyMap;\\n        helper(nums, 0,INT_MIN, MyMap);\\n\\n        int max_output = INT_MIN;\\n        for(auto it = MyMap.begin() ; it != MyMap.end() ; ++it){\\n            max_output = max(max_output , it->first);\\n        }\\n\\n        return MyMap[max_output];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823476,
                "title": "c-backtracking-solution",
                "content": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n\\tint res = 0, maxOR = 0;\\n\\tfor (const int& n : nums)\\n\\t\\tmaxOR |= n;\\n\\n\\tvector<int> subs { 0 };\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tint sz = subs.size();\\n\\t\\tfor (int j = 0; j < sz; j++) {\\n\\t\\t\\tsubs.push_back(subs[j]);\\n\\t\\t\\tsubs.back() |= nums[i];\\n\\t\\t\\tres += subs.back() == maxOR ? 1 : 0;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Iterator"
                ],
                "code": "```\\nint countMaxOrSubsets(vector<int>& nums) {\\n\\tint res = 0, maxOR = 0;\\n\\tfor (const int& n : nums)\\n\\t\\tmaxOR |= n;\\n\\n\\tvector<int> subs { 0 };\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tint sz = subs.size();\\n\\t\\tfor (int j = 0; j < sz; j++) {\\n\\t\\t\\tsubs.push_back(subs[j]);\\n\\t\\t\\tsubs.back() |= nums[i];\\n\\t\\t\\tres += subs.back() == maxOR ? 1 : 0;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800609,
                "title": "easy-to-understand-backtracking-with-optimisation-beats-86-on-time",
                "content": "# Intuition\\nNotice a few things:\\n1. The max xor of any subset is the xor of all numbers in input array\\n2. There can be one or more subsets where its xor equals the max xor. If we find such a subset, we can use math to calculate number of possible subsets from the remaining elements.\\n\\ne.g [7 (bits 111), 1, 2, 4]\\n[7] has max xor. Number of subsets including 7 is all ways of choosing [1, 2, 4]\\nNumber = 2 ^ 3\\n\\n# Approach\\nWe use the usual  backtracking approach, passing the current xor down to each recursive call. \\nIf the current xor is not the max xor yet, we try 2 cases:\\n1) Include current number in xor\\n2) Don\\'t include current number in xor\\n\\nIf the current xor is the max, we use math like above to calculate the number of subsets from here, saving time.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nO(2^n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxor = 0\\n        for num in nums:\\n            maxor = maxor | num\\n\\n        return self.helper(nums, 0, maxor, 0)\\n\\n    def helper(self, nums: List[int], i: int, maxor: int, curxor: int) -> int:\\n        if curxor == maxor:\\n            remaining = len(nums) - i\\n            return 2 ** remaining\\n\\n        if i == len(nums):\\n            return 0\\n\\n        return self.helper(nums, i+1, maxor, curxor | nums[i]) + self.helper(nums, i+1, maxor, curxor)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxor = 0\\n        for num in nums:\\n            maxor = maxor | num\\n\\n        return self.helper(nums, 0, maxor, 0)\\n\\n    def helper(self, nums: List[int], i: int, maxor: int, curxor: int) -> int:\\n        if curxor == maxor:\\n            remaining = len(nums) - i\\n            return 2 ** remaining\\n\\n        if i == len(nums):\\n            return 0\\n\\n        return self.helper(nums, i+1, maxor, curxor | nums[i]) + self.helper(nums, i+1, maxor, curxor)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789638,
                "title": "simple-beginner-friendly-recursiom",
                "content": "# Approach\\ncheck the maximum or of nums array\\nfind all subsets\\ncompare each subset with maximum or\\n\\n# Complexity\\n- Time complexity:\\nO(2^n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0,ans=0;\\n        for(auto &num:nums) x|=num;\\n        vector<int> curr;\\n        solve(0,curr,nums,ans,x);\\n        return ans;\\n    }\\n    void solve(int ind,vector<int> &curr,vector<int> &nums,int &ans,int x){\\n        if(isPossible(curr,x)) ans++;\\n        for(int i=ind;i<nums.size();i++){\\n            curr.push_back(nums[i]);\\n            solve(i+1,curr,nums,ans,x);\\n            curr.pop_back();\\n        }\\n    }\\n    bool isPossible(vector<int> &arr,int x){\\n        int y=0;\\n        for(auto &num:arr)y|=num;\\n        return x==y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0,ans=0;\\n        for(auto &num:nums) x|=num;\\n        vector<int> curr;\\n        solve(0,curr,nums,ans,x);\\n        return ans;\\n    }\\n    void solve(int ind,vector<int> &curr,vector<int> &nums,int &ans,int x){\\n        if(isPossible(curr,x)) ans++;\\n        for(int i=ind;i<nums.size();i++){\\n            curr.push_back(nums[i]);\\n            solve(i+1,curr,nums,ans,x);\\n            curr.pop_back();\\n        }\\n    }\\n    bool isPossible(vector<int> &arr,int x){\\n        int y=0;\\n        for(auto &num:arr)y|=num;\\n        return x==y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771874,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        List<Integer> ds = new ArrayList<>();\\n        List<Integer> OR = new ArrayList<>();\\n        DFS(0,nums,ds,OR);\\n        return maxcount(OR);\\n\\n        \\n    }\\n    public static void DFS(int ind,int[] nums,List<Integer> ds,List<Integer> OR){\\n        if(ind==nums.length){\\n            int a = ListOr(ds);\\n            OR.add(a);\\n            return;\\n        }\\n        ds.add(nums[ind]);\\n        DFS(ind+1,nums,ds,OR);\\n        ds.remove(ds.size()-1);\\n        DFS(ind+1,nums,ds,OR);\\n    }\\n    public static int maxcount(List<Integer> ds){\\n        if(ds == null || ds.isEmpty()){\\n            return 0;\\n        }\\n         int maxElement = ds.get(0);\\n        int maxCount = 1;\\n\\n         for (int i = 1; i < ds.size(); i++) {\\n            int currentElement = ds.get(i);\\n            if (currentElement > maxElement) {\\n                maxElement = currentElement;\\n                maxCount = 1;\\n            } else if (currentElement == maxElement) {\\n                maxCount++;\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n    public static int ListOr(List<Integer> OR){\\n         if(OR == null || OR.isEmpty()){\\n            return 0;\\n        \\n        }\\n         int result = OR.get(0);\\n        for (int i = 1; i < OR.size(); i++) {\\n            result |= OR.get(i);\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        List<Integer> ds = new ArrayList<>();\\n        List<Integer> OR = new ArrayList<>();\\n        DFS(0,nums,ds,OR);\\n        return maxcount(OR);\\n\\n        \\n    }\\n    public static void DFS(int ind,int[] nums,List<Integer> ds,List<Integer> OR){\\n        if(ind==nums.length){\\n            int a = ListOr(ds);\\n            OR.add(a);\\n            return;\\n        }\\n        ds.add(nums[ind]);\\n        DFS(ind+1,nums,ds,OR);\\n        ds.remove(ds.size()-1);\\n        DFS(ind+1,nums,ds,OR);\\n    }\\n    public static int maxcount(List<Integer> ds){\\n        if(ds == null || ds.isEmpty()){\\n            return 0;\\n        }\\n         int maxElement = ds.get(0);\\n        int maxCount = 1;\\n\\n         for (int i = 1; i < ds.size(); i++) {\\n            int currentElement = ds.get(i);\\n            if (currentElement > maxElement) {\\n                maxElement = currentElement;\\n                maxCount = 1;\\n            } else if (currentElement == maxElement) {\\n                maxCount++;\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n    public static int ListOr(List<Integer> OR){\\n         if(OR == null || OR.isEmpty()){\\n            return 0;\\n        \\n        }\\n         int result = OR.get(0);\\n        for (int i = 1; i < OR.size(); i++) {\\n            result |= OR.get(i);\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742119,
                "title": "c-target-or-take-nottake-dp-solution-easy-to-understand",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*(OR of array))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n*(OR of array))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int func(int ind,int mask,int tar,vector<int>&v){\\n        if(ind<0){\\n            if(mask==tar){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[ind][mask]!=-1) return dp[ind][mask];\\n        int nt=func(ind-1,mask,tar,v);\\n        int t=func(ind-1,mask|v[ind],tar,v);\\n        return dp[ind][mask]= t+nt;\\n    }\\n    int countMaxOrSubsets(vector<int>& v) {\\n        int tar=0;\\n        for(auto it:v) tar|=it;\\n        int n=v.size();\\n        dp=vector<vector<int>>(n,vector<int>(tar+1,-1));\\n        return func(n-1,0,tar,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int func(int ind,int mask,int tar,vector<int>&v){\\n        if(ind<0){\\n            if(mask==tar){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[ind][mask]!=-1) return dp[ind][mask];\\n        int nt=func(ind-1,mask,tar,v);\\n        int t=func(ind-1,mask|v[ind],tar,v);\\n        return dp[ind][mask]= t+nt;\\n    }\\n    int countMaxOrSubsets(vector<int>& v) {\\n        int tar=0;\\n        for(auto it:v) tar|=it;\\n        int n=v.size();\\n        dp=vector<vector<int>>(n,vector<int>(tar+1,-1));\\n        return func(n-1,0,tar,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735453,
                "title": "c-subset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n    bool isBitSet(int iteration, int bit)\\n    {\\n        int temp  = 1<<bit;\\n        if((temp & iteration))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {\\n        int n = pow(2, nums.size());\\n        unordered_map<int, int> uniqueSum;\\n        int maxCount = INT_MIN;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(isBitSet(i,j))\\n                {\\n                    sum = sum | nums[j];\\n                }\\n            }\\n            uniqueSum[sum]++;\\n            if(maxCount<uniqueSum[sum])\\n            {\\n                maxCount=uniqueSum[sum];\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    bool isBitSet(int iteration, int bit)\\n    {\\n        int temp  = 1<<bit;\\n        if((temp & iteration))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {\\n        int n = pow(2, nums.size());\\n        unordered_map<int, int> uniqueSum;\\n        int maxCount = INT_MIN;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(isBitSet(i,j))\\n                {\\n                    sum = sum | nums[j];\\n                }\\n            }\\n            uniqueSum[sum]++;\\n            if(maxCount<uniqueSum[sum])\\n            {\\n                maxCount=uniqueSum[sum];\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722527,
                "title": "simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&v, int i, int &mx, int&cnt, int r){\\n        if(i>=v.size()){\\n            if(r>mx){\\n                mx=r;\\n                cnt = 1;\\n            }\\n            else if(r==mx){\\n                cnt++;\\n            }\\n            return;\\n        }\\n        solve(v, i+1, mx, cnt, r|v[i]);\\n        solve(v, i+1, mx, cnt, r);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {   \\n         int mx=0,cnt=0,r=0;\\n         solve(nums, 0, mx, cnt, r);\\n         return cnt;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&v, int i, int &mx, int&cnt, int r){\\n        if(i>=v.size()){\\n            if(r>mx){\\n                mx=r;\\n                cnt = 1;\\n            }\\n            else if(r==mx){\\n                cnt++;\\n            }\\n            return;\\n        }\\n        solve(v, i+1, mx, cnt, r|v[i]);\\n        solve(v, i+1, mx, cnt, r);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) \\n    {   \\n         int mx=0,cnt=0,r=0;\\n         solve(nums, 0, mx, cnt, r);\\n         return cnt;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720514,
                "title": "simple-approach-backtracking",
                "content": "# Intuition\\nfirst we calculate the maximum or possible and then we will find all the possible candidate which can give that or and at the end store the count of them\\n\\n# Approach\\nwe will iterate through all possible subsequences of nums and check which all can give maximun or and store the count\\n\\n# Complexity\\n- Time complexity:\\nO(n*2^n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maxi |=nums[i];\\n        }\\n        int n=nums.size();\\n        int tot=(1<<n);\\n        int count=0;\\n        for(int i=0; i<tot; i++){\\n            int temp=0;\\n            for(int j=0; j<n; j++){\\n                if(i & (1<<j)){\\n                    temp |=nums[j];\\n                }\\n            }\\n            if(temp==maxi){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxi=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maxi |=nums[i];\\n        }\\n        int n=nums.size();\\n        int tot=(1<<n);\\n        int count=0;\\n        for(int i=0; i<tot; i++){\\n            int temp=0;\\n            for(int j=0; j<n; j++){\\n                if(i & (1<<j)){\\n                    temp |=nums[j];\\n                }\\n            }\\n            if(temp==maxi){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719067,
                "title": "short-naive-solution-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res;\\n    void solve(vector<int>&v,int target,int count,int temp){\\n        if(count==v.size()){\\n            if(target==temp) res++;\\n            return ;\\n        }\\n        solve(v,target,count+1,temp|v[count]);\\n        solve(v,target,count+1,temp);\\n    }\\n    int countMaxOrSubsets(vector<int>& v) {\\n        int target=0;\\n        int n=v.size();\\n        for(int i=0;i<n;i++) target=target|v[i];\\n        int count=0;\\n        int temp=0;\\n        res=0;\\n        solve(v,target,count,temp);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res;\\n    void solve(vector<int>&v,int target,int count,int temp){\\n        if(count==v.size()){\\n            if(target==temp) res++;\\n            return ;\\n        }\\n        solve(v,target,count+1,temp|v[count]);\\n        solve(v,target,count+1,temp);\\n    }\\n    int countMaxOrSubsets(vector<int>& v) {\\n        int target=0;\\n        int n=v.size();\\n        for(int i=0;i<n;i++) target=target|v[i];\\n        int count=0;\\n        int temp=0;\\n        res=0;\\n        solve(v,target,count,temp);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714158,
                "title": "c-implementation-using-recursion-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int num,vector<int> &nums,vector<int> &tmp){\\n        if(i==nums.size()){\\n            int c=0;\\n            for(auto x:tmp){\\n                c=c|x;\\n            }\\n            return c==num?1:0;\\n        }\\n        int ans=f(i+1,num,nums,tmp);\\n        tmp.push_back(nums[i]);\\n        int ans2=f(i+1,num,nums,tmp);\\n        tmp.pop_back();\\n        return ans+ans2;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int num=0;\\n        for(auto x:nums){\\n            num=num|x;\\n        }\\n        vector<int>tmp;\\n        return f(0,num,nums,tmp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int num,vector<int> &nums,vector<int> &tmp){\\n        if(i==nums.size()){\\n            int c=0;\\n            for(auto x:tmp){\\n                c=c|x;\\n            }\\n            return c==num?1:0;\\n        }\\n        int ans=f(i+1,num,nums,tmp);\\n        tmp.push_back(nums[i]);\\n        int ans2=f(i+1,num,nums,tmp);\\n        tmp.pop_back();\\n        return ans+ans2;\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int num=0;\\n        for(auto x:nums){\\n            num=num|x;\\n        }\\n        vector<int>tmp;\\n        return f(0,num,nums,tmp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709907,
                "title": "easiest-solution-with-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        int findans(int target, vector<int> &nums, int i, int n, int cal_or)\\n        {\\n            if (i == n)\\n            {\\n                if (cal_or == target)\\n                {\\n                    return 1;\\n                }\\n                else return 0;\\n            }\\n            int take=findans(target, nums, i+1, n, cal_or|nums[i]);\\n         \\n            int nontake=findans(target, nums, i+1, n, cal_or);\\n            return take+nontake;\\n        }\\n    int countMaxOrSubsets(vector<int> &nums)\\n    {\\n        int orred = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            orred |= nums[i];\\n        }\\n        int cal_or = 0;\\n        return findans(orred, nums, 0, nums.size(), cal_or);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int findans(int target, vector<int> &nums, int i, int n, int cal_or)\\n        {\\n            if (i == n)\\n            {\\n                if (cal_or == target)\\n                {\\n                    return 1;\\n                }\\n                else return 0;\\n            }\\n            int take=findans(target, nums, i+1, n, cal_or|nums[i]);\\n         \\n            int nontake=findans(target, nums, i+1, n, cal_or);\\n            return take+nontake;\\n        }\\n    int countMaxOrSubsets(vector<int> &nums)\\n    {\\n        int orred = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            orred |= nums[i];\\n        }\\n        int cal_or = 0;\\n        return findans(orred, nums, 0, nums.size(), cal_or);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695045,
                "title": "java-backtracking-memo-beats-95",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    public int countMaxOrSubsets(int[] arr) {\\n        var max = 0;\\n        for (var num:arr) max|=num;\\n        return traverse(arr,0,0,max);\\n    }\\n    \\n    public int traverse(int[] arr, int idx, int or, int max){\\n        if (idx==arr.length) return or==max?1:0;\\n        var key = key(idx,or);\\n        if (map.containsKey(key)) return map.get(key);\\n        var res = traverse(arr,idx+1,or|arr[idx],max) + traverse(arr,idx+1,or,max);\\n        map.put(key,res);\\n        return res;\\n    }\\n    \\n    public int key(int idx, int or){\\n        return idx*10_000_000+or;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    public int countMaxOrSubsets(int[] arr) {\\n        var max = 0;\\n        for (var num:arr) max|=num;\\n        return traverse(arr,0,0,max);\\n    }\\n    \\n    public int traverse(int[] arr, int idx, int or, int max){\\n        if (idx==arr.length) return or==max?1:0;\\n        var key = key(idx,or);\\n        if (map.containsKey(key)) return map.get(key);\\n        var res = traverse(arr,idx+1,or|arr[idx],max) + traverse(arr,idx+1,or,max);\\n        map.put(key,res);\\n        return res;\\n    }\\n    \\n    public int key(int idx, int or){\\n        return idx*10_000_000+or;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684646,
                "title": "simple-java-solution-using-backtracking-brute-force",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe calculate the XOR of subsets as we create subsets and when we reach at the leaf node we compare it with max result. If we get result greater than max then we update max and reset result to 1 otherwise if max is equal to the value we increase the result by one else if the value is less than max we don\\'t do anything. \\n\\n# Code\\n```\\nclass Solution {\\n    int max=0;\\n    int res=0;\\n    private void solve(int[] nums,int curr,int v){\\n        if(curr==nums.length){\\n            if(v>max){\\n                max=v;\\n                res=1;\\n            }\\n            else if(v==max)\\n            {\\n                res++;\\n            }\\n            return;\\n        }\\n        solve(nums,curr+1,v);\\n        solve(nums,curr+1,(v|nums[curr]));\\n    }\\n    public int countMaxOrSubsets(int[] nums) {\\n        solve(nums,0,0);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    int res=0;\\n    private void solve(int[] nums,int curr,int v){\\n        if(curr==nums.length){\\n            if(v>max){\\n                max=v;\\n                res=1;\\n            }\\n            else if(v==max)\\n            {\\n                res++;\\n            }\\n            return;\\n        }\\n        solve(nums,curr+1,v);\\n        solve(nums,curr+1,(v|nums[curr]));\\n    }\\n    public int countMaxOrSubsets(int[] nums) {\\n        solve(nums,0,0);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673689,
                "title": "counting-subsets-with-maximum-bitwise-or-value-using-backtracking",
                "content": "\\n# Approach\\n\\nTo count the number of subsets from the given array `nums` such that the bitwise OR of all the elements in the subset is maximum, we can use a backtracking algorithm. The backtracking approach allows us to explore all possible subsets without explicitly storing them.\\n\\nThe algorithm follows these steps:\\n\\n1. Initialize a variable `maxVal` to store the maximum OR value among all elements in `nums`. We can calculate `maxVal` by performing a bitwise OR operation on all the elements in `nums`.\\n\\n2. Initialize a count variable `count` to keep track of the number of subsets with the maximum OR value.\\n\\n3. Implement a backtracking function, `backTrack`, that takes two parameters: `start` and `curOr`.\\n\\n4. In the `backTrack` function:\\n   - Check if `curOr` is equal to `maxVal`. If it is, increment `count` by 1 to signify that a subset with the maximum OR value has been found.\\n   - Iterate over the elements in `nums` starting from the `start` index:\\n     - Recursively call the `backTrack` function with the next index (`j + 1`) and the updated `curOr` obtained by performing a bitwise OR operation between `curOr` and `nums[j]`.\\n\\n5. Return the value of `count` as the result.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) Auxiliary space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countMaxOrSubsets = function(nums) {\\n    \\n    let maxVal = nums.reduce((cur, pre)=> cur|pre, 0);\\n    let count = 0\\n    \\n    function backTrack(start, curOr) {\\n        if(curOr === maxVal) count++\\n\\n        for (let j = start; j < n; j++)  backTrack(j + 1, curOr  | nums[j]);\\n    }\\n\\n    const n = nums.length;\\n\\n    backTrack(0, 0);\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countMaxOrSubsets = function(nums) {\\n    \\n    let maxVal = nums.reduce((cur, pre)=> cur|pre, 0);\\n    let count = 0\\n    \\n    function backTrack(start, curOr) {\\n        if(curOr === maxVal) count++\\n\\n        for (let j = start; j < n; j++)  backTrack(j + 1, curOr  | nums[j]);\\n    }\\n\\n    const n = nums.length;\\n\\n    backTrack(0, 0);\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657860,
                "title": "java-solution-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    int res=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        List<Integer> l=new ArrayList<>();\\n        subset(0,nums,l);\\n        return res;\\n    }\\n    void subset(int i,int nums[],List<Integer> l){\\n        if(i==nums.length){\\n            int s=0;\\n            for(int j:l){\\n                s|=j;\\n            }\\n            if(s>max){\\n                res=1;\\n                max=s;\\n            }\\n            else if(s==max){\\n                res++;\\n            }\\n            return;\\n        }\\n        l.add(nums[i]);\\n        subset(i+1,nums,l);\\n        l.remove(l.size()-1);\\n        subset(i+1,nums,l);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    int res=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        List<Integer> l=new ArrayList<>();\\n        subset(0,nums,l);\\n        return res;\\n    }\\n    void subset(int i,int nums[],List<Integer> l){\\n        if(i==nums.length){\\n            int s=0;\\n            for(int j:l){\\n                s|=j;\\n            }\\n            if(s>max){\\n                res=1;\\n                max=s;\\n            }\\n            else if(s==max){\\n                res++;\\n            }\\n            return;\\n        }\\n        l.add(nums[i]);\\n        subset(i+1,nums,l);\\n        l.remove(l.size()-1);\\n        subset(i+1,nums,l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651709,
                "title": "easiest-c-solution",
                "content": "\\n# Complexity\\n- Time complexity: *O(2^n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(2^n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxor = INT_MIN, ans=0; \\n    void helper(vector<int>& v){\\n        int n =0;\\n        for(int i=0; i<v.size(); i++){\\n            n = n | v[i];\\n        }\\n        if(n == maxor) ans++;\\n        else if(n>maxor){\\n            maxor = n;\\n            ans=1;\\n        }\\n    }\\n    void solve(vector<int>& nums,vector<int>& v,int i){\\n        for(; i<nums.size(); i++){\\n            v.push_back(nums[i]);\\n            helper(v);\\n            solve(nums, v, i+1);\\n            v.pop_back();\\n        }\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vector<int> v;\\n        solve(nums, v, 0);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxor = INT_MIN, ans=0; \\n    void helper(vector<int>& v){\\n        int n =0;\\n        for(int i=0; i<v.size(); i++){\\n            n = n | v[i];\\n        }\\n        if(n == maxor) ans++;\\n        else if(n>maxor){\\n            maxor = n;\\n            ans=1;\\n        }\\n    }\\n    void solve(vector<int>& nums,vector<int>& v,int i){\\n        for(; i<nums.size(); i++){\\n            v.push_back(nums[i]);\\n            helper(v);\\n            solve(nums, v, i+1);\\n            v.pop_back();\\n        }\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vector<int> v;\\n        solve(nums, v, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616613,
                "title": "simple-recursive-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>& nums ,int crnt ,int idx ,int goal ){\\n\\n        //base case\\n        if(idx>=nums.size()) return 0;\\n        \\n        int ans = 0;\\n        if((crnt | nums[idx])==goal){\\n            ans=1;\\n        }\\n\\n        return ans + solve(nums ,crnt ,idx+1 ,goal )+solve(nums ,crnt|nums[idx] ,idx+1 ,goal);\\n\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int goal =  0;\\n        for(auto x: nums){\\n            goal|=x;\\n        }\\n\\n        return solve(nums ,0 , 0 ,goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>& nums ,int crnt ,int idx ,int goal ){\\n\\n        //base case\\n        if(idx>=nums.size()) return 0;\\n        \\n        int ans = 0;\\n        if((crnt | nums[idx])==goal){\\n            ans=1;\\n        }\\n\\n        return ans + solve(nums ,crnt ,idx+1 ,goal )+solve(nums ,crnt|nums[idx] ,idx+1 ,goal);\\n\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        \\n        int goal =  0;\\n        for(auto x: nums){\\n            goal|=x;\\n        }\\n\\n        return solve(nums ,0 , 0 ,goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575171,
                "title": "python-very-easy-bactracing-4-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        ans = []\\n        def bac(start , path , s):\\n            ans.append(path)\\n            for i in range(start , len(s)):\\n                bac(i+1 , path|s[i] , s)\\n        bac(0,0,nums)\\n        ans = Counter(ans)\\n        return max(ans.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        ans = []\\n        def bac(start , path , s):\\n            ans.append(path)\\n            for i in range(start , len(s)):\\n                bac(i+1 , path|s[i] , s)\\n        bac(0,0,nums)\\n        ans = Counter(ans)\\n        return max(ans.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573811,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:         \\n    def countMaxOrSubsets(self, nums):\\n        n = len(nums)\\n\\n        def backtrack(idx,path):\\n            if path:\\n                dict1[path] += 1\\n\\n            for i in range(idx,n):\\n                backtrack(i+1,path|nums[i])\\n\\n        dict1 = defaultdict(int)\\n\\n        backtrack(0,0)\\n\\n        return dict1[max(dict1.keys())]\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:         \\n    def countMaxOrSubsets(self, nums):\\n        n = len(nums)\\n\\n        def backtrack(idx,path):\\n            if path:\\n                dict1[path] += 1\\n\\n            for i in range(idx,n):\\n                backtrack(i+1,path|nums[i])\\n\\n        dict1 = defaultdict(int)\\n\\n        backtrack(0,0)\\n\\n        return dict1[max(dict1.keys())]\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567789,
                "title": "bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n=nums.size(),bit_orr=0;\\n        for(int x=0;x<n;x++)bit_orr|=nums[x];\\n        int ans=0;\\n        bitset<17>mask;mask=0;\\n        while(mask.to_ulong()<(1<<n)){\\n            int or_b=0;\\n            for(int x=0;x<n;x++){\\n                if(mask[x])or_b|=nums[x];\\n            }\\n            if(or_b==bit_orr)ans++;\\n            mask=mask.to_ulong()+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n=nums.size(),bit_orr=0;\\n        for(int x=0;x<n;x++)bit_orr|=nums[x];\\n        int ans=0;\\n        bitset<17>mask;mask=0;\\n        while(mask.to_ulong()<(1<<n)){\\n            int or_b=0;\\n            for(int x=0;x<n;x++){\\n                if(mask[x])or_b|=nums[x];\\n            }\\n            if(or_b==bit_orr)ans++;\\n            mask=mask.to_ulong()+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544332,
                "title": "java-backtracking-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int[]arr = new int[2];\\n    public int k =0;\\n    public void helper(int[]nums,int index,int or,int count){\\n        if(k == count){\\n            if(or == arr[0]){\\n                arr[1]++;\\n            }\\n            else if(or > arr[0]){\\n                arr[1] = 1;\\n                arr[0] = or;\\n            }\\n            return;\\n        }\\n        for(int i = index;i < nums.length;i++){\\n            count++;\\n            helper(nums,i+1,or | nums[i],count);\\n            count--;\\n        }\\n    }\\n    public int countMaxOrSubsets(int[] nums) {\\n        for(k = 1;k <= nums.length;k++){\\n            helper(nums,0,0,0);\\n        }\\n        return arr[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[]arr = new int[2];\\n    public int k =0;\\n    public void helper(int[]nums,int index,int or,int count){\\n        if(k == count){\\n            if(or == arr[0]){\\n                arr[1]++;\\n            }\\n            else if(or > arr[0]){\\n                arr[1] = 1;\\n                arr[0] = or;\\n            }\\n            return;\\n        }\\n        for(int i = index;i < nums.length;i++){\\n            count++;\\n            helper(nums,i+1,or | nums[i],count);\\n            count--;\\n        }\\n    }\\n    public int countMaxOrSubsets(int[] nums) {\\n        for(k = 1;k <= nums.length;k++){\\n            helper(nums,0,0,0);\\n        }\\n        return arr[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536776,
                "title": "go-find-all-subset-prefixsum-or",
                "content": "# Complexity\\n- Time complexity:  $$O(2^n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc countMaxOrSubsets(nums []int) int {\\n\\tn := len(nums)\\n\\tpre := make([]int, n+1)\\n\\tpre[0] = 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tpre[i+1] = pre[i] | nums[i]\\n\\t}\\n\\n\\tmaxOr, res := pre[n], 0\\n\\tcountMaxOrSubsetsBacktrack(nums, &res, 0, maxOr, 0)\\n\\treturn res\\n}\\n\\nfunc countMaxOrSubsetsBacktrack(nums []int, res *int, current int, maxOr int, i int) {\\n\\tif current == maxOr {\\n\\t\\t*res++\\n\\t}\\n\\n\\ttemp := current\\n\\tfor j := i; j < len(nums); j++ {\\n\\t\\tcurrent = current | nums[j]\\n\\t\\tcountMaxOrSubsetsBacktrack(nums, res, current, maxOr, j+1)\\n\\t\\tcurrent = temp\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n\\tn := len(nums)\\n\\tpre := make([]int, n+1)\\n\\tpre[0] = 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tpre[i+1] = pre[i] | nums[i]\\n\\t}\\n\\n\\tmaxOr, res := pre[n], 0\\n\\tcountMaxOrSubsetsBacktrack(nums, &res, 0, maxOr, 0)\\n\\treturn res\\n}\\n\\nfunc countMaxOrSubsetsBacktrack(nums []int, res *int, current int, maxOr int, i int) {\\n\\tif current == maxOr {\\n\\t\\t*res++\\n\\t}\\n\\n\\ttemp := current\\n\\tfor j := i; j < len(nums); j++ {\\n\\t\\tcurrent = current | nums[j]\\n\\t\\tcountMaxOrSubsetsBacktrack(nums, res, current, maxOr, j+1)\\n\\t\\tcurrent = temp\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528388,
                "title": "explained-every-single-thing-in-easy-way-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        // to calculate maximum orr we have to take or of whole array\\n        int morr = 0;\\n        for(int i=0 ; i < nums.size(); i++){\\n            morr = morr | nums[i];\\n        }\\n\\n        int orr = 0;\\n        int ans=0;\\n\\n        // total possible subsets\\n        int total = pow(2 , nums.size());\\n        \\n        for(int i = 0 ; i < total ; i++){\\n            int orr = 0;\\n            // we will iterate over each array and check if ith element in \\n            // set bit or not if it is set that means we have to take that element and  perform orr\\n            for(int j = 0 ; j < nums.size(); j++){\\n                if(i & (1 << j)){\\n                    orr  = orr | nums[j];\\n                }\\n            }\\n            if(orr == morr){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        // to calculate maximum orr we have to take or of whole array\\n        int morr = 0;\\n        for(int i=0 ; i < nums.size(); i++){\\n            morr = morr | nums[i];\\n        }\\n\\n        int orr = 0;\\n        int ans=0;\\n\\n        // total possible subsets\\n        int total = pow(2 , nums.size());\\n        \\n        for(int i = 0 ; i < total ; i++){\\n            int orr = 0;\\n            // we will iterate over each array and check if ith element in \\n            // set bit or not if it is set that means we have to take that element and  perform orr\\n            for(int j = 0 ; j < nums.size(); j++){\\n                if(i & (1 << j)){\\n                    orr  = orr | nums[j];\\n                }\\n            }\\n            if(orr == morr){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511933,
                "title": "dp-pick-nonpick",
                "content": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int n=nums.length;\\n        int a[]=new int[n];\\n        int maxOr=0;\\n        for(int x : nums)maxOr|=x;\\n        return f(0,nums,n,0,maxOr);\\n    }\\n    public int f(int i,int nums[],int n,int c,int maxOr){\\n        if(i==n){\\n            if(c==maxOr)return 1;\\n            else return 0;\\n        }\\n        int pick=f(i+1,nums,n,c|nums[i],maxOr);\\n        int notpick=f(i+1,nums,n,c,maxOr);\\n        return pick+notpick;\\n    }\\n}```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int n=nums.length;\\n        int a[]=new int[n];\\n        int maxOr=0;\\n        for(int x : nums)maxOr|=x;\\n        return f(0,nums,n,0,maxOr);\\n    }\\n    public int f(int i,int nums[],int n,int c,int maxOr){\\n        if(i==n){\\n            if(c==maxOr)return 1;\\n            else return 0;\\n        }\\n        int pick=f(i+1,nums,n,c|nums[i],maxOr);\\n        int notpick=f(i+1,nums,n,c,maxOr);\\n        return pick+notpick;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3482924,
                "title": "simplest-java-solution-beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   // int ans=1;\\n     int count=0;\\n      int max=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n       \\n     // max=nums[0]; \\n      for(int num:nums){\\n          max |=num;\\n      }\\n      System.out.print(max);  \\n      track(0,nums,0);\\n      return count;\\n    }\\n    void track(int i,int [] nums,int ans){\\n\\n        if(i==nums.length){\\n            if(ans==max)\\n              count++;\\n           return;\\n        }\\n         \\n        track(i+1,nums,ans|nums[i]);\\n        track(i+1,nums,ans);\\n    }\\n}        \\n    \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   // int ans=1;\\n     int count=0;\\n      int max=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n       \\n     // max=nums[0]; \\n      for(int num:nums){\\n          max |=num;\\n      }\\n      System.out.print(max);  \\n      track(0,nums,0);\\n      return count;\\n    }\\n    void track(int i,int [] nums,int ans){\\n\\n        if(i==nums.length){\\n            if(ans==max)\\n              count++;\\n           return;\\n        }\\n         \\n        track(i+1,nums,ans|nums[i]);\\n        track(i+1,nums,ans);\\n    }\\n}        \\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481019,
                "title": "python3-count-all-possible-or-s",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        def f(ind,ex):\\n            if ind==n:\\n                count[ex]+=1\\n                return\\n            \\n            f(ind+1,ex|nums[ind])\\n            f(ind+1,ex)\\n        \\n        count=Counter()\\n        f(0,0)\\n        \\n        mx=max(count)\\n        return count[mx]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        def f(ind,ex):\\n            if ind==n:\\n                count[ex]+=1\\n                return\\n            \\n            f(ind+1,ex|nums[ind])\\n            f(ind+1,ex)\\n        \\n        count=Counter()\\n        f(0,0)\\n        \\n        mx=max(count)\\n        return count[mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464173,
                "title": "simple-hashmap-powerset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        f(nums, 0, new ArrayList<>());\\n        int key = Collections.max(map.keySet());\\n        return map.get(key);\\n    }\\n    void f(int nums[], int start, List<Integer> temp) {\\n        int orResult = getBitwiseOR(temp);\\n        map.put(orResult, map.getOrDefault(orResult, 0)+1);\\n        for(int i=start;i<nums.length;++i) {\\n            temp.add(nums[i]);\\n            f(nums, i+1, temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n    int getBitwiseOR(List<Integer>nums) {\\n        int result = 0;\\n        for(int i: nums)\\n            result |= i;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    public int countMaxOrSubsets(int[] nums) {\\n        f(nums, 0, new ArrayList<>());\\n        int key = Collections.max(map.keySet());\\n        return map.get(key);\\n    }\\n    void f(int nums[], int start, List<Integer> temp) {\\n        int orResult = getBitwiseOR(temp);\\n        map.put(orResult, map.getOrDefault(orResult, 0)+1);\\n        for(int i=start;i<nums.length;++i) {\\n            temp.add(nums[i]);\\n            f(nums, i+1, temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n    int getBitwiseOR(List<Integer>nums) {\\n        int result = 0;\\n        for(int i: nums)\\n            result |= i;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422846,
                "title": "c-backtracking-simple-80-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)+recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>&nums,int &ans,int i,int tempans,int &maxans)\\n    {\\n        if(i==nums.size())\\n        {\\n             if(tempans>maxans)\\n             {\\n                 maxans=tempans;\\n                 ans=1;\\n             }\\n             else if(tempans==maxans)\\n             {\\n                 ans++;\\n             }\\n             return ;\\n        }\\n        int k=tempans;\\n        tempans=tempans | nums[i];\\n        helper(nums,ans,i+1,tempans,maxans);\\n        tempans=k;\\n        helper(nums,ans,i+1,tempans,maxans);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int ans=0,tempans=0,maxans=INT_MIN;\\n        helper(nums,ans,0,tempans,maxans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>&nums,int &ans,int i,int tempans,int &maxans)\\n    {\\n        if(i==nums.size())\\n        {\\n             if(tempans>maxans)\\n             {\\n                 maxans=tempans;\\n                 ans=1;\\n             }\\n             else if(tempans==maxans)\\n             {\\n                 ans++;\\n             }\\n             return ;\\n        }\\n        int k=tempans;\\n        tempans=tempans | nums[i];\\n        helper(nums,ans,i+1,tempans,maxans);\\n        tempans=k;\\n        helper(nums,ans,i+1,tempans,maxans);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int ans=0,tempans=0,maxans=INT_MIN;\\n        helper(nums,ans,0,tempans,maxans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414449,
                "title": "python3-dp-over-bitmask-approach",
                "content": "# Intuition\\nWe can notice that maximum OR of the subset from array ``num`` is OR of all its items. \\nIn order to find all such subsets, we can iterato over all of them. \\nWe can do that by iterating over all bitmasks, where bit ``i`` of the bitmask is set when given subset inludes ``nums[i]``. \\nWe can also track OR of the subsets defining it as:\\n```\\nDP(subset) = DP(subset XOR (1 << j)) OR nums[j]\\n```\\nfor subset containing nums[j]\\n\\nHere DP comes in.\\n\\n# Approach\\n1. Calculate OR of ``nums`` == ``value``, initialize ``result`` as ``0``\\n2. Initialize ``DP`` array of size ``1 << n``, where ``n`` is length of the array ``nums``\\n3. Iterate over all bitmasks from ``1`` to ``(1 << n) - 1`` and apply formulae from above. For each ``dp[i] == value`` increment ``result``\\n4. Return ``result`` \\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(2^n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        value = reduce(lambda s, t: s | t, nums)\\n        result = 0\\n        n = len(nums)\\n\\n        M = 1 << n\\n        dp = [0] * M\\n\\n        for i in range(1, M):\\n            for j in range(n):\\n                if (1 << j) & i:\\n                    dp[i] = dp[i ^ (1 << j)] | nums[j]\\n                    if dp[i] == value:\\n                        result += 1\\n                    break\\n\\n        return result\\n```\\n\\nShall you have any questions please ask and please UPVOTE if you like it!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nDP(subset) = DP(subset XOR (1 << j)) OR nums[j]\\n```\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        value = reduce(lambda s, t: s | t, nums)\\n        result = 0\\n        n = len(nums)\\n\\n        M = 1 << n\\n        dp = [0] * M\\n\\n        for i in range(1, M):\\n            for j in range(n):\\n                if (1 << j) & i:\\n                    dp[i] = dp[i ^ (1 << j)] | nums[j]\\n                    if dp[i] == value:\\n                        result += 1\\n                    break\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410665,
                "title": "2-combinations-codes-and-dynamic-programming-code",
                "content": "# Intuition\\n\\nJust wanted to share three possible solutions. Two of them are based on other peoples solution, credits are given on respective chapters.\\n\\n# Approach\\n- Combination\\n- Dynamic Programming\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Combination Code\\n![image.png](https://assets.leetcode.com/users/images/50aa7fa5-6219-47e1-ac64-5b630caf1dbf_1681346683.367062.png)\\n\\nThis code is authored by me.\\n\\n```java\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0, count=0;\\n        for(int n: nums) {\\n            max|=n;\\n        }\\n        int mask=(1<<nums.length)-1;\\n        // When iteratin like this, m will have\\n        // all possible combinations of mask\\n        for(int m=mask;m>0;m=mask&(m-1)){\\n            int g=0;\\n            for(int i=0,k=1;k<=m;k<<=1,i++) {\\n                if((m&k)==0) continue;\\n                // if g==mask we can stop\\n                if((g|=nums[i])==max) break;\\n            }\\n            if(g==max) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Combination Code 2\\n![image.png](https://assets.leetcode.com/users/images/39ca6f0c-1c25-441a-97c9-088899b04f38_1681346958.7366674.png)\\n\\nThis code is STRONGLY based on the fastest solutions submited on leetcode. Sadly I don\\'t know the owner.\\n\\n```java\\nclass Solution {\\n    int ans = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int n = nums.length, max = 0;\\n        for (int num : nums) max |= num;\\n        dfs(nums, 0, 0, max);\\n        return ans;\\n    }\\n\\n    private void dfs(int[] nums, int i, int or, int max) {\\n        if (or == max) {\\n            ans += 1 << (nums.length - i);\\n            return;\\n        }\\n        for (int j = i; j < nums.length; j++)\\n            dfs(nums, j + 1, or | nums[j], max);\\n    }\\n}\\n``` \\n# Dynamic Programing\\n![image.png](https://assets.leetcode.com/users/images/b5a7ef1f-fa5d-4a4e-bc49-e1e42abbf90b_1681347173.810235.png)\\n\\nThis code is based on the following solution, please consider upvoting it: https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/solutions/1525309/java-c-python-dp-solution/\\n\\n```java\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0, count=0, b;\\n        for(int n: nums) max|=n;\\n        int[] memo=new int[max+1];\\n        memo[0]=1;\\n        b=0;\\n        for(int n: nums) {\\n            for(int i=b;i>-1;i--) {\\n                int v=i|n;\\n                if(v>max) continue;\\n                if(v>b) b=v;\\n                memo[v]+=memo[i];\\n            }\\n        }\\n        return memo[max];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0, count=0;\\n        for(int n: nums) {\\n            max|=n;\\n        }\\n        int mask=(1<<nums.length)-1;\\n        // When iteratin like this, m will have\\n        // all possible combinations of mask\\n        for(int m=mask;m>0;m=mask&(m-1)){\\n            int g=0;\\n            for(int i=0,k=1;k<=m;k<<=1,i++) {\\n                if((m&k)==0) continue;\\n                // if g==mask we can stop\\n                if((g|=nums[i])==max) break;\\n            }\\n            if(g==max) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    int ans = 0;\\n    \\n    public int countMaxOrSubsets(int[] nums) {\\n        int n = nums.length, max = 0;\\n        for (int num : nums) max |= num;\\n        dfs(nums, 0, 0, max);\\n        return ans;\\n    }\\n\\n    private void dfs(int[] nums, int i, int or, int max) {\\n        if (or == max) {\\n            ans += 1 << (nums.length - i);\\n            return;\\n        }\\n        for (int j = i; j < nums.length; j++)\\n            dfs(nums, j + 1, or | nums[j], max);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max=0, count=0, b;\\n        for(int n: nums) max|=n;\\n        int[] memo=new int[max+1];\\n        memo[0]=1;\\n        b=0;\\n        for(int n: nums) {\\n            for(int i=b;i>-1;i--) {\\n                int v=i|n;\\n                if(v>max) continue;\\n                if(v>b) b=v;\\n                memo[v]+=memo[i];\\n            }\\n        }\\n        return memo[max];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393368,
                "title": "python-solution-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        def dfs(ind):\\n            if(ind==self.n):\\n                if(self.cumOr==self.ores):\\n                    self.ans+=1\\n                return\\n            temp=self.cumOr\\n            self.cumOr=self.cumOr|nums[ind]\\n            dfs(ind+1)\\n            self.cumOr=temp\\n            dfs(ind+1)        \\n        self.n=len(nums)\\n        self.ores=0\\n        for i in range(self.n):\\n            self.ores=self.ores|nums[i]\\n        self.ans=0\\n        self.cumOr=0\\n        for i in range(self.n):\\n            self.cumOr=nums[i]\\n            dfs(i+1)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        def dfs(ind):\\n            if(ind==self.n):\\n                if(self.cumOr==self.ores):\\n                    self.ans+=1\\n                return\\n            temp=self.cumOr\\n            self.cumOr=self.cumOr|nums[ind]\\n            dfs(ind+1)\\n            self.cumOr=temp\\n            dfs(ind+1)        \\n        self.n=len(nums)\\n        self.ores=0\\n        for i in range(self.n):\\n            self.ores=self.ores|nums[i]\\n        self.ans=0\\n        self.cumOr=0\\n        for i in range(self.n):\\n            self.cumOr=nums[i]\\n            dfs(i+1)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362218,
                "title": "javascript-backtracking-solution-81-ms-faster-than-100-00-43-1-mb-less-than-11-11",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countMaxOrSubsets = function(nums) {\\n    let res = 0;\\n    let max = 0;\\n    function backtrack(nums,start, val){   \\n        if(val === max)res++\\n        \\n        for(let i = start;i<nums.length; i++){\\n            backtrack(nums,i+1,val|nums[i])\\n        }\\n        \\n    }\\n    \\n    for(let num of nums) max |= num;\\n    backtrack(nums,0, 0)\\n    return res;\\n    \\n   \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countMaxOrSubsets = function(nums) {\\n    let res = 0;\\n    let max = 0;\\n    function backtrack(nums,start, val){   \\n        if(val === max)res++\\n        \\n        for(let i = start;i<nums.length; i++){\\n            backtrack(nums,i+1,val|nums[i])\\n        }\\n        \\n    }\\n    \\n    for(let num of nums) max |= num;\\n    backtrack(nums,0, 0)\\n    return res;\\n    \\n   \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3349936,
                "title": "c-easy-direct-enumeration",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums)\\n    {\\n        int maxor = 0;\\n        for (int i : nums)\\n            maxor |= i;\\n        \\n        int ans = 0;\\n        for (int i = 1; i < (1 << nums.size()); i++)\\n        {\\n            int subs = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (i & (1 << j))\\n                    subs |= nums[j];\\n            }\\n            \\n            if (subs == maxor)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums)\\n    {\\n        int maxor = 0;\\n        for (int i : nums)\\n            maxor |= i;\\n        \\n        int ans = 0;\\n        for (int i = 1; i < (1 << nums.size()); i++)\\n        {\\n            int subs = 0;\\n            for (int j = 0; j < nums.size(); j++)\\n            {\\n                if (i & (1 << j))\\n                    subs |= nums[j];\\n            }\\n            \\n            if (subs == maxor)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334815,
                "title": "dfs",
                "content": "```ruby\\ndef count_max_or_subsets a\\n    t, z, r = a.reduce(&:|), a.size, 0\\n    f = -> i, x do\\n        if i == z\\n            r += 1 if x == t\\n            return\\n        end\\n        f.(i + 1, x)\\n        f.(i + 1, x | a[i])\\n    end\\n    f.(0, 0)\\n    r\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef count_max_or_subsets a\\n    t, z, r = a.reduce(&:|), a.size, 0\\n    f = -> i, x do\\n        if i == z\\n            r += 1 if x == t\\n            return\\n        end\\n        f.(i + 1, x)\\n        f.(i + 1, x | a[i])\\n    end\\n    f.(0, 0)\\n    r\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3334771,
                "title": "c-recursion-backtracking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int idx,vector<int>& nums,int& cnt,int val,int maxi)\\n    {\\n        if(idx==nums.size())\\n        return;\\n        int tmp = val|nums[idx];\\n        if(tmp==maxi)\\n        {\\n            cnt++;\\n        }\\n        solve(idx+1,nums,cnt,tmp,maxi);\\n        solve(idx+1,nums,cnt,val,maxi);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0;\\n        for(auto &i:nums)\\n        maxOr|=i;\\n        int cnt=0;\\n        solve(0,nums,cnt,0,maxOr);\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int idx,vector<int>& nums,int& cnt,int val,int maxi)\\n    {\\n        if(idx==nums.size())\\n        return;\\n        int tmp = val|nums[idx];\\n        if(tmp==maxi)\\n        {\\n            cnt++;\\n        }\\n        solve(idx+1,nums,cnt,tmp,maxi);\\n        solve(idx+1,nums,cnt,val,maxi);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0;\\n        for(auto &i:nums)\\n        maxOr|=i;\\n        int cnt=0;\\n        solve(0,nums,cnt,0,maxOr);\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332525,
                "title": "c-easy-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int currOR, vector<int> &nums, int mxOR, vector<vector<int>> &dp){\\n        if(i > nums.size()) return 0;\\n        if(i == nums.size()) return (currOR == mxOR);\\n        if(dp[i][currOR] != -1) return dp[i][currOR];\\n\\n        int take = helper(i+1,currOR|nums[i],nums,mxOR,dp);\\n        int notTake = helper(i+1,currOR,nums,mxOR,dp);\\n\\n        return dp[i][currOR] = (take+notTake);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int mxOR = 0;\\n        for(int i=0;i<n;i++){\\n            mxOR |= nums[i];\\n        }\\n        vector<vector<int>> dp(n+1,vector<int> (mxOR+1,-1));\\n        return helper(0,0,nums,mxOR,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i, int currOR, vector<int> &nums, int mxOR, vector<vector<int>> &dp){\\n        if(i > nums.size()) return 0;\\n        if(i == nums.size()) return (currOR == mxOR);\\n        if(dp[i][currOR] != -1) return dp[i][currOR];\\n\\n        int take = helper(i+1,currOR|nums[i],nums,mxOR,dp);\\n        int notTake = helper(i+1,currOR,nums,mxOR,dp);\\n\\n        return dp[i][currOR] = (take+notTake);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size();\\n        int mxOR = 0;\\n        for(int i=0;i<n;i++){\\n            mxOR |= nums[i];\\n        }\\n        vector<vector<int>> dp(n+1,vector<int> (mxOR+1,-1));\\n        return helper(0,0,nums,mxOR,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325605,
                "title": "simple-recursive-solution-java",
                "content": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] arr) {\\n        int maxPossible = 0;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            maxPossible |= arr[i];\\n        }\\n        return getCount(0 , arr , 0 , maxPossible);\\n    }\\n    private int getCount(int i , int[] arr , int xor , int max){\\n        if(i >= arr.length) return 0;\\n        int ans = 0;\\n        for(int j = i ; j < arr.length ; j++){\\n            if((xor | arr[j]) == max){\\n                ans += 1 + getCount(j+1 , arr , (xor | arr[j]) , max);\\n            }else{\\n                ans += getCount(j+1 , arr , (xor | arr[j]) , max);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Please UpVote, If found useful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countMaxOrSubsets(int[] arr) {\\n        int maxPossible = 0;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            maxPossible |= arr[i];\\n        }\\n        return getCount(0 , arr , 0 , maxPossible);\\n    }\\n    private int getCount(int i , int[] arr , int xor , int max){\\n        if(i >= arr.length) return 0;\\n        int ans = 0;\\n        for(int j = i ; j < arr.length ; j++){\\n            if((xor | arr[j]) == max){\\n                ans += 1 + getCount(j+1 , arr , (xor | arr[j]) , max);\\n            }else{\\n                ans += getCount(j+1 , arr , (xor | arr[j]) , max);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293669,
                "title": "python-easy-to-understand-backtracking-not-the-best-but-it-works",
                "content": "# Code\\n```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        # Get the max_val\\n        max_val = 0\\n        res = 0\\n        used = [False] * len(nums)\\n        for num in nums:\\n            max_val |= num\\n        def dfs(length,curr_val,idx):\\n            nonlocal res\\n            if (curr_val == max_val) and (length != 0):\\n                res += 1\\n            if length == len(nums):\\n                return\\n            for i in range(idx,len(nums)):\\n                val = nums[i]\\n                if used[i]:\\n                    continue\\n                prev = curr_val\\n                curr_val |= val\\n                used[i] = True\\n                length += 1\\n                dfs(length,curr_val,i+1)\\n                # Reset one step back...\\n                length -= 1\\n                used[i] = False\\n                curr_val = prev\\n\\n        dfs(0,0,0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        # Get the max_val\\n        max_val = 0\\n        res = 0\\n        used = [False] * len(nums)\\n        for num in nums:\\n            max_val |= num\\n        def dfs(length,curr_val,idx):\\n            nonlocal res\\n            if (curr_val == max_val) and (length != 0):\\n                res += 1\\n            if length == len(nums):\\n                return\\n            for i in range(idx,len(nums)):\\n                val = nums[i]\\n                if used[i]:\\n                    continue\\n                prev = curr_val\\n                curr_val |= val\\n                used[i] = True\\n                length += 1\\n                dfs(length,curr_val,i+1)\\n                # Reset one step back...\\n                length -= 1\\n                used[i] = False\\n                curr_val = prev\\n\\n        dfs(0,0,0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292357,
                "title": "simple-c-solution-using-bit-manipulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(), ans=0, tt=0;\\n        unordered_map<int, int> m;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1;i < (1 << n);i++) {\\n            int btr=0;\\n            for (int j = 0;j < n;j++) {\\n                if (i & (1 << j)) {\\n                    btr|=nums[j];\\n                }\\n            }\\n            m[btr]++;\\n        }\\n        for(auto x: m) if(x.first>tt) { ans=x.second; tt=x.first; } \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n = nums.size(), ans=0, tt=0;\\n        unordered_map<int, int> m;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1;i < (1 << n);i++) {\\n            int btr=0;\\n            for (int j = 0;j < n;j++) {\\n                if (i & (1 << j)) {\\n                    btr|=nums[j];\\n                }\\n            }\\n            m[btr]++;\\n        }\\n        for(auto x: m) if(x.first>tt) { ans=x.second; tt=x.first; } \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291934,
                "title": "java-recursive",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    int count=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for(int i:nums)\\n            max = max | i;\\n        backtrack(nums,0,max, 0);\\n        return count;\\n    }\\n\\n    private void backtrack(int[] nums,int first,int max, int curr){\\n        if(max == curr)\\n            count++;\\n        if(first>=nums.length) return;\\n\\n        for(int i = first;i<nums.length;i++){\\n            backtrack(nums,i+1,max,curr|nums[i]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    int count=0;\\n    public int countMaxOrSubsets(int[] nums) {\\n        int max = 0;\\n        for(int i:nums)\\n            max = max | i;\\n        backtrack(nums,0,max, 0);\\n        return count;\\n    }\\n\\n    private void backtrack(int[] nums,int first,int max, int curr){\\n        if(max == curr)\\n            count++;\\n        if(first>=nums.length) return;\\n\\n        for(int i = first;i<nums.length;i++){\\n            backtrack(nums,i+1,max,curr|nums[i]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288706,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func countMaxOrSubsets(_ nums: [Int]) -> Int {\\n        \\n        let t = nums.reduce(0, |)\\n        \\n        func go(_ stack: [Int] = nums) -> [[Int]] {\\n            guard stack.count > 1 else { return [stack] }              \\n            let ret = go(Array(stack.dropFirst()))\\n            return [[stack[0]]] + ret + ret.map { [stack[0]] + $0 }\\n        }\\n        \\n        return go()\\n            .filter { $0.reduce(0, |) == t }\\n            .lazy\\n            .count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countMaxOrSubsets(_ nums: [Int]) -> Int {\\n        \\n        let t = nums.reduce(0, |)\\n        \\n        func go(_ stack: [Int] = nums) -> [[Int]] {\\n            guard stack.count > 1 else { return [stack] }              \\n            let ret = go(Array(stack.dropFirst()))\\n            return [[stack[0]]] + ret + ret.map { [stack[0]] + $0 }\\n        }\\n        \\n        return go()\\n            .filter { $0.reduce(0, |) == t }\\n            .lazy\\n            .count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264625,
                "title": "python3-simplest-recursive-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxBitwiseOr=0\\n        for num in nums:\\n            maxBitwiseOr|=num\\n        ans=[0]\\n        def dfs(i,maxBitwiseOr,curOrValue,ans):\\n            if i==len(nums):\\n                if maxBitwiseOr==curOrValue:\\n                    ans[0]+=1\\n                return\\n            dfs(i+1,maxBitwiseOr,curOrValue,ans)\\n            dfs(i+1,maxBitwiseOr,curOrValue|nums[i],ans)\\n        dfs(0,maxBitwiseOr,0,ans)\\n        return ans[0]\\n    ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        maxBitwiseOr=0\\n        for num in nums:\\n            maxBitwiseOr|=num\\n        ans=[0]\\n        def dfs(i,maxBitwiseOr,curOrValue,ans):\\n            if i==len(nums):\\n                if maxBitwiseOr==curOrValue:\\n                    ans[0]+=1\\n                return\\n            dfs(i+1,maxBitwiseOr,curOrValue,ans)\\n            dfs(i+1,maxBitwiseOr,curOrValue|nums[i],ans)\\n        dfs(0,maxBitwiseOr,0,ans)\\n        return ans[0]\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 3218397,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0, res = 0;\\n        for(auto x:nums) maxOr |= x;\\n        dfs(nums, 0, res, maxOr, 0);\\n        return res;\\n    }\\n\\n    void dfs(vector<int>& v, int i, int& res, int maxOr, int cur){\\n        if(i == v.size()){\\n            if(cur == maxOr) res++;\\n            return;\\n        }\\n        dfs(v, i+1, res, maxOr, cur);\\n        dfs(v, i+1, res, maxOr, cur|v[i]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxOr = 0, res = 0;\\n        for(auto x:nums) maxOr |= x;\\n        dfs(nums, 0, res, maxOr, 0);\\n        return res;\\n    }\\n\\n    void dfs(vector<int>& v, int i, int& res, int maxOr, int cur){\\n        if(i == v.size()){\\n            if(cur == maxOr) res++;\\n            return;\\n        }\\n        dfs(v, i+1, res, maxOr, cur);\\n        dfs(v, i+1, res, maxOr, cur|v[i]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180545,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint count=0;\\nvoid f(vector<int> &nums,int i,int sum,int x)\\n{\\n    if(i==nums.size() && sum>=x)\\n    {\\n        count++;\\n        return;\\n    }\\n    else if(i==nums.size())\\n    return;\\n    int y=sum|nums[i];\\n    f(nums,i+1,y,x);\\n    f(nums,i+1,sum,x);\\n}\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x|nums[i];\\n        }\\n        f(nums,0,0,x);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint count=0;\\nvoid f(vector<int> &nums,int i,int sum,int x)\\n{\\n    if(i==nums.size() && sum>=x)\\n    {\\n        count++;\\n        return;\\n    }\\n    else if(i==nums.size())\\n    return;\\n    int y=sum|nums[i];\\n    f(nums,i+1,y,x);\\n    f(nums,i+1,sum,x);\\n}\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x|nums[i];\\n        }\\n        f(nums,0,0,x);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171185,
                "title": "very-easy-and-simple-just-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int i,j,maxor=0,n=nums.size(),ans=0;\\n        for(i=0;i<n;i++)\\n        {\\n            maxor=nums[i]|maxor;\\n        }\\n        for(i=1;i<(1<<n);i++)\\n        {\\n            int p=0;\\n            for(j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    p=p|nums[j];\\n                }\\n            }\\n            if(p==maxor)\\n            {\\n                ans++;\\n           }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int i,j,maxor=0,n=nums.size(),ans=0;\\n        for(i=0;i<n;i++)\\n        {\\n            maxor=nums[i]|maxor;\\n        }\\n        for(i=1;i<(1<<n);i++)\\n        {\\n            int p=0;\\n            for(j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    p=p|nums[j];\\n                }\\n            }\\n            if(p==maxor)\\n            {\\n                ans++;\\n           }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124318,
                "title": "c-recursive-iterative",
                "content": "Recursive Solution\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums,int pos,int & ans,int & target,int curr){\\n        if(pos<0){\\n            if(curr==target) ans++;\\n            return;\\n        }\\n        helper(nums,pos-1,ans,target,curr);\\n        helper(nums,pos-1,ans,target,curr|nums[pos]);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n =nums.size(),target=0,ans=0;\\n        for(int el:nums) target|=el;\\n        helper(nums,n-1,ans,target,0);\\n        return ans;        \\n    }\\n};\\n```\\n\\nIterative Solution\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n =nums.size(),target=0,ans=0;\\n        for(int el:nums) target|=el;\\n        for(int i=0;i<(1<<n);i++){\\n            int temp=0;\\n            for(int j=0;j<n;j++)\\n                if(i&(1<<j)) temp|=nums[j];\\n            if(temp==target) ans++;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums,int pos,int & ans,int & target,int curr){\\n        if(pos<0){\\n            if(curr==target) ans++;\\n            return;\\n        }\\n        helper(nums,pos-1,ans,target,curr);\\n        helper(nums,pos-1,ans,target,curr|nums[pos]);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n =nums.size(),target=0,ans=0;\\n        for(int el:nums) target|=el;\\n        helper(nums,n-1,ans,target,0);\\n        return ans;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int n =nums.size(),target=0,ans=0;\\n        for(int el:nums) target|=el;\\n        for(int i=0;i<(1<<n);i++){\\n            int temp=0;\\n            for(int j=0;j<n;j++)\\n                if(i&(1<<j)) temp|=nums[j];\\n            if(temp==target) ans++;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124285,
                "title": "naive-solution-using-recursion-only-for-begginers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever in the problem it is given that we need to try out all possible options then we might think of recursion as one of the way to solve the problem.\\n\\nThe common way of generating all possible subsequences for any given array is the PICK/NOT_PICK method. \\n\\nhttps://www.youtube.com/watch?v=AxNNVECce8c\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the pick and not pick technique to generate all subsequences and at the same time computing the maximum possible bitwise or for the given array.\\n\\nOnce all the recursion calls are over we have the value of maximum possible bitwise or and all possible sub-sequences for the given array. Now we can easily traverse and compute bitwise or for all sub-sequences, and compare it with maximum bitwise or value if any of them gives the result equal to maximum bitwise or we increment the counter by one.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince it is Naive solution the Time complexity is quite poor.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. The 2D vector ans\\n2. The temporary vector v\\n3. Recursive stack space\\n\\n# Code\\n```\\nclass Solution {\\nint maxi=-1;\\nprivate:\\n     void f(int ind, int n, vector<int>& nums, vector<int>& v, int res,\\n           vector<vector<int>>& ans){\\n         if(ind>=n){\\n           maxi=max(maxi,res);\\n           ans.push_back(v);\\n           return;\\n         }\\n       \\n        v.push_back(nums[ind]);\\n       f(ind+1,n,nums,v, res|nums[ind],ans);\\n        v.pop_back();\\n       f(ind+1,n,nums,v, res, ans);\\n\\n     }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n     int n=nums.size();\\n     vector<vector<int>> ans;\\n     vector<int> v;\\n     f(0,n,nums,v,0,ans);\\n     int count=0;\\n     for(auto it:ans){\\n         int x=0;\\n         for(int i=0;i<it.size();i++){\\n             x|=it[i];\\n         }\\n         if(x==maxi) count++;\\n     }\\n     return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nint maxi=-1;\\nprivate:\\n     void f(int ind, int n, vector<int>& nums, vector<int>& v, int res,\\n           vector<vector<int>>& ans){\\n         if(ind>=n){\\n           maxi=max(maxi,res);\\n           ans.push_back(v);\\n           return;\\n         }\\n       \\n        v.push_back(nums[ind]);\\n       f(ind+1,n,nums,v, res|nums[ind],ans);\\n        v.pop_back();\\n       f(ind+1,n,nums,v, res, ans);\\n\\n     }\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n     int n=nums.size();\\n     vector<vector<int>> ans;\\n     vector<int> v;\\n     f(0,n,nums,v,0,ans);\\n     int count=0;\\n     for(auto it:ans){\\n         int x=0;\\n         for(int i=0;i<it.size();i++){\\n             x|=it[i];\\n         }\\n         if(x==maxi) count++;\\n     }\\n     return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113001,
                "title": "simple-java-solution-hashmap-backtracking",
                "content": "# Intuition\\nhandle the take and not take cases\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int max=0;\\n    public void fun(int i,int[] nums,int curr,HashMap<Integer,Integer> hash)\\n    {\\n        if(i==nums.length)\\n        {\\n            if(curr!=-1)  \\n            {\\n                max=Math.max(max,curr);\\n                hash.put(curr,hash.getOrDefault(curr,0)+1);\\n            }\\n            return ;\\n        }\\n        int now=0;\\n        if(curr==-1)  now=nums[i];\\n        else\\n        now=curr | nums[i];\\n        fun(i+1,nums,now,hash);\\n        fun(i+1,nums,curr,hash);\\n    }\\n    public int countMaxOrSubsets(int[] nums) \\n    {\\n        HashMap<Integer,Integer> hash=new HashMap<>();\\n        fun(0,nums,-1,hash);\\n        return hash.get(max)==null ? 0 : hash.get(max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int max=0;\\n    public void fun(int i,int[] nums,int curr,HashMap<Integer,Integer> hash)\\n    {\\n        if(i==nums.length)\\n        {\\n            if(curr!=-1)  \\n            {\\n                max=Math.max(max,curr);\\n                hash.put(curr,hash.getOrDefault(curr,0)+1);\\n            }\\n            return ;\\n        }\\n        int now=0;\\n        if(curr==-1)  now=nums[i];\\n        else\\n        now=curr | nums[i];\\n        fun(i+1,nums,now,hash);\\n        fun(i+1,nums,curr,hash);\\n    }\\n    public int countMaxOrSubsets(int[] nums) \\n    {\\n        HashMap<Integer,Integer> hash=new HashMap<>();\\n        fun(0,nums,-1,hash);\\n        return hash.get(max)==null ? 0 : hash.get(max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095240,
                "title": "c-backtracking",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int bitwise = 0;\\n        for (auto& n : nums) bitwise |= n;\\n        int res = 0;\\n        dfs(nums, 0, 0, bitwise, res);\\n        return res;\\n    }\\n\\n    void dfs(vector<int>& nums, int idx, int path, int bitwise, int& res) {\\n        if (idx == nums.size()) return;\\n\\n        int temp = path | nums[idx];\\n        if (temp == bitwise) res++;\\n        dfs(nums, idx + 1, temp, bitwise, res);\\n        dfs(nums, idx + 1, path, bitwise, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int bitwise = 0;\\n        for (auto& n : nums) bitwise |= n;\\n        int res = 0;\\n        dfs(nums, 0, 0, bitwise, res);\\n        return res;\\n    }\\n\\n    void dfs(vector<int>& nums, int idx, int path, int bitwise, int& res) {\\n        if (idx == nums.size()) return;\\n\\n        int temp = path | nums[idx];\\n        if (temp == bitwise) res++;\\n        dfs(nums, idx + 1, temp, bitwise, res);\\n        dfs(nums, idx + 1, path, bitwise, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076924,
                "title": "rust-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(2^n)$$\\n\\n# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn count_max_or_subsets(nums: Vec<i32>) -> i32 {\\n    let n = nums.len();\\n    let limit = 1 << n;\\n    let mut map = HashMap::new();\\n    for i in 0..limit {\\n      let mut temp = 0i32;\\n      for j in 0..n {\\n        if i>>j & 1 == 1 {\\n          temp |= nums[j];\\n        }\\n      }\\n      *map.entry(temp).or_insert(0) += 1;\\n    }\\n    let mut arr = map.into_iter().collect::<Vec<(i32,i32)>>();\\n    arr.sort();\\n    arr[arr.len()-1].1\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn count_max_or_subsets(nums: Vec<i32>) -> i32 {\\n    let n = nums.len();\\n    let limit = 1 << n;\\n    let mut map = HashMap::new();\\n    for i in 0..limit {\\n      let mut temp = 0i32;\\n      for j in 0..n {\\n        if i>>j & 1 == 1 {\\n          temp |= nums[j];\\n        }\\n      }\\n      *map.entry(temp).or_insert(0) += 1;\\n    }\\n    let mut arr = map.into_iter().collect::<Vec<(i32,i32)>>();\\n    arr.sort();\\n    arr[arr.len()-1].1\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057812,
                "title": "python-knapsack-style-dp-o-n-2-16",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        d = Counter([0])\\n        for num in nums:\\n            for k, v in list(d.items()):\\n                d[k|num] += v\\n        return d[max(d)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        d = Counter([0])\\n        for num in nums:\\n            for k, v in list(d.items()):\\n                d[k|num] += v\\n        return d[max(d)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055747,
                "title": "golang-dp",
                "content": "# Code\\n```\\nfunc countMaxOrSubsets(nums []int) int {\\n    var maxVal int = 0\\n    for _, num := range nums {\\n        maxVal = maxVal | num\\n    }\\n    DP := make([]int, maxVal + 1)\\n    DP[nums[0]] = 1;\\n    for i := 1; i < len(nums); i++ {\\n        for j := maxVal; j > 0; j-- {\\n            if DP[j] > 0 {\\n                DP[j | nums[i]] += DP[j]\\n            }\\n        }\\n        DP[nums[i]]++\\n    }\\n    return DP[maxVal]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n    var maxVal int = 0\\n    for _, num := range nums {\\n        maxVal = maxVal | num\\n    }\\n    DP := make([]int, maxVal + 1)\\n    DP[nums[0]] = 1;\\n    for i := 1; i < len(nums); i++ {\\n        for j := maxVal; j > 0; j-- {\\n            if DP[j] > 0 {\\n                DP[j | nums[i]] += DP[j]\\n            }\\n        }\\n        DP[nums[i]]++\\n    }\\n    return DP[maxVal]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055687,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxVal = 0;\\n        for(int num: nums) {\\n            maxVal = maxVal | num;\\n        }\\n        vector<int> DP(maxVal + 1, 0);\\n        DP[nums[0]] = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            for(int j = maxVal; j > 0; j--) {\\n                if(DP[j]) {\\n                    DP[j | nums[i]] += DP[j];\\n                }\\n            }\\n            DP[nums[i]]++;\\n        }\\n        return DP[maxVal];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxVal = 0;\\n        for(int num: nums) {\\n            maxVal = maxVal | num;\\n        }\\n        vector<int> DP(maxVal + 1, 0);\\n        DP[nums[0]] = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            for(int j = maxVal; j > 0; j--) {\\n                if(DP[j]) {\\n                    DP[j | nums[i]] += DP[j];\\n                }\\n            }\\n            DP[nums[i]]++;\\n        }\\n        return DP[maxVal];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044947,
                "title": "c-faster-than-65-brute-force-subsets-using-recursion-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\nvoid func(int i,vector<int>&nums,vector<int>&st,vector<vector<int>>&vs)\\n{\\n        if(st.size() > 0)vs.push_back(st);\\n        for(;i<nums.size();i++)\\n        {\\n            st.push_back(nums[i]);\\n            func(i+1,nums,st,vs);\\n            st.pop_back();\\n        }\\n        return;\\n}\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n       \\n       int Or  = nums[0];\\n\\n       for(int i = 1; i<nums.size();++i)  Or = Or | nums[i]; \\n\\n       vector<int>st;\\n       vector<vector<int>>vs;\\n       \\n       func(0,nums,st,vs);\\n\\n       int cnt = 0;\\n\\n       for(int i = 0; i < vs.size(); ++i)\\n       {\\n          int temp = vs[i][0];\\n\\n          for(int j = 1; j < vs[i].size();++j) temp = temp | vs[i][j];\\n          \\n          if(temp == Or) cnt++;\\n\\n       }\\n\\n       return cnt;\\n \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\nvoid func(int i,vector<int>&nums,vector<int>&st,vector<vector<int>>&vs)\\n{\\n        if(st.size() > 0)vs.push_back(st);\\n        for(;i<nums.size();i++)\\n        {\\n            st.push_back(nums[i]);\\n            func(i+1,nums,st,vs);\\n            st.pop_back();\\n        }\\n        return;\\n}\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n       \\n       int Or  = nums[0];\\n\\n       for(int i = 1; i<nums.size();++i)  Or = Or | nums[i]; \\n\\n       vector<int>st;\\n       vector<vector<int>>vs;\\n       \\n       func(0,nums,st,vs);\\n\\n       int cnt = 0;\\n\\n       for(int i = 0; i < vs.size(); ++i)\\n       {\\n          int temp = vs[i][0];\\n\\n          for(int j = 1; j < vs[i].size();++j) temp = temp | vs[i][j];\\n          \\n          if(temp == Or) cnt++;\\n\\n       }\\n\\n       return cnt;\\n \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025965,
                "title": "basic-approach-using-recursion-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define vi vector<int>\\n#define vll vector<ll>\\n#define vvi vector<vector<int>>\\n#define pb push_back\\n#define srt(x) sort(begin(x),end(x))\\n#define rep(i,a,b) for(int i=a,i<b;i++)\\n#define REP(i,a,b) for(int i=b;i>=a;i--)\\n#define imap unordered_map<int,int>\\n#define lmap unordered_map<ll,ll>\\nclass Solution {\\npublic:\\n    //Function to get all the subsets of the given array\\n    void getSubsets(int ind,vi &nums,vi &ans,vvi &res){\\n        //if the index crosses the size of the array then insert the found subset in the\\n        //result array\\n        if(ind==nums.size()){\\n            res.pb(ans);\\n            return ;\\n        }\\n        //push the subset at that index and then call the recursive function to look for\\n        //other indices\\n        ans.pb(nums[ind]);\\n        getSubsets(ind+1,nums,ans,res);\\n        //finally backtrack\\n        ans.pop_back();\\n        getSubsets(ind+1,nums,ans,res);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vvi res;\\n        vi ans;\\n        vi store;\\n        getSubsets(0,nums,ans,res);\\n        //Here we got all the subsets\\n        int count=0;\\n        //now we can iterate over all the subsets and calculate the OR of all of them\\n        for(auto &it:res){\\n            if(it.size()>=1){\\n                int x=it[0];\\n                for(int i=1;i<it.size();i++){\\n                    x|=it[i];\\n                }\\n                store.pb(x);\\n            }\\n        }\\n        //find out the maximum OR and count the number of max XOR\\'s\\n        int maxi=*max_element(begin(store),end(store));\\n        for(auto &it:store){\\n            if(it==maxi) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nI hope you like my approach, though it is a very naive approach for beginners. Will try to optimize it and will post the solutions. \\nHappy Coding:)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long\\n#define vi vector<int>\\n#define vll vector<ll>\\n#define vvi vector<vector<int>>\\n#define pb push_back\\n#define srt(x) sort(begin(x),end(x))\\n#define rep(i,a,b) for(int i=a,i<b;i++)\\n#define REP(i,a,b) for(int i=b;i>=a;i--)\\n#define imap unordered_map<int,int>\\n#define lmap unordered_map<ll,ll>\\nclass Solution {\\npublic:\\n    //Function to get all the subsets of the given array\\n    void getSubsets(int ind,vi &nums,vi &ans,vvi &res){\\n        //if the index crosses the size of the array then insert the found subset in the\\n        //result array\\n        if(ind==nums.size()){\\n            res.pb(ans);\\n            return ;\\n        }\\n        //push the subset at that index and then call the recursive function to look for\\n        //other indices\\n        ans.pb(nums[ind]);\\n        getSubsets(ind+1,nums,ans,res);\\n        //finally backtrack\\n        ans.pop_back();\\n        getSubsets(ind+1,nums,ans,res);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        vvi res;\\n        vi ans;\\n        vi store;\\n        getSubsets(0,nums,ans,res);\\n        //Here we got all the subsets\\n        int count=0;\\n        //now we can iterate over all the subsets and calculate the OR of all of them\\n        for(auto &it:res){\\n            if(it.size()>=1){\\n                int x=it[0];\\n                for(int i=1;i<it.size();i++){\\n                    x|=it[i];\\n                }\\n                store.pb(x);\\n            }\\n        }\\n        //find out the maximum OR and count the number of max XOR\\'s\\n        int maxi=*max_element(begin(store),end(store));\\n        for(auto &it:store){\\n            if(it==maxi) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011786,
                "title": "simple-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int mxOr,int& count,int curOr,int i){\\n        if(i>=nums.size()){\\n            if(mxOr==curOr){\\n             count++;\\n            }\\n            return;\\n        }\\n        //if i include ith index\\n        solve(nums,mxOr,count,curOr|nums[i],i+1);\\n        //if not include ith index\\n        solve(nums,mxOr,count,curOr,i+1);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int mxOr=0;\\n        for(auto it:nums){\\n            mxOr=mxOr|it;\\n        }\\n        int count=0;\\n        solve(nums,mxOr,count,0,0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,int mxOr,int& count,int curOr,int i){\\n        if(i>=nums.size()){\\n            if(mxOr==curOr){\\n             count++;\\n            }\\n            return;\\n        }\\n        //if i include ith index\\n        solve(nums,mxOr,count,curOr|nums[i],i+1);\\n        //if not include ith index\\n        solve(nums,mxOr,count,curOr,i+1);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int mxOr=0;\\n        for(auto it:nums){\\n            mxOr=mxOr|it;\\n        }\\n        int count=0;\\n        solve(nums,mxOr,count,0,0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976787,
                "title": "go-compact-dfs",
                "content": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n    bw := map[int]int{}\\n    max := -1\\n\\n    var dfs func(idx int, xor int)\\n    dfs = func(idx int, xor int) {\\n        if idx == len(nums) {\\n            bw[xor]++\\n            if xor > max { max = xor }\\n            return\\n        }\\n        dfs(idx + 1, xor | nums[idx])\\n        dfs(idx + 1, xor)\\n        return\\n    }\\n\\n    dfs(0, 0)\\n    return bw[max]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countMaxOrSubsets(nums []int) int {\\n    bw := map[int]int{}\\n    max := -1\\n\\n    var dfs func(idx int, xor int)\\n    dfs = func(idx int, xor int) {\\n        if idx == len(nums) {\\n            bw[xor]++\\n            if xor > max { max = xor }\\n            return\\n        }\\n        dfs(idx + 1, xor | nums[idx])\\n        dfs(idx + 1, xor)\\n        return\\n    }\\n\\n    dfs(0, 0)\\n    return bw[max]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2963978,
                "title": "php-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution\\n{\\n\\n    private $sum = 0;\\n    private $occurres = [];\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countMaxOrSubsets( $nums )\\n    {\\n        $this->backtrack( $nums, [], 0 );\\n        $max = 0;\\n\\n        foreach ( $this->occurres as $k => $v )\\n        {\\n            $max = max( $v, $max );\\n        }\\n\\n        return $max;\\n    }\\n\\n\\n    function backtrack( $nums, $set, $index = 0 )\\n    {\\n        $or = 0;\\n        foreach ( $set as $s )\\n        {\\n            $or |= $s;\\n        }\\n        $this->occurres[$or] = isset( $this->occurres[$or] ) ?\\n            $this->occurres[$or] + 1 : 1;\\n\\n        if ( count( $set ) === count( $nums ) )\\n        {\\n            return;\\n        }\\n\\n        for ( $i = $index; $i < count( $nums ); $i++ )\\n        {\\n            $set[] = $nums[$i];\\n            $this->backtrack( $nums, $set, $i + 1 );\\n            array_pop( $set );\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n\\nclass Solution\\n{\\n\\n    private $sum = 0;\\n    private $occurres = [];\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countMaxOrSubsets( $nums )\\n    {\\n        $this->backtrack( $nums, [], 0 );\\n        $max = 0;\\n\\n        foreach ( $this->occurres as $k => $v )\\n        {\\n            $max = max( $v, $max );\\n        }\\n\\n        return $max;\\n    }\\n\\n\\n    function backtrack( $nums, $set, $index = 0 )\\n    {\\n        $or = 0;\\n        foreach ( $set as $s )\\n        {\\n            $or |= $s;\\n        }\\n        $this->occurres[$or] = isset( $this->occurres[$or] ) ?\\n            $this->occurres[$or] + 1 : 1;\\n\\n        if ( count( $set ) === count( $nums ) )\\n        {\\n            return;\\n        }\\n\\n        for ( $i = $index; $i < count( $nums ); $i++ )\\n        {\\n            $set[] = $nums[$i];\\n            $this->backtrack( $nums, $set, $i + 1 );\\n            array_pop( $set );\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951749,
                "title": "c-recursion-backtracking-beats-100",
                "content": "# Approach\\n1.Calculate the max bitwise OR of a list, which is the ORing of all the elements in the list.\\n\\n2.Use backtracking to generate all the possible subsets and each time calculate the OR of the subset and compare with the max that we calcualte in step 1, if they are equal, then increment result counter by 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n * 2^n) where n is the length of n\\n\\n- Space complexity:\\nO(n) where n is the length of nums\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b8cec52a-c7f3-4392-a6c6-86bbd17a5807_1672023730.3167922.png)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountMaxOrSubsets(int[] nums) {\\n        int maxOrBitwiseCount = 0;\\n\\n        int maxOrBitwise = 0;\\n        foreach (int num in nums)\\n            maxOrBitwise |= num;\\n        \\n        List<int> currSol = new();\\n\\n        void Backtrack(int i)\\n        {\\n            if (CalculateOrBitwise(currSol) == maxOrBitwise)\\n                maxOrBitwiseCount++;\\n            \\n            for (int j = i; j < nums.Length; j++)\\n            {\\n                currSol.Add(nums[j]);\\n                Backtrack(j + 1);\\n                currSol.RemoveAt(currSol.Count - 1);\\n            }\\n        }\\n\\n        Backtrack(0);\\n\\n        return maxOrBitwiseCount;\\n    }\\n\\n    public int CalculateOrBitwise(List<int> list)\\n    {\\n        int res = 0;\\n        foreach (int num in list)\\n            res |= num;\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountMaxOrSubsets(int[] nums) {\\n        int maxOrBitwiseCount = 0;\\n\\n        int maxOrBitwise = 0;\\n        foreach (int num in nums)\\n            maxOrBitwise |= num;\\n        \\n        List<int> currSol = new();\\n\\n        void Backtrack(int i)\\n        {\\n            if (CalculateOrBitwise(currSol) == maxOrBitwise)\\n                maxOrBitwiseCount++;\\n            \\n            for (int j = i; j < nums.Length; j++)\\n            {\\n                currSol.Add(nums[j]);\\n                Backtrack(j + 1);\\n                currSol.RemoveAt(currSol.Count - 1);\\n            }\\n        }\\n\\n        Backtrack(0);\\n\\n        return maxOrBitwiseCount;\\n    }\\n\\n    public int CalculateOrBitwise(List<int> list)\\n    {\\n        int res = 0;\\n        foreach (int num in list)\\n            res |= num;\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949708,
                "title": "php-solution-using-subsets",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countMaxOrSubsets($nums) {\\n        $subsets=$this->subsets($nums);\\n        $ors=[];\\n        foreach($subsets as $sub){\\n            array_push($ors,array_reduce($sub,array($this,\"bitwiseOr\")));\\n        }\\n        $max=max(array_values($ors));\\n       $count=0;\\n       foreach($ors as $or){\\n           if($or==$max)\\n                $count++;\\n       }\\n        return $count;\\n    }\\n\\n    function subsets($nums) {\\n        $res=[[]];\\n        if(sizeof($nums)==1) \\n            array_push($res,[$nums[0]]);\\n        else{\\n            foreach($nums as $num){\\n                $first=array_shift($nums);\\n                $subs=$this->subsets($nums);\\n                foreach($subs as $sub){\\n                    array_push($sub,$first);\\n                    array_push($res,$sub);\\n                }\\n            }\\n        }\\n        return $res; \\n       \\n    }\\n    function bitwiseOr($a,$b){\\n        return $a|$b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countMaxOrSubsets($nums) {\\n        $subsets=$this->subsets($nums);\\n        $ors=[];\\n        foreach($subsets as $sub){\\n            array_push($ors,array_reduce($sub,array($this,\"bitwiseOr\")));\\n        }\\n        $max=max(array_values($ors));\\n       $count=0;\\n       foreach($ors as $or){\\n           if($or==$max)\\n                $count++;\\n       }\\n        return $count;\\n    }\\n\\n    function subsets($nums) {\\n        $res=[[]];\\n        if(sizeof($nums)==1) \\n            array_push($res,[$nums[0]]);\\n        else{\\n            foreach($nums as $num){\\n                $first=array_shift($nums);\\n                $subs=$this->subsets($nums);\\n                foreach($subs as $sub){\\n                    array_push($sub,$first);\\n                    array_push($res,$sub);\\n                }\\n            }\\n        }\\n        return $res; \\n       \\n    }\\n    function bitwiseOr($a,$b){\\n        return $a|$b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946488,
                "title": "java-simple-solution-using-backtracking-beats-90-solutions",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    int mx = 0;\\n\\n    public void f(int[] nums, int xr, int i) {\\n        //System.out.println(xr);\\n\\n        if (i == nums.length) {\\n            if (xr == mx) {\\n                ans++;\\n            }\\n            return;\\n        }\\n\\n        f(nums, xr | nums[i], i + 1);\\n        f(nums, xr, i + 1);\\n    }\\n\\n    public int countMaxOrSubsets(int[] nums) {\\n        int m = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            m = m | nums[i];\\n        }\\n\\n        mx = m;\\n\\n        f(nums, 0, 0);\\n\\n        //System.out.println(mx);\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int mx = 0;\\n\\n    public void f(int[] nums, int xr, int i) {\\n        //System.out.println(xr);\\n\\n        if (i == nums.length) {\\n            if (xr == mx) {\\n                ans++;\\n            }\\n            return;\\n        }\\n\\n        f(nums, xr | nums[i], i + 1);\\n        f(nums, xr, i + 1);\\n    }\\n\\n    public int countMaxOrSubsets(int[] nums) {\\n        int m = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            m = m | nums[i];\\n        }\\n\\n        mx = m;\\n\\n        f(nums, 0, 0);\\n\\n        //System.out.println(mx);\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942159,
                "title": "c-recursion-backtracking-very-easy",
                "content": "# Intuition\\nWe will check for all the subset.\\n\\n# Approach\\nFor a subset we calculate the or of all values when we get value is maximum then we declear count = 1 and if value we get is same as maximum value then we will increase our count value by 1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums, vector<int> v, int index, int &count,int &mx)\\n    {\\n        if(index>=nums.size())\\n        {\\n            int ans = 0;\\n            for(int i=0 ;i<v.size() ;i++)\\n            ans = ans|v[i];\\n            if(ans>mx){\\n                count=1;\\n                mx = ans;\\n            }\\n            else if(ans==mx)\\n            count++;\\n            return;\\n        }\\n        solve(nums, v, index+1, count, mx);\\n        v.push_back(nums[index]);\\n        solve(nums, v, index+1, count, mx);\\n        //v.pop_back(); no need for this because we are not passing the reference of vector.\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        int index= 0 , mx = INT_MIN;\\n        solve(nums, v, index, count, mx);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums, vector<int> v, int index, int &count,int &mx)\\n    {\\n        if(index>=nums.size())\\n        {\\n            int ans = 0;\\n            for(int i=0 ;i<v.size() ;i++)\\n            ans = ans|v[i];\\n            if(ans>mx){\\n                count=1;\\n                mx = ans;\\n            }\\n            else if(ans==mx)\\n            count++;\\n            return;\\n        }\\n        solve(nums, v, index+1, count, mx);\\n        v.push_back(nums[index]);\\n        solve(nums, v, index+1, count, mx);\\n        //v.pop_back(); no need for this because we are not passing the reference of vector.\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        int index= 0 , mx = INT_MIN;\\n        solve(nums, v, index, count, mx);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938171,
                "title": "c-beats-95-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Author : S.SARKAR\\n\\n// here we are not making subsets via vectors because it\\'s not needed to push elements into different vectors of subsets, as we need to keep count of the bitwise OR of each subset , so I removed all the push, pop operations and vectors needed, so we are not storing subsets in vectors, but we are actually going through all the subsets \\nclass Solution {\\npublic:\\n    int counter=0;  // counter stores count of subsets with maxm_bitwise_OR\\n// orr is bitwise_OR of all nos. in each subset: \\n    void subs(int index, vector<int>&nums,int orr,int maxm){ \\n        if(index>=nums.size()){  //base case\\n            if(orr==maxm) counter++;\\n            return;\\n        }\\n        subs(index+1,nums,orr,maxm);\\n        subs(index+1,nums,orr|nums[index],maxm);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxm_ORR=0;\\n        for(auto &i: nums){\\n            maxm_ORR|=i;\\n        }\\n        subs(0,nums,0,maxm_ORR); \\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n// Author : S.SARKAR\\n\\n// here we are not making subsets via vectors because it\\'s not needed to push elements into different vectors of subsets, as we need to keep count of the bitwise OR of each subset , so I removed all the push, pop operations and vectors needed, so we are not storing subsets in vectors, but we are actually going through all the subsets \\nclass Solution {\\npublic:\\n    int counter=0;  // counter stores count of subsets with maxm_bitwise_OR\\n// orr is bitwise_OR of all nos. in each subset: \\n    void subs(int index, vector<int>&nums,int orr,int maxm){ \\n        if(index>=nums.size()){  //base case\\n            if(orr==maxm) counter++;\\n            return;\\n        }\\n        subs(index+1,nums,orr,maxm);\\n        subs(index+1,nums,orr|nums[index],maxm);\\n    }\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        int maxm_ORR=0;\\n        for(auto &i: nums){\\n            maxm_ORR|=i;\\n        }\\n        subs(0,nums,0,maxm_ORR); \\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937290,
                "title": "bit-manipulation-bit-masking",
                "content": "int countMaxOrSubsets(vector<int>& nums) {\\n       int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           ans|=nums[i]; \\n        }\\n         \\n        int n=nums.size();\\n\\n      vector<vector<int>>subset;\\n    \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n                vector<int>v;\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                   v.push_back(nums[j]);\\n            }\\n            subset.push_back(v);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<subset.size();i++)\\n        {\\n            int orr=0;\\n          for(int j=0;j<subset[i].size();j++)\\n          {\\n             orr|=subset[i][j]; \\n          }\\n            if(orr==ans)cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "int countMaxOrSubsets(vector<int>& nums) {\\n       int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           ans|=nums[i]; \\n        }\\n         \\n        int n=nums.size();\\n\\n      vector<vector<int>>subset;\\n    \\n        for(int i=0;i<(1<<n);i++)\\n        {\\n                vector<int>v;\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                   v.push_back(nums[j]);\\n            }\\n            subset.push_back(v);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<subset.size();i++)\\n        {\\n            int orr=0;\\n          for(int j=0;j<subset[i].size();j++)\\n          {\\n             orr|=subset[i][j]; \\n          }\\n            if(orr==ans)cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570640,
                "content": [
                    {
                        "username": "LeetCodeFunker",
                        "content": "We can easily know the max value of Bitsise OR, then why we cannot apply DP here? To make it from O(2^N) -> O(N * maxval of Bitwise)"
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            },
            {
                "id": 2020925,
                "content": [
                    {
                        "username": "LeetCodeFunker",
                        "content": "We can easily know the max value of Bitsise OR, then why we cannot apply DP here? To make it from O(2^N) -> O(N * maxval of Bitwise)"
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "How to know whether the problem can be memoized or not ?\\n\\nfor every index the answer varies with previous considered element so we can fix certain value at every index for granted so there is no memo\\nis it true??\\n\\nhow to identify the sub problems?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Second Minimum Time to Reach Destination",
        "question_content": "<p>A city is represented as a <strong>bi-directional connected</strong> graph with <code>n</code> vertices where each vertex is labeled from <code>1</code> to <code>n</code> (<strong>inclusive</strong>). The edges in the graph are represented as a 2D integer array <code>edges</code>, where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a bi-directional edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by <strong>at most one</strong> edge, and no vertex has an edge to itself. The time taken to traverse any edge is <code>time</code> minutes.</p>\n\n<p>Each vertex has a traffic signal which changes its color from <strong>green</strong> to <strong>red</strong> and vice versa every&nbsp;<code>change</code> minutes. All signals change <strong>at the same time</strong>. You can enter a vertex at <strong>any time</strong>, but can leave a vertex <strong>only when the signal is green</strong>. You <strong>cannot wait </strong>at a vertex if the signal is <strong>green</strong>.</p>\n\n<p>The <strong>second minimum value</strong> is defined as the smallest value<strong> strictly larger </strong>than the minimum value.</p>\n\n<ul>\n\t<li>For example the second minimum value of <code>[2, 3, 4]</code> is <code>3</code>, and the second minimum value of <code>[2, 2, 4]</code> is <code>4</code>.</li>\n</ul>\n\n<p>Given <code>n</code>, <code>edges</code>, <code>time</code>, and <code>change</code>, return <em>the <strong>second minimum time</strong> it will take to go from vertex </em><code>1</code><em> to vertex </em><code>n</code>.</p>\n\n<p><strong>Notes:</strong></p>\n\n<ul>\n\t<li>You can go through any vertex <strong>any</strong> number of times, <strong>including</strong> <code>1</code> and <code>n</code>.</li>\n\t<li>You can assume that when the journey <strong>starts</strong>, all signals have just turned <strong>green</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/e1.png\" style=\"width: 200px; height: 250px;\" /> &emsp; &emsp; &emsp; &emsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/e2.png\" style=\"width: 200px; height: 250px;\" />\n<pre>\n<strong>Input:</strong> n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\n<strong>Output:</strong> 13\n<strong>Explanation:</strong>\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -&gt; 4: 3 minutes, time elapsed=3\n- 4 -&gt; 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -&gt; 3: 3 minutes, time elapsed=3\n- 3 -&gt; 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -&gt; 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/eg2.png\" style=\"width: 225px; height: 50px;\" />\n<pre>\n<strong>Input:</strong> n = 2, edges = [[1,2]], time = 3, change = 2\n<strong>Output:</strong> 11\n<strong>Explanation:</strong>\nThe minimum time path is 1 -&gt; 2 with time = 3 minutes.\nThe second minimum time path is 1 -&gt; 2 -&gt; 1 -&gt; 2 with time = 11 minutes.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>n - 1 &lt;= edges.length &lt;= min(2 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>There are no duplicate edges.</li>\n\t<li>Each vertex can be reached directly or indirectly from every other vertex.</li>\n\t<li><code>1 &lt;= time, change &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1525149,
                "title": "python-modified-dijkstra-explained",
                "content": "To solve this problem you need to understand how Dijkstra algorithm work and adapt it to find the second shortest path. In usual Dijkstra algorithm for each node we keep shortest distance so far for this node. Here we need to keep two shortest distances. So, we keep in `D[node]` list of shortest distances for `node`.\\n\\n1. First we traverse our `edges` and construct graph `G`.\\n2. Then we do the classical Dijkstra with heap, where we extract `min_dist, idx = heappop(heap)`.\\n3. We check if we already found two different distances for node `n` and if we found, return biggest distance among these two.\\n4. Iterate through all neighbours and calculate distance for candidates: if we go on green light, just add `time`, if we are on the red ligth, wait for green: for the smallest time divisible by `2*change`, such that it is greater or equal to `min_dist`.\\n5. Now, if we visit our `neib` for the first time, we update distance. If we visited it only once and new candidate is not equal to what we already have, add it to distances. Finally, if we already have two different distances for this node, we try to visit it only if new candidate is less than maximum (and not equal to minimum) that is we can update distances. **update**: in fact this condition is not needed, because we use greedy strategy here: for each node we first find the smallest distance and then the next smallest.\\n\\n#### Complexity\\nIt is almost like classical Dijkstra algorithm, but now we can revisit some nodes from time to time. Time complexity is still `O((E + V) * log V)` though, because we have no more than `2` candidates, space complexity is `O(E + V)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def secondMinimum(self, n, edges, time, change):\\n        D = [[] for _ in range(n + 1)]\\n        D[1] = [0]\\n        G, heap = defaultdict(list), [(0, 1)]\\n        \\n        for a, b in edges:\\n            G[a] += [b]\\n            G[b] += [a]\\n\\n        while heap:\\n            min_dist, idx = heappop(heap)\\n            if idx == n and len(D[n]) == 2: return max(D[n])\\n\\n            for neib in G[idx]:\\n                if (min_dist // change) % 2 == 0:\\n                    cand = min_dist + time\\n                else:\\n                    cand = ceil(min_dist/(2*change)) * (2*change) + time\\n\\n                if not D[neib] or (len(D[neib]) == 1 and D[neib] != [cand]):\\n                    D[neib] += [cand]\\n                    heappush(heap, (cand, neib))\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def secondMinimum(self, n, edges, time, change):\\n        D = [[] for _ in range(n + 1)]\\n        D[1] = [0]\\n        G, heap = defaultdict(list), [(0, 1)]\\n        \\n        for a, b in edges:\\n            G[a] += [b]\\n            G[b] += [a]\\n\\n        while heap:\\n            min_dist, idx = heappop(heap)\\n            if idx == n and len(D[n]) == 2: return max(D[n])\\n\\n            for neib in G[idx]:\\n                if (min_dist // change) % 2 == 0:\\n                    cand = min_dist + time\\n                else:\\n                    cand = ceil(min_dist/(2*change)) * (2*change) + time\\n\\n                if not D[neib] or (len(D[neib]) == 1 and D[neib] != [cand]):\\n                    D[neib] += [cand]\\n                    heappush(heap, (cand, neib))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525154,
                "title": "no-dijkstra-n-1-or-n-2",
                "content": "Since the transition time is the same, and all nodes change the light at the same time, we can talk in terms of the number of steps.\\n\\n> `change` and `time` does not affect the algorithm, so we calculate time it in the end (`stepsTime`).\\n\\n> Update: since the time is the same for the same number of steps, we do not need Dijkstra. I updated the solution below; I posted the original Dijkstra-based solution in the comments for your referece.\\n\\nIf the minimum number of steps is `n`, then the second minimum time is either `n + 1` (we take a detour) or `n + 2` (we go back-and-forth once).\\n\\nWe can run BFS, but if we go back-and-forth, the number of paths will get too large (TLE). So, we will only allow going through the node again if the number of steps is the same or one step more than the first time (`minSteps`). \\n\\nIf we find the second best time, we have `n + 1` situation. If not, we add two more steps to the best time (`n + 2`).\\n\\nFew optimizations:\\n- Our heap can have duplicates, so we remove them first.\\n- If the current step is larger than `minSteps[n] + 1`, we should not continue - it\\'s `n + 2` case.\\n\\n**C++**\\n```cpp\\nint stepsTime(int steps, int time, int change) {\\n    int res = 0;\\n    while (--steps) {\\n        res += time;\\n        if ((res / change) % 2)\\n            res = (res / change + 1) * change;\\n    }\\n    return res + time;\\n}\\nint secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n    vector<vector<int>> al(n + 1);\\n    vector<int> minSteps(n + 1, 10001);\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int step = -1;\\n    vector<int> q({1});\\n    while (!q.empty() && ++step <= minSteps[n] + 1) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            if (step == minSteps[i] || step > minSteps[i] + 1)\\n                continue;\\n            minSteps[i] = min(minSteps[i], step);\\n            if (i == n && step > minSteps[n])\\n                return stepsTime(step, time, change);\\n            for (int j : al[i])\\n                q1.push_back(j);\\n        }\\n        swap(q, q1);\\n    }\\n    return stepsTime(minSteps[n] + 2, time, change);\\n}   \\n```\\n**Java**\\n```java\\nint stepsTime(int steps, int time, int change) {\\n    int res = 0;\\n    while (--steps > 0) {\\n        res += time;\\n        if ((res / change) % 2 == 1)\\n            res = (res / change + 1) * change;\\n    }\\n    return res + time;\\n}    \\npublic int secondMinimum(int n, int[][] edges, int time, int change) {\\n    List<List<Integer>> al = new ArrayList<List<Integer>>();\\n    int[] minSteps = new int[n + 1];\\n    Arrays.fill(minSteps, 10001);\\n    for (int i = 0; i <= n; ++i)\\n        al.add(new ArrayList<Integer>());\\n    for (var e : edges) {\\n        al.get(e[0]).add(e[1]);\\n        al.get(e[1]).add(e[0]);\\n    }\\n    int step = -1;\\n    List<Integer> q = new ArrayList<>(List.of(1));\\n    while(!q.isEmpty() && ++step <= minSteps[n] + 1) {\\n        List<Integer> q1 = new ArrayList<>();\\n        for (int i : q) {\\n            if (step == minSteps[i] || step > minSteps[i] + 1)\\n                continue;\\n            minSteps[i] = Math.min(minSteps[i], step);\\n            if (i == n && step > minSteps[n])\\n                return stepsTime(step, time, change);\\n            for (int j : al.get(i))\\n                q1.add(j);\\n        }\\n        q = q1;\\n    }\\n    return stepsTime(minSteps[n] + 2, time, change);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint stepsTime(int steps, int time, int change) {\\n    int res = 0;\\n    while (--steps) {\\n        res += time;\\n        if ((res / change) % 2)\\n            res = (res / change + 1) * change;\\n    }\\n    return res + time;\\n}\\nint secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n    vector<vector<int>> al(n + 1);\\n    vector<int> minSteps(n + 1, 10001);\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int step = -1;\\n    vector<int> q({1});\\n    while (!q.empty() && ++step <= minSteps[n] + 1) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            if (step == minSteps[i] || step > minSteps[i] + 1)\\n                continue;\\n            minSteps[i] = min(minSteps[i], step);\\n            if (i == n && step > minSteps[n])\\n                return stepsTime(step, time, change);\\n            for (int j : al[i])\\n                q1.push_back(j);\\n        }\\n        swap(q, q1);\\n    }\\n    return stepsTime(minSteps[n] + 2, time, change);\\n}   \\n```\n```java\\nint stepsTime(int steps, int time, int change) {\\n    int res = 0;\\n    while (--steps > 0) {\\n        res += time;\\n        if ((res / change) % 2 == 1)\\n            res = (res / change + 1) * change;\\n    }\\n    return res + time;\\n}    \\npublic int secondMinimum(int n, int[][] edges, int time, int change) {\\n    List<List<Integer>> al = new ArrayList<List<Integer>>();\\n    int[] minSteps = new int[n + 1];\\n    Arrays.fill(minSteps, 10001);\\n    for (int i = 0; i <= n; ++i)\\n        al.add(new ArrayList<Integer>());\\n    for (var e : edges) {\\n        al.get(e[0]).add(e[1]);\\n        al.get(e[1]).add(e[0]);\\n    }\\n    int step = -1;\\n    List<Integer> q = new ArrayList<>(List.of(1));\\n    while(!q.isEmpty() && ++step <= minSteps[n] + 1) {\\n        List<Integer> q1 = new ArrayList<>();\\n        for (int i : q) {\\n            if (step == minSteps[i] || step > minSteps[i] + 1)\\n                continue;\\n            minSteps[i] = Math.min(minSteps[i], step);\\n            if (i == n && step > minSteps[n])\\n                return stepsTime(step, time, change);\\n            for (int j : al.get(i))\\n                q1.add(j);\\n        }\\n        q = q1;\\n    }\\n    return stepsTime(minSteps[n] + 2, time, change);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525165,
                "title": "c-two-bfs-with-detailed-explanation",
                "content": "idea:\\n1. calculate the shortest path from node `i` to `n-1`(index starts from 0), store the results in `d`\\n\\t- do BFS starting from `n-1`\\n2. check whether there is a path with length `d[0] + 1`\\n\\t- do BFS starting from `0`, and find at each vertex **whether there\\'s a neighbor with `d[nei] == d[cur]`**, if so, you have found a path with length `d[0] + 1`\\n3. there is always a path with length `d[0] + 2`\\n\\t- this is because you can always choose the path `0, a, ..., x, n-1,` **`x, n-1`**, where the prefix `0, a, ..., x, n-1` is a shortest path from `0` to `n-1`.\\n4. linear scan for each vertex and keep track of current time (after we checked the length of the second shortest path)\\n\\t- We don\\'t need to reconstruct the path, since all path of same length is considered same in this problem. We care only the length of a path.\\n\\t- The signal is green if current time falls in one of the intervals `[0, change), [2*change, 3*change), ..., [2k*change, (2k+1)*change), ...`\\n\\t- In my code, I check the parity of `currTime/change`. If it\\'s even, the current signal is green and we can directly go to the next vertex, if it\\'s odd then we have to wait until the signal turns into green.\\n\\n- code (C++)\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        // if the shortest path from 1 to n is of length L\\n        // find whether there is a path of length L+1\\n        // there is always a path of length L+2\\n        \\n        vector<vector<int>> adj(n);\\n        for (auto& e : edges) {\\n            int u = e[0]-1, v = e[1]-1;\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // bfs from goal\\n        vector<int> d(n, 1e9);\\n        d[n-1] = 0;\\n        queue<int> q;\\n        q.push(n-1);\\n        while (!q.empty()) {\\n            int cur = q.front(); q.pop();\\n            for (auto nei : adj[cur]) {\\n                if (d[nei] == 1e9) {\\n                    d[nei] = d[cur] + 1;\\n                    q.push(nei);\\n                }\\n            }\\n        }\\n        \\n        // check the existence of a path with length = d[0]+1\\n        int len = d[0] + 2;\\n        q.push(0);\\n        bool done = false;\\n        while (!q.empty()) {\\n            int cur = q.front(); q.pop();\\n            for (auto nei : adj[cur]) {\\n                if (d[nei] == d[cur]) {\\n                    len--;\\n                    done = true;\\n                    break;\\n                } else if (d[nei] == d[cur] - 1) {\\n                    q.push(nei);\\n                }\\n            }\\n            if (done) break;\\n        }\\n        \\n        // calculate the time needed\\n        // light : green in [0, c),  [2c, 3c), ... \\n        //          red  in [c, 2c), [3c, 4c), ...\\n        int currTime = 0;\\n        //cout << len << \\'\\\\n\\';\\n        for (int i = 0; i < len; i++) {\\n\\t\\t\\tif ((currTime / change) % 2 == 1)  // have to wait until the signal turns into green\\n                currTime = ((currTime / change) + 1) * change;    \\n            currTime += time;\\n        }\\n        return currTime;\\n    }\\n};\\n```\\n\\n- time complexity: `O(|V| + |E|)`, or equivalently`O(n + edges.length)`\\n\\t- 2 BFS + 1 linear scan, where `len < n+2`\\n- space complexity: `O(|V| + |E|)`\\n\\t- adjacency list `adj` + distance vector `d` + queue for BFS `q`",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        // if the shortest path from 1 to n is of length L\\n        // find whether there is a path of length L+1\\n        // there is always a path of length L+2\\n        \\n        vector<vector<int>> adj(n);\\n        for (auto& e : edges) {\\n            int u = e[0]-1, v = e[1]-1;\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // bfs from goal\\n        vector<int> d(n, 1e9);\\n        d[n-1] = 0;\\n        queue<int> q;\\n        q.push(n-1);\\n        while (!q.empty()) {\\n            int cur = q.front(); q.pop();\\n            for (auto nei : adj[cur]) {\\n                if (d[nei] == 1e9) {\\n                    d[nei] = d[cur] + 1;\\n                    q.push(nei);\\n                }\\n            }\\n        }\\n        \\n        // check the existence of a path with length = d[0]+1\\n        int len = d[0] + 2;\\n        q.push(0);\\n        bool done = false;\\n        while (!q.empty()) {\\n            int cur = q.front(); q.pop();\\n            for (auto nei : adj[cur]) {\\n                if (d[nei] == d[cur]) {\\n                    len--;\\n                    done = true;\\n                    break;\\n                } else if (d[nei] == d[cur] - 1) {\\n                    q.push(nei);\\n                }\\n            }\\n            if (done) break;\\n        }\\n        \\n        // calculate the time needed\\n        // light : green in [0, c),  [2c, 3c), ... \\n        //          red  in [c, 2c), [3c, 4c), ...\\n        int currTime = 0;\\n        //cout << len << \\'\\\\n\\';\\n        for (int i = 0; i < len; i++) {\\n\\t\\t\\tif ((currTime / change) % 2 == 1)  // have to wait until the signal turns into green\\n                currTime = ((currTime / change) + 1) * change;    \\n            currTime += time;\\n        }\\n        return currTime;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1525194,
                "title": "modified-dijkstra-s-algorithm-priorityqueue-java",
                "content": "Observation:\\nWe are tasked to find 2nd minimum time to reach city N.\\n\\nWe can use Dijkstra\\'s algorithm to find minimum time taken to the city N. However to find 2nd min time we need a little modification on\\nvanilla Dijkstra. i.e. visit cities again beyond their optimal times once found\\n\\nThe Question now becomes ?\\nHow many times do we need to visit  any city at maximum ? - answer is 2 times :) . We don\\'t need to care about 3rd min times and beyond for any of the cities. thats it! \\n\\nAlgorithm:\\n1. Use Dijkstra to find min elapsed time by visting cities in order and store this time\\n2. when visting the city again, check if this elapsed time is 2nd min time to previously recorded value\\n\\t 2.1 if yes. continue evaluation\\n\\t 2.2 if no, ignore this state and continue to next state in the heap\\n3 Also check if we already have 2 min times for the city already, if yes. make sure never evaluate for this city again. \\n\\tThis will optimize your solution\\n\\n\\nHere is code for your perusal\\n```\\nclass Solution {\\n    \\n    Map<Integer , List<Integer>> map; // adjacency map\\n    \\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        map = new HashMap<>();\\n\\t\\t\\n\\t\\t// prepare adjacency map\\n        for(int[] e : edges){\\n            map.putIfAbsent(e[0] , new ArrayList<>());\\n            map.putIfAbsent(e[1] , new ArrayList<>());\\n            \\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n\\t\\n\\t//create a min heap on int[] object [city , elapsedTime] , order by min elapsedTime first\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a , b) -> {\\n        return a[1] - b[1];\\n    });\\n    \\n\\t// initialize heap with city 1 and 0 time elapsed\\n    pq.add(new int[]{1 , 0});\\n    \\n\\t// use cache to record min time per city\\n    Map<Integer , Integer> cache = new HashMap<>();\\n\\t\\n\\t// modification: we want to visit each city maximum two times with different times,\\n\\t// this will help in early termination when we visit the city again (3rd time or more)\\n    HashSet<Integer> exhausted = new HashSet<>();\\n    \\n    while(!pq.isEmpty()){\\n        \\n        int[] top = pq.poll();\\n        int city = top[0];\\n        int timeElapsed = top[1];\\n        \\n\\t\\t// Base Termination : we have found our 2nd min time for city n\\n        if(city == n && timeElapsed > cache.getOrDefault(city , Integer.MAX_VALUE)){\\n            return timeElapsed;\\n        }\\n        \\n\\t\\t\\n        if(!cache.containsKey(city)){\\n\\t\\t\\t// we vistied this city for first time, so elapsed time is min for this city\\n            cache.put(city , timeElapsed);\\n        }else if(cache.get(city) == timeElapsed || exhausted.contains(city)){\\n\\t\\t\\t// early termination, if we are trying to visit the city 3rd time or more ,\\n\\t\\t\\t//or the elapsed time will not help in finding the solution\\n            continue;\\n        }else{\\n\\t\\t\\t// this means we are visiting the city with 2nd optimal time , we dont need to visit the city ever again\\n            exhausted.add(city);\\n        }\\n        \\n\\t\\t/**\\n\\t\\t\\twe visit the city on elapsedTime, we need to check if on basis of change time, whether this time falls in  cycle (green or red)\\n\\t\\t\\tif odd cycle (red), we must wait for this cycle to end\\n\\t\\t**/\\n        int factor = timeElapsed / change;\\n        if(factor%2 == 1){\\n            timeElapsed = (factor+1) * change;\\n        }\\n      \\n\\t\\t//straight forward : visit the neighbours\\n        for(int kid : map.getOrDefault(city , new ArrayList<>())){\\n            \\n            int visitTime = timeElapsed + time;\\n            if(!exhausted.contains(kid)){\\n                pq.add(new int[]{kid , visitTime});\\n            }\\n        }\\n    }\\n    \\n    return -1;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer , List<Integer>> map; // adjacency map\\n    \\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        map = new HashMap<>();\\n\\t\\t\\n\\t\\t// prepare adjacency map\\n        for(int[] e : edges){\\n            map.putIfAbsent(e[0] , new ArrayList<>());\\n            map.putIfAbsent(e[1] , new ArrayList<>());\\n            \\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n\\t\\n\\t//create a min heap on int[] object [city , elapsedTime] , order by min elapsedTime first\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a , b) -> {\\n        return a[1] - b[1];\\n    });\\n    \\n\\t// initialize heap with city 1 and 0 time elapsed\\n    pq.add(new int[]{1 , 0});\\n    \\n\\t// use cache to record min time per city\\n    Map<Integer , Integer> cache = new HashMap<>();\\n\\t\\n\\t// modification: we want to visit each city maximum two times with different times,\\n\\t// this will help in early termination when we visit the city again (3rd time or more)\\n    HashSet<Integer> exhausted = new HashSet<>();\\n    \\n    while(!pq.isEmpty()){\\n        \\n        int[] top = pq.poll();\\n        int city = top[0];\\n        int timeElapsed = top[1];\\n        \\n\\t\\t// Base Termination : we have found our 2nd min time for city n\\n        if(city == n && timeElapsed > cache.getOrDefault(city , Integer.MAX_VALUE)){\\n            return timeElapsed;\\n        }\\n        \\n\\t\\t\\n        if(!cache.containsKey(city)){\\n\\t\\t\\t// we vistied this city for first time, so elapsed time is min for this city\\n            cache.put(city , timeElapsed);\\n        }else if(cache.get(city) == timeElapsed || exhausted.contains(city)){\\n\\t\\t\\t// early termination, if we are trying to visit the city 3rd time or more ,\\n\\t\\t\\t//or the elapsed time will not help in finding the solution\\n            continue;\\n        }else{\\n\\t\\t\\t// this means we are visiting the city with 2nd optimal time , we dont need to visit the city ever again\\n            exhausted.add(city);\\n        }\\n        \\n\\t\\t/**\\n\\t\\t\\twe visit the city on elapsedTime, we need to check if on basis of change time, whether this time falls in  cycle (green or red)\\n\\t\\t\\tif odd cycle (red), we must wait for this cycle to end\\n\\t\\t**/\\n        int factor = timeElapsed / change;\\n        if(factor%2 == 1){\\n            timeElapsed = (factor+1) * change;\\n        }\\n      \\n\\t\\t//straight forward : visit the neighbours\\n        for(int kid : map.getOrDefault(city , new ArrayList<>())){\\n            \\n            int visitTime = timeElapsed + time;\\n            if(!exhausted.contains(kid)){\\n                pq.add(new int[]{kid , visitTime});\\n            }\\n        }\\n    }\\n    \\n    return -1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525251,
                "title": "java-easy-bfs-with-detailed-comments-t-o-n-m-s-o-n-m",
                "content": "```\\n/*\\n    If it was needed to find the minimum time to reach vertex n from vertex 1, \\n\\twe would have done a simple BFS and stored the minimum time to reach each vertex. \\n\\tHere we need to find the second minimum time, so basically, we need to reach each vertex \\n\\tat most twice and store the minimum and second minimum time to reach every vertex. \\n\\tNote: second minimum time should be strictly greater than the minimum time. \\n\\tWe can apply the same BFS with modification that we reach every vertex for the second time \\n\\tand the second arriving time should be strictly greater than the first arriving time.\\n*/\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {    \\n        \\n        // creating the graph\\n        List<Integer> list[]=new ArrayList[n+1];\\n        for(int i=0;i<=n;i++)\\n            list[i]=new ArrayList<>();\\n        for(int []e:edges){\\n            list[e[0]].add(e[1]);\\n            list[e[1]].add(e[0]);\\n        }\\n        \\n        // for each vertex we store two arriving times.\\n        long [][]dist=new long [n+1][2];\\n        for(long []I:dist)\\n            Arrays.fill(I,Long.MAX_VALUE);\\n                \\n        Queue<Duo> q=new LinkedList<>();\\n        \\n        // we start from vertex 1.\\n        q.offer(new Duo(1,0l));\\n        dist[1][0]=0; \\n        \\n        Duo p;\\n        long val,wait;\\n        while(q.size()>0){           \\n            p=q.poll();\\n            \\n            /*\\n                Calculation for the arriving time to the adjacent vertex:\\n                We have reached the current vertex p.idx at time p.val.\\n                Now, we need to find out the current state of the traffic light.\\n                Number of changes in traffic light=(p.val/change).\\n                If number of changes is odd, starting from green, \\n\\t\\t\\t\\tthe current state will be red and vice versa.\\n                If the current state is red, we need to wait for it to become green(another change) to leave the vertex.\\n                waiting time=change-(p.val%change);\\n                If the current state is green, we can instantly leave the vertex, \\n                waiting time=0.\\n            */\\n            wait=0l;\\n            if((p.val/change)%2==1){\\n                wait=change-(p.val%change);\\n            }                \\n            val=p.val+wait+(long)time; // time to reach adjacent node from the current node.\\n            \\n            for(int i:list[p.idx]){\\n                \\n                if(dist[i][0]>val){\\n                    // arriving for the first time to this node.\\n                    dist[i][0]=val;\\n                    q.offer(new Duo(i,val));\\n                }\\n                \\n                else if(val>dist[i][0]&&dist[i][1]>val){\\n                    // arriving for the second time to this node with second arriving time strictly greater than the first arriving time.\\n                    \\n                    if(i==n) // returning the answer\\n                        return (int)val;\\n                    \\n                    dist[i][1]=val;\\n                    q.offer(new Duo(i,val));\\n                }  \\n                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\nclass Duo{\\n    int idx;\\n    long val;\\n    Duo(int i, long v){\\n        idx=i;\\n        val=v;\\n    }\\n}\\n```\\nN= number of vertices and M=number of edges.\\nT=O(N+M), S=O(N+M)\\nPlease upvote if you find this helpful.",
                "solutionTags": [],
                "code": "```\\n/*\\n    If it was needed to find the minimum time to reach vertex n from vertex 1, \\n\\twe would have done a simple BFS and stored the minimum time to reach each vertex. \\n\\tHere we need to find the second minimum time, so basically, we need to reach each vertex \\n\\tat most twice and store the minimum and second minimum time to reach every vertex. \\n\\tNote: second minimum time should be strictly greater than the minimum time. \\n\\tWe can apply the same BFS with modification that we reach every vertex for the second time \\n\\tand the second arriving time should be strictly greater than the first arriving time.\\n*/\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {    \\n        \\n        // creating the graph\\n        List<Integer> list[]=new ArrayList[n+1];\\n        for(int i=0;i<=n;i++)\\n            list[i]=new ArrayList<>();\\n        for(int []e:edges){\\n            list[e[0]].add(e[1]);\\n            list[e[1]].add(e[0]);\\n        }\\n        \\n        // for each vertex we store two arriving times.\\n        long [][]dist=new long [n+1][2];\\n        for(long []I:dist)\\n            Arrays.fill(I,Long.MAX_VALUE);\\n                \\n        Queue<Duo> q=new LinkedList<>();\\n        \\n        // we start from vertex 1.\\n        q.offer(new Duo(1,0l));\\n        dist[1][0]=0; \\n        \\n        Duo p;\\n        long val,wait;\\n        while(q.size()>0){           \\n            p=q.poll();\\n            \\n            /*\\n                Calculation for the arriving time to the adjacent vertex:\\n                We have reached the current vertex p.idx at time p.val.\\n                Now, we need to find out the current state of the traffic light.\\n                Number of changes in traffic light=(p.val/change).\\n                If number of changes is odd, starting from green, \\n\\t\\t\\t\\tthe current state will be red and vice versa.\\n                If the current state is red, we need to wait for it to become green(another change) to leave the vertex.\\n                waiting time=change-(p.val%change);\\n                If the current state is green, we can instantly leave the vertex, \\n                waiting time=0.\\n            */\\n            wait=0l;\\n            if((p.val/change)%2==1){\\n                wait=change-(p.val%change);\\n            }                \\n            val=p.val+wait+(long)time; // time to reach adjacent node from the current node.\\n            \\n            for(int i:list[p.idx]){\\n                \\n                if(dist[i][0]>val){\\n                    // arriving for the first time to this node.\\n                    dist[i][0]=val;\\n                    q.offer(new Duo(i,val));\\n                }\\n                \\n                else if(val>dist[i][0]&&dist[i][1]>val){\\n                    // arriving for the second time to this node with second arriving time strictly greater than the first arriving time.\\n                    \\n                    if(i==n) // returning the answer\\n                        return (int)val;\\n                    \\n                    dist[i][1]=val;\\n                    q.offer(new Duo(i,val));\\n                }  \\n                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\nclass Duo{\\n    int idx;\\n    long val;\\n    Duo(int i, long v){\\n        idx=i;\\n        val=v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525148,
                "title": "c-solution-bfs",
                "content": "\\nall nodes have the same time to arrive to the next node. each node can be revisited at most 1 time then we can calculate the second minimum value, note that we need to skip the same arriving time.\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int> > adj;\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        adj.resize(n + 1);\\n        int firstArrivedTime = INT_MAX;\\n        for(auto &e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        queue< vector<int> > q;\\n        q.push({1, 0});\\n        vector<int> visTime(n + 1, INT_MAX);\\n        vector<int> visCount(n + 1, 0);\\n        while(q.size()) {\\n            auto p = q.front(); q.pop();\\n            int node = p[0], t = p[1];\\n            for(int next : adj[node]) {\\n                int t2 = t;\\n                bool isRed = (t2 / change) % 2;\\n                if(isRed) t2 += change - t2 % change;\\n                t2 += time;\\n                if(next == n && firstArrivedTime == INT_MAX) firstArrivedTime = t2;\\n                if(next == n && t2 > firstArrivedTime) return t2;\\n                if(visTime[next] != t2 && visCount[next] <= 1) { //at most revisit one time.\\n                    visTime[next] = t2;\\n                    visCount[next]++;\\n                    q.push({next, t2});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int> > adj;\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        adj.resize(n + 1);\\n        int firstArrivedTime = INT_MAX;\\n        for(auto &e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        queue< vector<int> > q;\\n        q.push({1, 0});\\n        vector<int> visTime(n + 1, INT_MAX);\\n        vector<int> visCount(n + 1, 0);\\n        while(q.size()) {\\n            auto p = q.front(); q.pop();\\n            int node = p[0], t = p[1];\\n            for(int next : adj[node]) {\\n                int t2 = t;\\n                bool isRed = (t2 / change) % 2;\\n                if(isRed) t2 += change - t2 % change;\\n                t2 += time;\\n                if(next == n && firstArrivedTime == INT_MAX) firstArrivedTime = t2;\\n                if(next == n && t2 > firstArrivedTime) return t2;\\n                if(visTime[next] != t2 && visCount[next] <= 1) { //at most revisit one time.\\n                    visTime[next] = t2;\\n                    visCount[next]++;\\n                    q.push({next, t2});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533199,
                "title": "c-python-weights-are-the-same-for-each-exploration-bfs-is-enough",
                "content": "Essential BFS is a special case of Dijkstra when the graph has equal positive weights or at each step, the weights are equal (the case of this problem).\\nI compared with 3 solutions:\\n1. BFS with maximum visit time constrains\\n2. Dijkstra with two distances (shortest and second shortest)\\n3. BFS with two distances (shortest and second shortest)\\n\\nAll those 3 solutions can AC. The difference between 2 and 3 is only changing the priority queue to queue. The solution 3 is fastest.\\nHere is my BFS code\\n- C++\\n```cpp\\nusing PII = pair<int, int>;\\nclass Solution {\\n    public:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> dis(n+1, INT_MAX), dis2(n+1, INT_MAX);\\n        vector<vector<int>> graph(n + 1);\\n        for (auto &e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        dis[1] = 0;\\n        queue<PII> Q; Q.emplace(0, 1);\\n        while (Q.size()) {\\n            auto [cost, node] = Q.front();Q.pop();\\n            for (auto nei: graph[node]) {\\n                int new_cost = cost + time;\\n                // red signal\\n                if ((cost / change) % 2 == 1){\\n                    new_cost += change - (cost % change);\\n                }\\n\\t\\t\\t\\t// update two distances.\\n                if (dis[nei] > new_cost){\\n                    dis2[nei] = dis[nei]; dis[nei] = new_cost;\\n                    Q.emplace(new_cost, nei);\\n                } else if (new_cost > dis[nei] && new_cost < dis2[nei] ) {\\n                    dis2[nei] = new_cost;\\n                    Q.emplace(new_cost, nei);\\n                }\\n            }\\n        }\\n        return dis2[n];\\n    }\\n};\\n```\\nRuntime\\n```\\nRuntime: 544 ms, faster than 92.53% of C++ online submissions forSecond Minimum Time to Reach Destination.\\nMemory Usage: 182 MB, less than 73.56% of C++ online submissions for Second Minimum Time to Reach Destination.\\n```\\n\\n\\n- python\\n```python\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        dis, dis2 = [float(\"inf\")]*(n+1), [float(\"inf\")]*(n+1)\\n        graph = collections.defaultdict(list)\\n        for u, v in  edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dis[1] = 0\\n        Q = deque()\\n        Q.append((0, 1))\\n        while Q:\\n            cost, node = Q.popleft()\\n            for nei in graph[node]:\\n                new_cost = cost + time;\\n                # red signal\\n                if (cost // change) % 2 == 1:\\n                    new_cost += change - (cost % change)\\n                # update two distances.\\n                if dis[nei] > new_cost:\\n                    dis2[nei], dis[nei]  = dis[nei], new_cost;\\n                    Q.append((new_cost, nei))\\n                elif new_cost > dis[nei] and new_cost < dis2[nei]:\\n                    dis2[nei] = new_cost\\n                    Q.append((new_cost, nei))\\n        return dis2[n] \\n```\\nDetail see my medium article[ Solve the Second Shortest Path problem](https://jimmy-shen.medium.com/solve-the-second-shortest-path-problem-7c1082e85049)",
                "solutionTags": [],
                "code": "```cpp\\nusing PII = pair<int, int>;\\nclass Solution {\\n    public:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> dis(n+1, INT_MAX), dis2(n+1, INT_MAX);\\n        vector<vector<int>> graph(n + 1);\\n        for (auto &e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        dis[1] = 0;\\n        queue<PII> Q; Q.emplace(0, 1);\\n        while (Q.size()) {\\n            auto [cost, node] = Q.front();Q.pop();\\n            for (auto nei: graph[node]) {\\n                int new_cost = cost + time;\\n                // red signal\\n                if ((cost / change) % 2 == 1){\\n                    new_cost += change - (cost % change);\\n                }\\n\\t\\t\\t\\t// update two distances.\\n                if (dis[nei] > new_cost){\\n                    dis2[nei] = dis[nei]; dis[nei] = new_cost;\\n                    Q.emplace(new_cost, nei);\\n                } else if (new_cost > dis[nei] && new_cost < dis2[nei] ) {\\n                    dis2[nei] = new_cost;\\n                    Q.emplace(new_cost, nei);\\n                }\\n            }\\n        }\\n        return dis2[n];\\n    }\\n};\\n```\n```\\nRuntime: 544 ms, faster than 92.53% of C++ online submissions forSecond Minimum Time to Reach Destination.\\nMemory Usage: 182 MB, less than 73.56% of C++ online submissions for Second Minimum Time to Reach Destination.\\n```\n```python\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        dis, dis2 = [float(\"inf\")]*(n+1), [float(\"inf\")]*(n+1)\\n        graph = collections.defaultdict(list)\\n        for u, v in  edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dis[1] = 0\\n        Q = deque()\\n        Q.append((0, 1))\\n        while Q:\\n            cost, node = Q.popleft()\\n            for nei in graph[node]:\\n                new_cost = cost + time;\\n                # red signal\\n                if (cost // change) % 2 == 1:\\n                    new_cost += change - (cost % change)\\n                # update two distances.\\n                if dis[nei] > new_cost:\\n                    dis2[nei], dis[nei]  = dis[nei], new_cost;\\n                    Q.append((new_cost, nei))\\n                elif new_cost > dis[nei] and new_cost < dis2[nei]:\\n                    dis2[nei] = new_cost\\n                    Q.append((new_cost, nei))\\n        return dis2[n] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177415,
                "title": "cpp-dijkstra-with-heap-easy-explanation",
                "content": "Firstly , coming to the intuition :-\\nAs we need second min. distance of the last node, I decided to keep a visited vector (**but not of integers, but of a priority queue of integers**). \\nThe priority queue will be of max length 2. \\n* At first, I have taken edges[i] and made an adjacency list (**undirected graph**).\\n* Now, populate the distance array with 1e8 (**resembling to INT_MAX**).\\n* Now, for the source, I have popped out INT_MAX and put 0 in the dis[0].     // The distance vector\\n* Now, performing Dijkstra operation using priority_queue of (**dist,node**).\\n* When we are popping out of the queue, **understand** that we are now going to travel to other city. So, if we have a red signal, we have to wait for the rest amount of time. \\n```\\n\\t\\t\\tint dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            int k=dist/change;\\n            if (k%2==1) {\\n                dist=dist+(change-dist%change);\\n            }\\n```\\nHere, suppose time=3, change=5 and we got dist=7 from the priority_queue.\\nSo, as signal changes from green to red in alternating intervals, it is red from 5-10, 15-20 and so on. So, if dist/change is odd, we have to wait until signal becomes green again. That adjustment is done. \\n* While visiting the adj. nodes, we add \"time\" to dist. \\n* Now, if the adjacency list of adj.node contains 1e8 at the top, means the node is not visited more than once (or never). So, we can add new dist to the node. \\n* If the heap size is less than 2 and the top element is not equal to dist, we can also add. (**The second minimum value is defined as the smallest value strictly larger than the minimum value.**) \\n* But when the size of heap is 2, we have to check if the top of heap is greater than dist. If it is so, we have got **less** second min time. So, update it in the heap.\\n* Finally, return top of the dis[n-1].\\n\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<priority_queue<int>> dis (n);\\n        for (int i=0;i<n;i++){\\n            dis[i].push(1e8);\\n        }\\n        //maxheap and node \\n        // we will keep two dist of each node.\\n        \\n        vector<int> adj[n];\\n        for (auto it:edges){\\n            adj[it[0]-1].push_back(it[1]-1);\\n            adj[it[1]-1].push_back(it[0]-1);\\n        }\\n        \\n        priority_queue <pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        pq.push({0,0}); // time=0, node=0\\n        dis[0].pop();\\n        dis[0].push(0); \\n        \\n        while (pq.empty()==false){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            int k=dist/change;\\n            if (k%2==1) {\\n                dist=dist+(change-dist%change);\\n            }\\n            \\n            for (auto adjnode:adj[node]){\\n                int adjdis=dist+time;\\n                \\n                if (dis[adjnode].top()==1e8){\\n                    dis[adjnode].pop();\\n                    dis[adjnode].push(adjdis);\\n                    pq.push({adjdis,adjnode});\\n                }\\n                else if (dis[adjnode].size()<2 && dis[adjnode].top()!= adjdis){\\n                    dis[adjnode].push(adjdis);\\n                    pq.push({adjdis,adjnode});\\n                }\\n                else {\\n                    if (dis[adjnode].top() > adjdis){\\n                        dis[adjnode].pop();\\n                        dis[adjnode].push(adjdis);\\n                        pq.push({adjdis,adjnode});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dis[n-1].top();\\n    }\\n};\\n```\\n\\n***Hope, this solution helped ! Do upvote if you like this  :)***\\n\\t\\t\\t",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\t\\t\\tint dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            int k=dist/change;\\n            if (k%2==1) {\\n                dist=dist+(change-dist%change);\\n            }\\n```\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<priority_queue<int>> dis (n);\\n        for (int i=0;i<n;i++){\\n            dis[i].push(1e8);\\n        }\\n        //maxheap and node \\n        // we will keep two dist of each node.\\n        \\n        vector<int> adj[n];\\n        for (auto it:edges){\\n            adj[it[0]-1].push_back(it[1]-1);\\n            adj[it[1]-1].push_back(it[0]-1);\\n        }\\n        \\n        priority_queue <pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        pq.push({0,0}); // time=0, node=0\\n        dis[0].pop();\\n        dis[0].push(0); \\n        \\n        while (pq.empty()==false){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            int k=dist/change;\\n            if (k%2==1) {\\n                dist=dist+(change-dist%change);\\n            }\\n            \\n            for (auto adjnode:adj[node]){\\n                int adjdis=dist+time;\\n                \\n                if (dis[adjnode].top()==1e8){\\n                    dis[adjnode].pop();\\n                    dis[adjnode].push(adjdis);\\n                    pq.push({adjdis,adjnode});\\n                }\\n                else if (dis[adjnode].size()<2 && dis[adjnode].top()!= adjdis){\\n                    dis[adjnode].push(adjdis);\\n                    pq.push({adjdis,adjnode});\\n                }\\n                else {\\n                    if (dis[adjnode].top() > adjdis){\\n                        dis[adjnode].pop();\\n                        dis[adjnode].push(adjdis);\\n                        pq.push({adjdis,adjnode});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dis[n-1].top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526616,
                "title": "java-relaxed-dijkstra-best-first-search-complete-analysis-and-proof",
                "content": "This question tests your mastery over best first search (simpliest version being Dijkstra and general version being A* search). I will for now assume the readers to be familiar with base [Dijkstra algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).  Essentially, you are allowed to terminate the algoritm immediately once you reached our destination, this is because 1) correctness of the best first greedy strategy (proof is non trivial, found in most CS class notebooks) 2) the later searches only lead to even worse results (easy to show due to the edge weights > 0, aka consistency requirement).\\n\\nThe primary goal now, is to modify this standard best first search + priority queue template, to consider distances beyond minimum, or relax the search until some condition. Ok, what is such condition? Let\\'s consider how do we reach to the destination: \\n\\n- You must reach the destiantion from some of its neighbors. And your min distance is found from such neighbor\\'s min paths (Dijkstra logic). Let\\'s call this path: x* -> dest, where x* stands for the optimal path to x.\\n- You second min distance must also come from those neighbors (this is trivial, no other way to reach to dest), AND \\n\\t1. This second min distance can be reached from the neighbors\\' **min** paths **OR**\\n\\t2. This second distance is reached by x*\\'s **second** optimal path x**, thus x** -> dest.\\n\\t3. Therefore, we must consider both 1 and 2 cases. How? Record min distance and 2nd min distance to all nodes during best first search.\\n\\n- You must not think you are mostly done after figuring out the above logic. This question is dirty in its own way: the aforementioned so called time, MUST be the **departure** time, and you must make sure, the first min and 2nd min departure time is **different**, otherwise they leads to the same results, and it is not what we designed for.\\n- YET, you must also record the **arrival** times only for the destination node. Cause once you are there, you don\\'t need to leave again. \\n- How annoying is that? **Update**: we don\\'t really need to separately record arrival and departure time, cause two different arrival times will definitely leads to two different departure times, that is, it is impossible to have two different valid arrival times both located in [k*change, (k+1)*change] interval, where k is odd number. To be honest with you guys, I think it is non trivial to get to this conclusion in limited time, either during interview or in context. I resort to separating the two types of time during the context.\\n\\t- To understand this, consider you just move between nodes and record number of steps from source to any given node. We define f(k) as arrival time to any node after taking k steps. Then it is easy to show that a given step number k will always take the same amount of time f(k), and as k is monotonically increasing, so is f(k). It is definitely provable with induction. Therefore, when we have two different f(k1) and f(k2) at some node, implying k1!=k2, we must have their next time cost of f(k1+1) and f(k2+1) be different cause k1+1!=k2+1. \\n\\nComplexity analysis: intuitively, you will only need to expand each node **twice**, that is all it needs for us to derive the bound. Thus, it is just 2X Dijkstra: O(E log E). By the way, for Java, you need to insert dummy nodes, containing outdated min distances, cause you cannot modify priority value for your heap. Thus, you are not dealing with text book complexity of O(V + E) log V, but log E. \\n\\nAnyways, code is here: \\n```\\nclass Solution {\\n    // Modified Dijkstra\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for (int[] e : edges) {\\n            graph.get(e[0] - 1).add(e[1] - 1);\\n            graph.get(e[1] - 1).add(e[0] - 1);\\n        }\\n        \\n        List<TreeSet<Integer>> minDists = new ArrayList<>();\\n        // Treeset helps de-dupe the 1st and 2nd min distances.\\n        for (int i = 0; i < n; i++) minDists.add(new TreeSet<>());\\n        \\n        // Prep Dijkstra.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(10,\\n                                  (o1, o2) -> (o1[1] - o2[1]));\\n        pq.offer(new int[]{0, 0});\\n        \\n        // Main logic.\\n        PriorityQueue<Integer> res = new PriorityQueue<>();\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int curNode = cur[0];\\n            int curDist = cur[1];\\n            \\n            // Dummy node.\\n            if (minDists.get(curNode).size() == 2 &&\\n                curDist > minDists.get(curNode).last()) {\\n                continue;\\n            }\\n            \\n            // Best First Expansion.\\n            for (int next : graph.get(curNode)) {\\n                // cur -> n;\\n                int nextDist = time + curDist;\\n                \\n                // Must record arrival time for dest.\\n                if (next == n - 1) {\\n                    res.add(nextDist);\\n                }\\n                \\n                // Traffic light correction. Must wait until green.\\n                if ((nextDist / change) % 2 == 1) {\\n                    nextDist = ((nextDist / change) + 1) * change;\\n                }\\n                \\n                // Dup distance found.\\n                if (minDists.get(next).contains(nextDist)) {\\n                    continue;\\n                }\\n                \\n                // Push departure time to queue and update min records.\\n                if (minDists.get(next).size() < 2) {\\n                    minDists.get(next).add(nextDist);\\n                    pq.offer(new int[]{next, nextDist});\\n                } else if (minDists.get(next).last() > nextDist){\\n                    minDists.get(next).remove(minDists.get(next).last());\\n                    minDists.get(next).add(nextDist);\\n                    pq.offer(new int[]{next, nextDist});\\n                }\\n            }\\n        }\\n        \\n        int top = res.peek();\\n        while (res.peek() == top) {\\n            res.poll();\\n        }\\n        \\n        return res.poll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Modified Dijkstra\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for (int[] e : edges) {\\n            graph.get(e[0] - 1).add(e[1] - 1);\\n            graph.get(e[1] - 1).add(e[0] - 1);\\n        }\\n        \\n        List<TreeSet<Integer>> minDists = new ArrayList<>();\\n        // Treeset helps de-dupe the 1st and 2nd min distances.\\n        for (int i = 0; i < n; i++) minDists.add(new TreeSet<>());\\n        \\n        // Prep Dijkstra.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(10,\\n                                  (o1, o2) -> (o1[1] - o2[1]));\\n        pq.offer(new int[]{0, 0});\\n        \\n        // Main logic.\\n        PriorityQueue<Integer> res = new PriorityQueue<>();\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int curNode = cur[0];\\n            int curDist = cur[1];\\n            \\n            // Dummy node.\\n            if (minDists.get(curNode).size() == 2 &&\\n                curDist > minDists.get(curNode).last()) {\\n                continue;\\n            }\\n            \\n            // Best First Expansion.\\n            for (int next : graph.get(curNode)) {\\n                // cur -> n;\\n                int nextDist = time + curDist;\\n                \\n                // Must record arrival time for dest.\\n                if (next == n - 1) {\\n                    res.add(nextDist);\\n                }\\n                \\n                // Traffic light correction. Must wait until green.\\n                if ((nextDist / change) % 2 == 1) {\\n                    nextDist = ((nextDist / change) + 1) * change;\\n                }\\n                \\n                // Dup distance found.\\n                if (minDists.get(next).contains(nextDist)) {\\n                    continue;\\n                }\\n                \\n                // Push departure time to queue and update min records.\\n                if (minDists.get(next).size() < 2) {\\n                    minDists.get(next).add(nextDist);\\n                    pq.offer(new int[]{next, nextDist});\\n                } else if (minDists.get(next).last() > nextDist){\\n                    minDists.get(next).remove(minDists.get(next).last());\\n                    minDists.get(next).add(nextDist);\\n                    pq.offer(new int[]{next, nextDist});\\n                }\\n            }\\n        }\\n        \\n        int top = res.peek();\\n        while (res.peek() == top) {\\n            res.poll();\\n        }\\n        \\n        return res.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525493,
                "title": "java-dijkstra-s-with-2-relaxation-o-elogv-thinking-process",
                "content": "It\\'s easy to leverage Dijkstra to find the shortest path.\\nWhen it comes to the second shortest, Firstly I used the brute force method, which doesn\\'t mark visited for the visited node, so there will eventually reach n for the second time with second minimum time. It\\'s correct for sure.\\n\\nHowever unfortunately, it gets TLE, since every middle node will be expanded multiple times before we reaching the n node the second time with second minimum time.\\n\\nInspired by the others\\' idea. Yes we can use the relaxing to dedupe.\\n\\nWhy it works?\\nWe know the distance for each node is non-decreasing in each visiting, so when we first reach the node, we get the minimum, then the second time, there are two cases:\\n1. it\\'s the same dis as the first time\\n2. it\\'s larger than the first time \\n\\nFor case1, we can just skip, since we expand before, expanding again will not contribute more.\\nFor case2, we will expand and generate again, since it can possible lead to a solution. \\n\\nDo we need to relax more than 2 times? \\nNot necessary, let\\'s prove by contradiction, let\\'s assume we found a path between 1 to n which is the result. if there is middle node in between has been relaxed by more than 2 times, assume 3 times, why don\\'t we replace it with the distance when it\\'s relaxed the second time? So 2 relaxations is enough.\\n\\nb/c each node has been expanded at most twice. The time complexity is O(ElogV).\\n\\n```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, List<Integer>> g = new HashMap();\\n        for(int[] e : edges) {\\n            int u  = e[0], v = e[1];\\n            g.computeIfAbsent(u, x -> new ArrayList()).add(v);\\n            g.computeIfAbsent(v, x -> new ArrayList()).add(u);\\n        }\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        q.offer(new int[]{1, 0});\\n        int[] uniqueVisit = new int[n+1]; // uniqueVisit limit to 2 <==> relax twice at most\\n        int[] dis = new int[n+1];\\n        Arrays.fill(dis, -1);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int[] cur = q.poll();\\n            int node = cur[0], t = cur[1];  // arriving time\\n            if(dis[node] == t || uniqueVisit[node] >= 2) continue; // skip if it\\'s same value or has been relaxed twice already\\n            uniqueVisit[node]++; \\n            dis[node] = t;\\n            if(node == n && uniqueVisit[node] == 2) return dis[node];\\n            // generate leaving time (waiting the green light)\\n            if((t / change) % 2 != 0) t = (t/change + 1) * change;\\n            for(int nei : g.getOrDefault(node, new ArrayList<>())) {\\n                q.offer(new int[]{nei, t + time});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, List<Integer>> g = new HashMap();\\n        for(int[] e : edges) {\\n            int u  = e[0], v = e[1];\\n            g.computeIfAbsent(u, x -> new ArrayList()).add(v);\\n            g.computeIfAbsent(v, x -> new ArrayList()).add(u);\\n        }\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        q.offer(new int[]{1, 0});\\n        int[] uniqueVisit = new int[n+1]; // uniqueVisit limit to 2 <==> relax twice at most\\n        int[] dis = new int[n+1];\\n        Arrays.fill(dis, -1);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int[] cur = q.poll();\\n            int node = cur[0], t = cur[1];  // arriving time\\n            if(dis[node] == t || uniqueVisit[node] >= 2) continue; // skip if it\\'s same value or has been relaxed twice already\\n            uniqueVisit[node]++; \\n            dis[node] = t;\\n            if(node == n && uniqueVisit[node] == 2) return dis[node];\\n            // generate leaving time (waiting the green light)\\n            if((t / change) % 2 != 0) t = (t/change + 1) * change;\\n            for(int nei : g.getOrDefault(node, new ArrayList<>())) {\\n                q.offer(new int[]{nei, t + time});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525227,
                "title": "python3-dijkstra-bfs",
                "content": "\\n```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].append(v-1)\\n            graph[v-1].append(u-1)\\n        pq = [(0, 0)]\\n        seen = [[] for _ in range(n)]\\n        least = None\\n        while pq: \\n            t, u = heappop(pq)\\n            if u == n-1: \\n                if least is None: least = t\\n                elif least < t: return t \\n            if (t//change) & 1: t = (t//change+1)*change # waiting for green\\n            t += time\\n            for v in graph[u]: \\n                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: \\n                    seen[v].append(t)\\n                    heappush(pq, (t, v))\\n```\\n\\nEdited on 2021-10-20\\nDijkstra\\'s algo is an overkill for this problem as the weights on edges are identical per the one `time` variable. BFS is enough for this problem. \\n```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].append(v-1)\\n            graph[v-1].append(u-1)\\n        \\n        least = None\\n        queue = deque([(0, 0)])\\n        seen = [[] for _ in range(n)]\\n        while queue: \\n            t, u = queue.popleft()\\n            if u == n-1: \\n                if least is None: least = t\\n                elif least < t: return t \\n            if (t//change) & 1: t = (t//change+1)*change # waiting for green\\n            t += time\\n            for v in graph[u]: \\n                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: \\n                    seen[v].append(t)\\n                    queue.append((t, v))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].append(v-1)\\n            graph[v-1].append(u-1)\\n        pq = [(0, 0)]\\n        seen = [[] for _ in range(n)]\\n        least = None\\n        while pq: \\n            t, u = heappop(pq)\\n            if u == n-1: \\n                if least is None: least = t\\n                elif least < t: return t \\n            if (t//change) & 1: t = (t//change+1)*change # waiting for green\\n            t += time\\n            for v in graph[u]: \\n                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: \\n                    seen[v].append(t)\\n                    heappush(pq, (t, v))\\n```\n```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].append(v-1)\\n            graph[v-1].append(u-1)\\n        \\n        least = None\\n        queue = deque([(0, 0)])\\n        seen = [[] for _ in range(n)]\\n        while queue: \\n            t, u = queue.popleft()\\n            if u == n-1: \\n                if least is None: least = t\\n                elif least < t: return t \\n            if (t//change) & 1: t = (t//change+1)*change # waiting for green\\n            t += time\\n            for v in graph[u]: \\n                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: \\n                    seen[v].append(t)\\n                    queue.append((t, v))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526244,
                "title": "java-bfs-no-dijkstra-2-best-distances-for-each-node",
                "content": "Run BFS and keep track of **two best distances for each node**.\\nIt\\'s BFS not Dijkstra \\n- there is no distance relaxation in each step - it is guaranteed to be longer than the previous step, as all edges are same length (essentially unweighted) - hence no need for a Dijkstra\\'s priority queue\\n- the distance arrays serve the purpose of \"visited\" arrays (visited once and twice, at what - distinct - elapsed time).\\n\\nThere is a small additional twist to elapsed time, as we need to wait for green light, but that\\'s it.\\n```\\nstatic int INF= Integer.MAX_VALUE;\\npublic int secondMinimum(int n, int[][] edges, int time, int change) {\\n\\tArrayList<Integer>[] al= new ArrayList[n+1]; // 0 is not used\\n\\tfor(int i=1; i<=n; i++) al[i]= new ArrayList<>();\\n\\tfor(int[] e:edges){\\n\\t\\tint u= e[0], v= e[1];\\n\\t\\tal[u].add(v);\\n\\t\\tal[v].add(u);\\n\\t}\\n\\t// best and 2nd best distance\\n\\tint[] d= new int[n+1], d2= new int[n+1];\\n\\tArrays.fill(d, INF);\\n\\tArrays.fill(d2, INF);\\n\\t//dfs        \\n\\tQueue<Integer> q= new LinkedList<>();\\n\\tq.add(1);\\n\\tint timeElapsed= 0;\\n\\twhile(!q.isEmpty() && d2[n]==INF){\\n\\t\\ttimeElapsed+= time;\\n\\t\\tint k= q.size();\\n\\t\\twhile(k-->0){\\n\\t\\t\\tint u= q.remove();\\n\\t\\t\\tfor(int v:al[u]){\\n\\t\\t\\t\\tif(d[v]==INF){\\n\\t\\t\\t\\t\\td[v]= timeElapsed;\\n\\t\\t\\t\\t\\tq.add(v);\\n\\t\\t\\t\\t}else if(d2[v]==INF && timeElapsed!=d[v]){\\n\\t\\t\\t\\t\\td2[v]= timeElapsed;\\n\\t\\t\\t\\t\\tq.add(v);\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// wait for green light            \\n\\t\\tif(timeElapsed/change%2==1)\\n\\t\\t\\ttimeElapsed+= change - timeElapsed%change;\\n\\t}\\n\\treturn d2[n];   \\n}",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "Run BFS and keep track of **two best distances for each node**.\\nIt\\'s BFS not Dijkstra \\n- there is no distance relaxation in each step - it is guaranteed to be longer than the previous step, as all edges are same length (essentially unweighted) - hence no need for a Dijkstra\\'s priority queue\\n- the distance arrays serve the purpose of \"visited\" arrays (visited once and twice, at what - distinct - elapsed time).\\n\\nThere is a small additional twist to elapsed time, as we need to wait for green light, but that\\'s it.\\n```\\nstatic int INF= Integer.MAX_VALUE;\\npublic int secondMinimum(int n, int[][] edges, int time, int change) {\\n\\tArrayList<Integer>[] al= new ArrayList[n+1]; // 0 is not used\\n\\tfor(int i=1; i<=n; i++) al[i]= new ArrayList<>();\\n\\tfor(int[] e:edges){\\n\\t\\tint u= e[0], v= e[1];\\n\\t\\tal[u].add(v);\\n\\t\\tal[v].add(u);\\n\\t}\\n\\t// best and 2nd best distance\\n\\tint[] d= new int[n+1], d2= new int[n+1];\\n\\tArrays.fill(d, INF);\\n\\tArrays.fill(d2, INF);\\n\\t//dfs        \\n\\tQueue<Integer> q= new LinkedList<>();\\n\\tq.add(1);\\n\\tint timeElapsed= 0;\\n\\twhile(!q.isEmpty() && d2[n]==INF){\\n\\t\\ttimeElapsed+= time;\\n\\t\\tint k= q.size();\\n\\t\\twhile(k-->0){\\n\\t\\t\\tint u= q.remove();\\n\\t\\t\\tfor(int v:al[u]){\\n\\t\\t\\t\\tif(d[v]==INF){\\n\\t\\t\\t\\t\\td[v]= timeElapsed;\\n\\t\\t\\t\\t\\tq.add(v);\\n\\t\\t\\t\\t}else if(d2[v]==INF && timeElapsed!=d[v]){\\n\\t\\t\\t\\t\\td2[v]= timeElapsed;\\n\\t\\t\\t\\t\\tq.add(v);\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// wait for green light            \\n\\t\\tif(timeElapsed/change%2==1)\\n\\t\\t\\ttimeElapsed+= change - timeElapsed%change;\\n\\t}\\n\\treturn d2[n];   \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1525254,
                "title": "c-2045-second-minimum-time-to-reach-destination",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> graph(n); \\n        for (auto& edge : edges) {\\n            graph[edge[0]-1].push_back(edge[1]-1); \\n            graph[edge[1]-1].push_back(edge[0]-1); \\n        }\\n        \\n        int least = -1; \\n        queue<pair<int, int>> pq;\\n        pq.emplace(0, 0); \\n        vector<vector<int>> seen(n); \\n        \\n        while (pq.size()) {\\n            auto [t, u] = pq.front(); pq.pop(); \\n            if (u == n-1) {\\n                if (least == -1) least = t; \\n                else if (least < t) return t; \\n            }\\n            if (t/change & 1) t = (t/change+1)*change; \\n            t += time; \\n            for (auto& v : graph[u]) \\n                if (seen[v].empty() or (seen[v].size() == 1 and seen[v][0] != t)) {\\n                    seen[v].push_back(t); \\n                    pq.emplace(t, v); \\n                }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> graph(n); \\n        for (auto& edge : edges) {\\n            graph[edge[0]-1].push_back(edge[1]-1); \\n            graph[edge[1]-1].push_back(edge[0]-1); \\n        }\\n        \\n        int least = -1; \\n        queue<pair<int, int>> pq;\\n        pq.emplace(0, 0); \\n        vector<vector<int>> seen(n); \\n        \\n        while (pq.size()) {\\n            auto [t, u] = pq.front(); pq.pop(); \\n            if (u == n-1) {\\n                if (least == -1) least = t; \\n                else if (least < t) return t; \\n            }\\n            if (t/change & 1) t = (t/change+1)*change; \\n            t += time; \\n            for (auto& v : graph[u]) \\n                if (seen[v].empty() or (seen[v].size() == 1 and seen[v][0] != t)) {\\n                    seen[v].push_back(t); \\n                    pq.emplace(t, v); \\n                }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525427,
                "title": "java-clean",
                "content": "All the rest is pretty similar to 787 https://leetcode.com/problems/cheapest-flights-within-k-stops/\\none line to reduce time which is different and important is below, if we reach same node same time we ignore.\\n```\\nif (!visited.get(city).add(cost)) continue;\\n```\\n\\n1. every node we only need to visit twice, in other words save 2 shortest time\\n2. if same node second time we reach same as first time, we ignore.\\n\\n\\n```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        Map<Integer, Set<Integer>> visited = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int from = edge[0], to = edge[1];\\n            graph.computeIfAbsent(from, x -> new ArrayList<>()).add(to);\\n            graph.computeIfAbsent(to, x -> new ArrayList<>()).add(from);\\n        }\\n        pq.add(new int[] {1, 0}); //{city, cost}\\n        int min = Integer.MAX_VALUE;\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int city = cur[0], cost = cur[1];\\n            if (city == n) {\\n                if (min == Integer.MAX_VALUE || cost == min) min = cost;\\n                else return cost;\\n            } \\n            cost = findNextAvailabel(cost, change);\\n            visited.putIfAbsent(city, new HashSet<>());\\n            if (!visited.get(city).add(cost)) continue;\\n            if (visited.get(city).size() > 2) continue; //aleady have 2 case, we don\\'t need third one\\n            for (int nei : graph.getOrDefault(city, new ArrayList<>()))\\n                pq.offer(new int[]{nei, cost + time});\\n        }\\n        return -1;\\n    }\\n    private int findNextAvailabel(int cur, int change) {\\n        int count = 0;\\n        int traffic = 0;\\n        while (traffic <= cur) {\\n            traffic += change;\\n            count++;\\n        }\\n        if (count % 2 == 0) return traffic;\\n        else return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif (!visited.get(city).add(cost)) continue;\\n```\n```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        Map<Integer, Set<Integer>> visited = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int from = edge[0], to = edge[1];\\n            graph.computeIfAbsent(from, x -> new ArrayList<>()).add(to);\\n            graph.computeIfAbsent(to, x -> new ArrayList<>()).add(from);\\n        }\\n        pq.add(new int[] {1, 0}); //{city, cost}\\n        int min = Integer.MAX_VALUE;\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int city = cur[0], cost = cur[1];\\n            if (city == n) {\\n                if (min == Integer.MAX_VALUE || cost == min) min = cost;\\n                else return cost;\\n            } \\n            cost = findNextAvailabel(cost, change);\\n            visited.putIfAbsent(city, new HashSet<>());\\n            if (!visited.get(city).add(cost)) continue;\\n            if (visited.get(city).size() > 2) continue; //aleady have 2 case, we don\\'t need third one\\n            for (int nei : graph.getOrDefault(city, new ArrayList<>()))\\n                pq.offer(new int[]{nei, cost + time});\\n        }\\n        return -1;\\n    }\\n    private int findNextAvailabel(int cur, int change) {\\n        int count = 0;\\n        int traffic = 0;\\n        while (traffic <= cur) {\\n            traffic += change;\\n            count++;\\n        }\\n        if (count % 2 == 0) return traffic;\\n        else return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526249,
                "title": "dijkstra-variation-newbie-implementation-stepwise-explanation-c",
                "content": "Idea : to store first two distinct smallest path to a node. then corresponding to that path length, find the time required\\n\\n```\\nclass Solution {\\npublic:\\n    #define pii pair<int,pair<int,int>>\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> graph[n+1];\\n        int m =edges.size();\\n        // creating graph\\n        for(int i=0;i<m;i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // for maintaining two distinct shortest time\\n        vector<pair<int,int>> d(n+1);\\n        for(int i=2;i<n+1;i++){\\n            d[i] = {1000000,1000000};\\n        }\\n        // Dijkstra\\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\\n        //pii to store smallest, second smallest , node value\\n        pq.push({0,{0,1}});\\n        d[1] = {0,0};\\n        while(pq.size()>0){\\n            int v1 = pq.top().first;\\n            int v2 = pq.top().second.first;\\n            int node = pq.top().second.second;\\n            pq.pop();\\n            for(auto child : graph[node]){\\n                int cv1 = d[child].first;\\n                int cv2 = d[child].second; \\n                vector<int> tev;\\n                tev.push_back(v1+1);\\n                tev.push_back(v2+1);\\n                tev.push_back(cv1);\\n                tev.push_back(cv2);\\n                sort(tev.begin(),tev.end());\\n                int nv1 = tev[0];\\n                int nv2 = INT_MAX;\\n                if(tev[0]!=tev[1]){nv2 = tev[1];}\\n                else if(tev[2]!=tev[1]){nv2 = tev[2];}\\n                else if(tev[3]!=tev[2]){nv2 = tev[3];}\\n                //check if 2 smallest values get updated or not\\n                // as if they are already smallest , NO change will occur\\n                if(nv1!=cv1||nv2!=cv2){\\n                    d[child] = {nv1,nv2};\\n                    pq.push({nv1,{nv2,child}});   \\n                }\\n            }\\n        }\\n        int x = d[n].second;\\n        int ctr = time;\\n        \\n        for(int i=1;i<x;i++){\\n            if(i==x){break;}\\n            int val =(ctr+change)/change; // to check whether to stop or not, \\n                                            // multiple of 2, then wait till then\\n            if(val%2==0){ctr = val*change;}\\n            ctr += time;            // perform next move\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pii pair<int,pair<int,int>>\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> graph[n+1];\\n        int m =edges.size();\\n        // creating graph\\n        for(int i=0;i<m;i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // for maintaining two distinct shortest time\\n        vector<pair<int,int>> d(n+1);\\n        for(int i=2;i<n+1;i++){\\n            d[i] = {1000000,1000000};\\n        }\\n        // Dijkstra\\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\\n        //pii to store smallest, second smallest , node value\\n        pq.push({0,{0,1}});\\n        d[1] = {0,0};\\n        while(pq.size()>0){\\n            int v1 = pq.top().first;\\n            int v2 = pq.top().second.first;\\n            int node = pq.top().second.second;\\n            pq.pop();\\n            for(auto child : graph[node]){\\n                int cv1 = d[child].first;\\n                int cv2 = d[child].second; \\n                vector<int> tev;\\n                tev.push_back(v1+1);\\n                tev.push_back(v2+1);\\n                tev.push_back(cv1);\\n                tev.push_back(cv2);\\n                sort(tev.begin(),tev.end());\\n                int nv1 = tev[0];\\n                int nv2 = INT_MAX;\\n                if(tev[0]!=tev[1]){nv2 = tev[1];}\\n                else if(tev[2]!=tev[1]){nv2 = tev[2];}\\n                else if(tev[3]!=tev[2]){nv2 = tev[3];}\\n                //check if 2 smallest values get updated or not\\n                // as if they are already smallest , NO change will occur\\n                if(nv1!=cv1||nv2!=cv2){\\n                    d[child] = {nv1,nv2};\\n                    pq.push({nv1,{nv2,child}});   \\n                }\\n            }\\n        }\\n        int x = d[n].second;\\n        int ctr = time;\\n        \\n        for(int i=1;i<x;i++){\\n            if(i==x){break;}\\n            int val =(ctr+change)/change; // to check whether to stop or not, \\n                                            // multiple of 2, then wait till then\\n            if(val%2==0){ctr = val*change;}\\n            ctr += time;            // perform next move\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835252,
                "title": "python-heap-modified-dijkstra-very-easy-to-understand-explained",
                "content": "We just use Dijkstra\\'s algorithm by using heap.\\nTo get the second minimum, when the minimum distances updated for each vertex, we just need two minimum distances(the first and the second) to the vertex, for the other distances we just skip.\\nIf you like, plz upVote.\\n```\\nfrom heapq import heappop,heappush\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        G = defaultdict(list)\\n        dist = defaultdict(set)\\n        for v, w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        h = [(0, 1)]\\n        res = []\\n        while h:\\n            d, v = heappop(h)\\n            if len(dist[v]) > 1:\\n                continue\\n            if d in dist[v]:\\n                continue\\n            dist[v].add(d)\\n            q, r = divmod(d, change)\\n            if q%2 == 1:\\n                d += change - r\\n            for w in G[v]:\\n                if w == n:\\n                    if  res:\\n                        if d+time not in res:\\n                            return d+time\\n                    else:\\n                        res.append(d+time)\\n                if len(dist[w]) < 2:\\n                    heappush(h, (d+time,w))\\n```                 \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappop,heappush\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        G = defaultdict(list)\\n        dist = defaultdict(set)\\n        for v, w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        h = [(0, 1)]\\n        res = []\\n        while h:\\n            d, v = heappop(h)\\n            if len(dist[v]) > 1:\\n                continue\\n            if d in dist[v]:\\n                continue\\n            dist[v].add(d)\\n            q, r = divmod(d, change)\\n            if q%2 == 1:\\n                d += change - r\\n            for w in G[v]:\\n                if w == n:\\n                    if  res:\\n                        if d+time not in res:\\n                            return d+time\\n                    else:\\n                        res.append(d+time)\\n                if len(dist[w]) < 2:\\n                    heappush(h, (d+time,w))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595581,
                "title": "python-bfs-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def secondMinimum(self, n, edges, time, change):\\n        hd = collections.defaultdict(list)\\n        for i, j in edges:\\n            hd[i].append(j)\\n            hd[j].append(i)\\n        # First, find the smallest and the second smallest steps from city 1 to every city via BFS.\\n        first = [0] * (n + 1)\\n        second = [0] * (n + 1)\\n        dq = collections.deque([(1, 0)])\\n        while len(dq) > 0:\\n            node, steps = dq.popleft()\\n            for next in hd[node]:\\n                if second[next] == 0:\\n                    if first[next] == 0:\\n                        first[next] = steps + 1\\n                        dq.append((next, steps + 1))\\n                    elif steps + 1 > first[next]:\\n                        second[next] = steps + 1\\n                        dq.append((next, steps + 1))\\n        # Simulate the change process of the signal light and calculate the time required for the second smallest steps \\n        # from the start point to the end point.\\n        cost = 0\\n        for i in range(second[n]):\\n            if cost % (2 * change) >= change:\\n                cost = (cost // (2 * change) + 1) * (2 * change)\\n            cost += time\\n        return cost\\n```\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondMinimum(self, n, edges, time, change):\\n        hd = collections.defaultdict(list)\\n        for i, j in edges:\\n            hd[i].append(j)\\n            hd[j].append(i)\\n        # First, find the smallest and the second smallest steps from city 1 to every city via BFS.\\n        first = [0] * (n + 1)\\n        second = [0] * (n + 1)\\n        dq = collections.deque([(1, 0)])\\n        while len(dq) > 0:\\n            node, steps = dq.popleft()\\n            for next in hd[node]:\\n                if second[next] == 0:\\n                    if first[next] == 0:\\n                        first[next] = steps + 1\\n                        dq.append((next, steps + 1))\\n                    elif steps + 1 > first[next]:\\n                        second[next] = steps + 1\\n                        dq.append((next, steps + 1))\\n        # Simulate the change process of the signal light and calculate the time required for the second smallest steps \\n        # from the start point to the end point.\\n        cost = 0\\n        for i in range(second[n]):\\n            if cost % (2 * change) >= change:\\n                cost = (cost // (2 * change) + 1) * (2 * change)\\n            cost += time\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617396,
                "title": "c-modified-dijkstra-normal-dsa-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        // Initialising the adjacency list\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]-1].push_back(e[1]-1);\\n            adj[e[1]-1].push_back(e[0]-1);\\n        }\\n\\n        /* Forming distance as a pair in which first store smaller distance \\n           and second store larger distance and both distinct*/\\n        vector<pair<int, int>> dist(n, {1e9, 1e9});\\n        priority_queue<pair<int,int>> pq;\\n\\n        dist[0] = {0, 1e9};\\n        pq.push({0, 0});\\n        \\n        // ^Normal Dijkstra Initialisation\\n\\n        // BFS Loop ----> Starts\\n        while(!pq.empty()){\\n            auto [currTime, node] = pq.top();\\n            pq.pop();\\n            \\n            // As it is max heap we have to store neg. dist for low to high sorting\\n            currTime *= -1;\\n            if(currTime > dist[node].second)   continue;\\n\\n            // If signal is green, reaching another node will take extra \\'time\\' time\\n            int newTime = currTime + time;\\n\\n            // If signal is red, we have stay to this node till signal is green again\\n            int temp = currTime/change;\\n            if(temp%2 == 1)     // Condition of Red Signal\\n                newTime = (temp+1)*change + time;\\n\\n            // Traversing adjacent nodes\\n            for(auto adjNode : adj[node]){\\n\\n                // If this newTime is smaller than the smallest distance of adjacent node\\n                if(dist[adjNode].first > newTime){\\n                    // Assign first value to second and assign first new smaller value\\n                    dist[adjNode].second = dist[adjNode].first;\\n                    dist[adjNode].first = newTime;\\n\\n                    pq.push({-1*dist[adjNode].first, adjNode});\\n                }\\n                // Very important condition to ensure distince values in \\'dist\\' vector for particular node.\\n                else if(dist[adjNode].first == newTime)\\n                    continue;\\n                else if(dist[adjNode].second > newTime){\\n                    dist[adjNode].second = newTime;\\n                    pq.push({-1*dist[adjNode].second, adjNode});\\n                }\\n            }\\n        }\\n        // BFS Loop ----> Ends\\n\\n        return dist[n-1].second;\\n    }\\n};\\n```\\n\\n---\\n\\n```\\nThank you\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        // Initialising the adjacency list\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]-1].push_back(e[1]-1);\\n            adj[e[1]-1].push_back(e[0]-1);\\n        }\\n\\n        /* Forming distance as a pair in which first store smaller distance \\n           and second store larger distance and both distinct*/\\n        vector<pair<int, int>> dist(n, {1e9, 1e9});\\n        priority_queue<pair<int,int>> pq;\\n\\n        dist[0] = {0, 1e9};\\n        pq.push({0, 0});\\n        \\n        // ^Normal Dijkstra Initialisation\\n\\n        // BFS Loop ----> Starts\\n        while(!pq.empty()){\\n            auto [currTime, node] = pq.top();\\n            pq.pop();\\n            \\n            // As it is max heap we have to store neg. dist for low to high sorting\\n            currTime *= -1;\\n            if(currTime > dist[node].second)   continue;\\n\\n            // If signal is green, reaching another node will take extra \\'time\\' time\\n            int newTime = currTime + time;\\n\\n            // If signal is red, we have stay to this node till signal is green again\\n            int temp = currTime/change;\\n            if(temp%2 == 1)     // Condition of Red Signal\\n                newTime = (temp+1)*change + time;\\n\\n            // Traversing adjacent nodes\\n            for(auto adjNode : adj[node]){\\n\\n                // If this newTime is smaller than the smallest distance of adjacent node\\n                if(dist[adjNode].first > newTime){\\n                    // Assign first value to second and assign first new smaller value\\n                    dist[adjNode].second = dist[adjNode].first;\\n                    dist[adjNode].first = newTime;\\n\\n                    pq.push({-1*dist[adjNode].first, adjNode});\\n                }\\n                // Very important condition to ensure distince values in \\'dist\\' vector for particular node.\\n                else if(dist[adjNode].first == newTime)\\n                    continue;\\n                else if(dist[adjNode].second > newTime){\\n                    dist[adjNode].second = newTime;\\n                    pq.push({-1*dist[adjNode].second, adjNode});\\n                }\\n            }\\n        }\\n        // BFS Loop ----> Ends\\n\\n        return dist[n-1].second;\\n    }\\n};\\n```\n```\\nThank you\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217189,
                "title": "c-bfs-set-a-counter-for-maximum-number-of-times-a-node-can-be-visited-detailed-explanation",
                "content": "Please upvote\\n**Since for this problem, the weights are equal, we can think about solve the problem by using the BFS**. \\nBasic steps:\\n\\n* Using the BFS to traverse the graph. The difference to the standard BFS is one node can be visited multiple times. (You can think we should ignore the seen information)\\n* If we first reach the target node, we should not stop (in the standard SSSP problem, we stop here). What we should do is keep on exploring the graph until the second shortest path is found for the target node.\\n* If we don\\u2019t set a constraints of the visit times for each node, we will get TLE, as the graph size can be increased exponentially. We can apply an unproved trick by set an upper bound for the maximum visiting time for e each node, then the problem can be solved.\\n\\n```\\n#define pii pair<int,int>\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> adj[n+1];\\n        vector<int> seen(n+1);\\n        const int MAX_VISIT=70;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        queue<pii>q;\\n        q.push({0,1});//cost,node\\n        seen[1]++;\\n        int mn=INT_MAX;\\n        while(q.size()){\\n            auto it=q.front();q.pop();\\n            int cost=it.ff;//actually cost menas time here as we are dealing with time\\n            int node=it.ss;\\n            for(auto nbr:adj[node]){\\n                if(seen[nbr]>70){\\n                    continue;//if you dont check here,it will givr TLE\\n                }\\n                int newcost=cost+time;// time to reach this nbr\\n                if(((cost/change)&1)){\\n                   newcost=newcost+(change-(cost%change));   \\n                }\\n\\t\\t\\t\\t//add any extra time\\n                if(nbr==n){\\n                    //you have reached the destination\\n                    //now check\\n                    if(newcost!=INT_MAX and newcost>mn){\\n                        //that means you are visiting this destination for the second time\\n                        return newcost;\\n                    }\\n                    else if(newcost<mn){\\n                        mn=newcost;\\n                    }\\n                }\\n                q.push({newcost,nbr});\\n                seen[nbr]++;//you are seeing the nbr anyway and you are pushing in the neighbour and newcost anyway\\n                //so seen[nbr]++ is a must ofc\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int,int>\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> adj[n+1];\\n        vector<int> seen(n+1);\\n        const int MAX_VISIT=70;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        queue<pii>q;\\n        q.push({0,1});//cost,node\\n        seen[1]++;\\n        int mn=INT_MAX;\\n        while(q.size()){\\n            auto it=q.front();q.pop();\\n            int cost=it.ff;//actually cost menas time here as we are dealing with time\\n            int node=it.ss;\\n            for(auto nbr:adj[node]){\\n                if(seen[nbr]>70){\\n                    continue;//if you dont check here,it will givr TLE\\n                }\\n                int newcost=cost+time;// time to reach this nbr\\n                if(((cost/change)&1)){\\n                   newcost=newcost+(change-(cost%change));   \\n                }\\n\\t\\t\\t\\t//add any extra time\\n                if(nbr==n){\\n                    //you have reached the destination\\n                    //now check\\n                    if(newcost!=INT_MAX and newcost>mn){\\n                        //that means you are visiting this destination for the second time\\n                        return newcost;\\n                    }\\n                    else if(newcost<mn){\\n                        mn=newcost;\\n                    }\\n                }\\n                q.push({newcost,nbr});\\n                seen[nbr]++;//you are seeing the nbr anyway and you are pushing in the neighbour and newcost anyway\\n                //so seen[nbr]++ is a must ofc\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095206,
                "title": "c-dijkstra-s-algorithm-easy-to-understand",
                "content": "```\\ntypedef pair<int, int> pii;\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>> graph;\\n    priority_queue<pii, vector<pii>, greater<pii>> min_heap;\\n    \\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        graph.resize(n+1);\\n        \\n        for(auto it: edges) {\\n            int u = it[0];\\n            int v = it[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        // for visiting each node at most 2 times\\n        vector<int> freq(n+1, 0);\\n        vector<int> weight(n+1, INT_MAX);\\n        \\n        \\n        // {time, node}\\n        min_heap.push({0, 1});\\n        weight[1] = 0;\\n        \\n        int cnt = 0;\\n        while(!min_heap.empty()) {\\n            auto curr = min_heap.top();\\n            min_heap.pop();\\n            int w = curr.first;\\n            int u = curr.second;\\n            \\n            freq[u] += 1;\\n            \\n            int elapse = w / change;\\n            if(elapse%2) \\n                w += (change * (elapse+1)) - w;\\n        \\n            for(int v: graph[u]) {\\n                if(w + time != weight[v] && freq[v] <= 2) {\\n                    weight[v] = w + time;\\n                    if(v == n) {\\n                        cnt += 1;\\n                        if(cnt == 2)\\n                            return weight[v];\\n                    }  \\n                    min_heap.push({weight[v], v});\\n                }\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<int, int> pii;\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>> graph;\\n    priority_queue<pii, vector<pii>, greater<pii>> min_heap;\\n    \\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        graph.resize(n+1);\\n        \\n        for(auto it: edges) {\\n            int u = it[0];\\n            int v = it[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        // for visiting each node at most 2 times\\n        vector<int> freq(n+1, 0);\\n        vector<int> weight(n+1, INT_MAX);\\n        \\n        \\n        // {time, node}\\n        min_heap.push({0, 1});\\n        weight[1] = 0;\\n        \\n        int cnt = 0;\\n        while(!min_heap.empty()) {\\n            auto curr = min_heap.top();\\n            min_heap.pop();\\n            int w = curr.first;\\n            int u = curr.second;\\n            \\n            freq[u] += 1;\\n            \\n            int elapse = w / change;\\n            if(elapse%2) \\n                w += (change * (elapse+1)) - w;\\n        \\n            for(int v: graph[u]) {\\n                if(w + time != weight[v] && freq[v] <= 2) {\\n                    weight[v] = w + time;\\n                    if(v == n) {\\n                        cnt += 1;\\n                        if(cnt == 2)\\n                            return weight[v];\\n                    }  \\n                    min_heap.push({weight[v], v});\\n                }\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046280,
                "title": "python-one-pass-with-thought-process-when-being-asked-during-interviews",
                "content": "### Dijkstra Shortest Path\\nLet\\'s simplify the problem first. What if we are asked to find out the path with the minimum time?\\nIt\\'s to use just dijkstra shortest path by taking `time` as the weight of edge. The only stuff we have to consider is to calculate the status of traffic light, which is quite simple.\\nWe check whether the quotient of `curr_time` and `change` is even or not. We are in green if it\\'s even, otherwise we need to wait until it changes to green which increases the quotient by 1. Because we need to cover edge case, which is we just got light change from green to red. For instance, current time is `2` and `change` is `2`. \\n\\n```\\nif green:\\n    next_time = current_time + time\\nelse:\\n\\tnext_time = (current_time // change + 1) * change + time\\n```\\n\\nAlright, that\\'s it. We can get the right answer for minimum time we have to take from `1` to `n`. \\nThen what if we have to calculate the second minimum time? We can just use the same calculation for the second time. If we know the time we take to `n` is second minmum , then all the time we take to other nodes is minimum or second minimum. So we can just add one more variable for each node to track the second minimum time. Only those cases where the current time is smaller than either minimum or second minimum are considered. \\n\\nOne trap is that the second minimum must be different with minimum, so only updat the second minimum when it\\'s different.\\n\\n```python\\ndef secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n\\tgraph = defaultdict(list)\\n    for u, v in edges:\\n\\t\\tgraph[u].append(v)\\n        graph[v].append(u)\\n        \\n\\theap = [(0, 1)]\\n    seen = [[float(\\'inf\\')] * 2 for _ in range(n + 1)]\\n        \\n    while heap: \\n\\t\\tcurr_time, node = heapq.heappop(heap)\\n        if node == n and seen[n][1] != float(\\'inf\\'):\\n\\t\\t\\treturn seen[n][1] \\n\\t\\tfor nei in graph[node]:\\n\\t\\t\\tnext_time = curr_time + time if not (curr_time // change) % 2 else (curr_time // change + 1) * change + time\\n            min_time, second_time = seen[nei]\\n\\t\\t\\tif next_time < min_time or (min_time != next_time < second_time):\\n\\t\\t\\t\\tif next_time < min_time:\\n\\t\\t\\t\\t\\tmin_time = next_time\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsecond_time = next_time\\n\\t\\t\\t\\theapq.heappush(heap, (next_time, nei))\\n                seen[nei] = [min_time, second_time]\\n\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```\\nif green:\\n    next_time = current_time + time\\nelse:\\n\\tnext_time = (current_time // change + 1) * change + time\\n```\n```python\\ndef secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n\\tgraph = defaultdict(list)\\n    for u, v in edges:\\n\\t\\tgraph[u].append(v)\\n        graph[v].append(u)\\n        \\n\\theap = [(0, 1)]\\n    seen = [[float(\\'inf\\')] * 2 for _ in range(n + 1)]\\n        \\n    while heap: \\n\\t\\tcurr_time, node = heapq.heappop(heap)\\n        if node == n and seen[n][1] != float(\\'inf\\'):\\n\\t\\t\\treturn seen[n][1] \\n\\t\\tfor nei in graph[node]:\\n\\t\\t\\tnext_time = curr_time + time if not (curr_time // change) % 2 else (curr_time // change + 1) * change + time\\n            min_time, second_time = seen[nei]\\n\\t\\t\\tif next_time < min_time or (min_time != next_time < second_time):\\n\\t\\t\\t\\tif next_time < min_time:\\n\\t\\t\\t\\t\\tmin_time = next_time\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsecond_time = next_time\\n\\t\\t\\t\\theapq.heappush(heap, (next_time, nei))\\n                seen[nei] = [min_time, second_time]\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1852267,
                "title": "two-problems-in-one",
                "content": "This task is simplified (and made more efficient) when we ralise that there are two separate problems in this task.\\n\\nSince every node and every path has the same time and change time, it means that any path that goes through x nodes will take y time, regardless of the path it takes.  Therefore given a number of nodes, we can work out time independently of the path taken using maths rather than calculating it at every step we take.\\n\\nThis calculation is the first problem, and the second problem is working out the second shortest path.\\n\\nGiven example 2, we can see thar we are allowed to backtrackm and therefore the second shortest path is at most 2 more than the shortest, and at least 1.  So the second part of the problem is working out the shortest path and whether it is possible to do it in +1 step rather than +2.\\n\\n**Steps -> Time calculation**\\nWhen we hit a red light, we have to wait for it to change and we can only start moving at the point it turns green.  This is exactly the same as the starting position, so rather than doing it 1 step at a time we can work out how many steps before we hit a red light and therefore what the cycle time is.\\n\\nIf time <= change then after a certain number of steps we must hot the case where \\nchange <= total time < 2 * change (ie the light is red).  Then we have to wait unti time 2 * change for it to change back again.\\n\\nIn this case \\ncycle = (change - 1) mod time + 1\\n\\nThe harder case is where time < change.  This best illustrated with an example.  If we take time = 12 and change = 5\\n\\nAfter 1 step (12 seconds) the lights have changed red/green and we are 2 seconds into that green.  After 2 steps (24 seconds) we are 4 seconds into a green light and after 3 steps (36 seconds) we are in a red light and must wait for the light to change (40 seconds).  So the cycle is 3 steps and they take 40 seconds.\\n\\nOr a different case, change = 2, time = 8.  After 1 step of 8 seconds the lights have already changed red/green twice and we are 0 seconds into the next green.  We will never hit a red.  For this case we can take a cycle of 1 step with a time of 8 seconds.\\n\\nSo how to calculate this generically?\\n\\nFirst we need to calculate the number of seconds increment into a green light each step takes us.\\n\\nincr = time mod (2 * change)\\n\\nIf incr = 0 then we have the second case above - cycle = 1 and cycleTime = time\\n\\nOtherwise we need to know how many steps we take before a multiple of incr >= change\\n\\ncycle = ((change - 1) / incr + 1\\ncycleTime is the next multiple of change > cycle.  Various ways of doing this, but the code below does this as:\\ncycleTime = cycle * time + change - ((cycle * time) mod change)\\n\\nNow that we have the cycle length and time, given that it takes x steps to be 1 node away from N (see below)\\n\\nTime to get to within 1 node of N = (x /cycle) * cycleTime + (x mod cycle) * time\\n\\nThe time to get to N is obtained by just adding time to that value.\\n\\nNote that we cannot calculate to N directly since cycle time includes waiting at a red light.  If we get to node N just as the light changes we would calculate a time for after the lights change, which would be wrong.\\n\\n**Second most number of steps**\\n\\nSince we have established that we just need to calculate each trip to a node as 1 step, and as noted above we only need to determine if the second shortest path is 1 or 2 steps longer than the shortest path we don\\'t have to do anything much cleverer than just calculating the shortest path.\\n\\nNote that Djkstra\\'s algorithm requires a priority queue because the shortest path to a node might get shorter after you first find a path to it.  In this case all paths cost 1 step, so we can just use a simple fifo queue.\\n\\nPut node 1 in the queue\\nset cost of node 1 as 0, all others to a -ve number\\nUntil node N is top of the queue:\\n\\tcurrent =   top of the queue (remove)\\n\\tFor each connected node to current:\\n\\t\\tif not already visited:\\n\\t\\t\\tset cost to 1 more than current\\n\\t\\t\\tadd to the back of the queue\\n\\t\\t\\t\\nThe cost for node N is the shortest distance.\\n\\nSo how do we modify that to detect a case where there is a second shortest distance of only 1 more than the shortest?\\n\\nFirst we maintain a flag for each node (plus1 found).  \\n\\nOnce set, that value is propagated to all children with a cost of 1 greater than cost for this node.  This can happen in two ways.  When processing the neighbours for this node we find a node that is unvisited.  In which case we set the cost, add it to the queue and set the plus1Found flag.  Alternatively we find a node that is visited, but the cost is 1 more than the current cost (ie.  There are two ways to get to this node at equal cost).  In this case the plus1Found flag is an or of the current value with the value for the target node.\\n\\nBut how does the flag get set in the first case?  When processing a node, we look at all the neighbours.  If any neighbour has been visited with an equal cost to us, then both us and they are possible to reach in plus1 steps.  We therefore set the flag for both nodes.\\n\\nThere is also an edge case where this only happens at node N.  To process that case, once we have reached N as the top of the queue, we look at all the neighbours of N.  If any have the same cost as the cost to N, then we can get to N in cost+1.\\n\\nPut the two parts of the problem together and then we have an efficient solution - although as always you can run it multiple times and get results that vary ridiculously :-) \\n\\n```\\nclass Solution {\\n    /*\\n    We can work out the time as a separate step.  The important thing is the\\n    number of nides that we need to visit.\\n    The second most will always be 1 or 2 nodes longer than the shortest path.\\n    */\\n    fun secondMinimum(n: Int, edges: Array<IntArray>, time: Int, change: Int): Int {\\n        val edgeList = Array(n + 1){mutableListOf<Int>()}\\n        val foundPlus1 = BooleanArray(n + 1){false}\\n        val cost = IntArray(n + 1){-1}\\n        cost[1] = 0\\n        edges.forEach {\\n            edgeList[it[0]].add(it[1])\\n            edgeList[it[1]].add(it[0])\\n        }\\n        val stack = ArrayDeque<Int>()\\n        stack.addLast(1)\\n        while (stack.first() != n) {\\n            val current = stack.removeFirst()\\n            val oldCost = cost[current]\\n            if (!foundPlus1[current]) {\\n                for (neighbour in edgeList[current]) {\\n                    if (cost[neighbour] == oldCost) {\\n                        foundPlus1[current] = true\\n                        foundPlus1[neighbour] = true\\n                    }\\n                }\\n            }\\n            \\n            for (neighbour in edgeList[current]) {\\n                if (cost[neighbour] == -1) {\\n                    cost[neighbour] = oldCost + 1\\n                    stack.addLast(neighbour)\\n                    foundPlus1[neighbour] = foundPlus1[current]    \\n                    \\n                } else {\\n                    if (cost[neighbour] == oldCost + 1) {\\n                        foundPlus1[neighbour] = foundPlus1[neighbour] or foundPlus1[current]\\n                    }\\n                }\\n            }\\n        }\\n        if (!foundPlus1[n]) {\\n            for (neighbour in edgeList[n]) {\\n                if (cost[neighbour] == cost[n]) {\\n                    foundPlus1[n] = true\\n                    break\\n                }\\n            }\\n        }\\n        val steps: Int = if (foundPlus1[n]) cost[n]  else cost[n] + 1\\n        val cycle: Int\\n        val total: Int\\n        if (time <= change) {\\n            cycle = ((change - 1) / time) + 1\\n            total = 2 * change\\n        } else {\\n            val incr = time %  (2 * change)\\n            if (incr == 0) {\\n                cycle = 1\\n                total = time\\n            } else {\\n                cycle = ((change - 1) / incr) + 1\\n                total = cycle * time + change - (cycle * time) % change\\n            }\\n        }\\n        val timeToPrev = (steps / cycle) * total + (steps % cycle) * time \\n        return timeToPrev + time\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    We can work out the time as a separate step.  The important thing is the\\n    number of nides that we need to visit.\\n    The second most will always be 1 or 2 nodes longer than the shortest path.\\n    */\\n    fun secondMinimum(n: Int, edges: Array<IntArray>, time: Int, change: Int): Int {\\n        val edgeList = Array(n + 1){mutableListOf<Int>()}\\n        val foundPlus1 = BooleanArray(n + 1){false}\\n        val cost = IntArray(n + 1){-1}\\n        cost[1] = 0\\n        edges.forEach {\\n            edgeList[it[0]].add(it[1])\\n            edgeList[it[1]].add(it[0])\\n        }\\n        val stack = ArrayDeque<Int>()\\n        stack.addLast(1)\\n        while (stack.first() != n) {\\n            val current = stack.removeFirst()\\n            val oldCost = cost[current]\\n            if (!foundPlus1[current]) {\\n                for (neighbour in edgeList[current]) {\\n                    if (cost[neighbour] == oldCost) {\\n                        foundPlus1[current] = true\\n                        foundPlus1[neighbour] = true\\n                    }\\n                }\\n            }\\n            \\n            for (neighbour in edgeList[current]) {\\n                if (cost[neighbour] == -1) {\\n                    cost[neighbour] = oldCost + 1\\n                    stack.addLast(neighbour)\\n                    foundPlus1[neighbour] = foundPlus1[current]    \\n                    \\n                } else {\\n                    if (cost[neighbour] == oldCost + 1) {\\n                        foundPlus1[neighbour] = foundPlus1[neighbour] or foundPlus1[current]\\n                    }\\n                }\\n            }\\n        }\\n        if (!foundPlus1[n]) {\\n            for (neighbour in edgeList[n]) {\\n                if (cost[neighbour] == cost[n]) {\\n                    foundPlus1[n] = true\\n                    break\\n                }\\n            }\\n        }\\n        val steps: Int = if (foundPlus1[n]) cost[n]  else cost[n] + 1\\n        val cycle: Int\\n        val total: Int\\n        if (time <= change) {\\n            cycle = ((change - 1) / time) + 1\\n            total = 2 * change\\n        } else {\\n            val incr = time %  (2 * change)\\n            if (incr == 0) {\\n                cycle = 1\\n                total = time\\n            } else {\\n                cycle = ((change - 1) / incr) + 1\\n                total = cycle * time + change - (cycle * time) % change\\n            }\\n        }\\n        val timeToPrev = (steps / cycle) * total + (steps % cycle) * time \\n        return timeToPrev + time\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739209,
                "title": "c-bfs-solution",
                "content": "In this case, every node can visit at most 2 times with different arrive times.\\nso we need to check how many times does `node[n]` visited with two different times.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        unordered_map<int, vector<int>> m;\\n        vector<pair<int, int>> v(n + 1, {0, 0});\\n        queue<pair<int, int>> q;\\n        for(auto& e : edges) {\\n            m[e[0]].push_back(e[1]);\\n            m[e[1]].push_back(e[0]);\\n        }\\n\\n        q.push({1,0});\\n        v[1] = {1, 0}; // node 1 visited once, at time 0\\n        while(true) {\\n            auto [node, arrive] = q.front();\\n            q.pop();\\n            bool needWait = (arrive / change) & 1; // arrive / change is odd means we have to wait\\n            int waitTime = needWait ? ((arrive / change) + 1) * change - arrive : 0;\\n            int nextTime = arrive + waitTime + time;\\n            for(auto& nxt : m[node]) {\\n\\t\\t\\t //check how many times next node visited, more than 2 times is not necessary\\n                if(v[nxt].first < 2 and v[nxt].second != nextTime) {\\n                    q.push({nxt, arrive + waitTime + time});\\n                    v[nxt].first += 1;\\n                    v[nxt].second = nextTime;\\n                    if(nxt == n and v[nxt].first == 2) {\\n                        return nextTime;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        unordered_map<int, vector<int>> m;\\n        vector<pair<int, int>> v(n + 1, {0, 0});\\n        queue<pair<int, int>> q;\\n        for(auto& e : edges) {\\n            m[e[0]].push_back(e[1]);\\n            m[e[1]].push_back(e[0]);\\n        }\\n\\n        q.push({1,0});\\n        v[1] = {1, 0}; // node 1 visited once, at time 0\\n        while(true) {\\n            auto [node, arrive] = q.front();\\n            q.pop();\\n            bool needWait = (arrive / change) & 1; // arrive / change is odd means we have to wait\\n            int waitTime = needWait ? ((arrive / change) + 1) * change - arrive : 0;\\n            int nextTime = arrive + waitTime + time;\\n            for(auto& nxt : m[node]) {\\n\\t\\t\\t //check how many times next node visited, more than 2 times is not necessary\\n                if(v[nxt].first < 2 and v[nxt].second != nextTime) {\\n                    q.push({nxt, arrive + waitTime + time});\\n                    v[nxt].first += 1;\\n                    v[nxt].second = nextTime;\\n                    if(nxt == n and v[nxt].first == 2) {\\n                        return nextTime;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640320,
                "title": "c-modified-dijkstra",
                "content": "```\\ntypedef long long int ll;\\ntypedef vector<vector<pair<ll, int>>> VVP;\\ntypedef vector<ll> VL;\\ntypedef vector<VL> VVL;\\n\\nclass Solution {\\npublic:\\n    ll dijkstra(VVP graph, int change){\\n        int n = graph.size();\\n        multiset<pair<ll, int>> pq;\\n        VVL dis(n);\\n        pq.insert({0, 0});\\n        \\n        while(!pq.empty()){\\n            ll node = pq.begin()->second, weight = pq.begin() -> first;\\n            pq.erase(pq.begin());\\n            \\n            if((int)dis[node].size() == 0) dis[node].push_back(weight);\\n            else if((int)dis[node].size() == 1 && dis[node][0] != weight) dis[node].push_back(weight);\\n            else continue;\\n            \\n            bool signal = false;\\n            int time=-1;\\n            if((weight / change) % 2 == 0){\\n                signal = true;\\n            }\\n            else{\\n                time = change*((weight/change) + 1);\\n            }\\n            \\n            for(auto z: graph[node]){\\n                if((int)dis[z.first].size() < 2){\\n                    //check if signal is green on the parent node;\\n                    if(signal){\\n                        pq.insert({weight + z.second, z.first});\\n                    }\\n                    else{\\n                        pq.insert({time + z.second, z.first});\\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1][1];\\n    }\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        VVP graph(n);\\n        for(int i=0;i<(int)edges.size();i++){\\n            graph[edges[i][0]-1].push_back({edges[i][1]-1, time});\\n            graph[edges[i][1]-1].push_back({edges[i][0]-1, time});\\n        }\\n        return dijkstra(graph, change);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ntypedef long long int ll;\\ntypedef vector<vector<pair<ll, int>>> VVP;\\ntypedef vector<ll> VL;\\ntypedef vector<VL> VVL;\\n\\nclass Solution {\\npublic:\\n    ll dijkstra(VVP graph, int change){\\n        int n = graph.size();\\n        multiset<pair<ll, int>> pq;\\n        VVL dis(n);\\n        pq.insert({0, 0});\\n        \\n        while(!pq.empty()){\\n            ll node = pq.begin()->second, weight = pq.begin() -> first;\\n            pq.erase(pq.begin());\\n            \\n            if((int)dis[node].size() == 0) dis[node].push_back(weight);\\n            else if((int)dis[node].size() == 1 && dis[node][0] != weight) dis[node].push_back(weight);\\n            else continue;\\n            \\n            bool signal = false;\\n            int time=-1;\\n            if((weight / change) % 2 == 0){\\n                signal = true;\\n            }\\n            else{\\n                time = change*((weight/change) + 1);\\n            }\\n            \\n            for(auto z: graph[node]){\\n                if((int)dis[z.first].size() < 2){\\n                    //check if signal is green on the parent node;\\n                    if(signal){\\n                        pq.insert({weight + z.second, z.first});\\n                    }\\n                    else{\\n                        pq.insert({time + z.second, z.first});\\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1][1];\\n    }\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        VVP graph(n);\\n        for(int i=0;i<(int)edges.size();i++){\\n            graph[edges[i][0]-1].push_back({edges[i][1]-1, time});\\n            graph[edges[i][1]-1].push_back({edges[i][0]-1, time});\\n        }\\n        return dijkstra(graph, change);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535803,
                "title": "clear-solution-with-bfs-java",
                "content": "\\n```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        // build graph\\n        Map<Integer, Set<Integer>> graph = buildGraph(edges);\\n\\n        // find all path length from node to 1 or n\\n        Map<Integer, Integer> numberToOne = bfs(graph,1,n);\\n        Map<Integer, Integer> numberToN = bfs(graph,n,1);\\n\\n        int min = numberToOne.get(n);\\n\\n        // candidate: min + 1 or min + 2\\n        for(int i = 2 ; i < n ; i++){\\n            if(numberToOne.containsKey(i) && numberToN.containsKey(i) && numberToOne.get(i) + numberToN.get(i) == min + 1) {\\n                return calculateTime(numberToOne.get(n) + 1,time,change);\\n            }\\n        }\\n\\n        return calculateTime(numberToOne.get(n) + 2,time,change);\\n    }\\n\\n    private Map<Integer, Integer> bfs(Map<Integer, Set<Integer>> graph, int start, int end){\\n        Map<Integer, Integer> numberToOne = new HashMap<>();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(start);\\n        HashSet<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            boolean flag = false;\\n            for(int i = 0 ; i < size ; i++){\\n                int curr = queue.poll();\\n                if(curr == end) flag = true;\\n                numberToOne.put(curr,step);\\n                for(int next : graph.getOrDefault(curr, new HashSet<>())){\\n                    if(!visited.contains(next)){\\n                        visited.add(next);\\n                        queue.offer(next);\\n                    }\\n                }\\n            }\\n            step++;\\n            if(flag) break;\\n        }\\n        return numberToOne;\\n    }\\n\\n\\n    private int calculateTime(int len, int time, int change){\\n        int result = 0;\\n        for(int i = 0 ; i < len ; i++){\\n            if((result / change) % 2 == 1) {\\n                result = (result / change + 1) * change;\\n\\n            }\\n            result += time;\\n        }\\n        return result;\\n    }\\n\\n    private Map<Integer, Set<Integer>> buildGraph(int[][] edges){\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n\\n        for(int[] edge : edges){\\n            Set<Integer> neighbors1 = graph.getOrDefault(edge[0],new HashSet<>());\\n            neighbors1.add(edge[1]);\\n            graph.put(edge[0], neighbors1);\\n            Set<Integer> neighbors2 = graph.getOrDefault(edge[1],new HashSet<>());\\n            neighbors2.add(edge[0]);\\n            graph.put(edge[1], neighbors2);\\n        }\\n\\n        return graph;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        // build graph\\n        Map<Integer, Set<Integer>> graph = buildGraph(edges);\\n\\n        // find all path length from node to 1 or n\\n        Map<Integer, Integer> numberToOne = bfs(graph,1,n);\\n        Map<Integer, Integer> numberToN = bfs(graph,n,1);\\n\\n        int min = numberToOne.get(n);\\n\\n        // candidate: min + 1 or min + 2\\n        for(int i = 2 ; i < n ; i++){\\n            if(numberToOne.containsKey(i) && numberToN.containsKey(i) && numberToOne.get(i) + numberToN.get(i) == min + 1) {\\n                return calculateTime(numberToOne.get(n) + 1,time,change);\\n            }\\n        }\\n\\n        return calculateTime(numberToOne.get(n) + 2,time,change);\\n    }\\n\\n    private Map<Integer, Integer> bfs(Map<Integer, Set<Integer>> graph, int start, int end){\\n        Map<Integer, Integer> numberToOne = new HashMap<>();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(start);\\n        HashSet<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            boolean flag = false;\\n            for(int i = 0 ; i < size ; i++){\\n                int curr = queue.poll();\\n                if(curr == end) flag = true;\\n                numberToOne.put(curr,step);\\n                for(int next : graph.getOrDefault(curr, new HashSet<>())){\\n                    if(!visited.contains(next)){\\n                        visited.add(next);\\n                        queue.offer(next);\\n                    }\\n                }\\n            }\\n            step++;\\n            if(flag) break;\\n        }\\n        return numberToOne;\\n    }\\n\\n\\n    private int calculateTime(int len, int time, int change){\\n        int result = 0;\\n        for(int i = 0 ; i < len ; i++){\\n            if((result / change) % 2 == 1) {\\n                result = (result / change + 1) * change;\\n\\n            }\\n            result += time;\\n        }\\n        return result;\\n    }\\n\\n    private Map<Integer, Set<Integer>> buildGraph(int[][] edges){\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n\\n        for(int[] edge : edges){\\n            Set<Integer> neighbors1 = graph.getOrDefault(edge[0],new HashSet<>());\\n            neighbors1.add(edge[1]);\\n            graph.put(edge[0], neighbors1);\\n            Set<Integer> neighbors2 = graph.getOrDefault(edge[1],new HashSet<>());\\n            neighbors2.add(edge[0]);\\n            graph.put(edge[1], neighbors2);\\n        }\\n\\n        return graph;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525540,
                "title": "python-c-bfs-visiting-twice",
                "content": "**Idea**\\nThe rough idea is to use a shortest path algorithm and keep searching until we find the *second* shortest path.\\n\\nWe don\\'t need Dijkstra\\'s algorithm, BFS is fine:\\n* Notice that the cost for step `t` is fixed: we always start moving as soon as the light becomes green and we\\'ll wait for a red light every `k` steps, otherwise the cost is `time`.\\n\\nTo find the second shortest path we\\'ll need to allow visiting nodes more than once.\\n* Notice there\\'s no point in exploring a node at the same step `t` more than once.\\n* The second shortest path couldn\\'t possibly visit a node more than twice so we can prevent the search from exploding too much.\\n\\n**Python**\\n```python\\nfrom collections import deque\\n\\nclass Solution:\\n    def secondMinimum(self, n, edges, time, change):\\n        g = [[] for _ in range(n + 1)]\\n        \\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n            \\n        visited_at = [-1 for _ in range(n + 1)]\\n        visited_cnt = [0 for _ in range(n + 1)]\\n        first = None\\n        q = deque([(0, 1)])\\n        \\n        while q:\\n            t, u = q.popleft()\\n            if visited_at[u] == t or visited_cnt[u] > 1:\\n                continue\\n            visited_cnt[u] += 1\\n            visited_at[u] = t\\n            if u == n:\\n                if first is None:\\n                    first = t\\n                else:\\n                    return t\\n            is_green = (t // change) % 2 == 0\\n            move_at = t if is_green else change * (t // change + 1)\\n            for v in g[u]:\\n                q.append((move_at + time, v))\\n                \\n        return -1\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> g(n + 1);\\n        \\n        for (auto &e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> visited_at(n + 1, -1);\\n        vector<int> visited_cnt(n + 1);\\n        deque<pair<int, int>> q({{0, 1}});\\n        int first = -1;\\n        \\n        while (!q.empty()) {\\n            auto [t, u] = q.front(); q.pop_front();\\n            if (visited_at[u] == t || visited_cnt[u] > 1) {\\n                continue;\\n            }\\n            visited_at[u] = t;\\n            visited_cnt[u]++;\\n            if (u == n) {\\n                if (first == -1) {\\n                    first = t;\\n                } else {\\n                    return t;\\n                }\\n            }\\n            bool is_green = (t / change) % 2 == 0;\\n            int move_at = is_green ? t : change * (t / change + 1);\\n            for (auto v : g[u]) {\\n                q.push_back({move_at + time, v});\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```python\\nfrom collections import deque\\n\\nclass Solution:\\n    def secondMinimum(self, n, edges, time, change):\\n        g = [[] for _ in range(n + 1)]\\n        \\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n            \\n        visited_at = [-1 for _ in range(n + 1)]\\n        visited_cnt = [0 for _ in range(n + 1)]\\n        first = None\\n        q = deque([(0, 1)])\\n        \\n        while q:\\n            t, u = q.popleft()\\n            if visited_at[u] == t or visited_cnt[u] > 1:\\n                continue\\n            visited_cnt[u] += 1\\n            visited_at[u] = t\\n            if u == n:\\n                if first is None:\\n                    first = t\\n                else:\\n                    return t\\n            is_green = (t // change) % 2 == 0\\n            move_at = t if is_green else change * (t // change + 1)\\n            for v in g[u]:\\n                q.append((move_at + time, v))\\n                \\n        return -1\\n```\n```c++\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> g(n + 1);\\n        \\n        for (auto &e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> visited_at(n + 1, -1);\\n        vector<int> visited_cnt(n + 1);\\n        deque<pair<int, int>> q({{0, 1}});\\n        int first = -1;\\n        \\n        while (!q.empty()) {\\n            auto [t, u] = q.front(); q.pop_front();\\n            if (visited_at[u] == t || visited_cnt[u] > 1) {\\n                continue;\\n            }\\n            visited_at[u] = t;\\n            visited_cnt[u]++;\\n            if (u == n) {\\n                if (first == -1) {\\n                    first = t;\\n                } else {\\n                    return t;\\n                }\\n            }\\n            bool is_green = (t / change) % 2 == 0;\\n            int move_at = is_green ? t : change * (t / change + 1);\\n            for (auto v : g[u]) {\\n                q.push_back({move_at + time, v});\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525416,
                "title": "bfs-java",
                "content": "**Why choose BFS?**\\n\\tBecause at every level of BFS we are getting same time, So we dont have to maintain time of each node in any corresponding object.\\n\\n**Code Java**\\n```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        ArrayList<Integer>[] graph = new ArrayList[n+1];\\n        HashMap<Integer,HashSet<Integer>> vis = new HashMap<>();\\n        for(int i = 0 ; i <= n ; i++){\\n            graph[i] = new ArrayList<>();\\n            vis.put(i,new HashSet<>());\\n        }\\n        \\n        for(int[] e : edges){\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        \\n        ArrayDeque<Integer> pq = new ArrayDeque<>();\\n        pq.add(1);\\n        vis.get(1).add(0);\\n        int currentTime = 0;\\n        int changeInterval = change;\\n        boolean isGreen = true;\\n        int min = Integer.MAX_VALUE;\\n        while(pq.size() > 0){\\n            int size = pq.size();\\n            while(size-- > 0){\\n                int rem = pq.remove();    \\n                if(rem == n){\\n                    if(min != Integer.MAX_VALUE)\\n                       return currentTime;\\n                    min = currentTime;\\n                }\\n                for(int nbrs : graph[rem]){\\n                    HashSet<Integer> set = vis.get(nbrs);\\n                    if(set.size() < 2 && !set.contains(currentTime)){\\n                       set.add(currentTime);\\n                       pq.add(nbrs); \\n                    }\\n                }\\n            }\\n            if(isGreen){\\n                currentTime += time;\\n            }else{\\n                currentTime = time + change;\\n            }\\n            \\n            if(currentTime >= change){\\n                while(currentTime >= change){\\n                    change += changeInterval;\\n                    isGreen = !isGreen;\\n                } \\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        ArrayList<Integer>[] graph = new ArrayList[n+1];\\n        HashMap<Integer,HashSet<Integer>> vis = new HashMap<>();\\n        for(int i = 0 ; i <= n ; i++){\\n            graph[i] = new ArrayList<>();\\n            vis.put(i,new HashSet<>());\\n        }\\n        \\n        for(int[] e : edges){\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        \\n        ArrayDeque<Integer> pq = new ArrayDeque<>();\\n        pq.add(1);\\n        vis.get(1).add(0);\\n        int currentTime = 0;\\n        int changeInterval = change;\\n        boolean isGreen = true;\\n        int min = Integer.MAX_VALUE;\\n        while(pq.size() > 0){\\n            int size = pq.size();\\n            while(size-- > 0){\\n                int rem = pq.remove();    \\n                if(rem == n){\\n                    if(min != Integer.MAX_VALUE)\\n                       return currentTime;\\n                    min = currentTime;\\n                }\\n                for(int nbrs : graph[rem]){\\n                    HashSet<Integer> set = vis.get(nbrs);\\n                    if(set.size() < 2 && !set.contains(currentTime)){\\n                       set.add(currentTime);\\n                       pq.add(nbrs); \\n                    }\\n                }\\n            }\\n            if(isGreen){\\n                currentTime += time;\\n            }else{\\n                currentTime = time + change;\\n            }\\n            \\n            if(currentTime >= change){\\n                while(currentTime >= change){\\n                    change += changeInterval;\\n                    isGreen = !isGreen;\\n                } \\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057409,
                "title": "bfs-slight-modification-shortest-path-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nModified Priority Queue (Dijktra Algo)\\n\\n***A node can be visted at max two times \\nIf the node n is visited 2 time , we return the time ,taken to reach node n \\nSince the first time you visit node n , you will get smallest time , for second smallest time  you need to visit two times node n\\nSo , we maintain a freq array , to keep a check on freq of every node \\n\\nDo Upvote If it helps ***\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        // we need to find the second minimum , \\n        /*\\n        so we need to find actually time when the node n will be visited the second time \\n        first time when node n is visited it will give , smallest path \\n        Here wt => time \\n        */\\n        priority_queue<pair<int , int> , vector<pair<int, int>> , greater<pair<int, int>>> pq;\\n        pq.push({0 , 1});\\n        //time 0 : node 1 \\n        vector<vector<int>> adj(n+1);\\n        for(auto it : edges)\\n        {\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<int> wt(n+1 , INT_MAX);\\n        wt[0] = 1;\\n        int cnt = 0;\\n        vector<int>freq(n+1 , 0);\\n        freq[1] = 1;\\n        while(pq.size())\\n        {\\n            int t = pq.top().first;\\n            int node1 = pq.top().second;\\n            pq.pop();\\n            freq[node1]++;\\n            int x = t/change;\\n            if(x%2==1)\\n            {\\n                //waiting time is to be included \\n                int wait = ((x+1) * change) - t;\\n                t=t+wait;\\n            }\\n            //now we have the net time currently \\n            for(auto node2 : adj[node1])\\n            {\\n                if(freq[node2] <= 2 && t+time != wt[node2])\\n                {\\n                    wt[node2] = t+time;\\n                    if(node2 == n)\\n                    {\\n                        cnt++;\\n                        //out target is n and if freq of node n is 2 , we return at this point \\n                        if(cnt == 2)\\n                        {\\n                            return wt[n];\\n                        }\\n                    }\\n                    \\n                    pq.push({t+time , node2});\\n                }\\n                //a node can be visited two times \\n            }\\n        }\\n        return 0 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        // we need to find the second minimum , \\n        /*\\n        so we need to find actually time when the node n will be visited the second time \\n        first time when node n is visited it will give , smallest path \\n        Here wt => time \\n        */\\n        priority_queue<pair<int , int> , vector<pair<int, int>> , greater<pair<int, int>>> pq;\\n        pq.push({0 , 1});\\n        //time 0 : node 1 \\n        vector<vector<int>> adj(n+1);\\n        for(auto it : edges)\\n        {\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<int> wt(n+1 , INT_MAX);\\n        wt[0] = 1;\\n        int cnt = 0;\\n        vector<int>freq(n+1 , 0);\\n        freq[1] = 1;\\n        while(pq.size())\\n        {\\n            int t = pq.top().first;\\n            int node1 = pq.top().second;\\n            pq.pop();\\n            freq[node1]++;\\n            int x = t/change;\\n            if(x%2==1)\\n            {\\n                //waiting time is to be included \\n                int wait = ((x+1) * change) - t;\\n                t=t+wait;\\n            }\\n            //now we have the net time currently \\n            for(auto node2 : adj[node1])\\n            {\\n                if(freq[node2] <= 2 && t+time != wt[node2])\\n                {\\n                    wt[node2] = t+time;\\n                    if(node2 == n)\\n                    {\\n                        cnt++;\\n                        //out target is n and if freq of node n is 2 , we return at this point \\n                        if(cnt == 2)\\n                        {\\n                            return wt[n];\\n                        }\\n                    }\\n                    \\n                    pq.push({t+time , node2});\\n                }\\n                //a node can be visited two times \\n            }\\n        }\\n        return 0 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011896,
                "title": "go-o-n-m-solution-using-bfs-for-second-shorted-path-pre-calculated-time-costs",
                "content": "# Intuition\\n- Time cost for a path depends on its number of edges only. Hence, we can use modulus check to precalculate cost for a specific number of edges.\\n- For finding second smallest path, we can do BFS 2 times, one from source and one from destination, then do edge replacements to figure out.\\n- If we can not find the second smallest path (due to all equivalent smallest paths), then we can use the smallest path with 2 directed edges to loop back to the destination. Hence it should be the second smallest value.\\n\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n+m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc secondMinimum(n int, edges [][]int, time int, change int) int {\\n    adj := make([][]int, n)\\n    for _, e := range edges {\\n        x, y := e[0]-1, e[1]-1\\n        adj[x] = append(adj[x], y)\\n        adj[y] = append(adj[y], x)\\n    }\\n    g := make([]int, 10_001)\\n    for i := 1; i < len(g); i++ {\\n        if (g[i-1] / change) % 2 == 0 {\\n            g[i] = g[i-1] + time\\n        } else {\\n            g[i] = (g[i-1] / change + 1) * change + time\\n        }\\n    }\\n    bfs := func(src int) []int {\\n        q := []int{src}\\n        d := make([]int, n)\\n        for i := 0; i < n; i++ {\\n            if i != src {\\n                d[i] = -1\\n            }\\n        }\\n        for len(q) > 0 {\\n            u := q[0]\\n            q = q[1:]\\n            for _, v := range adj[u] {\\n                if d[v] == -1 {\\n                    d[v] = d[u] + 1\\n                    q = append(q, v)\\n                }\\n            }\\n        }\\n        return d\\n    }\\n    src, dst := bfs(0), bfs(n-1)\\n    first := src[n-1]\\n    second := math.MaxInt32\\n    for _, e := range edges {\\n        x, y := e[0]-1, e[1]-1\\n        if t := src[x] + dst[y] + 1; t > first && t < second {\\n            second = t\\n        }\\n        if t := src[y] + dst[x] + 1; t > first && t < second {\\n            second = t\\n        }\\n    }\\n    if second == math.MaxInt32 {\\n        return g[first+2]\\n    }\\n    return g[second]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondMinimum(n int, edges [][]int, time int, change int) int {\\n    adj := make([][]int, n)\\n    for _, e := range edges {\\n        x, y := e[0]-1, e[1]-1\\n        adj[x] = append(adj[x], y)\\n        adj[y] = append(adj[y], x)\\n    }\\n    g := make([]int, 10_001)\\n    for i := 1; i < len(g); i++ {\\n        if (g[i-1] / change) % 2 == 0 {\\n            g[i] = g[i-1] + time\\n        } else {\\n            g[i] = (g[i-1] / change + 1) * change + time\\n        }\\n    }\\n    bfs := func(src int) []int {\\n        q := []int{src}\\n        d := make([]int, n)\\n        for i := 0; i < n; i++ {\\n            if i != src {\\n                d[i] = -1\\n            }\\n        }\\n        for len(q) > 0 {\\n            u := q[0]\\n            q = q[1:]\\n            for _, v := range adj[u] {\\n                if d[v] == -1 {\\n                    d[v] = d[u] + 1\\n                    q = append(q, v)\\n                }\\n            }\\n        }\\n        return d\\n    }\\n    src, dst := bfs(0), bfs(n-1)\\n    first := src[n-1]\\n    second := math.MaxInt32\\n    for _, e := range edges {\\n        x, y := e[0]-1, e[1]-1\\n        if t := src[x] + dst[y] + 1; t > first && t < second {\\n            second = t\\n        }\\n        if t := src[y] + dst[x] + 1; t > first && t < second {\\n            second = t\\n        }\\n    }\\n    if second == math.MaxInt32 {\\n        return g[first+2]\\n    }\\n    return g[second]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2713527,
                "title": "python-modified-dijkstra-easy-and-concise-code",
                "content": "```\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        D = [set() for _ in range(n+1)]\\n        D[1].add(0)\\n        adj, heap = defaultdict(list), [(0, 1)]\\n        # Create an Adjacency list\\n        for a,b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        # Modified Djikstras\\'s implementation\\n        while heap:\\n            curr_time, i = heapq.heappop(heap)\\n            if i == n and len(D[n]) == 2: return max(list(D[n]))\\n            \\n\\t\\t\\tsignal = curr_time // change\\n            \\n            for nei in adj[i]:\\n                if signal % 2 == 1: \\n                    curr_time += (change*(signal+1) - curr_time)\\n                \\n                if not D[nei] or len(D[nei]) < 2:\\n                    D[nei].add(curr_time + time)\\n                    heapq.heappush(heap, (curr_time + time, nei))\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        D = [set() for _ in range(n+1)]\\n        D[1].add(0)\\n        adj, heap = defaultdict(list), [(0, 1)]\\n        # Create an Adjacency list\\n        for a,b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        # Modified Djikstras\\'s implementation\\n        while heap:\\n            curr_time, i = heapq.heappop(heap)\\n            if i == n and len(D[n]) == 2: return max(list(D[n]))\\n            \\n\\t\\t\\tsignal = curr_time // change\\n            \\n            for nei in adj[i]:\\n                if signal % 2 == 1: \\n                    curr_time += (change*(signal+1) - curr_time)\\n                \\n                if not D[nei] or len(D[nei]) < 2:\\n                    D[nei].add(curr_time + time)\\n                    heapq.heappush(heap, (curr_time + time, nei))\\n            \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2621823,
                "title": "python-simple-bfs-solution",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = defaultdict(list)\\n        for vertex1, vertex2 in edges:\\n            graph[vertex1].append(vertex2)\\n            graph[vertex2].append(vertex1)\\n        minDistance, secondMinDistance, queue = [math.inf] * (n + 1), [math.inf] * (n + 1), deque()\\n        minDistance[1] = 0\\n        queue.append((0, 1))\\n        while queue:\\n            cost, node = queue.popleft()\\n            for neighbor in graph[node]:\\n                redLights, newCost = cost // change, cost + time\\n                if redLights % 2:\\n                    newCost = (change * (1 + redLights)) + time\\n                if minDistance[neighbor] > newCost:\\n                    secondMinDistance[neighbor] = minDistance[neighbor]\\n                    minDistance[neighbor] = newCost\\n                    queue.append((newCost, neighbor))\\n                elif minDistance[neighbor] < newCost and secondMinDistance[neighbor] > newCost:\\n                    secondMinDistance[neighbor] = newCost\\n                    queue.append((newCost, neighbor))\\n        return secondMinDistance[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = defaultdict(list)\\n        for vertex1, vertex2 in edges:\\n            graph[vertex1].append(vertex2)\\n            graph[vertex2].append(vertex1)\\n        minDistance, secondMinDistance, queue = [math.inf] * (n + 1), [math.inf] * (n + 1), deque()\\n        minDistance[1] = 0\\n        queue.append((0, 1))\\n        while queue:\\n            cost, node = queue.popleft()\\n            for neighbor in graph[node]:\\n                redLights, newCost = cost // change, cost + time\\n                if redLights % 2:\\n                    newCost = (change * (1 + redLights)) + time\\n                if minDistance[neighbor] > newCost:\\n                    secondMinDistance[neighbor] = minDistance[neighbor]\\n                    minDistance[neighbor] = newCost\\n                    queue.append((newCost, neighbor))\\n                elif minDistance[neighbor] < newCost and secondMinDistance[neighbor] > newCost:\\n                    secondMinDistance[neighbor] = newCost\\n                    queue.append((newCost, neighbor))\\n        return secondMinDistance[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284173,
                "title": "c-find-minimum-two-paths-for-node",
                "content": "The algorithm is modified BFS. Each node can enter the queue at most twice.\\nWe have to find the 2 minimum distances for each node . \\nWe can do so by maintaining a pair for each node to store distance.\\nOnce we have found both the distances, the node with never enter queue again\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<int> adj[n+1];\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        queue<pair<int,int> > q;\\n        \\n        vector<pair<int,int> > dis(n+1 , {-1,-1});\\n        q.push({1,1});\\n        dis[1].first=0;\\n        \\n        while(q.size()){\\n            auto x = q.front();q.pop();\\n            int node = x.first , mode = x.second; //mode helps us to find the distance the current node is at \\n            for(auto to:adj[node]){\\n                int distance = (mode==1)?dis[node].first:dis[node].second;\\n                distance++;\\n                if(dis[to].first ==-1){    //if first distance is not found till now\\n                    dis[to].first = distance;\\n                    q.push({to,1});\\n                }else if(dis[to].second ==-1){  //if second distance is not found till now\\n\\t\\t\\t\\t\\t\\tif(distance == dis[to].first) continue;//we only need new distance\\n                    dis[to].second = distance;\\n                    q.push({to,2});\\n                }else{}\\n            }    \\n        }\\n        int len = dis[n].second, currTime=0;\\n\\t\\n\\t/*\\n\\tgreen : [0,c]  [2c,3c]  [4c,5c]\\n\\tred : [c,2c] [3c,4c]  \\n\\twe basically have to check if our currtime lies in the red brackets , if yes change the time to end time of that  bracket\\n\\t*/\\n\\n        for(int i=0;i<len;i++){\\n            if((currTime/change)%2==1){\\n                currTime =( (currTime/change) + 1)*change;\\n            }\\n            currTime += time;\\n        }\\n        \\n        return currTime;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<int> adj[n+1];\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        queue<pair<int,int> > q;\\n        \\n        vector<pair<int,int> > dis(n+1 , {-1,-1});\\n        q.push({1,1});\\n        dis[1].first=0;\\n        \\n        while(q.size()){\\n            auto x = q.front();q.pop();\\n            int node = x.first , mode = x.second; //mode helps us to find the distance the current node is at \\n            for(auto to:adj[node]){\\n                int distance = (mode==1)?dis[node].first:dis[node].second;\\n                distance++;\\n                if(dis[to].first ==-1){    //if first distance is not found till now\\n                    dis[to].first = distance;\\n                    q.push({to,1});\\n                }else if(dis[to].second ==-1){  //if second distance is not found till now\\n\\t\\t\\t\\t\\t\\tif(distance == dis[to].first) continue;//we only need new distance\\n                    dis[to].second = distance;\\n                    q.push({to,2});\\n                }else{}\\n            }    \\n        }\\n        int len = dis[n].second, currTime=0;\\n\\t\\n\\t/*\\n\\tgreen : [0,c]  [2c,3c]  [4c,5c]\\n\\tred : [c,2c] [3c,4c]  \\n\\twe basically have to check if our currtime lies in the red brackets , if yes change the time to end time of that  bracket\\n\\t*/\\n\\n        for(int i=0;i<len;i++){\\n            if((currTime/change)%2==1){\\n                currTime =( (currTime/change) + 1)*change;\\n            }\\n            currTime += time;\\n        }\\n        \\n        return currTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714665,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        //\\u9700\\u8981\\u8FDB\\u884Cadj\\u5185\\u7F6Earraylist\\u7684\\u521D\\u59CB\\u5316\\n        for(int i = 0; i < adj.length; i ++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges){\\n            int p = edge[0] - 1;\\n            int q = edge[1] - 1;\\n            adj[p].add(q);\\n            adj[q].add(p);\\n        }\\n        //\\u6700\\u77ED\\u8DEF\\n        int[] dis1 = new int[n];\\n        //\\u6B21\\u77ED\\u8DEF\\n        int[] dis2 = new int[n];\\n        \\n        Arrays.fill(dis1, Integer.MAX_VALUE);\\n        Arrays.fill(dis2, Integer.MAX_VALUE);\\n        dis1[0] = 0;\\n        // dis2[0] = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        //BFS\\n        while(! queue.isEmpty()){\\n            int[] temp = queue.poll();\\n            //\\u6240\\u5728\\u8282\\u70B9\\u4F4D\\u7F6E\\n            int cur = temp[0];\\n            //\\u79EF\\u7D2F\\u7684path\\n            int path = temp[1];\\n            \\n            //\\u904D\\u5386\\u76F8\\u90BB\\u8282\\u70B9\\n            for(int node : adj[cur]){\\n                int newPath = path + 1;\\n                //\\u8FDB\\u884C\\u66F4\\u65B0\\n                if(newPath < dis1[node]){\\n                    //\\u82E5\\u6BD4\\u6700\\u5C0F\\u503C\\u8FD8\\u5C0F\\n                    dis2[node] = dis1[node];\\n                    dis1[node] = newPath;\\n                    queue.offer(new int[]{node, newPath});\\n                }else if((newPath > dis1[node]) && (newPath < dis2[node])){\\n                    //\\u5728\\u4E8C\\u8005\\u4E2D\\u95F4\\n                    dis2[node] = newPath;\\n                    queue.offer(new int[]{node, newPath});\\n                }\\n            }\\n        }\\n        return helper(dis2[n - 1], time, change);\\n    }\\n    \\n    //\\u5C06\\u7EA2\\u7EFF\\u706F\\u8003\\u8651\\u8FDB\\u6765\\n    private int helper(int pathValue, int time, int change){\\n        int sum = 0;\\n        for(int i = 0; i < pathValue; i ++){\\n            sum += time;\\n            //\\u4E0D\\u9700\\u8981\\u7B49\\u5F85\\n            if(i == pathValue - 1)\\n                break;            \\n            //\\u5982\\u679C\\u662F\\u5076\\u6570 --> \\u7EFF\\u706F\\n            if((sum / change) % 2 == 0)\\n                continue;\\n            //\\u6280\\u672F\\u662F\\u7EA2\\u706F\\uFF0C\\u9700\\u8981\\u8865\\u507F\\u7B49\\u5F85\\u65F6\\u95F4\\n            sum = (sum / change + 1) * change;\\n        }\\n        return sum;\\n    }\\n\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        //\\u9700\\u8981\\u8FDB\\u884Cadj\\u5185\\u7F6Earraylist\\u7684\\u521D\\u59CB\\u5316\\n        for(int i = 0; i < adj.length; i ++){\\n            adj[i] = new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1667943,
                "title": "bfs-c",
                "content": "```\\n\\nmaintain 2 distance array \\ndist1 -> first shortest path\\ndist2 -> second shortest path.\\n\\n// no need to use Dijkstra as distance between each node is same , simple bfs would work.\\n\\ntypedef pair<int,int> pi;\\n\\nclass Solution {\\npublic:\\n    \\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<vector<int>> adj(n + 1);\\n        \\n        for(auto &it : edges){\\n            int u = it[0] , v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int> dist1(n + 1 , INT_MAX);\\n        vector<int> dist2(n + 1 , INT_MAX);\\n        \\n        dist1[1] = 0;\\n        \\n        queue<pi> q;\\n        q.push({0,1});\\n        \\n        while(q.size()){\\n            \\n            auto[tm,src] = q.front();\\n            q.pop();\\n         \\n      // If the signal is red at the vertex wait until the signal gets green.\\n            \\n            int val = tm/change;\\n            \\n            if(val % 2 != 0)tm = change * (val + 1);\\n            \\n            \\n            for(auto &v : adj[src]){\\n                \\n                int path = tm + time;\\n                \\n      // first shortest path          \\n                if(path < dist1[v]){\\n                    dist2[v] = dist1[v];\\n                    dist1[v] = path;\\n                    q.push({path,v});\\n                }\\n                \\n     // second shortest path           \\n                else if(path > dist1[v] && path < dist2[v]){\\n                    dist2[v] = path;\\n                    q.push({path,v});\\n                }\\n            }\\n        }\\n        \\n     return dist2[n];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nmaintain 2 distance array \\ndist1 -> first shortest path\\ndist2 -> second shortest path.\\n\\n// no need to use Dijkstra as distance between each node is same , simple bfs would work.\\n\\ntypedef pair<int,int> pi;\\n\\nclass Solution {\\npublic:\\n    \\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<vector<int>> adj(n + 1);\\n        \\n        for(auto &it : edges){\\n            int u = it[0] , v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int> dist1(n + 1 , INT_MAX);\\n        vector<int> dist2(n + 1 , INT_MAX);\\n        \\n        dist1[1] = 0;\\n        \\n        queue<pi> q;\\n        q.push({0,1});\\n        \\n        while(q.size()){\\n            \\n            auto[tm,src] = q.front();\\n            q.pop();\\n         \\n      // If the signal is red at the vertex wait until the signal gets green.\\n            \\n            int val = tm/change;\\n            \\n            if(val % 2 != 0)tm = change * (val + 1);\\n            \\n            \\n            for(auto &v : adj[src]){\\n                \\n                int path = tm + time;\\n                \\n      // first shortest path          \\n                if(path < dist1[v]){\\n                    dist2[v] = dist1[v];\\n                    dist1[v] = path;\\n                    q.push({path,v});\\n                }\\n                \\n     // second shortest path           \\n                else if(path > dist1[v] && path < dist2[v]){\\n                    dist2[v] = path;\\n                    q.push({path,v});\\n                }\\n            }\\n        }\\n        \\n     return dist2[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536549,
                "title": "python3-simple-bfs-solution",
                "content": "I add a `p` to record the path as well. can remove it.\\n\\nfind the second minimum time.\\n\\n```python\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # loc, time, path\\n        q = collections.deque([(1, 0, \\'1(0)\\')])\\n        seen = [[] for _ in range(n+1)]\\n        seen[1] = [0]\\n        res = -1\\n        while q:\\n            for _ in range(len(q)):\\n                c, t, p = q.popleft()\\n                wait = change - t % change\\n                # odd is red\\n                is_red = (t // change) % 2 == 1\\n                if c == n:\\n                    if res == -1:\\n                        res = t\\n                    elif t > res:\\n                        return t\\n                        \\n                for nxt in graph[c]:\\n                    nxt_time = t+time\\n                    if is_red:\\n                        nxt_time += wait\\n                    if not seen[nxt] or (len(seen[nxt])==1 and seen[nxt][0] < nxt_time):\\n                        seen[nxt].append(nxt_time)\\n                        q.append((nxt, nxt_time, p+\\'->\\'+str(nxt)+\\'(\\'+str(nxt_time)+\\')\\'))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # loc, time, path\\n        q = collections.deque([(1, 0, \\'1(0)\\')])\\n        seen = [[] for _ in range(n+1)]\\n        seen[1] = [0]\\n        res = -1\\n        while q:\\n            for _ in range(len(q)):\\n                c, t, p = q.popleft()\\n                wait = change - t % change\\n                # odd is red\\n                is_red = (t // change) % 2 == 1\\n                if c == n:\\n                    if res == -1:\\n                        res = t\\n                    elif t > res:\\n                        return t\\n                        \\n                for nxt in graph[c]:\\n                    nxt_time = t+time\\n                    if is_red:\\n                        nxt_time += wait\\n                    if not seen[nxt] or (len(seen[nxt])==1 and seen[nxt][0] < nxt_time):\\n                        seen[nxt].append(nxt_time)\\n                        q.append((nxt, nxt_time, p+\\'->\\'+str(nxt)+\\'(\\'+str(nxt_time)+\\')\\'))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533161,
                "title": "java-concise-2d-dijkstra-tc-o-v-elogv-sc-o-v",
                "content": "```\\n   public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        List<Integer>[] graph = new List[n+1];\\n        for(int i=0; i<=n; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] i: edges){\\n            graph[i[0]].add(i[1]);\\n            graph[i[1]].add(i[0]);\\n        }\\n        \\n        int[][] dist = new int[n+1][2]; // Instead of 1D dist array maintain 2nd col for 2nd min path\\n        for (int[] d : dist) {\\n            Arrays.fill(d, Integer.MAX_VALUE);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1]-b[1]);\\n        pq.add(new int[]{1, 0}); \\n        dist[1][0] = 0; // Set Node1 min path to 0\\n        while(!pq.isEmpty()){\\n            int[] cur = pq.poll();\\n            int node = cur[0], curTime = cur[1];\\n            \\n            if(dist[node][1] < curTime) continue; // Optimization: already visited and taken 2nd min version.\\n            \\n\\t\\t\\t/* [0-4->0(Green); 5-9->1(Red); 10-14->2(G); 15-19->3(R)] */\\n            int wait = 0;\\n            if ((curTime / change) % 2 ==1) {\\n                wait = change - (curTime % change);\\n            }\\n            int nextTime = curTime + wait + time;\\n            \\n            for(int nei: graph[node]){\\n                if (dist[nei][0] > nextTime) {\\n                    dist[nei][0] = nextTime;\\n                    pq.offer(new int[]{nei, nextTime});\\n                } else if (dist[nei][1] > nextTime && dist[nei][0] < nextTime) { // take second min\\n                    dist[nei][1] = nextTime; // in 2nd column\\n                    if(nei==n) return nextTime; //System.out.println(Arrays.deepToString(dist));\\n                    pq.offer(new int[]{nei, nextTime});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        List<Integer>[] graph = new List[n+1];\\n        for(int i=0; i<=n; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] i: edges){\\n            graph[i[0]].add(i[1]);\\n            graph[i[1]].add(i[0]);\\n        }\\n        \\n        int[][] dist = new int[n+1][2]; // Instead of 1D dist array maintain 2nd col for 2nd min path\\n        for (int[] d : dist) {\\n            Arrays.fill(d, Integer.MAX_VALUE);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1]-b[1]);\\n        pq.add(new int[]{1, 0}); \\n        dist[1][0] = 0; // Set Node1 min path to 0\\n        while(!pq.isEmpty()){\\n            int[] cur = pq.poll();\\n            int node = cur[0], curTime = cur[1];\\n            \\n            if(dist[node][1] < curTime) continue; // Optimization: already visited and taken 2nd min version.\\n            \\n\\t\\t\\t/* [0-4->0(Green); 5-9->1(Red); 10-14->2(G); 15-19->3(R)] */\\n            int wait = 0;\\n            if ((curTime / change) % 2 ==1) {\\n                wait = change - (curTime % change);\\n            }\\n            int nextTime = curTime + wait + time;\\n            \\n            for(int nei: graph[node]){\\n                if (dist[nei][0] > nextTime) {\\n                    dist[nei][0] = nextTime;\\n                    pq.offer(new int[]{nei, nextTime});\\n                } else if (dist[nei][1] > nextTime && dist[nei][0] < nextTime) { // take second min\\n                    dist[nei][1] = nextTime; // in 2nd column\\n                    if(nei==n) return nextTime; //System.out.println(Arrays.deepToString(dist));\\n                    pq.offer(new int[]{nei, nextTime});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1528149,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i<=n; i++) graph.add(new ArrayList<>());\\n        for(int e[]:edges){\\n            int u = e[0], v = e[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        \\n        int vis[][] = new int[2][n+1];  // vis[][0] -> first min, vis[][1] -> second min\\n        for(int r[]: vis) Arrays.fill(r, -1);\\n        \\n\\t\\tQueue<int[]> pq = new LinkedList<>();\\n        \\n        pq.add(new int[]{1, 0});\\n        \\n        while(pq.size() > 0){\\n            int rem[] = pq.remove();\\n            int v = rem[0];\\n            int timeTaken = rem[1];\\n            \\n            if(vis[0][v] != -1){\\n                if(vis[1][v] != -1) continue;\\n                \\n                if(vis[0][v] < timeTaken){\\n                    vis[1][v] = timeTaken;\\n                }\\n            }else{\\n                vis[0][v] = timeTaken;\\n            }\\n            \\n            for(int nbr : graph.get(v)){\\n                if(vis[1][nbr] == -1){\\n                    int val= timeTaken / change;\\n                    \\n                    if(val % 2 == 0){\\n                        pq.add(new int[]{nbr, timeTaken + time});\\n                    }else{\\n                        pq.add(new int[]{nbr, time + (val+1) * change}); // if val is odd that means light is red therefore we have to wait till the signal turns green \\n                    }\\n                }\\n            }\\n            \\n        }\\n        return vis[1][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i<=n; i++) graph.add(new ArrayList<>());\\n        for(int e[]:edges){\\n            int u = e[0], v = e[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        \\n        int vis[][] = new int[2][n+1];  // vis[][0] -> first min, vis[][1] -> second min\\n        for(int r[]: vis) Arrays.fill(r, -1);\\n        \\n\\t\\tQueue<int[]> pq = new LinkedList<>();\\n        \\n        pq.add(new int[]{1, 0});\\n        \\n        while(pq.size() > 0){\\n            int rem[] = pq.remove();\\n            int v = rem[0];\\n            int timeTaken = rem[1];\\n            \\n            if(vis[0][v] != -1){\\n                if(vis[1][v] != -1) continue;\\n                \\n                if(vis[0][v] < timeTaken){\\n                    vis[1][v] = timeTaken;\\n                }\\n            }else{\\n                vis[0][v] = timeTaken;\\n            }\\n            \\n            for(int nbr : graph.get(v)){\\n                if(vis[1][nbr] == -1){\\n                    int val= timeTaken / change;\\n                    \\n                    if(val % 2 == 0){\\n                        pq.add(new int[]{nbr, timeTaken + time});\\n                    }else{\\n                        pq.add(new int[]{nbr, time + (val+1) * change}); // if val is odd that means light is red therefore we have to wait till the signal turns green \\n                    }\\n                }\\n            }\\n            \\n        }\\n        return vis[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527051,
                "title": "java-bfs-two-relaxation",
                "content": "I basically transferred this post\\'s C++ into Java. [Original Post in Chinese](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/solution/wei-rao-li-lun-bfsji-lu-dao-di-er-duan-d-z67m/)\\nBecause time is same for all edges, BFS is feasible.\\n\\nThe major idea is to have two maps that keeps track of the shortest and second shortest time arriving at any node.\\nEach node are allowed to be added into these maps at most once respectively. \\n\\nAnother issue is the signal light, this is handled by update `targetTime` which is the time when we leave the `next` node. \\n\\n```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, Integer> fast = new HashMap<>();\\n        Map<Integer, Integer> second = new HashMap<>();\\n        Queue<int[]> Q = new ArrayDeque<>();\\n        Q.offer(new int[] {1, 0});\\n        fast.put(1,0);\\n        Map<Integer, List<Integer>> G = new HashMap<>();\\n        int first = -1;\\n        // build graph\\n        for (int[] edge : edges) {\\n            if (!G.containsKey(edge[0])) {\\n                G.put(edge[0], new ArrayList<>());\\n            }\\n            if (!G.containsKey(edge[1])) {\\n                G.put(edge[1], new ArrayList<>());\\n            }\\n            G.get(edge[0]).add(edge[1]);\\n            G.get(edge[1]).add(edge[0]);\\n        }\\n        // bfs\\n        while (!Q.isEmpty()) {\\n            int[] p = Q.poll();\\n            int node = p[0];\\n            int currTime = p[1];\\n            for (Integer next : G.get(node)) {\\n                // when next node reaches the destination\\n                if (next == n) {\\n                    // if no shortest recorded, set shortest path time\\n                    if (first == -1) {\\n                        first = currTime + time;\\n                    } else {\\n                        // if the current path is strictly larger than the shortest path, then return\\n                        if (currTime + time > first) {\\n                            return currTime + time;\\n                        }\\n                    }\\n                }\\n                // target time is the starting time when we leaves the next node\\n                int targetTime = currTime + time;\\n                if ((targetTime / change) % 2 == 1) {\\n                    targetTime = (targetTime / change + 1) * change;\\n                }\\n                // each node can only be inserted into the queue twice.\\n                // only record once of each node\\'s fastest time\\n                if (!fast.containsKey(next)) {\\n                    fast.put(next, targetTime);\\n                    Q.offer(new int[] {next, targetTime});\\n                    continue;\\n                }\\n                // only record once of each nodes\\'s second fastest time\\n                if (!second.containsKey(next) && fast.get(next) < targetTime) {\\n                    second.put(next, targetTime);\\n                    Q.offer(new int[] {next, targetTime});\\n                    continue;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, Integer> fast = new HashMap<>();\\n        Map<Integer, Integer> second = new HashMap<>();\\n        Queue<int[]> Q = new ArrayDeque<>();\\n        Q.offer(new int[] {1, 0});\\n        fast.put(1,0);\\n        Map<Integer, List<Integer>> G = new HashMap<>();\\n        int first = -1;\\n        // build graph\\n        for (int[] edge : edges) {\\n            if (!G.containsKey(edge[0])) {\\n                G.put(edge[0], new ArrayList<>());\\n            }\\n            if (!G.containsKey(edge[1])) {\\n                G.put(edge[1], new ArrayList<>());\\n            }\\n            G.get(edge[0]).add(edge[1]);\\n            G.get(edge[1]).add(edge[0]);\\n        }\\n        // bfs\\n        while (!Q.isEmpty()) {\\n            int[] p = Q.poll();\\n            int node = p[0];\\n            int currTime = p[1];\\n            for (Integer next : G.get(node)) {\\n                // when next node reaches the destination\\n                if (next == n) {\\n                    // if no shortest recorded, set shortest path time\\n                    if (first == -1) {\\n                        first = currTime + time;\\n                    } else {\\n                        // if the current path is strictly larger than the shortest path, then return\\n                        if (currTime + time > first) {\\n                            return currTime + time;\\n                        }\\n                    }\\n                }\\n                // target time is the starting time when we leaves the next node\\n                int targetTime = currTime + time;\\n                if ((targetTime / change) % 2 == 1) {\\n                    targetTime = (targetTime / change + 1) * change;\\n                }\\n                // each node can only be inserted into the queue twice.\\n                // only record once of each node\\'s fastest time\\n                if (!fast.containsKey(next)) {\\n                    fast.put(next, targetTime);\\n                    Q.offer(new int[] {next, targetTime});\\n                    continue;\\n                }\\n                // only record once of each nodes\\'s second fastest time\\n                if (!second.containsKey(next) && fast.get(next) < targetTime) {\\n                    second.put(next, targetTime);\\n                    Q.offer(new int[] {next, targetTime});\\n                    continue;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526592,
                "title": "java-dijkstra-keep-two-min-time-for-each-node-comments-explained",
                "content": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n\\t\\t// build the graph\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for (int i = 1; i <= n; i++) graph.put(i, new HashSet<>());\\n        for (int[] e : edges) {\\n            graph.get(e[0]).add(e[1]);\\n            graph.get(e[1]).add(e[0]);\\n        }\\n\\t\\t// keep two min times for each node\\n        int[][] visited = new int[n+1][2]; //{min, secMin}\\n        for (int[] v : visited) {\\n            Arrays.fill(v, Integer.MAX_VALUE);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1]));\\n        pq.offer(new int[]{1, 0}); // {curNode, curTime}\\n        \\n        int min = Integer.MAX_VALUE, secMin = min;\\n        \\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int curNode = cur[0], curTime = cur[1];\\n\\n\\t\\t\\t// update the global value when reach target\\n            if (curNode == n) {\\n                if (curTime < min) {\\n                    secMin = min;\\n                    min = curTime;\\n                } else if (curTime != min && curTime < secMin) {\\n                    secMin = curTime;\\n                }\\n            }\\n            \\n\\t\\t\\t// calculate if we need to wait for the green light, if change is 5, then:\\n\\t\\t\\t// 0~4 green\\n\\t\\t\\t// 5~9 red\\n\\t\\t\\t// 10 ~14 green\\n\\t\\t\\t// ...\\n            if ((curTime / change) % 2 ==1) {\\n                curTime += change - (curTime % change);\\n            }\\n            \\n            int nextTime = curTime + time;\\n            \\n            for (int nxt : graph.get(curNode)) {\\n                int nxtMin = visited[nxt][0], nxtSecMin = visited[nxt][1];\\n                if (nextTime < nxtMin) { // update min\\n                    visited[nxt][1] = nxtMin;\\n                    visited[nxt][0] = nextTime;\\n                    pq.offer(new int[]{nxt, nextTime});\\n                } else if (nextTime != nxtMin && nextTime < nxtSecMin) { // update secMin\\n                    visited[nxt][1] = nextTime;\\n                    pq.offer(new int[]{nxt, nextTime});\\n                }\\n            }\\n        }\\n  \\n        return secMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n\\t\\t// build the graph\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for (int i = 1; i <= n; i++) graph.put(i, new HashSet<>());\\n        for (int[] e : edges) {\\n            graph.get(e[0]).add(e[1]);\\n            graph.get(e[1]).add(e[0]);\\n        }\\n\\t\\t// keep two min times for each node\\n        int[][] visited = new int[n+1][2]; //{min, secMin}\\n        for (int[] v : visited) {\\n            Arrays.fill(v, Integer.MAX_VALUE);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1]));\\n        pq.offer(new int[]{1, 0}); // {curNode, curTime}\\n        \\n        int min = Integer.MAX_VALUE, secMin = min;\\n        \\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int curNode = cur[0], curTime = cur[1];\\n\\n\\t\\t\\t// update the global value when reach target\\n            if (curNode == n) {\\n                if (curTime < min) {\\n                    secMin = min;\\n                    min = curTime;\\n                } else if (curTime != min && curTime < secMin) {\\n                    secMin = curTime;\\n                }\\n            }\\n            \\n\\t\\t\\t// calculate if we need to wait for the green light, if change is 5, then:\\n\\t\\t\\t// 0~4 green\\n\\t\\t\\t// 5~9 red\\n\\t\\t\\t// 10 ~14 green\\n\\t\\t\\t// ...\\n            if ((curTime / change) % 2 ==1) {\\n                curTime += change - (curTime % change);\\n            }\\n            \\n            int nextTime = curTime + time;\\n            \\n            for (int nxt : graph.get(curNode)) {\\n                int nxtMin = visited[nxt][0], nxtSecMin = visited[nxt][1];\\n                if (nextTime < nxtMin) { // update min\\n                    visited[nxt][1] = nxtMin;\\n                    visited[nxt][0] = nextTime;\\n                    pq.offer(new int[]{nxt, nextTime});\\n                } else if (nextTime != nxtMin && nextTime < nxtSecMin) { // update secMin\\n                    visited[nxt][1] = nextTime;\\n                    pq.offer(new int[]{nxt, nextTime});\\n                }\\n            }\\n        }\\n  \\n        return secMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526220,
                "title": "rust-c-bfs-o-e-solution-and-explanation",
                "content": "Let `min` be the minimum distance from node 1 to n. Then the second min must be `min + 1` or `min + 2`. We call the min path `p`.\\n\\n> We can add a cycle into `p` to construct a `min + 2` path.\\n> For example, change `1 -> 2` to `1 -> 2 -> 1 -> 2`. Thus the second min doesn\\'t exceed `min + 2`.\\n\\nWe just need to check if there is a path from 1 to n that has length `min + 1` and without a cycle.\\n\\n> A path with a cycle shouldn\\'t have smaller length than `min + 2`. If it has,\\n> we can eliminate the circle (its length is at least 2) then get a new path that shorter than `p`.\\n\\nThat is, we need to check if there is a node `x` that the min distance between 1 and `x` plus the min distance between `x` and n equals `min + 1`.\\n\\n> Why min distance between 1 and `x`?\\n> Let `d1` be the distance between 1 and `x`, `d2` the distance between n and `x`. `d1 + d2 == min + 1`.\\n> If `d1` and `d2` both are not the min distance. we can shorten them to get a shorter path than `p`. So at least one of `d1` and `d2` is the min distance.\\n> Suppose `d2` is, `d1` isn\\'t. There will be a node `y` in `d1`, it minimize the distance from node 1 and not minimize the distance from node n.\\n> `y`\\'s successor `yp` minimize the distance from node n and not minimize the distance from node 1. It\\'s impossible.\\n> Thus there are a node the sum of its distance from 1 and n is `min + 1` if there are a path length `min + 1` from 1 to n.\\n\\nWe use two BFS to find the min distance from node 1 to any other node and the min distance from node n to any other node.\\n\\n```rust\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn second_minimum(n: i32, edges: Vec<Vec<i32>>, time: i32, change: i32) -> i32 {\\n        let mut adj: Vec<Vec<usize>> = vec![vec![]; (n + 1) as usize];\\n\\n        for e in edges {\\n            let v1 = e[0] as usize;\\n            let v2 = e[1] as usize;\\n            adj[v1].push(v2);\\n            adj[v2].push(v1);\\n        }\\n\\n        let dist2start = Solution::bfs(&adj, 1);\\n        let dist2end = Solution::bfs(&adj, adj.len() - 1);\\n        let min = dist2start.last().unwrap();\\n        let min2 = if Solution::check_dist(&dist2start, &dist2end, min + 1) {\\n            min + 1\\n        } else {\\n            min + 2\\n        };\\n\\n        (0..min2).into_iter().fold(0, |sum, _| {\\n            if sum / change % 2 == 1 {\\n                (sum / change + 1) * change + time\\n            } else {\\n                sum + time\\n            }\\n        })\\n    }\\n\\n    fn check_dist(dist2start: &[usize], dist2end: &[usize], target: usize) -> bool {\\n        dist2start[1..]\\n            .iter()\\n            .zip(dist2end[1..].iter())\\n            .any(|(d1, d2)| d1 + d2 == target)\\n    }\\n\\n    fn bfs(adj: &[Vec<usize>], start: usize) -> Vec<usize> {\\n        let mut q: VecDeque<usize> = VecDeque::new();\\n        q.push_back(start);\\n        let mut dist2start = vec![usize::MAX; adj.len()];\\n        dist2start[start] = 0;\\n        while !q.is_empty() {\\n            let v = q.pop_front().unwrap();\\n            for &a in &adj[v] {\\n                if dist2start[a] == usize::MAX {\\n                    dist2start[a] = dist2start[v] + 1;\\n                    q.push_back(a);\\n                }\\n            }\\n        }\\n\\n        dist2start\\n    }\\n}\\n```\\n\\nTime: O(E)\\nSpace: O(E)\\n\\nE is the number of edges.\\n\\n---\\n\\nC++ version:\\n\\n```cpp\\nclass Solution {\\n   public:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n + 1);\\n        for (const auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        const auto dist2start = bfs(adj, 1);\\n        const auto dist2end = bfs(adj, n);\\n        const auto min = dist2start.back();\\n        int min2 = 0;\\n        if (check_dist(dist2start, dist2end, min + 1)) {\\n            min2 = min + 1;\\n        } else {\\n            min2 = min + 2;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i != min2; ++i) {\\n            if (sum / change % 2 == 1) {\\n                sum = (sum / change + 1) * change + time;\\n            } else {\\n                sum += time;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    bool check_dist(const vector<int>& dist2start,\\n                    const vector<int>& dist2end,\\n                    int target) {\\n        for (int i = 1; i != dist2start.size(); ++i) {\\n            if (dist2start[i] + dist2end[i] == target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    vector<int> bfs(const vector<vector<int>>& adj, int start) {\\n        queue<int> q({start});\\n        vector<int> dist2start(adj.size(), -1);\\n        dist2start[start] = 0;\\n        while (!q.empty()) {\\n            const auto v = q.front();\\n            q.pop();\\n            for (const auto a : adj[v]) {\\n                if (dist2start[a] == -1) {\\n                    dist2start[a] = dist2start[v] + 1;\\n                    q.push(a);\\n                }\\n            }\\n        }\\n\\n        return dist2start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn second_minimum(n: i32, edges: Vec<Vec<i32>>, time: i32, change: i32) -> i32 {\\n        let mut adj: Vec<Vec<usize>> = vec![vec![]; (n + 1) as usize];\\n\\n        for e in edges {\\n            let v1 = e[0] as usize;\\n            let v2 = e[1] as usize;\\n            adj[v1].push(v2);\\n            adj[v2].push(v1);\\n        }\\n\\n        let dist2start = Solution::bfs(&adj, 1);\\n        let dist2end = Solution::bfs(&adj, adj.len() - 1);\\n        let min = dist2start.last().unwrap();\\n        let min2 = if Solution::check_dist(&dist2start, &dist2end, min + 1) {\\n            min + 1\\n        } else {\\n            min + 2\\n        };\\n\\n        (0..min2).into_iter().fold(0, |sum, _| {\\n            if sum / change % 2 == 1 {\\n                (sum / change + 1) * change + time\\n            } else {\\n                sum + time\\n            }\\n        })\\n    }\\n\\n    fn check_dist(dist2start: &[usize], dist2end: &[usize], target: usize) -> bool {\\n        dist2start[1..]\\n            .iter()\\n            .zip(dist2end[1..].iter())\\n            .any(|(d1, d2)| d1 + d2 == target)\\n    }\\n\\n    fn bfs(adj: &[Vec<usize>], start: usize) -> Vec<usize> {\\n        let mut q: VecDeque<usize> = VecDeque::new();\\n        q.push_back(start);\\n        let mut dist2start = vec![usize::MAX; adj.len()];\\n        dist2start[start] = 0;\\n        while !q.is_empty() {\\n            let v = q.pop_front().unwrap();\\n            for &a in &adj[v] {\\n                if dist2start[a] == usize::MAX {\\n                    dist2start[a] = dist2start[v] + 1;\\n                    q.push_back(a);\\n                }\\n            }\\n        }\\n\\n        dist2start\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\n   public:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n + 1);\\n        for (const auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        const auto dist2start = bfs(adj, 1);\\n        const auto dist2end = bfs(adj, n);\\n        const auto min = dist2start.back();\\n        int min2 = 0;\\n        if (check_dist(dist2start, dist2end, min + 1)) {\\n            min2 = min + 1;\\n        } else {\\n            min2 = min + 2;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i != min2; ++i) {\\n            if (sum / change % 2 == 1) {\\n                sum = (sum / change + 1) * change + time;\\n            } else {\\n                sum += time;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    bool check_dist(const vector<int>& dist2start,\\n                    const vector<int>& dist2end,\\n                    int target) {\\n        for (int i = 1; i != dist2start.size(); ++i) {\\n            if (dist2start[i] + dist2end[i] == target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    vector<int> bfs(const vector<vector<int>>& adj, int start) {\\n        queue<int> q({start});\\n        vector<int> dist2start(adj.size(), -1);\\n        dist2start[start] = 0;\\n        while (!q.empty()) {\\n            const auto v = q.front();\\n            q.pop();\\n            for (const auto a : adj[v]) {\\n                if (dist2start[a] == -1) {\\n                    dist2start[a] = dist2start[v] + 1;\\n                    q.push(a);\\n                }\\n            }\\n        }\\n\\n        return dist2start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525741,
                "title": "simple-bfs-c-intuitive",
                "content": "**Idea:**\\nStart BFS from `node 1` and return elapsed time when `node n` has been visited more than 1 time AND the elapsed time is higher than the time when node n was visited for the first time.\\n\\n**Optimizations:**\\n1. Ensure current level of queue has only one entry per node.\\n2. Do not insert current node into queue if it has already been visited twice.\\n\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<vector<int>> adj(n+1, vector<int>(0));\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        queue<int> q;\\n        q.push(1);\\n        int vis[n+1];\\n        memset(vis, 0, sizeof vis);\\n        int t =0;\\n        int ans =INT_MAX;\\n\\n        \\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            vector<bool> local(n+1, 0);\\n            for(int i=0;i<s;i++)\\n            {\\n                int cur = q.front();\\n                q.pop();\\n                \\n                vis[cur]++;\\n                \\n                if(cur==n)\\n                {\\n                    if(vis[cur]==1)\\n                    {\\n                        ans = min(ans, t);\\n                    }\\n                    else if(vis[cur]>1 && t>ans)\\n                    {\\n                        return t;\\n                    }\\n                }\\n\\n                for(int j=0;j<adj[cur].size();j++)\\n                {\\n                    if(!local[adj[cur][j]] && vis[adj[cur][j]]<2)\\n                    {\\n                        local[adj[cur][j]]=1;\\n                        q.push(adj[cur][j]);\\n                    }\\n                }\\n            }\\n            \\n            if((t/change)%2)\\n            {\\n                t+= change - t%change + time; \\n            }\\n            else\\n            {\\n                t += time;\\n            }\\n            \\n        }\\n        \\n        \\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<vector<int>> adj(n+1, vector<int>(0));\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        queue<int> q;\\n        q.push(1);\\n        int vis[n+1];\\n        memset(vis, 0, sizeof vis);\\n        int t =0;\\n        int ans =INT_MAX;\\n\\n        \\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            vector<bool> local(n+1, 0);\\n            for(int i=0;i<s;i++)\\n            {\\n                int cur = q.front();\\n                q.pop();\\n                \\n                vis[cur]++;\\n                \\n                if(cur==n)\\n                {\\n                    if(vis[cur]==1)\\n                    {\\n                        ans = min(ans, t);\\n                    }\\n                    else if(vis[cur]>1 && t>ans)\\n                    {\\n                        return t;\\n                    }\\n                }\\n\\n                for(int j=0;j<adj[cur].size();j++)\\n                {\\n                    if(!local[adj[cur][j]] && vis[adj[cur][j]]<2)\\n                    {\\n                        local[adj[cur][j]]=1;\\n                        q.push(adj[cur][j]);\\n                    }\\n                }\\n            }\\n            \\n            if((t/change)%2)\\n            {\\n                t+= change - t%change + time; \\n            }\\n            else\\n            {\\n                t += time;\\n            }\\n            \\n        }\\n        \\n        \\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525489,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        adj = defaultdict(list)\\n        # not visit after already visited twice, as it won\\'t be second minimum when 1 vertex visitied for third time.\\n        visited = defaultdict(set)\\n        for i, j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n            \\n        q = collections.deque([(0,1)])\\n        while q:\\n            t, node = q.popleft()\\n            if node == n and len(visited[n]) == 2:\\n                return max(visited[n])\\n            if (t // change) % 2 == 1:\\n                # red, wait\\n                t = (t // change + 1) * change\\n            t += time\\n            # now green, push nei\\n            for nei in adj[node]:\\n                if t in visited[nei] or len(visited[nei]) == 2:\\n                    continue\\n                else:\\n                    visited[nei].add(t)\\n                    q.append((t, nei))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        adj = defaultdict(list)\\n        # not visit after already visited twice, as it won\\'t be second minimum when 1 vertex visitied for third time.\\n        visited = defaultdict(set)\\n        for i, j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n            \\n        q = collections.deque([(0,1)])\\n        while q:\\n            t, node = q.popleft()\\n            if node == n and len(visited[n]) == 2:\\n                return max(visited[n])\\n            if (t // change) % 2 == 1:\\n                # red, wait\\n                t = (t // change + 1) * change\\n            t += time\\n            # now green, push nei\\n            for nei in adj[node]:\\n                if t in visited[nei] or len(visited[nei]) == 2:\\n                    continue\\n                else:\\n                    visited[nei].add(t)\\n                    q.append((t, nei))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525401,
                "title": "python-bfs",
                "content": "Using BFS, and for the second time we arrive at n, return the time.\\nFor each vertex, we only visit it at most twice, since we are finding the second minimum reach time.\\n\\n```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        q = deque([(1, 0)])\\n        first = -1\\n        visit_time = defaultdict(int)\\n        while q:\\n            u, t = q.popleft()\\n            if u == n:\\n                if first == -1:\\n                    first = t\\n                elif t > first:\\n                    return t\\n                \\n            if visit_time[u] == -1:\\n                continue\\n            if visit_time[u] == 0:\\n                visit_time[u] = t\\n            elif t > visit_time[u]:\\n                visit_time[u] = -1\\n\\n            for v in graph[u]:\\n                if visit_time[v] != -1:\\n                    if (t//change)%2 == 1:\\n                        wait_time = change - t%change\\n                        q.append((v, t+wait_time+time))\\n                    else:\\n                        q.append((v, t+time))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        q = deque([(1, 0)])\\n        first = -1\\n        visit_time = defaultdict(int)\\n        while q:\\n            u, t = q.popleft()\\n            if u == n:\\n                if first == -1:\\n                    first = t\\n                elif t > first:\\n                    return t\\n                \\n            if visit_time[u] == -1:\\n                continue\\n            if visit_time[u] == 0:\\n                visit_time[u] = t\\n            elif t > visit_time[u]:\\n                visit_time[u] = -1\\n\\n            for v in graph[u]:\\n                if visit_time[v] != -1:\\n                    if (t//change)%2 == 1:\\n                        wait_time = change - t%change\\n                        q.append((v, t+wait_time+time))\\n                    else:\\n                        q.append((v, t+time))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525291,
                "title": "java-dijkstra",
                "content": "import java.util.*;\\n\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        int m = edges.length;\\n        for(int i=0;i<m;i++) {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        PriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[1]-o2[1];\\n            }\\n        });\\n\\n        q.add(new int[]{1,0,0});\\n        int[] visited = new int[n+1];\\n\\n        int max=0;\\n\\n        while (!q.isEmpty()) {\\n\\n\\n            int[] a = q.poll();\\n\\n\\n            for (int i = 0; i < adj.get(a[0]).size(); i++) {\\n\\n                int u = adj.get(a[0]).get(i);\\n                int curr_time = a[1];\\n                visited[u]++;\\n\\n                int rem = a[1] / change;\\n                if (visited[u] <= 100) {\\n                    if (rem % 2 == 0) {\\n                        q.add(new int[]{u, a[1] + time});\\n                        if (max < a[1] + time && u == n) {\\n                            if (max != 0) {\\n                                return a[1] + time;\\n                            } else {\\n                                max = a[1] + time;\\n                            }\\n                        }\\n\\n                    } else {\\n                        int wait = a[1] % change;\\n                        wait = change - wait;\\n                        q.add(new int[]{u, a[1] + time + wait});\\n                        if (max < a[1] + time + wait && u == n) {\\n                            if (max != 0) {\\n                                return a[1] + time + wait;\\n                            } else {\\n                                max = a[1] + time + wait;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1525195,
                "title": "short-java-dijkstra-solution",
                "content": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int[] e : edges) {\\n            map.putIfAbsent(e[0], new HashSet<>());\\n            map.get(e[0]).add(e[1]);\\n            map.putIfAbsent(e[1], new HashSet<>());\\n            map.get(e[1]).add(e[0]);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n\\t\\tMap<Integer, Set<Integer>> visited = new HashMap<>();\\n        pq.offer(new int[]{1, 0});\\n        int prev = -1;\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int node = cur[0], t = cur[1]; \\n            if (node == n) {\\n                if (prev == -1 || t == prev) prev = t;\\n                else return t;\\n            } \\n            if (t % (2 * change) >= change)  // wait for green light\\n\\t\\t\\t    t += (2 * change - t % (2 * change));\\n            visited.putIfAbsent(node, new HashSet<>());\\n            if (!visited.get(node).add(t) || visited.get(node).size() >= 3) continue;\\n            if (map.containsKey(node)) {\\n                for (int next : map.get(node)) {\\n                    pq.offer(new int[]{next, t + time});\\n                }                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int[] e : edges) {\\n            map.putIfAbsent(e[0], new HashSet<>());\\n            map.get(e[0]).add(e[1]);\\n            map.putIfAbsent(e[1], new HashSet<>());\\n            map.get(e[1]).add(e[0]);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n\\t\\tMap<Integer, Set<Integer>> visited = new HashMap<>();\\n        pq.offer(new int[]{1, 0});\\n        int prev = -1;\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int node = cur[0], t = cur[1]; \\n            if (node == n) {\\n                if (prev == -1 || t == prev) prev = t;\\n                else return t;\\n            } \\n            if (t % (2 * change) >= change)  // wait for green light\\n\\t\\t\\t    t += (2 * change - t % (2 * change));\\n            visited.putIfAbsent(node, new HashSet<>());\\n            if (!visited.get(node).add(t) || visited.get(node).size() >= 3) continue;\\n            if (map.containsKey(node)) {\\n                for (int next : map.get(node)) {\\n                    pq.offer(new int[]{next, t + time});\\n                }                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525168,
                "title": "dijkstra-c",
                "content": "Classic second shortest path problem with a little modification.\\n\\n``` c++\\nstruct node {\\n    int id, dis;\\n    bool operator<(const node& a) const { return dis > a.dis; }\\n};\\n\\nclass Solution {\\n   public:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> g(n + 1);\\n        for (vector<int>& e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<vector<int>> dis(n + 1, vector<int>(2, INT_MAX));\\n        priority_queue<node> pq;\\n        pq.push({1, 0});\\n        \\n        while (!pq.empty()) {\\n            node u = pq.top();\\n            pq.pop();\\n\\n            if (u.dis < dis[u.id][0]) {\\n                swap(dis[u.id][0], dis[u.id][1]);\\n                dis[u.id][0] = u.dis;\\n            } else if (u.dis != dis[u.id][0] && u.dis < dis[u.id][1]) {\\n                dis[u.id][1] = u.dis;\\n            } else\\n                continue;\\n                \\n            for (int v : g[u.id]) {\\n                int seg = u.dis / change, d;\\n                if (seg & 1)\\n                    pq.push({v, (u.dis / change + 1) * change + time});\\n                else\\n                    pq.push({v, u.dis + time});\\n            }\\n        }\\n        return dis[n][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` c++\\nstruct node {\\n    int id, dis;\\n    bool operator<(const node& a) const { return dis > a.dis; }\\n};\\n\\nclass Solution {\\n   public:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> g(n + 1);\\n        for (vector<int>& e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<vector<int>> dis(n + 1, vector<int>(2, INT_MAX));\\n        priority_queue<node> pq;\\n        pq.push({1, 0});\\n        \\n        while (!pq.empty()) {\\n            node u = pq.top();\\n            pq.pop();\\n\\n            if (u.dis < dis[u.id][0]) {\\n                swap(dis[u.id][0], dis[u.id][1]);\\n                dis[u.id][0] = u.dis;\\n            } else if (u.dis != dis[u.id][0] && u.dis < dis[u.id][1]) {\\n                dis[u.id][1] = u.dis;\\n            } else\\n                continue;\\n                \\n            for (int v : g[u.id]) {\\n                int seg = u.dis / change, d;\\n                if (seg & 1)\\n                    pq.push({v, (u.dis / change + 1) * change + time});\\n                else\\n                    pq.push({v, u.dis + time});\\n            }\\n        }\\n        return dis[n][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051167,
                "title": "easier-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<int> adj[n+1];\\n        for(auto &e: edges){\\n            int u = e[0], v = e[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pqu;\\n        vector<vector<int> > dp(n+1, {(int)1e9, (int)1e9+1});\\n        \\n        pqu.push({0, 1});\\n        dp[1][0] = 0;\\n        \\n        while(!pqu.empty()){\\n            auto f = pqu.top(); pqu.pop();\\n            int d = f.first, u = f.second;\\n            \\n            int div = d/change;\\n            if(div%2){ // red\\n                d += (change - d%change);\\n            }\\n            \\n            for(int v: adj[u]){\\n                if(dp[v][1] > (d + time)){\\n                    if(dp[v][0] > (d + time)){ // min\\n                        dp[v][1] = dp[v][0];\\n                        dp[v][0] = (d + time);\\n                        pqu.push({dp[v][0], v});\\n                    }else if(dp[v][0] == (d + time)){ // skip                        \\n                    }else{ // secMin\\n                        dp[v][1] = (d + time);\\n                        pqu.push({dp[v][1], v});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return dp[n][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        \\n        vector<int> adj[n+1];\\n        for(auto &e: edges){\\n            int u = e[0], v = e[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pqu;\\n        vector<vector<int> > dp(n+1, {(int)1e9, (int)1e9+1});\\n        \\n        pqu.push({0, 1});\\n        dp[1][0] = 0;\\n        \\n        while(!pqu.empty()){\\n            auto f = pqu.top(); pqu.pop();\\n            int d = f.first, u = f.second;\\n            \\n            int div = d/change;\\n            if(div%2){ // red\\n                d += (change - d%change);\\n            }\\n            \\n            for(int v: adj[u]){\\n                if(dp[v][1] > (d + time)){\\n                    if(dp[v][0] > (d + time)){ // min\\n                        dp[v][1] = dp[v][0];\\n                        dp[v][0] = (d + time);\\n                        pqu.push({dp[v][0], v});\\n                    }else if(dp[v][0] == (d + time)){ // skip                        \\n                    }else{ // secMin\\n                        dp[v][1] = (d + time);\\n                        pqu.push({dp[v][1], v});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return dp[n][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040162,
                "title": "c-more-readable-oop",
                "content": "# Intuition\\nAt this level of complexity you would want a manageable, readable code, rather than just an algorithm-solving array-based solutions \\n\\n\"class Node\" represents a conceptual node in this problem, keeping track of how many times and when it has been visited\\n\\nMain loop is just a usual BFS as you can see in other solutions\\n\\n* Dijkstra would be an overkill as all cost is the same \\n\\n# Code\\n```\\n\\n// Representation of a node \\nclass Node {\\npublic:\\n    Node(int num) : _num (num) {}\\n\\n    void addEdge(Node* node) {\\n        _edges.push_back(node);\\n    }\\n\\n    const vector<Node*>& getEdges() const {\\n        return _edges;\\n    }\\n\\n    void visit(const int time) {\\n        if (!_visitedTimes.empty() && _visitedTimes.back() == time) {\\n           // Do not record the same time multiple times. We need to get \\'second-best\\' time\\n           return;\\n        }\\n        _visitedTimes.push_back(time);\\n    }\\n\\n    bool canVisit() const {\\n        return _visitedTimes.size() < MaxVisits;\\n    }\\n\\n    int getNum() const {\\n        return _num;\\n    }\\n\\nprivate:\\n    static const int MaxVisits = 2;\\n    const int _num;\\n\\n    vector<Node*> _edges;\\n\\n    // Remember how many times this node has been visited. \\n    // Allow only 2 different times as we need the second best answer\\n    vector<int> _visitedTimes;\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        buildNodes(edges);\\n\\n        int firstTime = 0;\\n        int curTime = 0;\\n\\n        queue<Node*> q;\\n        Node* head = _nodes[1];\\n        head->visit(curTime);\\n        q.push(head);\\n\\n        // Breadth-first search\\n        while (!q.empty()) {\\n            curTime = adjustTime(curTime, change);\\n            const int arrivalTime = curTime + time;\\n            const int qCount = (int) q.size(); // queue count for this given time\\n\\n            // through all the nodes being visited at [curTime]\\n            for (int i = 0; i < qCount; i ++) {\\n                Node* node = q.front(); q.pop();\\n\\n                // through all target nodes to be visited at [arrivalTime]\\n                for (Node* edge : node->getEdges()) {\\n\\n                    // Check if it\\'s possible to visit (only allowed 2 different times)\\n                    if (edge->canVisit()) {\\n\\n                        // Check if we\\'re at the goal!\\n                        if (edge->getNum() == n) {\\n                            if (firstTime == 0) {\\n                                firstTime = arrivalTime;\\n                            } else if (arrivalTime > firstTime) { // Found!!\\n                                return arrivalTime;\\n                            }\\n                        }\\n\\n                        edge->visit(arrivalTime);\\n                        q.push(edge);\\n                    } \\n                }\\n            }\\n            curTime = arrivalTime;\\n        }\\n\\n        // Failure - shouldn\\'t happen\\n        return -1;\\n    }\\nprivate:\\n    map<int, Node*> _nodes;\\n\\n    int adjustTime(int curTime, const int change) {\\n\\n        if ((curTime / change) % 2 == 0) {\\n            return curTime;\\n        }\\n\\n        return (curTime + change) / change * change;\\n    }\\n\\n    void buildNodes(const vector<vector<int>>& edges) {\\n        for (const vector<int>& edge : edges) {\\n            Node* node1 = createOrGetNode(edge.front());\\n            Node* node2 = createOrGetNode(edge.back());\\n            node1->addEdge(node2);\\n            node2->addEdge(node1);\\n        }\\n    }\\n\\n    Node* createOrGetNode(const int num) {\\n        if (auto ite = _nodes.find(num); ite != _nodes.end()) {\\n            return ite->second;\\n        }\\n        auto node = new Node(num);\\n        _nodes[num] = node;\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// Representation of a node \\nclass Node {\\npublic:\\n    Node(int num) : _num (num) {}\\n\\n    void addEdge(Node* node) {\\n        _edges.push_back(node);\\n    }\\n\\n    const vector<Node*>& getEdges() const {\\n        return _edges;\\n    }\\n\\n    void visit(const int time) {\\n        if (!_visitedTimes.empty() && _visitedTimes.back() == time) {\\n           // Do not record the same time multiple times. We need to get \\'second-best\\' time\\n           return;\\n        }\\n        _visitedTimes.push_back(time);\\n    }\\n\\n    bool canVisit() const {\\n        return _visitedTimes.size() < MaxVisits;\\n    }\\n\\n    int getNum() const {\\n        return _num;\\n    }\\n\\nprivate:\\n    static const int MaxVisits = 2;\\n    const int _num;\\n\\n    vector<Node*> _edges;\\n\\n    // Remember how many times this node has been visited. \\n    // Allow only 2 different times as we need the second best answer\\n    vector<int> _visitedTimes;\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        buildNodes(edges);\\n\\n        int firstTime = 0;\\n        int curTime = 0;\\n\\n        queue<Node*> q;\\n        Node* head = _nodes[1];\\n        head->visit(curTime);\\n        q.push(head);\\n\\n        // Breadth-first search\\n        while (!q.empty()) {\\n            curTime = adjustTime(curTime, change);\\n            const int arrivalTime = curTime + time;\\n            const int qCount = (int) q.size(); // queue count for this given time\\n\\n            // through all the nodes being visited at [curTime]\\n            for (int i = 0; i < qCount; i ++) {\\n                Node* node = q.front(); q.pop();\\n\\n                // through all target nodes to be visited at [arrivalTime]\\n                for (Node* edge : node->getEdges()) {\\n\\n                    // Check if it\\'s possible to visit (only allowed 2 different times)\\n                    if (edge->canVisit()) {\\n\\n                        // Check if we\\'re at the goal!\\n                        if (edge->getNum() == n) {\\n                            if (firstTime == 0) {\\n                                firstTime = arrivalTime;\\n                            } else if (arrivalTime > firstTime) { // Found!!\\n                                return arrivalTime;\\n                            }\\n                        }\\n\\n                        edge->visit(arrivalTime);\\n                        q.push(edge);\\n                    } \\n                }\\n            }\\n            curTime = arrivalTime;\\n        }\\n\\n        // Failure - shouldn\\'t happen\\n        return -1;\\n    }\\nprivate:\\n    map<int, Node*> _nodes;\\n\\n    int adjustTime(int curTime, const int change) {\\n\\n        if ((curTime / change) % 2 == 0) {\\n            return curTime;\\n        }\\n\\n        return (curTime + change) / change * change;\\n    }\\n\\n    void buildNodes(const vector<vector<int>>& edges) {\\n        for (const vector<int>& edge : edges) {\\n            Node* node1 = createOrGetNode(edge.front());\\n            Node* node2 = createOrGetNode(edge.back());\\n            node1->addEdge(node2);\\n            node2->addEdge(node1);\\n        }\\n    }\\n\\n    Node* createOrGetNode(const int num) {\\n        if (auto ite = _nodes.find(num); ite != _nodes.end()) {\\n            return ite->second;\\n        }\\n        auto node = new Node(num);\\n        _nodes[num] = node;\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001056,
                "title": "100-solution-modified-bfs-k-1-or-k-2",
                "content": "**Motivation**\\nSuppose the shortest path from `\"1\"` to `\"n\"` is \"1->2->...->n\" with length k. We can simply add a length-2-loop in this path and achieve a path \"1 **->2->1->** 2->...->n\" with length k+2. As a result, there are only **2 options** for the second minimum distance: **\"k+1\"** or **\"k+2\"**. Actually, we just need to check whether it is ok to have a \"k+1\" path. The remainning part is a litte trick with respect to \"`time`\" and \"`change`\".\\n\\n***NOTE:*** @votrubac has provided a post to share a similar idea.  https://leetcode.com/problems/second-minimum-time-to-reach-destination/discuss/1525154/No-Dijkstra%3A-(n-%2B-1)-or-(n-%2B-2)  \\n***NOTE:*** We prepare this post to show a different method to check whether **k+1** works.\\n\\n**Algorithm**\\nRecall that all edges are equal length, we can use breath-first-search (BFS) to find the minimum distance between `1` and all other node `x` where `1<x<n+1`. For the ease of discussion, we denote the distance from `1` to `x` as `dist[x]`. Appearently, `dist[1]=0`.\\n\\nHere, we would like to verify whether it is possible that `dist[n]+1` would be the second minimum distance. Again, we use `plus[x]=true/false` to denote the result. And, `plus[1]=false`. Now, let\\'s considering what makes `plus[x]` be `true`. We have found two cases.\\n1. **\"inherit\"**: `dist[a]<dist[b]` and `plus[a]==true`, we have the edge `{a,b}`. Then, `dist[b]=dist[a]+1`  and `plus[b]=true`.\\n2. **\"loop\"**: `dist[a]==dist[b]`, we have the edge `{a,b}`. Then, both `plus[a]` and `plus[b]` would be `true`.\\n\\nWe would like to embed such verification into the normal BFS. FYI, the distance will increase during the BFS, the second case should be processed before passing the result as shown in the first case. Therefore, we visit the buffered nodes twice. The first pass is dedicated to cope with \"loop\" and the second pass is as normal.\\n\\n**Complexity**\\n```\\nTime: O(V+E)\\nSpace: O(V+E)\\n```\\n\\n**Performance**\\n```\\nRuntime: 409 ms, faster than 100.00% of C++ online submissions for Second Minimum Time to Reach Destination.\\nMemory Usage: 179.3 MB, less than 87.54% of C++ online submissions for Second Minimum Time to Reach Destination.\\n```\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d;\\n        int m=edges.size(), ans=0;\\n        vector<int>  dist(n, INT_MAX);\\n        vector<bool> plus(n, false);\\n        vector<vector<int>> conn(n);\\n        queue<int> buf;\\n        for(int i=0; i<m; ++i) {\\n            conn[edges[i][0]-1].emplace_back(edges[i][1]-1);\\n            conn[edges[i][1]-1].emplace_back(edges[i][0]-1);\\n        }\\n        buf.push(0);\\n        dist[0]=0;\\n        for(int cur, d=1, k=buf.size(); k && dist[n-1]>=d-1; ++d, k=buf.size()) {\\n            for(; k; --k) {\\n                cur=buf.front();\\n                buf.pop();\\n                buf.push(cur);\\n                for(int next : conn[cur]) {\\n                    if(dist[next]==d-1) {\\n                        plus[next]=true;\\n                    }\\n                }\\n            }\\n            for(k=buf.size(); k; --k, buf.pop()) {\\n                cur=buf.front();\\n                for(int next : conn[cur]) {\\n                    if(dist[next]>=d) {\\n                        if(dist[next]>d) {\\n                            buf.push(next);\\n                            dist[next]=d;\\n                        }\\n                        plus[next]=plus[next] || plus[cur];\\n                    }\\n                }\\n            }\\n        }\\n        for(int k=dist[n-1]+ (plus[n-1]? 1 : 2); k; ans+=time, --k) {\\n            d=div(ans, change);\\n            if(d.quot&1) {//red\\n                ans+=change-d.rem;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nTime: O(V+E)\\nSpace: O(V+E)\\n```\n```\\nRuntime: 409 ms, faster than 100.00% of C++ online submissions for Second Minimum Time to Reach Destination.\\nMemory Usage: 179.3 MB, less than 87.54% of C++ online submissions for Second Minimum Time to Reach Destination.\\n```\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d;\\n        int m=edges.size(), ans=0;\\n        vector<int>  dist(n, INT_MAX);\\n        vector<bool> plus(n, false);\\n        vector<vector<int>> conn(n);\\n        queue<int> buf;\\n        for(int i=0; i<m; ++i) {\\n            conn[edges[i][0]-1].emplace_back(edges[i][1]-1);\\n            conn[edges[i][1]-1].emplace_back(edges[i][0]-1);\\n        }\\n        buf.push(0);\\n        dist[0]=0;\\n        for(int cur, d=1, k=buf.size(); k && dist[n-1]>=d-1; ++d, k=buf.size()) {\\n            for(; k; --k) {\\n                cur=buf.front();\\n                buf.pop();\\n                buf.push(cur);\\n                for(int next : conn[cur]) {\\n                    if(dist[next]==d-1) {\\n                        plus[next]=true;\\n                    }\\n                }\\n            }\\n            for(k=buf.size(); k; --k, buf.pop()) {\\n                cur=buf.front();\\n                for(int next : conn[cur]) {\\n                    if(dist[next]>=d) {\\n                        if(dist[next]>d) {\\n                            buf.push(next);\\n                            dist[next]=d;\\n                        }\\n                        plus[next]=plus[next] || plus[cur];\\n                    }\\n                }\\n            }\\n        }\\n        for(int k=dist[n-1]+ (plus[n-1]? 1 : 2); k; ans+=time, --k) {\\n            d=div(ans, change);\\n            if(d.quot&1) {//red\\n                ans+=change-d.rem;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982371,
                "title": "rust-generalized-dijkstra-algorithm",
                "content": "# Intuition\\n\\nThe relation between the number of edges in a path and its travel time is an injective, increasing function. Basically, finding the route with the least travel time == finding the route with minimum edges.\\n\\n# Approach\\n\\n**Dijkstra\\'s Algorithm** is commonly used for finding the shortest path.\\n\\nHowever, we need to find the route with the **second-smallest** number of edges. Which means we need to generalize Dijkstra\\'s Algorithm to maintain a list of `k` shortest paths for each destination vertex. A **BTreeSet** can be used to keep track of `k` shortest paths with unique number of edges.\\n\\n(In this question `k` is equal to 2, so using an ordered set is overkill. But what if it needs the 3rd shortest path? The 10th? A BTreeSet solution in this case also work for `k>2`)\\n\\n# Complexity\\n- Time complexity:\\n$$O(V \\\\log (V + k) + E)$$\\n\\n- Space complexity:\\n$$O(V + E)$$\\n\\n# Code\\n```rust\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\nuse std::collections::BTreeSet;\\n\\n// Given a weighted directed graph,\\n//   returns the `k`-th minimum unique distances from `src` to\\n//   every vertices in the graph.\\n// Parameters:\\n//   `graph`: adjacency list for the graph\\n//   `src`: source vertex\\n//   `n`: number of vertices\\n//   `k`: the number of minimum distances to track\\npub fn dijkstra_kth_unique(\\n    graph: Vec<Vec<(usize, u32)>>,\\n    src: usize,\\n    n: usize,\\n    k: usize,\\n) -> Vec<Vec<u64>> {\\n    assert!(src < n, \"source vertex outside graph\");\\n\\n    let mut ret = vec![BTreeSet::new(); n]; // max-heap\\n    ret[src].insert(u64::MIN);\\n\\n    let mut heap = BinaryHeap::new(); // min-heap\\n    heap.push(Reverse((u64::MIN, src)));\\n\\n    while let Some(Reverse((dist, vertex))) = heap.pop() {\\n        for &(vertex_next, weight) in &graph[vertex] {\\n            let dist_next = dist + weight as u64;\\n            let ret_set = &mut ret[vertex_next];\\n            if ret_set.contains(&dist_next) {\\n                continue; // already reached\\n            }\\n\\n            if ret_set.len() >= k {\\n                if let Some(dist_max) = ret_set.iter().rev().next().cloned() {\\n                    if dist_max <= dist_next {\\n                        continue; // heap is full, abort\\n                    }\\n                }\\n            }\\n\\n            ret_set.insert(dist_next);\\n            while ret_set.len() > k {\\n                let dist_max = ret_set.iter().rev().next().cloned().unwrap();\\n                ret_set.remove(&dist_max);\\n            }\\n\\n            heap.push(Reverse((dist_next, vertex_next)));\\n        }\\n    }\\n\\n    ret.into_iter()\\n        .map(|v| {\\n            let mut v = v.into_iter().collect::<Vec<_>>();\\n            v.sort_unstable();\\n            v\\n        })\\n        .collect::<Vec<_>>()\\n}\\n\\npub fn undirected_edges_to_graph(\\n    edges: Vec<Vec<i32>>,\\n    n: usize,\\n) -> Vec<Vec<(usize, u32)>> {\\n    let mut ret = vec![vec![]; n];\\n    for v in edges {\\n        assert!(v.len() >= 2, \"malformed input\");\\n        let v0 = v[0] as usize - 1;\\n        let v1 = v[1] as usize - 1;\\n\\n        ret[v0].push((v1, 1u32));\\n        ret[v1].push((v0, 1u32));\\n    }\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn second_minimum(n: i32, edges: Vec<Vec<i32>>, time: i32, change: i32) -> i32 {\\n        let n = n as usize;\\n        let src = usize::MIN;\\n        let dst = n - 1;\\n        let weight = time as u32;\\n        let switch_interval = change as u32;\\n\\n        let graph = undirected_edges_to_graph(edges, n);\\n\\n        let dist_vec = dijkstra_kth_unique(\\n            graph, src, n, 2,\\n        );\\n\\n        let num_edges = dist_vec[dst][1];\\n\\n        let mut ts = u32::MIN;\\n        for _ in 0..num_edges {\\n            let num_switches = ts / switch_interval;\\n            if num_switches % 2 > 0 {\\n                ts = (num_switches + 1) * switch_interval;\\n            }\\n\\n            ts += weight;\\n        }\\n\\n        ts as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\nuse std::collections::BTreeSet;\\n\\n// Given a weighted directed graph,\\n//   returns the `k`-th minimum unique distances from `src` to\\n//   every vertices in the graph.\\n// Parameters:\\n//   `graph`: adjacency list for the graph\\n//   `src`: source vertex\\n//   `n`: number of vertices\\n//   `k`: the number of minimum distances to track\\npub fn dijkstra_kth_unique(\\n    graph: Vec<Vec<(usize, u32)>>,\\n    src: usize,\\n    n: usize,\\n    k: usize,\\n) -> Vec<Vec<u64>> {\\n    assert!(src < n, \"source vertex outside graph\");\\n\\n    let mut ret = vec![BTreeSet::new(); n]; // max-heap\\n    ret[src].insert(u64::MIN);\\n\\n    let mut heap = BinaryHeap::new(); // min-heap\\n    heap.push(Reverse((u64::MIN, src)));\\n\\n    while let Some(Reverse((dist, vertex))) = heap.pop() {\\n        for &(vertex_next, weight) in &graph[vertex] {\\n            let dist_next = dist + weight as u64;\\n            let ret_set = &mut ret[vertex_next];\\n            if ret_set.contains(&dist_next) {\\n                continue; // already reached\\n            }\\n\\n            if ret_set.len() >= k {\\n                if let Some(dist_max) = ret_set.iter().rev().next().cloned() {\\n                    if dist_max <= dist_next {\\n                        continue; // heap is full, abort\\n                    }\\n                }\\n            }\\n\\n            ret_set.insert(dist_next);\\n            while ret_set.len() > k {\\n                let dist_max = ret_set.iter().rev().next().cloned().unwrap();\\n                ret_set.remove(&dist_max);\\n            }\\n\\n            heap.push(Reverse((dist_next, vertex_next)));\\n        }\\n    }\\n\\n    ret.into_iter()\\n        .map(|v| {\\n            let mut v = v.into_iter().collect::<Vec<_>>();\\n            v.sort_unstable();\\n            v\\n        })\\n        .collect::<Vec<_>>()\\n}\\n\\npub fn undirected_edges_to_graph(\\n    edges: Vec<Vec<i32>>,\\n    n: usize,\\n) -> Vec<Vec<(usize, u32)>> {\\n    let mut ret = vec![vec![]; n];\\n    for v in edges {\\n        assert!(v.len() >= 2, \"malformed input\");\\n        let v0 = v[0] as usize - 1;\\n        let v1 = v[1] as usize - 1;\\n\\n        ret[v0].push((v1, 1u32));\\n        ret[v1].push((v0, 1u32));\\n    }\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn second_minimum(n: i32, edges: Vec<Vec<i32>>, time: i32, change: i32) -> i32 {\\n        let n = n as usize;\\n        let src = usize::MIN;\\n        let dst = n - 1;\\n        let weight = time as u32;\\n        let switch_interval = change as u32;\\n\\n        let graph = undirected_edges_to_graph(edges, n);\\n\\n        let dist_vec = dijkstra_kth_unique(\\n            graph, src, n, 2,\\n        );\\n\\n        let num_edges = dist_vec[dst][1];\\n\\n        let mut ts = u32::MIN;\\n        for _ in 0..num_edges {\\n            let num_switches = ts / switch_interval;\\n            if num_switches % 2 > 0 {\\n                ts = (num_switches + 1) * switch_interval;\\n            }\\n\\n            ts += weight;\\n        }\\n\\n        ts as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980171,
                "title": "bfs-easy-c",
                "content": "BFS can come to rescue us whenever the edge weights are same so instead of applying dijikstra we can use bfs its little easy \\nnow we talk step wise i want the second minimum dist from 1 to n\\ngoing on step 1 we can create a adjcancy list\\nstep 2 intilizing dist1 and dist2 array \\nstep 3 initallizing the queue to start with given node 1 now here i am taking a pair to check whether this node is coming for the first time or second time if i am coming for first time i will compute the dis1 for this since this will be the minimum dis and if my dis1 is computed then i can go for dis2 and update its calculations \\nstep 4 now coming to the node since each edge will take t time and if you reached on red lite time then extra time will be added the wait time after this we will go to neighbour or childs the main thing here was if we encounter the node for the first time we will update the dis1 and if we come to this node second time we will update dis2 one more thing it should be greater than the dis1 then only we will update it the main thing was this and as soon we reach the n for second time we will return dis2\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n       vector<int> adj[n+1];\\n       // step 1\\n       for(int i=0; i<edges.size(); i++){\\n           int x=edges[i][0];\\n           int y=edges[i][1];\\n           adj[x].push_back(y);\\n           adj[y].push_back(x);\\n       }\\n       // step 2\\n       vector<int> dis1(n+1,-1);\\n       vector<int> dis2(n+1,-1);\\n       // step 3\\n       queue<pair<int,int>> q;\\n       q.push({1,1});\\n       dis1[1]=0;\\n       // step 4\\n       while(!q.empty()){\\n           auto it=q.front();\\n           q.pop();\\n           int node=it.first;\\n           int frq=it.second;\\n           int tt=(frq==1? dis1[node]: dis2[node]);\\n           if((tt/change)%2){\\n               tt=change*(tt/change+1)+time;\\n           }else{\\n               tt=tt+time;\\n           }\\n\\n           for(int child:adj[node]){\\n               if(dis1[child]==-1){\\n                   dis1[child]=tt;\\n                   q.push({child,1});\\n               }else if(dis2[child]==-1 && dis1[child]!=tt){\\n                   if(child==n) return tt;\\n                   dis2[child]=tt;\\n                   q.push({child,2});\\n               }\\n           }\\n           \\n       }\\n       return 0;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n       vector<int> adj[n+1];\\n       // step 1\\n       for(int i=0; i<edges.size(); i++){\\n           int x=edges[i][0];\\n           int y=edges[i][1];\\n           adj[x].push_back(y);\\n           adj[y].push_back(x);\\n       }\\n       // step 2\\n       vector<int> dis1(n+1,-1);\\n       vector<int> dis2(n+1,-1);\\n       // step 3\\n       queue<pair<int,int>> q;\\n       q.push({1,1});\\n       dis1[1]=0;\\n       // step 4\\n       while(!q.empty()){\\n           auto it=q.front();\\n           q.pop();\\n           int node=it.first;\\n           int frq=it.second;\\n           int tt=(frq==1? dis1[node]: dis2[node]);\\n           if((tt/change)%2){\\n               tt=change*(tt/change+1)+time;\\n           }else{\\n               tt=tt+time;\\n           }\\n\\n           for(int child:adj[node]){\\n               if(dis1[child]==-1){\\n                   dis1[child]=tt;\\n                   q.push({child,1});\\n               }else if(dis2[child]==-1 && dis1[child]!=tt){\\n                   if(child==n) return tt;\\n                   dis2[child]=tt;\\n                   q.push({child,2});\\n               }\\n           }\\n           \\n       }\\n       return 0;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967241,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& e, int t, int c) {   vector<vector<int>>adj(n+1);\\n    for(int i=0;i<e.size();i++){\\n        adj[e[i][0]].push_back(e[i][1]);\\n        adj[e[i][1]].push_back(e[i][0]);\\n    }\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>p;\\n  p.push({0,1});int cnt=0,ans=0;\\n  vector<int>vis(n+1,0);\\n  while(!p.empty()){\\n    int val=p.top().first;\\n    int node=p.top().second;\\n    p.pop();\\n    int d=val/c;\\n    if(node==n){\\n        if(cnt==0){\\n            ans=val;cnt++;\\n        }\\n        else if(val!=ans){\\n            return val; \\n        }\\n    }\\n    if(vis[node]==10 && node!=n)continue;\\n    vis[node]++;\\n    if(d%2!=0 ){\\n        val+=(c-val%c);\\n    }\\n    for(auto it:adj[node]){\\n        if(vis[it]<10){\\n            p.push({val+t,it});\\n        }\\n    }\\n\\n  }\\n  return 0;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& e, int t, int c) {   vector<vector<int>>adj(n+1);\\n    for(int i=0;i<e.size();i++){\\n        adj[e[i][0]].push_back(e[i][1]);\\n        adj[e[i][1]].push_back(e[i][0]);\\n    }\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>p;\\n  p.push({0,1});int cnt=0,ans=0;\\n  vector<int>vis(n+1,0);\\n  while(!p.empty()){\\n    int val=p.top().first;\\n    int node=p.top().second;\\n    p.pop();\\n    int d=val/c;\\n    if(node==n){\\n        if(cnt==0){\\n            ans=val;cnt++;\\n        }\\n        else if(val!=ans){\\n            return val; \\n        }\\n    }\\n    if(vis[node]==10 && node!=n)continue;\\n    vis[node]++;\\n    if(d%2!=0 ){\\n        val+=(c-val%c);\\n    }\\n    for(auto it:adj[node]){\\n        if(vis[it]<10){\\n            p.push({val+t,it});\\n        }\\n    }\\n\\n  }\\n  return 0;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905610,
                "title": "easy-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>>vp(n);\\n\\n        for(auto it:edges){\\n            vp[it[0]-1].push_back(it[1]-1);\\n            vp[it[1]-1].push_back(it[0]-1);\\n\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        vector<pair<int,int>>mindis(n);\\n        for(int i=0;i<n;i++){\\n            mindis[i].first=INT_MAX;\\n            mindis[i].second=INT_MAX;\\n        }\\n\\n        pq.push({0,0});\\n        while(pq.size()>0){\\n            int node=pq.top().second;\\n            int dis=pq.top().first;\\n            pq.pop();\\n            // int k=2*change;\\n            // int \\n            int k=dis/change;\\n           int newdis=dis+time;\\n            if(k%2==1)\\n            newdis+=(change-dis%change);\\n\\n            for(auto it:vp[node]){\\n                if(mindis[it].first>newdis){\\n                    mindis[it].second=mindis[it].first;\\n                    mindis[it].first=newdis;\\n                    pq.push({mindis[it].first,it});\\n                }\\n                else if(mindis[it].first<newdis&&mindis[it].second>newdis){\\n                    mindis[it].second=newdis;\\n                    pq.push({mindis[it].second,it});\\n                }\\n            }\\n        }\\n        return mindis[n-1].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>>vp(n);\\n\\n        for(auto it:edges){\\n            vp[it[0]-1].push_back(it[1]-1);\\n            vp[it[1]-1].push_back(it[0]-1);\\n\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        vector<pair<int,int>>mindis(n);\\n        for(int i=0;i<n;i++){\\n            mindis[i].first=INT_MAX;\\n            mindis[i].second=INT_MAX;\\n        }\\n\\n        pq.push({0,0});\\n        while(pq.size()>0){\\n            int node=pq.top().second;\\n            int dis=pq.top().first;\\n            pq.pop();\\n            // int k=2*change;\\n            // int \\n            int k=dis/change;\\n           int newdis=dis+time;\\n            if(k%2==1)\\n            newdis+=(change-dis%change);\\n\\n            for(auto it:vp[node]){\\n                if(mindis[it].first>newdis){\\n                    mindis[it].second=mindis[it].first;\\n                    mindis[it].first=newdis;\\n                    pq.push({mindis[it].first,it});\\n                }\\n                else if(mindis[it].first<newdis&&mindis[it].second>newdis){\\n                    mindis[it].second=newdis;\\n                    pq.push({mindis[it].second,it});\\n                }\\n            }\\n        }\\n        return mindis[n-1].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904995,
                "title": "c-solution-graph-bfs-modified-dijkstra-s-algorithm",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(E.log(n))$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>>graph(n+1);\\n        for(auto it : edges){\\n          graph[it[0]].push_back(it[1]);\\n          graph[it[1]].push_back(it[0]);\\n        }\\n        vector<int>totaltime(n+1, INT_MAX);\\n        vector<int>repeat(n+1,0);\\n        \\n        totaltime[1]=0;\\n        repeat[1]=1;\\n        priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int,int>>>pq;\\n        pq.push({totaltime[1], 1});\\n        int wait = 0;\\n        while(!pq.empty()){\\n          int tm = pq.top().first, node = pq.top().second;\\n          pq.pop();\\n\\n          for(auto it : graph[node]){\\n            if((tm/change)%2 == 1){\\n              tm = ((tm/change)+1)*change;\\n            }\\n            int newtime = tm + time;\\n            if(repeat[it]==0 || repeat[it]==1){\\n              if(newtime != totaltime[it]){\\n                repeat[it]++;\\n              }\\n              totaltime[it] = newtime;\\n              pq.push({newtime , it});\\n              if(repeat[n]==2){\\n                return totaltime[n];\\n              }\\n            }\\n            \\n          }\\n        }\\n        return totaltime[n];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>>graph(n+1);\\n        for(auto it : edges){\\n          graph[it[0]].push_back(it[1]);\\n          graph[it[1]].push_back(it[0]);\\n        }\\n        vector<int>totaltime(n+1, INT_MAX);\\n        vector<int>repeat(n+1,0);\\n        \\n        totaltime[1]=0;\\n        repeat[1]=1;\\n        priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int,int>>>pq;\\n        pq.push({totaltime[1], 1});\\n        int wait = 0;\\n        while(!pq.empty()){\\n          int tm = pq.top().first, node = pq.top().second;\\n          pq.pop();\\n\\n          for(auto it : graph[node]){\\n            if((tm/change)%2 == 1){\\n              tm = ((tm/change)+1)*change;\\n            }\\n            int newtime = tm + time;\\n            if(repeat[it]==0 || repeat[it]==1){\\n              if(newtime != totaltime[it]){\\n                repeat[it]++;\\n              }\\n              totaltime[it] = newtime;\\n              pq.push({newtime , it});\\n              if(repeat[n]==2){\\n                return totaltime[n];\\n              }\\n            }\\n            \\n          }\\n        }\\n        return totaltime[n];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836776,
                "title": "simple-bfs-in-python-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, a vertex can be visited more than one time. In fact, only the first two visits should be considered since the goal is to find the second shortest path. This is the key to solve this problem efficiently. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem can solved by a slightly revised BFS graph traversal algorithm. A state in the search space is $(v, t, r)$, where $v$ is the current staying vertex, $t$ is the time to leave $v$, and $r$ is the times of $v$ being visited. \\nOnly the first time and the second time of visits should be considered, so all the state with $r>2$ can be ignored. As a result, the size of the search space is only $2 \\\\times |V|$, which is manageable.\\n\\n# Complexity\\n- Time complexity: $$O(|E| + |V|)$$, where $|E|$ is the number of edges and $|V|$ is the number of vertices. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(|E| + |V|)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[v].add(u)\\n            graph[u].add(v)\\n\\n        ans = inf\\n        q = deque([(1, 0)])\\n        visited = defaultdict(set)\\n        visited[1].add(0)\\n\\n        while q:\\n            v, t = q.popleft()\\n            next_t = t + time\\n            if next_t // change % 2 == 1:\\n                next_t = (next_t // change + 1) * change\\n            for u in graph[v]:\\n                if u == n:\\n                    if ans == inf:\\n                        ans = t + time\\n                    elif t + time > ans:\\n                        return t + time\\n                if len(visited[u]) < 2 and next_t not in visited[u]:\\n                    visited[u].add(next_t)\\n                    q.append((u, next_t))\\n        return -1\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[v].add(u)\\n            graph[u].add(v)\\n\\n        ans = inf\\n        q = deque([(1, 0)])\\n        visited = defaultdict(set)\\n        visited[1].add(0)\\n\\n        while q:\\n            v, t = q.popleft()\\n            next_t = t + time\\n            if next_t // change % 2 == 1:\\n                next_t = (next_t // change + 1) * change\\n            for u in graph[v]:\\n                if u == n:\\n                    if ans == inf:\\n                        ans = t + time\\n                    elif t + time > ans:\\n                        return t + time\\n                if len(visited[u]) < 2 and next_t not in visited[u]:\\n                    visited[u].add(next_t)\\n                    q.append((u, next_t))\\n        return -1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640360,
                "title": "o-n-bfs-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int time;\\n    int change;\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        int m=edges.size();\\n        vector<vector<int>> adj(n+1);\\n        vector<int> vis(n+1,0);\\n         vector<int> wt(n+1,-1);\\n        for(int i=0;i<m;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,1});\\n        vis[1]++;\\n        int ans=0;\\n        while(!pq.empty()){\\n            pair<int,int> temp=pq.top();\\n            pq.pop();\\n            for(auto x:adj[temp.second]){\\n                if(vis[x]>1)\\n                continue;\\n                \\n                int tk=(temp.first+time);\\n                if(x==n){ \\n                    ans=tk;\\n                    // if(vis[x]==1)\\n                    // return ans;\\n                }\\n                if((tk/change)%2==1){\\n                    tk=((tk/change)+1)*change;\\n                }\\n                if(wt[x]<tk){\\n                     wt[x]=tk;\\n                     vis[x]++;\\n                     pq.push({tk,x});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int time;\\n    int change;\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        int m=edges.size();\\n        vector<vector<int>> adj(n+1);\\n        vector<int> vis(n+1,0);\\n         vector<int> wt(n+1,-1);\\n        for(int i=0;i<m;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,1});\\n        vis[1]++;\\n        int ans=0;\\n        while(!pq.empty()){\\n            pair<int,int> temp=pq.top();\\n            pq.pop();\\n            for(auto x:adj[temp.second]){\\n                if(vis[x]>1)\\n                continue;\\n                \\n                int tk=(temp.first+time);\\n                if(x==n){ \\n                    ans=tk;\\n                    // if(vis[x]==1)\\n                    // return ans;\\n                }\\n                if((tk/change)%2==1){\\n                    tk=((tk/change)+1)*change;\\n                }\\n                if(wt[x]<tk){\\n                     wt[x]=tk;\\n                     vis[x]++;\\n                     pq.push({tk,x});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580789,
                "title": "c-modified-dijkstra-s-to-allow-revisits",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adjList(n+1);\\n        for (auto& e: edges) {\\n            adjList[e[0]].push_back(e[1]);\\n            adjList[e[1]].push_back(e[0]);\\n        }\\n\\n        priority_queue<\\n            pair<int, int>,\\n            vector<pair<int, int>>,\\n            greater<>> q;\\n        vector<int> visited1(n+1, -1);\\n        vector<int> visited2(n+1, -1);\\n        q.push({ 0, 1 });\\n        while (!q.empty()) {\\n            auto [ elapsed, node ] = q.top();\\n            q.pop();\\n            // div : time elapse/change\\n            // if even -> green\\n            // if odd  -> red\\n            // if red -> round up to next change\\n            int div = elapsed / change;\\n            if (div & 1) {\\n                elapsed = change * (div + 1);\\n            }\\n            elapsed += time;\\n\\n            for (auto& nei: adjList[node]) {\\n                if (visited2[nei] != -1) continue;\\n                if (visited1[nei] == -1) {\\n                    visited1[nei] = elapsed;\\n                } else if (elapsed > visited1[nei]){\\n                    if (nei == n) return elapsed;\\n                    visited2[nei] = elapsed;\\n                } else {\\n                    continue;\\n                }\\n                q.push({ elapsed, nei });\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adjList(n+1);\\n        for (auto& e: edges) {\\n            adjList[e[0]].push_back(e[1]);\\n            adjList[e[1]].push_back(e[0]);\\n        }\\n\\n        priority_queue<\\n            pair<int, int>,\\n            vector<pair<int, int>>,\\n            greater<>> q;\\n        vector<int> visited1(n+1, -1);\\n        vector<int> visited2(n+1, -1);\\n        q.push({ 0, 1 });\\n        while (!q.empty()) {\\n            auto [ elapsed, node ] = q.top();\\n            q.pop();\\n            // div : time elapse/change\\n            // if even -> green\\n            // if odd  -> red\\n            // if red -> round up to next change\\n            int div = elapsed / change;\\n            if (div & 1) {\\n                elapsed = change * (div + 1);\\n            }\\n            elapsed += time;\\n\\n            for (auto& nei: adjList[node]) {\\n                if (visited2[nei] != -1) continue;\\n                if (visited1[nei] == -1) {\\n                    visited1[nei] = elapsed;\\n                } else if (elapsed > visited1[nei]){\\n                    if (nei == n) return elapsed;\\n                    visited2[nei] = elapsed;\\n                } else {\\n                    continue;\\n                }\\n                q.push({ elapsed, nei });\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419668,
                "title": "c-double-bfs-90-54-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n+1);\\n        for(auto &a:edges){\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({1,1});\\n        vector<pair<int,int>> visited(n+1,{-1,-1});\\n        visited[1]={0,-1};\\n        int mint;\\n        while(q.size()){\\n            auto [f,first]=q.front();\\n            q.pop();\\n            int t;\\n            if(first==1)\\n                t=visited[f].first;\\n            else\\n                t=visited[f].second;\\n            if(f==n and visited[n].second!=-1){\\n                return visited[n].second;\\n            }\\n            for(auto &a:adj[f]){\\n                if(visited[a].second!=-1)\\n                    continue;\\n                auto &[at1,at2]=visited[a];\\n                int nt;\\n                if((t/change)%2==0)\\n                    nt=t+time;\\n                else\\n                    nt=change*((t/change)+1)+time;\\n                if(at1==-1){\\n                    q.push({a,1});\\n                    at1=nt;\\n                }else if(at2==-1 and at1!=nt){\\n                    q.push({a,2});\\n                    at2=nt;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n+1);\\n        for(auto &a:edges){\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({1,1});\\n        vector<pair<int,int>> visited(n+1,{-1,-1});\\n        visited[1]={0,-1};\\n        int mint;\\n        while(q.size()){\\n            auto [f,first]=q.front();\\n            q.pop();\\n            int t;\\n            if(first==1)\\n                t=visited[f].first;\\n            else\\n                t=visited[f].second;\\n            if(f==n and visited[n].second!=-1){\\n                return visited[n].second;\\n            }\\n            for(auto &a:adj[f]){\\n                if(visited[a].second!=-1)\\n                    continue;\\n                auto &[at1,at2]=visited[a];\\n                int nt;\\n                if((t/change)%2==0)\\n                    nt=t+time;\\n                else\\n                    nt=change*((t/change)+1)+time;\\n                if(at1==-1){\\n                    q.push({a,1});\\n                    at1=nt;\\n                }else if(at2==-1 and at1!=nt){\\n                    q.push({a,2});\\n                    at2=nt;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241749,
                "title": "bfs-o-n-m-save-first-and-second-min-distances",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n + m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n + m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SecondMinimum(int n, int[][] edges, int time, int change) {\\n        List<int>[] graph = new List<int>[n + 1];\\n        int[] count = new int[n + 1];\\n        (int first, int second)[] dist = new (int, int)[n + 1];\\n        \\n        for (int i = 1; i <= n; i++)\\n        {\\n            graph[i] = new List<int>();\\n            dist[i] = (int.MaxValue, int.MaxValue);\\n        }\\n        \\n        foreach (var edge in edges)\\n        {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        \\n        Queue<(int, int)> q = new Queue<(int, int)>();\\n        q.Enqueue((1, 0));\\n        dist[1] = (0, int.MaxValue);\\n        \\n        while (q.Count > 0)\\n        {\\n            int size = q.Count;\\n            \\n            for (int i = 0; i < size; i++)\\n            {\\n                (int v, int t) = q.Dequeue();\\n                \\n                foreach (var u in graph[v])\\n                {\\n                    bool isGreen = ((t / change) % 2 == 0);\\n                    int newTime = t + time + (isGreen ? 0 : change - t % change);\\n                    \\n                    if (dist[u].first == int.MaxValue)\\n                    {\\n                        dist[u].first = newTime;\\n                        q.Enqueue((u, newTime));\\n                    }\\n                    else if (newTime > dist[u].first && dist[u].second == int.MaxValue)\\n                    {\\n                        dist[u].second = newTime;\\n                        q.Enqueue((u, newTime));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist[n].second;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SecondMinimum(int n, int[][] edges, int time, int change) {\\n        List<int>[] graph = new List<int>[n + 1];\\n        int[] count = new int[n + 1];\\n        (int first, int second)[] dist = new (int, int)[n + 1];\\n        \\n        for (int i = 1; i <= n; i++)\\n        {\\n            graph[i] = new List<int>();\\n            dist[i] = (int.MaxValue, int.MaxValue);\\n        }\\n        \\n        foreach (var edge in edges)\\n        {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        \\n        Queue<(int, int)> q = new Queue<(int, int)>();\\n        q.Enqueue((1, 0));\\n        dist[1] = (0, int.MaxValue);\\n        \\n        while (q.Count > 0)\\n        {\\n            int size = q.Count;\\n            \\n            for (int i = 0; i < size; i++)\\n            {\\n                (int v, int t) = q.Dequeue();\\n                \\n                foreach (var u in graph[v])\\n                {\\n                    bool isGreen = ((t / change) % 2 == 0);\\n                    int newTime = t + time + (isGreen ? 0 : change - t % change);\\n                    \\n                    if (dist[u].first == int.MaxValue)\\n                    {\\n                        dist[u].first = newTime;\\n                        q.Enqueue((u, newTime));\\n                    }\\n                    else if (newTime > dist[u].first && dist[u].second == int.MaxValue)\\n                    {\\n                        dist[u].second = newTime;\\n                        q.Enqueue((u, newTime));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist[n].second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215580,
                "title": "c-bfs-with-min1-and-min2-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int bfs(int n, vector<vector<int>> &adj, int time, int change){\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        vector<int> dis1(n, 1e9), dis2(n, 1e9);\\n        dis1[0] = 1;\\n        while(!q.empty()){\\n            int node = q.front().first;\\n            int cost = q.front().second;\\n            q.pop();\\n            for(auto nbr : adj[node]){\\n                int new_cost = cost + time;\\n                // red-signal\\n                if((cost / change) % 2 == 1) new_cost += change - (cost % change);\\n                if(dis1[nbr] > new_cost){\\n                    dis2[nbr] = dis1[nbr];\\n                    dis1[nbr] = new_cost;\\n                    q.push({nbr, new_cost});\\n                }\\n                else if(dis1[nbr] < new_cost and dis2[nbr] > new_cost){\\n                    dis2[nbr] = new_cost;\\n                    q.push({nbr, new_cost});\\n                }\\n            }\\n        }\\n        return dis2[n - 1];\\n    }\\n    \\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges){\\n            adj[edge[0] - 1].push_back(edge[1] - 1);\\n            adj[edge[1] - 1].push_back(edge[0] - 1);\\n        }\\n        return bfs(n, adj, time, change);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int bfs(int n, vector<vector<int>> &adj, int time, int change){\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 3206248,
                "title": "c-bfs-memo-versy-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a typical graph problem, we can using BFS to slove it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTips:\\n1. Must using a **memo** to avoid no use visit, only that we can avoid TLE.\\n2. We must find the unique 2nd result , so we can crate memo[][], each memo[i] is 2 length, contain 1st and 2nd timeCost to this vertex\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n        public int SecondMinimum(int n, int[][] edges, int time, int change)\\n        {\\n            List<int>[] graph = new List<int>[n+1];\\n            for (int i = 0; i<graph.Length; i++)\\n            {\\n                graph[i] = new List<int>();\\n            }\\n            foreach (var e in edges)\\n            {\\n                graph[e[0]].Add(e[1]);//build the graph\\n                graph[e[1]].Add(e[0]);\\n            }\\n            int[][] memo = new int[n+1][];//build the memo\\n            for (int i = 0; i<memo.Length; i++)\\n            {\\n                memo[i] = new int[] { int.MaxValue, int.MaxValue };\\n            }\\n            //using queue to BFS, every element in q is [index,totalTime] pair\\n            var q = new Queue<int[]>();\\n            int[] seed = new int[] { 1, 0 };\\n            q.Enqueue(seed);\\n            while(q.Count > 0)\\n            {\\n                int size = q.Count;\\n                while (size-->0)\\n                {\\n                    var top = q.Dequeue();\\n                    //we can only leave vertex on green light\\n                    int offset = top[1]%(change*2);\\n                    if (offset<change)//green light\\n                    {\\n                        foreach (var i in graph[top[0]])\\n                        {\\n                            int arriveTime = top[1]+time;\\n                            if (arriveTime>memo[i][1])\\n                                continue;//slower than 2nd, discard\\n                            else if (arriveTime==memo[i][0]|| arriveTime==memo[i][1])\\n                                continue;//want unique result, discard duplicate\\n                            else\\n                            {\\n                                if (arriveTime<memo[i][0])//better than 1st\\n                                {\\n                                    memo[i][1] = memo[i][0];\\n                                    memo[i][0] = arriveTime;\\n                                }\\n                                else\\n                                {\\n                                    memo[i][1] = arriveTime;\\n                                }\\n                                int[] nextVisit = new int[] { i, arriveTime };\\n                                q.Enqueue(nextVisit);\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                        //wait unitl next green light\\n                        top[1]+=2*change - offset;\\n                        q.Enqueue(top);\\n                    }\\n                }\\n            }\\n            return memo[n][1];\\n        }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n        public int SecondMinimum(int n, int[][] edges, int time, int change)\\n        {\\n            List<int>[] graph = new List<int>[n+1];\\n            for (int i = 0; i<graph.Length; i++)\\n            {\\n                graph[i] = new List<int>();\\n            }\\n            foreach (var e in edges)\\n            {\\n                graph[e[0]].Add(e[1]);//build the graph\\n                graph[e[1]].Add(e[0]);\\n            }\\n            int[][] memo = new int[n+1][];//build the memo\\n            for (int i = 0; i<memo.Length; i++)\\n            {\\n                memo[i] = new int[] { int.MaxValue, int.MaxValue };\\n            }\\n            //using queue to BFS, every element in q is [index,totalTime] pair\\n            var q = new Queue<int[]>();\\n            int[] seed = new int[] { 1, 0 };\\n            q.Enqueue(seed);\\n            while(q.Count > 0)\\n            {\\n                int size = q.Count;\\n                while (size-->0)\\n                {\\n                    var top = q.Dequeue();\\n                    //we can only leave vertex on green light\\n                    int offset = top[1]%(change*2);\\n                    if (offset<change)//green light\\n                    {\\n                        foreach (var i in graph[top[0]])\\n                        {\\n                            int arriveTime = top[1]+time;\\n                            if (arriveTime>memo[i][1])\\n                                continue;//slower than 2nd, discard\\n                            else if (arriveTime==memo[i][0]|| arriveTime==memo[i][1])\\n                                continue;//want unique result, discard duplicate\\n                            else\\n                            {\\n                                if (arriveTime<memo[i][0])//better than 1st\\n                                {\\n                                    memo[i][1] = memo[i][0];\\n                                    memo[i][0] = arriveTime;\\n                                }\\n                                else\\n                                {\\n                                    memo[i][1] = arriveTime;\\n                                }\\n                                int[] nextVisit = new int[] { i, arriveTime };\\n                                q.Enqueue(nextVisit);\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                        //wait unitl next green light\\n                        top[1]+=2*change - offset;\\n                        q.Enqueue(top);\\n                    }\\n                }\\n            }\\n            return memo[n][1];\\n        }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981725,
                "title": "python-simple-modified-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondMinimum(self, n, edges, time, change):\\n        dict1 = collections.defaultdict(list)\\n\\n        for i,j in edges:\\n            dict1[i-1].append((j-1,time))\\n            dict1[j-1].append((i-1,time))\\n\\n        d1, d2 = {i:float(\"inf\") for i in range(n)}, {i:float(\"inf\") for i in range(n)}\\n\\n        d1[0], freq = 0, collections.defaultdict(int)\\n\\n        stack = [(0,0)]\\n\\n        while stack:\\n            cur_time, node = heapq.heappop(stack)\\n\\n            freq[node] += 1\\n\\n            if freq[node] == 2 and node == n-1:\\n                return cur_time\\n\\n            if ((cur_time//change)%2):\\n                cur_time = change*(cur_time//change + 1)\\n\\n            for neighbor,t in dict1[node]:\\n                if freq[neighbor] == 2: continue\\n                if d1[neighbor] > cur_time + t:\\n                    d2[neighbor] = d1[neighbor]\\n                    d1[neighbor] = cur_time + t\\n                    heapq.heappush(stack,(cur_time + t,neighbor))\\n\\n                elif d2[neighbor] > cur_time + t and d1[neighbor] != cur_time + t:\\n                    d2[neighbor] = cur_time + t\\n                    heapq.heappush(stack,(cur_time + t,neighbor))\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n, edges, time, change):\\n        dict1 = collections.defaultdict(list)\\n\\n        for i,j in edges:\\n            dict1[i-1].append((j-1,time))\\n            dict1[j-1].append((i-1,time))\\n\\n        d1, d2 = {i:float(\"inf\") for i in range(n)}, {i:float(\"inf\") for i in range(n)}\\n\\n        d1[0], freq = 0, collections.defaultdict(int)\\n\\n        stack = [(0,0)]\\n\\n        while stack:\\n            cur_time, node = heapq.heappop(stack)\\n\\n            freq[node] += 1\\n\\n            if freq[node] == 2 and node == n-1:\\n                return cur_time\\n\\n            if ((cur_time//change)%2):\\n                cur_time = change*(cur_time//change + 1)\\n\\n            for neighbor,t in dict1[node]:\\n                if freq[neighbor] == 2: continue\\n                if d1[neighbor] > cur_time + t:\\n                    d2[neighbor] = d1[neighbor]\\n                    d1[neighbor] = cur_time + t\\n                    heapq.heappush(stack,(cur_time + t,neighbor))\\n\\n                elif d2[neighbor] > cur_time + t and d1[neighbor] != cur_time + t:\\n                    d2[neighbor] = cur_time + t\\n                    heapq.heappush(stack,(cur_time + t,neighbor))\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906043,
                "title": "n-1-n-2-explained-without-dijkstra-with-dijkstra-little-optimization-c",
                "content": "# Intuition\\n```\\nlet n be number of edge between start and end node for min time.\\nthen , then either n+1 or n+2 will be second min.\\n```\\n```\\nwhy not more than n+2?\\nbecause we can always move to second last and then come to last incrementing by 2 resulting n+2.\\n\\nlet 0 -> 2 -> 4 -> 5 -> 3-> 1 be the minimum path\\nthen 0 -> 2 -> 4 -> 5 -> 3 -> 1 -> 3 -> 1 is always possible.\\n```\\n```\\nif we can reach any node in path of minimum time with one extra unit,\\nthat will be second minimum (n+1) unit.\\nelse if no such path exist, dist will be (n+2).\\n```\\n\\n# Code\\n**1. without Dijkstra using only level-wise BFS (897 ms)**\\n```\\ntypedef pair<int,int> pii;\\ntypedef vector<pair<int,int>> vpi;\\nclass Solution {\\npublic:\\n    int time_taken(int k,int time,int change){\\n        int curr_time=0;\\n        for(int i=1;i<=k;i++){\\n            int turn=(curr_time/change);\\n            if(turn%2) curr_time=(turn+1)*change;\\n            curr_time+=time;\\n        }\\n        return curr_time;\\n    }\\n\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n);\\n        for(auto &k: edges){\\n            int first=k[0],second=k[1];\\n            first--;second--;\\n            adj[first].push_back(second);\\n            adj[second].push_back(first);\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n        vector<int> dis(n,INT_MAX);\\n        int dist=-1;\\n        while(!q.empty() && ++dist<=dis[n-1]){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                auto u=q.front();\\n                q.pop();\\n\\n                for(auto &v: adj[u]){\\n                    if(dist<=dis[v]){\\n                        q.push(v);\\n                        dis[v]=min(dis[v],dist+1);\\n                        if(v==n-1 && dist==dis[v]) return time_taken(dist+1,time,change);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return time_taken(dis[n-1]+2,time,change);\\n    }\\n};\\n```\\n**2. Dijkstra using priority queue (1346 ms)**\\n```\\ntypedef pair<int,int> pii;\\ntypedef vector<pair<int,int>> vpi;\\nclass Solution {\\npublic:\\n    int time_taken(int k,int time,int change){\\n        int curr_time=0;\\n        for(int i=1;i<=k;i++){\\n            int turn=(curr_time/change);\\n            if(turn%2) curr_time=(turn+1)*change;\\n            curr_time+=time;\\n        }\\n        return curr_time;\\n    }\\n\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n);\\n        for(auto &k: edges){\\n            int first=k[0],second=k[1];\\n            first--;second--;\\n            adj[first].push_back(second);\\n            adj[second].push_back(first);\\n        }\\n\\n        int ans=INT_MAX;\\n        priority_queue<pii,vpi,greater<>> pq;\\n        vector<int> dis(n,INT_MAX);\\n        vector<bool> visited(n,0);\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            auto f=pq.top();\\n            pq.pop();\\n            int dist=f.first,u=f.second;\\n\\n            if(u==n-1){\\n                if(ans==INT_MAX) ans=dist;\\n                else if(dist!=ans) return time_taken(dist,time,change);\\n            }\\n\\n            for(auto &v: adj[u]){\\n                if(dis[v]==INT_MAX){\\n                    dis[v]=dist+1;\\n                    pq.push({dist+1,v});\\n                }\\n\\n             /* if node be reached by one extra unit of dist.\\n                visited array confirms one such path.\\n                one will be enough since ahead the path will be same */ \\n\\n                else if(dist+1==dis[v]+1 && !visited[v]){\\n                    pq.push({dist+1,v});\\n                    visited[v]=true;\\n                } \\n            }\\n        }\\n        return time_taken(ans+2,time,change);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlet n be number of edge between start and end node for min time.\\nthen , then either n+1 or n+2 will be second min.\\n```\n```\\nwhy not more than n+2?\\nbecause we can always move to second last and then come to last incrementing by 2 resulting n+2.\\n\\nlet 0 -> 2 -> 4 -> 5 -> 3-> 1 be the minimum path\\nthen 0 -> 2 -> 4 -> 5 -> 3 -> 1 -> 3 -> 1 is always possible.\\n```\n```\\nif we can reach any node in path of minimum time with one extra unit,\\nthat will be second minimum (n+1) unit.\\nelse if no such path exist, dist will be (n+2).\\n```\n```\\ntypedef pair<int,int> pii;\\ntypedef vector<pair<int,int>> vpi;\\nclass Solution {\\npublic:\\n    int time_taken(int k,int time,int change){\\n        int curr_time=0;\\n        for(int i=1;i<=k;i++){\\n            int turn=(curr_time/change);\\n            if(turn%2) curr_time=(turn+1)*change;\\n            curr_time+=time;\\n        }\\n        return curr_time;\\n    }\\n\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n);\\n        for(auto &k: edges){\\n            int first=k[0],second=k[1];\\n            first--;second--;\\n            adj[first].push_back(second);\\n            adj[second].push_back(first);\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n        vector<int> dis(n,INT_MAX);\\n        int dist=-1;\\n        while(!q.empty() && ++dist<=dis[n-1]){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                auto u=q.front();\\n                q.pop();\\n\\n                for(auto &v: adj[u]){\\n                    if(dist<=dis[v]){\\n                        q.push(v);\\n                        dis[v]=min(dis[v],dist+1);\\n                        if(v==n-1 && dist==dis[v]) return time_taken(dist+1,time,change);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return time_taken(dis[n-1]+2,time,change);\\n    }\\n};\\n```\n```\\ntypedef pair<int,int> pii;\\ntypedef vector<pair<int,int>> vpi;\\nclass Solution {\\npublic:\\n    int time_taken(int k,int time,int change){\\n        int curr_time=0;\\n        for(int i=1;i<=k;i++){\\n            int turn=(curr_time/change);\\n            if(turn%2) curr_time=(turn+1)*change;\\n            curr_time+=time;\\n        }\\n        return curr_time;\\n    }\\n\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n);\\n        for(auto &k: edges){\\n            int first=k[0],second=k[1];\\n            first--;second--;\\n            adj[first].push_back(second);\\n            adj[second].push_back(first);\\n        }\\n\\n        int ans=INT_MAX;\\n        priority_queue<pii,vpi,greater<>> pq;\\n        vector<int> dis(n,INT_MAX);\\n        vector<bool> visited(n,0);\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            auto f=pq.top();\\n            pq.pop();\\n            int dist=f.first,u=f.second;\\n\\n            if(u==n-1){\\n                if(ans==INT_MAX) ans=dist;\\n                else if(dist!=ans) return time_taken(dist,time,change);\\n            }\\n\\n            for(auto &v: adj[u]){\\n                if(dis[v]==INT_MAX){\\n                    dis[v]=dist+1;\\n                    pq.push({dist+1,v});\\n                }\\n\\n             /* if node be reached by one extra unit of dist.\\n                visited array confirms one such path.\\n                one will be enough since ahead the path will be same */ \\n\\n                else if(dist+1==dis[v]+1 && !visited[v]){\\n                    pq.push({dist+1,v});\\n                    visited[v]=true;\\n                } \\n            }\\n        }\\n        return time_taken(ans+2,time,change);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865739,
                "title": "c-bfs-record-go-through-edges-count-only-twice-of-each-city",
                "content": "# Intuition\\nDirectly BFS.\\n\\n# Approach\\nJust record the go through edges when arrive each city. If the edges are the same with previous one of this city, ignore this case. Each city only has two change to update.\\n\\nOnce the last city get two result of edges. We got the edges count and just calculate it and return it.\\nIf not, just add 2 and reture the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cal(int path, int &time, int &change)\\n    {\\n        // There are \"path\" count of edges, just calculate the needed time;\\n        int i, curTime = 0;\\n\\n        for(i = 0; i < path-1; i++)\\n        {\\n            int t1 = (curTime + time) / change;\\n            int t2 = (curTime) / change;\\n            if((change > 1) && ((t1 - t2) % 2))\\n            {\\n                curTime += time;\\n                curTime += (change - curTime%change);\\n            }\\n            else if((change == 1) && (t1 % 2))\\n            {\\n                curTime += time;\\n                curTime += (change - curTime%change);\\n            }\\n            else\\n            {\\n                curTime += time;\\n            }\\n        }\\n\\n        return curTime + time;\\n    }\\n\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> path(n+1);\\n\\n        // union find each edge\\n        for(auto v : edges)\\n        {\\n            int c1 = v[0], c2 = v[1];\\n            path[c1].push_back(c2);\\n            path[c2].push_back(c1);\\n        }\\n\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> count(n+1);\\n        count[1].push_back(0);\\n        q.push({1, 0});\\n\\n        while(!q.empty())\\n        {\\n            int city = q.front().first;\\n            int line = q.front().second;\\n            q.pop();\\n\\n            for(auto next : path[city])\\n            {\\n                // each city only has two oppotunity to go through,\\n                // every time arrive a city, update the go though edge count\\n                // if the edge count is the same, we don\\'t update and ignore it\\n                if((count[next].empty()) || ((count[next].size() == 1) && (count[next].back() <= line)))\\n                {\\n                    count[next].push_back(line + 1);\\n                    q.push({next, line+1});\\n                }\\n\\n                if((next == n) && (count[next].size() == 2))\\n                {\\n                    // the last city got two route, calculate the time\\n                    return cal(count[next].back(), time, change);\\n                }\\n            }\\n        }\\n\\n        // the last city only got one route, just add 2 to get the second shortest path.\\n        return cal(count[n].back()+2, time, change);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(int path, int &time, int &change)\\n    {\\n        // There are \"path\" count of edges, just calculate the needed time;\\n        int i, curTime = 0;\\n\\n        for(i = 0; i < path-1; i++)\\n        {\\n            int t1 = (curTime + time) / change;\\n            int t2 = (curTime) / change;\\n            if((change > 1) && ((t1 - t2) % 2))\\n            {\\n                curTime += time;\\n                curTime += (change - curTime%change);\\n            }\\n            else if((change == 1) && (t1 % 2))\\n            {\\n                curTime += time;\\n                curTime += (change - curTime%change);\\n            }\\n            else\\n            {\\n                curTime += time;\\n            }\\n        }\\n\\n        return curTime + time;\\n    }\\n\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> path(n+1);\\n\\n        // union find each edge\\n        for(auto v : edges)\\n        {\\n            int c1 = v[0], c2 = v[1];\\n            path[c1].push_back(c2);\\n            path[c2].push_back(c1);\\n        }\\n\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> count(n+1);\\n        count[1].push_back(0);\\n        q.push({1, 0});\\n\\n        while(!q.empty())\\n        {\\n            int city = q.front().first;\\n            int line = q.front().second;\\n            q.pop();\\n\\n            for(auto next : path[city])\\n            {\\n                // each city only has two oppotunity to go through,\\n                // every time arrive a city, update the go though edge count\\n                // if the edge count is the same, we don\\'t update and ignore it\\n                if((count[next].empty()) || ((count[next].size() == 1) && (count[next].back() <= line)))\\n                {\\n                    count[next].push_back(line + 1);\\n                    q.push({next, line+1});\\n                }\\n\\n                if((next == n) && (count[next].size() == 2))\\n                {\\n                    // the last city got two route, calculate the time\\n                    return cal(count[next].back(), time, change);\\n                }\\n            }\\n        }\\n\\n        // the last city only got one route, just add 2 to get the second shortest path.\\n        return cal(count[n].back()+2, time, change);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848018,
                "title": "python-dijkstra-with-heap-and-map",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = collections.defaultdict(list)\\n        for v1, v2 in edges:\\n            graph[v1].append(v2)\\n            graph[v2].append(v1)\\n        \\n        heap = [(0, 1)]  # cost, vertices\\n        costs = collections.defaultdict(lambda: [math.inf, math.inf])\\n        \\n        res = []\\n        \\n        while heap:\\n            cost, node = heappop(heap)\\n            \\n            for neighbor in graph[node]:\\n                new_cost = cost + time\\n                \\n                # Skip nodes we\\'ve seen twice alredy\\n                if costs[neighbor][1] != math.inf:\\n                    continue\\n                \\n                # If target node, return early before incur wait cost\\n                if neighbor == n:\\n                    res.append(new_cost)\\n                    if len(res) >= 2 and res[-1] != res[-2]:\\n                        return res[-1]\\n                \\n                if (new_cost // change) % 2 == 1:\\n                    new_cost += change - (new_cost % change)\\n                \\n                if neighbor not in costs or new_cost < costs[neighbor][0]:\\n                    costs[neighbor][1] = costs[neighbor][0]\\n                    costs[neighbor][0] = new_cost \\n                    heappush(heap, (new_cost, neighbor))\\n                elif new_cost < costs[neighbor][1] and new_cost != costs[neighbor][0]:\\n                    costs[neighbor][1] = new_cost \\n                    heappush(heap, (new_cost, neighbor))\\n           \\n        return costs[n][1]\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = collections.defaultdict(list)\\n        for v1, v2 in edges:\\n            graph[v1].append(v2)\\n            graph[v2].append(v1)\\n        \\n        heap = [(0, 1)]  # cost, vertices\\n        costs = collections.defaultdict(lambda: [math.inf, math.inf])\\n        \\n        res = []\\n        \\n        while heap:\\n            cost, node = heappop(heap)\\n            \\n            for neighbor in graph[node]:\\n                new_cost = cost + time\\n                \\n                # Skip nodes we\\'ve seen twice alredy\\n                if costs[neighbor][1] != math.inf:\\n                    continue\\n                \\n                # If target node, return early before incur wait cost\\n                if neighbor == n:\\n                    res.append(new_cost)\\n                    if len(res) >= 2 and res[-1] != res[-2]:\\n                        return res[-1]\\n                \\n                if (new_cost // change) % 2 == 1:\\n                    new_cost += change - (new_cost % change)\\n                \\n                if neighbor not in costs or new_cost < costs[neighbor][0]:\\n                    costs[neighbor][1] = costs[neighbor][0]\\n                    costs[neighbor][0] = new_cost \\n                    heappush(heap, (new_cost, neighbor))\\n                elif new_cost < costs[neighbor][1] and new_cost != costs[neighbor][0]:\\n                    costs[neighbor][1] = new_cost \\n                    heappush(heap, (new_cost, neighbor))\\n           \\n        return costs[n][1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837212,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        unordered_map<int, unordered_set<int>> g;\\n        for(auto& e : edges) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        queue<int> q;\\n        q.push(1);\\n        int dist[10001]{}, one_more_step[10001]{};\\n        dist[1] = 1;\\n        int step = 2;\\n        while(!q.empty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int t = q.front(); q.pop();\\n                for(int nxt : g[t]) if(dist[nxt] == step-1 || one_more_step[nxt]) one_more_step[t] = 1;\\n                for(int nxt : g[t]) {\\n                    if(!dist[nxt]) {\\n                        q.push(nxt);\\n                        dist[nxt] = step;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n\\n        step = one_more_step[n] ? dist[n] : dist[n]+1;\\n        int ans = 0;\\n        for(int i = 0; i < step; i++) {\\n            ans += time;\\n            if(i < step -1) {\\n                int mul = ans/change;\\n                if(mul%2) ans = (mul+1)*change;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        unordered_map<int, unordered_set<int>> g;\\n        for(auto& e : edges) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        queue<int> q;\\n        q.push(1);\\n        int dist[10001]{}, one_more_step[10001]{};\\n        dist[1] = 1;\\n        int step = 2;\\n        while(!q.empty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int t = q.front(); q.pop();\\n                for(int nxt : g[t]) if(dist[nxt] == step-1 || one_more_step[nxt]) one_more_step[t] = 1;\\n                for(int nxt : g[t]) {\\n                    if(!dist[nxt]) {\\n                        q.push(nxt);\\n                        dist[nxt] = step;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n\\n        step = one_more_step[n] ? dist[n] : dist[n]+1;\\n        int ans = 0;\\n        for(int i = 0; i < step; i++) {\\n            ans += time;\\n            if(i < step -1) {\\n                int mul = ans/change;\\n                if(mul%2) ans = (mul+1)*change;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804866,
                "title": "java-with-dijkstra-or-bfs-run-for-2-iterations",
                "content": "```\\nclass Solution {\\n    List<Integer>[] adjList;\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        \\n        buildGraph(n, edges);\\n        //return secondMinimumUsingDijkstra(n, 1, time, change);\\n        return secondMinimumUsingBFS(n, 1, time, change);\\n    }\\n    public int INF = Integer.MAX_VALUE;\\n    \\n    public int secondMinimumUsingBFS(int n, int src, int time, int change){\\n        \\n        int[][] times = new int[n+1][2];\\n        for (int i = 0; i <= n; i++)\\n            Arrays.fill(times[i], INF);\\n        \\n        Deque<Integer> queue = new LinkedList<>();\\n        \\n        queue.addLast(src);\\n        times[src][0] = 0;\\n        \\n        int timeElapsed = 0;\\n        \\n        while (!queue.isEmpty()){\\n            timeElapsed += time;\\n            int size = queue.size();\\n            while (size > 0){\\n                int u = queue.removeFirst();\\n                if (u == n && times[n][1] != INF)\\n                    return times[n][1];\\n\\n                for (int v : adjList[u]){\\n                    if (times[v][0] == INF){\\n                        times[v][0] = timeElapsed;\\n                        queue.addLast(v);\\n                    } else if (times[v][1] == INF && timeElapsed != times[v][0]){\\n                        times[v][1] = timeElapsed;\\n                        queue.addLast(v);\\n                    }\\n                }\\n                size--;\\n            }\\n            if (timeElapsed/change%2 == 1) {\\n                //odd interval i.e red light. set the timeelapsed to the nxt start of green\\n                timeElapsed += change - (timeElapsed%change);\\n            }\\n        }\\n        return -1;\\n    }\\n    public int secondMinimumUsingDijkstra(int n, int src, int time, int change){\\n        \\n        int[] captured = new int[n+1];\\n        int[] times = new int[n+1];\\n        Arrays.fill(times, -1);\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        pq.offer(new int[]{src, 0});\\n        \\n        while (!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n            int node = curr[0], nodeTime = curr[1];\\n            \\n            //Dijkstra bail out\\n            if (captured[node] >= 2 || times[node] == nodeTime)\\n                continue;\\n            \\n            captured[node]++;\\n            times[node] = nodeTime;\\n            \\n            if (node == n && captured[node] == 2)\\n                return times[node];\\n            \\n            for (int neigh : adjList[node]){\\n                if (captured[neigh] < 2){\\n                    //depart time\\n                    // if arrivalTime i. e nodeTime is even multiple of change .. go\\n                    // else set depart time to (nodetime/change+1) * change  + time\\n                    int departTime = nodeTime + time; // assuming green light is on.\\n                    if((nodeTime/change)%2 != 0){\\n                        //red light\\n                        departTime = (((nodeTime/change) + 1) * change) + time;\\n                    }\\n                    pq.offer(new int[]{neigh, departTime});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public void buildGraph(int n, int[][] edges){\\n        adjList = new ArrayList[n+1];\\n        \\n        for (int i = 0; i <= n; i++){\\n            adjList[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int[] edge :  edges){\\n            int u = edge[0], v = edge[1];\\n            adjList[u].add(v);\\n            adjList[v].add(u);\\n        }\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    List<Integer>[] adjList;\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        \\n        buildGraph(n, edges);\\n        //return secondMinimumUsingDijkstra(n, 1, time, change);\\n        return secondMinimumUsingBFS(n, 1, time, change);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2804198,
                "title": "swift-2250-ms",
                "content": "```\\nprivate final class GraphNode {\\n    var first = Int.max\\n    var second = Int.max\\n    var edges: [Int] = []\\n}\\n\\nclass Solution {\\n    func secondMinimum(_ n: Int, _ edges: [[Int]], _ time: Int, _ change: Int) -> Int {\\n        let nodes = (0 ..< n).map { _ in GraphNode() }\\n        for e in edges {\\n            nodes[e[0] - 1].edges.append(e[1])\\n            nodes[e[1] - 1].edges.append(e[0])\\n        }\\n        nodes[0].first = 0\\n        var nn = Set([1])\\n        let nodeTo = nodes[n - 1]\\n        var times = [time]\\n        while !nn.isEmpty {\\n            let t1 = times.last!\\n            let t2 = t1 % (2 * change) - change\\n            times.append(t1 + time + (t2 >= 0 ? change - t2 : 0))\\n            var newNn = Set<Int>()\\n            for n in nn {\\n                let d0 = nodes[n - 1]\\n                for t in d0.edges {\\n                    let d1 = nodes[t - 1]\\n                    if d1.first > d0.first + 1 {\\n                        d1.first = d0.first + 1\\n                        newNn.insert(t)\\n                    }\\n                    for m in 0 ... 1 {\\n                        if m == 1 && d0.second == Int.max { continue }\\n                        let s = (m == 0 ? d0.first : d0.second) + 1\\n                        if s != d1.first && d1.second > s {\\n                            d1.second = s\\n                            newNn.insert(t)\\n                        }\\n                    }\\n                }\\n            }\\n            if nodeTo.first < Int.max {\\n                if nodeTo.second == Int.max {\\n                    nodeTo.second = nodeTo.first + 2\\n                } else {\\n                    break\\n                }\\n            }\\n            nn = newNn\\n        }\\n        return times[nodeTo.second - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nprivate final class GraphNode {\\n    var first = Int.max\\n    var second = Int.max\\n    var edges: [Int] = []\\n}\\n\\nclass Solution {\\n    func secondMinimum(_ n: Int, _ edges: [[Int]], _ time: Int, _ change: Int) -> Int {\\n        let nodes = (0 ..< n).map { _ in GraphNode() }\\n        for e in edges {\\n            nodes[e[0] - 1].edges.append(e[1])\\n            nodes[e[1] - 1].edges.append(e[0])\\n        }\\n        nodes[0].first = 0\\n        var nn = Set([1])\\n        let nodeTo = nodes[n - 1]\\n        var times = [time]\\n        while !nn.isEmpty {\\n            let t1 = times.last!\\n            let t2 = t1 % (2 * change) - change\\n            times.append(t1 + time + (t2 >= 0 ? change - t2 : 0))\\n            var newNn = Set<Int>()\\n            for n in nn {\\n                let d0 = nodes[n - 1]\\n                for t in d0.edges {\\n                    let d1 = nodes[t - 1]\\n                    if d1.first > d0.first + 1 {\\n                        d1.first = d0.first + 1\\n                        newNn.insert(t)\\n                    }\\n                    for m in 0 ... 1 {\\n                        if m == 1 && d0.second == Int.max { continue }\\n                        let s = (m == 0 ? d0.first : d0.second) + 1\\n                        if s != d1.first && d1.second > s {\\n                            d1.second = s\\n                            newNn.insert(t)\\n                        }\\n                    }\\n                }\\n            }\\n            if nodeTo.first < Int.max {\\n                if nodeTo.second == Int.max {\\n                    nodeTo.second = nodeTo.first + 2\\n                } else {\\n                    break\\n                }\\n            }\\n            nn = newNn\\n        }\\n        return times[nodeTo.second - 1]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780567,
                "title": "c-bfs",
                "content": "Since the weights on edges are all the same, we can simply use BFS to get the second least number of edges from vertex 1 to vertex n and calculate the time.\\n\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> graph(n); // adjacent list\\n        for (auto &e : edges) {\\n\\t\\t\\t// 0-index\\n            graph[e[0]-1].emplace_back(e[1]-1);\\n            graph[e[1]-1].emplace_back(e[0]-1);\\n        }\\n        \\n        vector<vector<int>> min_dist(n);\\n        min_dist[0].emplace_back(0);\\n        \\n        queue<pair<int,int>> q; // (cur_dist, vertex)\\n        q.emplace(0, 0);\\n        \\n        while (!q.empty()) {\\n            auto [cur_dist, v] = q.front();\\n            q.pop();\\n            \\n            cur_dist++;\\n            \\n            for (auto &next_v : graph[v]) {\\n                if (min_dist[next_v].size() == 0 or (min_dist[next_v].size() == 1 and cur_dist > min_dist[next_v][0])) {\\n                    min_dist[next_v].emplace_back(cur_dist);\\n                    q.emplace(cur_dist, next_v);\\n                }\\n            }\\n        }\\n        \\n\\t\\t// calculate time\\n        int res = 0;\\n        while (min_dist.back()[1]--) {\\n            if ((res / change) & 1) {\\n                res += change - res % change; // wait until green light\\n            }\\n            res += time;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> graph(n); // adjacent list\\n        for (auto &e : edges) {\\n\\t\\t\\t// 0-index\\n            graph[e[0]-1].emplace_back(e[1]-1);\\n            graph[e[1]-1].emplace_back(e[0]-1);\\n        }\\n        \\n        vector<vector<int>> min_dist(n);\\n        min_dist[0].emplace_back(0);\\n        \\n        queue<pair<int,int>> q; // (cur_dist, vertex)\\n        q.emplace(0, 0);\\n        \\n        while (!q.empty()) {\\n            auto [cur_dist, v] = q.front();\\n            q.pop();\\n            \\n            cur_dist++;\\n            \\n            for (auto &next_v : graph[v]) {\\n                if (min_dist[next_v].size() == 0 or (min_dist[next_v].size() == 1 and cur_dist > min_dist[next_v][0])) {\\n                    min_dist[next_v].emplace_back(cur_dist);\\n                    q.emplace(cur_dist, next_v);\\n                }\\n            }\\n        }\\n        \\n\\t\\t// calculate time\\n        int res = 0;\\n        while (min_dist.back()[1]--) {\\n            if ((res / change) & 1) {\\n                res += change - res % change; // wait until green light\\n            }\\n            res += time;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766265,
                "title": "javascript-dijkstra-s-algorithm",
                "content": "**Solution: Dijkstra\\'s Algorithm w/ Two Minimum Times**\\n\\nDijkstra\\'s algorithm, except we store two minimum times for each node instead of just one.\\nWe only visit a neighbor node if:\\n  1. The neighbor has less than two minimum times stored so far and the new time is not equal to the minimum time (since the second minimum time must be strictly larger than the minimum value)\\n  2. The new time is not equal to the minimum time and the new time is smaller than the second minimum time.\\n\\nCalculate time to travel from one node to another:\\n*   Green light: `Math.floor(curr time / change) % 2 === 0`\\n\\t*    time to travel: curr time + time \\n*   Red light: `Math.floor(curr time / change) % 2 === 1`\\n    *    time to travel: curr time + time + time until next green light\\n    *    time to wait until next green light = `change - (curr time % change)`\\n\\n`V = number of cities`, `E = number of edges`\\nTime Complexity: `O((V + E) * log(V))` 1088ms\\nSpace Complexity: `O(V + E) `115.2MB\\n```\\nvar secondMinimum = function(n, edges, time, change) {\\n  let graph = Array(n + 1).fill(0).map(() => []);\\n  for (let [u, v] of edges) {\\n    graph[u].push(v);\\n    graph[v].push(u);\\n  }\\n  let heap = new PriorityQueue((a, b) => a[1] - b[1]); // [node, time]  \\n  let minTime = Array(n + 1).fill(0).map(() => []);\\n  minTime[1].push(0);\\n  heap.add([1, 0]);\\n  while (!heap.isEmpty()) {\\n    let [node, currTime] = heap.remove();\\n    if (node === n && minTime[node].length === 2) return Math.max(...minTime[node]);\\n    \\n    let isGreenLight = Math.floor(currTime / change) % 2 === 0;\\n    let timeUntilGreenLight = change - (currTime % change);\\n    let newTime = isGreenLight ? currTime + time : currTime + time + timeUntilGreenLight;\\n    for (let nei of graph[node]) {\\n      if ((minTime[nei].length <= 1 && minTime[nei][0] !== newTime) || (minTime[nei][0] !== newTime && minTime[nei][1] > newTime)) {\\n        minTime[nei].push(newTime);\\n        minTime[nei].sort((a, b) => a - b);\\n        if (minTime[nei].length > 2) minTime[nei].pop(); // pop out largest time if length exceeds 2\\n        heap.add([nei, newTime]);\\n      }\\n    }\\n  }\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar secondMinimum = function(n, edges, time, change) {\\n  let graph = Array(n + 1).fill(0).map(() => []);\\n  for (let [u, v] of edges) {\\n    graph[u].push(v);\\n    graph[v].push(u);\\n  }\\n  let heap = new PriorityQueue((a, b) => a[1] - b[1]); // [node, time]  \\n  let minTime = Array(n + 1).fill(0).map(() => []);\\n  minTime[1].push(0);\\n  heap.add([1, 0]);\\n  while (!heap.isEmpty()) {\\n    let [node, currTime] = heap.remove();\\n    if (node === n && minTime[node].length === 2) return Math.max(...minTime[node]);\\n    \\n    let isGreenLight = Math.floor(currTime / change) % 2 === 0;\\n    let timeUntilGreenLight = change - (currTime % change);\\n    let newTime = isGreenLight ? currTime + time : currTime + time + timeUntilGreenLight;\\n    for (let nei of graph[node]) {\\n      if ((minTime[nei].length <= 1 && minTime[nei][0] !== newTime) || (minTime[nei][0] !== newTime && minTime[nei][1] > newTime)) {\\n        minTime[nei].push(newTime);\\n        minTime[nei].sort((a, b) => a - b);\\n        if (minTime[nei].length > 2) minTime[nei].pop(); // pop out largest time if length exceeds 2\\n        heap.add([nei, newTime]);\\n      }\\n    }\\n  }\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645206,
                "title": "simple-bfs-well-commented-no-dijkstra",
                "content": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        \\n        //Adjacency List for BFS\\n        List<List<Integer>> adjList = new ArrayList<>();\\n        \\n        //Set will contain only those vertices which have been visited twice with different number of steps\\n        Set<Integer> visitedTwice = new HashSet<>();\\n        \\n        //Populate adjacency list\\n        for (int i = 0; i <= n; i++) adjList.add(new ArrayList<>());\\n        for (int[] e: edges) {\\n            adjList.get(e[0]).add(e[1]);\\n            adjList.get(e[1]).add(e[0]);\\n        }\\n        \\n        //Keeping second minimun steps for every node\\n        int[] distSecMin = new int[n + 1];\\n        Arrays.fill(distSecMin, Integer.MAX_VALUE);\\n        \\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(1);\\n        distSecMin[0] = 2; //This is 2 because initial node can be minimally reached again by immediate to and fro from another node\\n        int steps = 1;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int size = queue.size();\\n            \\n            // Traverse layer by layer\\n            for (int i = 0; i < size; i++) {\\n                \\n                int curr = queue.poll();\\n                \\n                //Break the loop if n has been visited twice\\n                if (curr == n && visitedTwice.contains(n)) break;\\n                \\n                for (int adj: adjList.get(curr)) {\\n                    \\n                    //Only retraverse a node if it has not been visited twice with distinct steps\\n                    if (!visitedTwice.contains(adj) && distSecMin[adj] != steps) {\\n                        \\n                        //When visiting first time\\n                        if (distSecMin[adj] == Integer.MAX_VALUE) {\\n                            distSecMin[adj] = steps;\\n                        } else { // Visiting for the second time. This is the second min for every node\\n                            distSecMin[adj] = steps;\\n                            visitedTwice.add(adj);\\n                        }\\n                        \\n                        queue.offer(adj);\\n                    }\\n                }\\n            }\\n            \\n            steps++;\\n        }\\n        \\n        //Calculate time elapsed to reach n with 2nd minimum number of steps\\n        int timeElapsed = 0;\\n        for (int i = 1; i <= distSecMin[n]; i++) {\\n            timeElapsed += time;\\n            \\n            // Check if wait is needed at this instant of time. Dont add wait when the last step is taken\\n            if (timeElapsed % (2 * change) >= change && i != distSecMin[n]) {\\n                timeElapsed += (change * 2) - (timeElapsed % (change * 2));;\\n            }\\n        }\\n        \\n        return timeElapsed;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        \\n        //Adjacency List for BFS\\n        List<List<Integer>> adjList = new ArrayList<>();\\n        \\n        //Set will contain only those vertices which have been visited twice with different number of steps\\n        Set<Integer> visitedTwice = new HashSet<>();\\n        \\n        //Populate adjacency list\\n        for (int i = 0; i <= n; i++) adjList.add(new ArrayList<>());\\n        for (int[] e: edges) {\\n            adjList.get(e[0]).add(e[1]);\\n            adjList.get(e[1]).add(e[0]);\\n        }\\n        \\n        //Keeping second minimun steps for every node\\n        int[] distSecMin = new int[n + 1];\\n        Arrays.fill(distSecMin, Integer.MAX_VALUE);\\n        \\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(1);\\n        distSecMin[0] = 2; //This is 2 because initial node can be minimally reached again by immediate to and fro from another node\\n        int steps = 1;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int size = queue.size();\\n            \\n            // Traverse layer by layer\\n            for (int i = 0; i < size; i++) {\\n                \\n                int curr = queue.poll();\\n                \\n                //Break the loop if n has been visited twice\\n                if (curr == n && visitedTwice.contains(n)) break;\\n                \\n                for (int adj: adjList.get(curr)) {\\n                    \\n                    //Only retraverse a node if it has not been visited twice with distinct steps\\n                    if (!visitedTwice.contains(adj) && distSecMin[adj] != steps) {\\n                        \\n                        //When visiting first time\\n                        if (distSecMin[adj] == Integer.MAX_VALUE) {\\n                            distSecMin[adj] = steps;\\n                        } else { // Visiting for the second time. This is the second min for every node\\n                            distSecMin[adj] = steps;\\n                            visitedTwice.add(adj);\\n                        }\\n                        \\n                        queue.offer(adj);\\n                    }\\n                }\\n            }\\n            \\n            steps++;\\n        }\\n        \\n        //Calculate time elapsed to reach n with 2nd minimum number of steps\\n        int timeElapsed = 0;\\n        for (int i = 1; i <= distSecMin[n]; i++) {\\n            timeElapsed += time;\\n            \\n            // Check if wait is needed at this instant of time. Dont add wait when the last step is taken\\n            if (timeElapsed % (2 * change) >= change && i != distSecMin[n]) {\\n                timeElapsed += (change * 2) - (timeElapsed % (change * 2));;\\n            }\\n        }\\n        \\n        return timeElapsed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602522,
                "title": "java-bfs-heap-solution",
                "content": "Here is my solution to this problem. Hope you\\'ll find it useful. \\n\\n```\\nclass Solution {\\n    Map<Integer, Set<Integer>> connections;\\n    Integer[] minimum;\\n    Integer[] sMinimum;\\n    \\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        init(n, edges);\\n        PriorityQueue<Vertex> pq = new PriorityQueue<>((a, b) -> (a.t - b.t));\\n        pq.offer(new Vertex(1, 0));\\n        \\n        Vertex cur;\\n        while(!pq.isEmpty()) {\\n            cur = pq.poll();\\n            int v = cur.v, t = cur.t;\\n\\n            if((sMinimum[v] != null && sMinimum[v] <= t) || (minimum[v] != null && minimum[v] == t)) continue;\\n            if(minimum[v] == null) minimum[v] = t;\\n            else if(sMinimum[v] == null) sMinimum[v] = t;\\n            else sMinimum[v] = Math.min(sMinimum[v], t);\\n            \\n            int nextT = getTimeAfterWait(t, change);\\n            for(int neighbor: connections.get(v)){\\n                pq.offer(new Vertex(neighbor, nextT + time));\\n            }\\n        }\\n        \\n        return sMinimum[n];\\n    }\\n    \\n    void init(int n, int[][] edges){\\n        this.connections = new HashMap<>();\\n        minimum = new Integer[n+1];\\n        sMinimum = new Integer[n+1];\\n        \\n        for(int i = 1; i<=n; i++) connections.put(i, new HashSet<>());\\n        for(int[] edge: edges){\\n            int u = edge[0], v = edge[1];\\n            connections.get(u).add(v);\\n            connections.get(v).add(u);\\n        }\\n    }\\n    \\n    int getTimeAfterWait(int currentTime, int change){\\n        if((currentTime / change)%2==1) return (currentTime + change - currentTime%change);\\n        return currentTime;\\n    }\\n    \\n    class Vertex {\\n        int v;\\n        int t;\\n        Vertex(int v, int t){\\n            this.v = v;\\n            this.t = t;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, Set<Integer>> connections;\\n    Integer[] minimum;\\n    Integer[] sMinimum;\\n    \\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        init(n, edges);\\n        PriorityQueue<Vertex> pq = new PriorityQueue<>((a, b) -> (a.t - b.t));\\n        pq.offer(new Vertex(1, 0));\\n        \\n        Vertex cur;\\n        while(!pq.isEmpty()) {\\n            cur = pq.poll();\\n            int v = cur.v, t = cur.t;\\n\\n            if((sMinimum[v] != null && sMinimum[v] <= t) || (minimum[v] != null && minimum[v] == t)) continue;\\n            if(minimum[v] == null) minimum[v] = t;\\n            else if(sMinimum[v] == null) sMinimum[v] = t;\\n            else sMinimum[v] = Math.min(sMinimum[v], t);\\n            \\n            int nextT = getTimeAfterWait(t, change);\\n            for(int neighbor: connections.get(v)){\\n                pq.offer(new Vertex(neighbor, nextT + time));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2538808,
                "title": "c-bfs-solution",
                "content": "```\\n#define pii pair<int, int>\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> dist1(n+1, INT_MAX);\\n        vector<int> dist2(n+1, INT_MAX);\\n        vector<vector<int> > graph(n+1);\\n        for(auto e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            \\n        }\\n        queue<pii> q;\\n        dist1[1] = 0;\\n        q.push({0, 1});\\n        while(!q.empty()) {\\n            int cost = q.front().first;\\n            int node = q.front().second;\\n            q.pop();\\n            for(auto nbr : graph[node]) {\\n                int r = cost/change;\\n                int newcost = cost + time;\\n                if(r%2) newcost = change*(1+r) + time;\\n                if(dist1[nbr] > newcost) {\\n                    dist2[nbr] = dist1[nbr];\\n                    dist1[nbr] = newcost;\\n                    q.push({newcost, nbr});\\n                } else if(newcost > dist1[nbr] && newcost < dist2[nbr]) {\\n                    dist2[nbr] = newcost;\\n                    q.push({newcost, nbr});\\n                }\\n            }\\n        }\\n        return dist2[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define pii pair<int, int>\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> dist1(n+1, INT_MAX);\\n        vector<int> dist2(n+1, INT_MAX);\\n        vector<vector<int> > graph(n+1);\\n        for(auto e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n            \\n        }\\n        queue<pii> q;\\n        dist1[1] = 0;\\n        q.push({0, 1});\\n        while(!q.empty()) {\\n            int cost = q.front().first;\\n            int node = q.front().second;\\n            q.pop();\\n            for(auto nbr : graph[node]) {\\n                int r = cost/change;\\n                int newcost = cost + time;\\n                if(r%2) newcost = change*(1+r) + time;\\n                if(dist1[nbr] > newcost) {\\n                    dist2[nbr] = dist1[nbr];\\n                    dist1[nbr] = newcost;\\n                    q.push({newcost, nbr});\\n                } else if(newcost > dist1[nbr] && newcost < dist2[nbr]) {\\n                    dist2[nbr] = newcost;\\n                    q.push({newcost, nbr});\\n                }\\n            }\\n        }\\n        return dist2[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533293,
                "title": "c-bfs-using-queue",
                "content": "BFS - using Queue\\n```\\npublic int SecondMinimum(int n, int[][] edges, int time, int change) {\\n        Dictionary<int, HashSet<int>> graph = new Dictionary<int, HashSet<int>>();\\n        foreach (var edge in edges)\\n        {\\n            int from = edge[0];\\n            int to = edge[1];\\n            if (!graph.ContainsKey(from))\\n                graph.Add(from, new HashSet<int>());\\n            if (!graph.ContainsKey(to))\\n                graph.Add(to, new HashSet<int>());\\n            graph[from].Add(to);\\n            graph[to].Add(from);\\n        }\\n\\n        int[] visited = new int[n + 1];\\n        int[] dist = new int[n + 1];\\n        Array.Fill(dist, -1);\\n\\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n\\n        queue.Enqueue((1,0)); //(node, time)\\n        dist[1] = 0; // 1 is start\\n\\n        while (queue.Count > 0) {\\n            var curr = queue.Dequeue();\\n\\n            int cur = curr.Item1;\\n            int t = curr.Item2;\\n            int tt = 0;\\n            int round = t / change;\\n            \\n            if (round % 2 == 0) //round is even number -- //green light\\n                tt = t + time;\\n            else \\n                tt = (round + 1) * change + time; //wait for green light\\n\\n            foreach (var next in graph[cur]) {\\n                if (visited[next] < 2 && dist[next] < tt) { \\n                    //not visited this node before, or visited this node once, \\n                    //and \"time cost\"(dist[next]) < tt, need to update dist[next] and visited[next]  \\n                    dist[next] = tt;\\n                    visited[next] += 1;\\n                    queue.Enqueue((next, tt));\\n\\n                    if (next == n && visited[next] == 2) //second time to reach destination\\n                        return tt;\\n                }\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "BFS - using Queue\\n```\\npublic int SecondMinimum(int n, int[][] edges, int time, int change) {\\n        Dictionary<int, HashSet<int>> graph = new Dictionary<int, HashSet<int>>();\\n        foreach (var edge in edges)\\n        {\\n            int from = edge[0];\\n            int to = edge[1];\\n            if (!graph.ContainsKey(from))\\n                graph.Add(from, new HashSet<int>());\\n            if (!graph.ContainsKey(to))\\n                graph.Add(to, new HashSet<int>());\\n            graph[from].Add(to);\\n            graph[to].Add(from);\\n        }\\n\\n        int[] visited = new int[n + 1];\\n        int[] dist = new int[n + 1];\\n        Array.Fill(dist, -1);\\n\\n        Queue<(int,int)> queue = new Queue<(int,int)>();\\n\\n        queue.Enqueue((1,0)); //(node, time)\\n        dist[1] = 0; // 1 is start\\n\\n        while (queue.Count > 0) {\\n            var curr = queue.Dequeue();\\n\\n            int cur = curr.Item1;\\n            int t = curr.Item2;\\n            int tt = 0;\\n            int round = t / change;\\n            \\n            if (round % 2 == 0) //round is even number -- //green light\\n                tt = t + time;\\n            else \\n                tt = (round + 1) * change + time; //wait for green light\\n\\n            foreach (var next in graph[cur]) {\\n                if (visited[next] < 2 && dist[next] < tt) { \\n                    //not visited this node before, or visited this node once, \\n                    //and \"time cost\"(dist[next]) < tt, need to update dist[next] and visited[next]  \\n                    dist[next] = tt;\\n                    visited[next] += 1;\\n                    queue.Enqueue((next, tt));\\n\\n                    if (next == n && visited[next] == 2) //second time to reach destination\\n                        return tt;\\n                }\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2523607,
                "title": "c-modified-dijkstras-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int T, int change) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]-1].push_back(edges[i][1]-1);\\n            adj[edges[i][1]-1].push_back(edges[i][0]-1);\\n        }\\n        \\n        vector<vector<int>> vis(n, vector<int>(2, INT_MAX));\\n        vis[0][0] = 0;\\n        set<pair<int, int>> s;\\n        s.insert({vis[0][0], 0});\\n        \\n        while(!s.empty()){\\n            int time = (*s.begin()).first, node = (*s.begin()).second;\\n            if(node==n-1 && time == vis[node][1])\\n                return time;\\n            s.erase(s.begin());\\n            if((time/change)%2 == 1)\\n                time = (1+(time/change))*change;\\n            \\n            for(auto i:adj[node]){\\n                if(vis[i][0]>time+T){\\n                    auto it = s.find({vis[i][0], i});\\n                    if(it!=s.end())\\n                        s.erase(it);\\n                    \\n                    long long movtime = vis[i][0];\\n                    if((movtime/change)%2 == 1)\\n                        movtime = (1+(movtime/change))*change;\\n                    long long newmovtime = time+T;\\n                    if(((time+T)/change)%2 == 1)\\n                        newmovtime = (1+(newmovtime/change))*change;\\n                    \\n                    if(movtime!=newmovtime){\\n                        auto it = s.find({vis[i][1], i});\\n                        if(it!=s.end())\\n                            s.erase(it);\\n                        vis[i][1] = vis[i][0];\\n                        s.insert({vis[i][1], i});\\n                    }\\n                    \\n                    vis[i][0] = time+T;\\n                    s.insert({vis[i][0], i});\\n                }\\n                else if(vis[i][1]>time+T){\\n                    long long movtime = vis[i][0];\\n                    if((movtime/change)%2 == 1)\\n                        movtime = (1+(movtime/change))*change;\\n                    long long newmovtime = time+T;\\n                    if(((time+T)/change)%2 == 1)\\n                        newmovtime = (1+(newmovtime/change))*change;\\n                    \\n                    if(movtime!=newmovtime){\\n                        auto it = s.find({vis[i][1], i});\\n                        if(it!=s.end())\\n                            s.erase(it);\\n                        vis[i][1] = time+T;\\n                        s.insert({vis[i][1], i});\\n                    }\\n                }\\n            }\\n        }\\n        return vis[n-1][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int T, int change) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]-1].push_back(edges[i][1]-1);\\n            adj[edges[i][1]-1].push_back(edges[i][0]-1);\\n        }\\n        \\n        vector<vector<int>> vis(n, vector<int>(2, INT_MAX));\\n        vis[0][0] = 0;\\n        set<pair<int, int>> s;\\n        s.insert({vis[0][0], 0});\\n        \\n        while(!s.empty()){\\n            int time = (*s.begin()).first, node = (*s.begin()).second;\\n            if(node==n-1 && time == vis[node][1])\\n                return time;\\n            s.erase(s.begin());\\n            if((time/change)%2 == 1)\\n                time = (1+(time/change))*change;\\n            \\n            for(auto i:adj[node]){\\n                if(vis[i][0]>time+T){\\n                    auto it = s.find({vis[i][0], i});\\n                    if(it!=s.end())\\n                        s.erase(it);\\n                    \\n                    long long movtime = vis[i][0];\\n                    if((movtime/change)%2 == 1)\\n                        movtime = (1+(movtime/change))*change;\\n                    long long newmovtime = time+T;\\n                    if(((time+T)/change)%2 == 1)\\n                        newmovtime = (1+(newmovtime/change))*change;\\n                    \\n                    if(movtime!=newmovtime){\\n                        auto it = s.find({vis[i][1], i});\\n                        if(it!=s.end())\\n                            s.erase(it);\\n                        vis[i][1] = vis[i][0];\\n                        s.insert({vis[i][1], i});\\n                    }\\n                    \\n                    vis[i][0] = time+T;\\n                    s.insert({vis[i][0], i});\\n                }\\n                else if(vis[i][1]>time+T){\\n                    long long movtime = vis[i][0];\\n                    if((movtime/change)%2 == 1)\\n                        movtime = (1+(movtime/change))*change;\\n                    long long newmovtime = time+T;\\n                    if(((time+T)/change)%2 == 1)\\n                        newmovtime = (1+(newmovtime/change))*change;\\n                    \\n                    if(movtime!=newmovtime){\\n                        auto it = s.find({vis[i][1], i});\\n                        if(it!=s.end())\\n                            s.erase(it);\\n                        vis[i][1] = time+T;\\n                        s.insert({vis[i][1], i});\\n                    }\\n                }\\n            }\\n        }\\n        return vis[n-1][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508550,
                "title": "c-solution-using-2-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> edge(n);\\n        for (vector<int>& e : edges) {\\n            edge[e[0] - 1].push_back(e[1] - 1);\\n            edge[e[1] - 1].push_back(e[0] - 1);\\n        }\\n        vector<int> dist1(n);\\n        vector<bool> vis(n);\\n        vis[n - 1] = true;\\n        vector<int> que;\\n        que.push_back(n - 1);\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            int v = que[i];\\n            for (int u : edge[v]) {\\n                if (!vis[u]) {\\n                    dist1[u] = dist1[v] + 1;\\n                    vis[u] = true;\\n                    que.push_back(u);\\n                }\\n            }\\n        }\\n        vis = vector<bool> (n);\\n        vector<int> dist2(n);\\n        int shortDist = dist1[0];\\n        int isTrue = false;\\n        que.clear();\\n        que.push_back(0);\\n        vis[0] = true;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            int v = que[i];\\n            for (int u : edge[v]) {\\n                if (!vis[u]) {\\n                    if (dist2[v] + dist1[u] == shortDist) {\\n                        isTrue = true;\\n                    }\\n                    dist2[u] = dist2[v] + 1;\\n                    vis[u] = true;\\n                    que.push_back(u);\\n                } else {\\n                    if (dist2[v] == dist2[u]) {\\n                        if (dist2[v] + dist1[u] == shortDist) {\\n                            isTrue = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int dist = shortDist + 2;\\n        if (isTrue) {\\n            --dist;\\n        }\\n        int sol = time;\\n        for (int i = 0; i < dist - 1; i++) {\\n            int t = sol / change;\\n            if (t % 2 == 0) {\\n                sol += time;\\n            } else {\\n                sol = (t + 1) * change;\\n                sol += time;\\n            }\\n        }\\n        return sol;\\n         \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> edge(n);\\n        for (vector<int>& e : edges) {\\n            edge[e[0] - 1].push_back(e[1] - 1);\\n            edge[e[1] - 1].push_back(e[0] - 1);\\n        }\\n        vector<int> dist1(n);\\n        vector<bool> vis(n);\\n        vis[n - 1] = true;\\n        vector<int> que;\\n        que.push_back(n - 1);\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            int v = que[i];\\n            for (int u : edge[v]) {\\n                if (!vis[u]) {\\n                    dist1[u] = dist1[v] + 1;\\n                    vis[u] = true;\\n                    que.push_back(u);\\n                }\\n            }\\n        }\\n        vis = vector<bool> (n);\\n        vector<int> dist2(n);\\n        int shortDist = dist1[0];\\n        int isTrue = false;\\n        que.clear();\\n        que.push_back(0);\\n        vis[0] = true;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            int v = que[i];\\n            for (int u : edge[v]) {\\n                if (!vis[u]) {\\n                    if (dist2[v] + dist1[u] == shortDist) {\\n                        isTrue = true;\\n                    }\\n                    dist2[u] = dist2[v] + 1;\\n                    vis[u] = true;\\n                    que.push_back(u);\\n                } else {\\n                    if (dist2[v] == dist2[u]) {\\n                        if (dist2[v] + dist1[u] == shortDist) {\\n                            isTrue = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int dist = shortDist + 2;\\n        if (isTrue) {\\n            --dist;\\n        }\\n        int sol = time;\\n        for (int i = 0; i < dist - 1; i++) {\\n            int t = sol / change;\\n            if (t % 2 == 0) {\\n                sol += time;\\n            } else {\\n                sol = (t + 1) * change;\\n                sol += time;\\n            }\\n        }\\n        return sol;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351732,
                "title": "optimal-solution-single-bfs-o-m-n",
                "content": "Thinking process:\\n1. The time it takes to reach `n` does not depend on the order of the nodes, only does the path\\'s length matter. The longer the length is, the longer it takes to reach `n`.\\n2. To reach `n` in minimum time, the optimal path to take is the shortest path from `1` to `n`. Let `length` denotes its length, we could easily find `length` by using BFS.\\n3. The second shortest path to reach `n` is the path of length `length+1` if there exists one. Otherwise, its lenght is always`length+2`.\\n\\t<details>\\n\\t<summary>Proof</summary>\\n\\t\\n\\tThe second shortest path always have the length at lest of `length+2`. From the last node of the shortest path, visit back to its previous node, then move back to the last node, we achive a path of length `lenght+2`. Hence, unless there exists a path of length `lenght+1`, `lenght+2` is the second shortest path.\\n\\t</details>\\n\\t\\n4. If a node `x` has its second shortest path of length `x_length+1` then either a node `y` on the shortest path to `x` also has its second longest path of  `y_length+1`, or there\\'s a node whose shortest path is also of length `x_length` and there\\'s an edge connecting `x` and it.\\n\\n```python\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        seen = {1:0}\\n        hasSecond = [0] * (n+1)\\n        g = [[] for _ in range(n+1)]\\n        for u,v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        q = [1]\\n        for u in q:\\n            for v in g[u]:\\n                if seen.get(v) == seen[u]:\\n                    hasSecond[v] = hasSecond[u] = 1\\n            for v in g[u] :\\n                if v not in seen:\\n                    seen[v] = seen[u] + 1\\n                    q.append(v)\\n                if seen[v] == seen[u] + 1:\\n                    hasSecond[v] |= hasSecond[u]\\n                \\n        length = seen[n] + 2 - hasSecond[n]\\n        res = 0\\n        for _ in range(length):\\n            if (res//change) & 1:\\n                res = (res+change) // change * change\\n            res += time\\n        return res\\n   ```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        seen = {1:0}\\n        hasSecond = [0] * (n+1)\\n        g = [[] for _ in range(n+1)]\\n        for u,v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        q = [1]\\n        for u in q:\\n            for v in g[u]:\\n                if seen.get(v) == seen[u]:\\n                    hasSecond[v] = hasSecond[u] = 1\\n            for v in g[u] :\\n                if v not in seen:\\n                    seen[v] = seen[u] + 1\\n                    q.append(v)\\n                if seen[v] == seen[u] + 1:\\n                    hasSecond[v] |= hasSecond[u]\\n                \\n        length = seen[n] + 2 - hasSecond[n]\\n        res = 0\\n        for _ in range(length):\\n            if (res//change) & 1:\\n                res = (res+change) // change * change\\n            res += time\\n        return res\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2289357,
                "title": "c-code-2-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[10005];\\n    int dist[10005];\\n    \\n    int secondMinimum(int n, vector<vector<int>>& v, int time, int change) {\\n        int i;\\n        for (i=0; i<v.size(); i++){\\n            v[i][0]--;\\n            v[i][1]--;\\n            \\n            adj[v[i][0]].push_back(v[i][1]);\\n            adj[v[i][1]].push_back(v[i][0]);\\n        }\\n        \\n        vector<int> dist(n+1,INT_MAX);\\n        queue<int> q;\\n        q.push(0);\\n        dist[0]=0;\\n        \\n        while (!q.empty()){\\n            int val=q.front();\\n            q.pop();\\n            \\n            \\n            for (auto it: adj[val]){\\n                if (dist[it]>dist[val]+1){\\n                    dist[it]=dist[val]+1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        int ans=dist[n-1]+2;\\n        \\n        queue<int> temp;\\n        temp.push(n-1);\\n        bool flag=false;\\n        \\n        while (!temp.empty()){\\n            int node=temp.front();\\n            temp.pop();\\n            \\n            \\n            for (auto it: adj[node]){\\n                if (dist[it]==dist[node]){\\n                    flag=true;\\n                    break;\\n                }\\n                else if (dist[it]+1==dist[node]){\\n                    temp.push(it);\\n                }\\n                \\n            }\\n            \\n            if (flag){\\n                break;\\n            }\\n        }\\n        \\n        \\n        \\n        if (flag){\\n            ans--;\\n        }\\n        \\n        int curr=0;\\n        \\n        for (i=0; i<ans; i++){\\n          if ((curr/change)%2==1){\\n              curr=((curr/change)+1)*change;\\n          } \\n          curr+=time;\\n        }\\n        \\n     return curr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[10005];\\n    int dist[10005];\\n    \\n    int secondMinimum(int n, vector<vector<int>>& v, int time, int change) {\\n        int i;\\n        for (i=0; i<v.size(); i++){\\n            v[i][0]--;\\n            v[i][1]--;\\n            \\n            adj[v[i][0]].push_back(v[i][1]);\\n            adj[v[i][1]].push_back(v[i][0]);\\n        }\\n        \\n        vector<int> dist(n+1,INT_MAX);\\n        queue<int> q;\\n        q.push(0);\\n        dist[0]=0;\\n        \\n        while (!q.empty()){\\n            int val=q.front();\\n            q.pop();\\n            \\n            \\n            for (auto it: adj[val]){\\n                if (dist[it]>dist[val]+1){\\n                    dist[it]=dist[val]+1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        int ans=dist[n-1]+2;\\n        \\n        queue<int> temp;\\n        temp.push(n-1);\\n        bool flag=false;\\n        \\n        while (!temp.empty()){\\n            int node=temp.front();\\n            temp.pop();\\n            \\n            \\n            for (auto it: adj[node]){\\n                if (dist[it]==dist[node]){\\n                    flag=true;\\n                    break;\\n                }\\n                else if (dist[it]+1==dist[node]){\\n                    temp.push(it);\\n                }\\n                \\n            }\\n            \\n            if (flag){\\n                break;\\n            }\\n        }\\n        \\n        \\n        \\n        if (flag){\\n            ans--;\\n        }\\n        \\n        int curr=0;\\n        \\n        for (i=0; i<ans; i++){\\n          if ((curr/change)%2==1){\\n              curr=((curr/change)+1)*change;\\n          } \\n          curr+=time;\\n        }\\n        \\n     return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269511,
                "title": "variant-of-dijkstra-algo",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n, edges, time, change):\\n        # dist: keep the min and sub-min distance so far, using set to keep only 2 unique values\\n        # conn: connection table to record connected nodes \\n        # h: priority queue to track the potential path, in the format of (dist, idx)\\n        h = [(0, 1)]   # starting from node 1, with dist of 0\\n        conn = defaultdict(set)\\n        dist = [set() for _ in range(n+1)]\\n        dist[1] = set([0])\\n        \\n        for s, e in edges:\\n            conn[s].add(e)\\n            conn[e].add(s)\\n        \\n        while h:\\n            d, idx = heappop(h)\\n            if idx == n and len(dist[n]) == 2:\\n                break\\n            \\n            # calculate the cost to nei, for a certain node, all of its neighbors will have the same time cost\\n            if (d // change) % 2 == 0: # green means go, green (0) -> red (1) -> green (2) -> red (3)\\n                cost = d + time\\n            else:\\n                cost = ceil(d / (change * 2)) * (change * 2) + time    \\n            for nei in conn[idx]:\\n                # valid nei is only when it\\'s visited once or twice (only the shortest or sub-shortest \\n                # path is needed), or more times if prior paths generate the same time cost\\n                if len(dist[nei]) <= 1:\\n                    dist[nei].add(cost)\\n                    heappush(h, (cost, nei))\\n        return max(dist[n])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n, edges, time, change):\\n        # dist: keep the min and sub-min distance so far, using set to keep only 2 unique values\\n        # conn: connection table to record connected nodes \\n        # h: priority queue to track the potential path, in the format of (dist, idx)\\n        h = [(0, 1)]   # starting from node 1, with dist of 0\\n        conn = defaultdict(set)\\n        dist = [set() for _ in range(n+1)]\\n        dist[1] = set([0])\\n        \\n        for s, e in edges:\\n            conn[s].add(e)\\n            conn[e].add(s)\\n        \\n        while h:\\n            d, idx = heappop(h)\\n            if idx == n and len(dist[n]) == 2:\\n                break\\n            \\n            # calculate the cost to nei, for a certain node, all of its neighbors will have the same time cost\\n            if (d // change) % 2 == 0: # green means go, green (0) -> red (1) -> green (2) -> red (3)\\n                cost = d + time\\n            else:\\n                cost = ceil(d / (change * 2)) * (change * 2) + time    \\n            for nei in conn[idx]:\\n                # valid nei is only when it\\'s visited once or twice (only the shortest or sub-shortest \\n                # path is needed), or more times if prior paths generate the same time cost\\n                if len(dist[nei]) <= 1:\\n                    dist[nei].add(cost)\\n                    heappush(h, (cost, nei))\\n        return max(dist[n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197380,
                "title": "modified-dijkstra-in-c-solution",
                "content": "This problems could be solved by using Dijksta algorithm which help us to find the shortest path or distance.To solve this problem we need to define one min heap, vector for time taken and frequenct count . we can\\'t move if signal is red so we need to add that rest of time into our current time , to check whether we have green signal or red , we can do following steps... \\n\\t\\t\\t\\t\\t```\\tint signal = currT/change;\\n\\t\\t\\t\\t\\t\\tif(signal%2==0) then colour would be green otherwise else red.\\n\\t\\t\\t\\t\\t```\\n\\t\\twe can understand it in this way like when **currT==0** then we green , after one **change** time colour would turn into **red**, after one change time **red** turns into **green**.. so whenever we have** odd multiple of change** that time color would be **red**.\\n\\t\\t\\n\\t\\tif we haven\\'t freq vector to store the frequency of relaxation then we get TLE . here we have to find the second minimum time so we need to relax the node atmost two times. \\n\\t\\t\\n\\t\\there we have complete code:\\n\\t\\t\\n\\t\\t\\n\\t\\t```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tint secondMinimum(int n, vector<vector<int>>& edges, int time, int change){\\n\\t\\t\\tvector<vector<int>>adj(n+1);\\n\\t\\t\\tfor(auto ed:edges){\\n\\t\\t\\t\\tint u=ed[0];\\n\\t\\t\\t\\tint v= ed[1];\\n\\t\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\t\\tadj[v].push_back(u);\\n\\t\\t\\t}\\n        bool flag=false;\\n        vector<int>d(n+1);\\n        vector<int>freq(n+1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        d[1]=0;\\n        pq.push({0,1});\\n        while(!pq.empty()){\\n            int currT = pq.top().first;\\n            int currN = pq.top().second;\\n            pq.pop();\\n            \\n            int signal = currT/change;\\n            if(signal%2!=0){\\n                currT+=((signal+1)*change - currT);\\n            }\\n            \\n            for(auto x:adj[currN]){\\n                if(d[x]!=currT+time && freq[x]<2){\\n                \\n                if(x==n && flag){\\n                    // cout<<currT+time<<endl;\\n                    return currT+time;\\n                }\\n                 if(x==n){\\n                     flag=true;\\n                 }   \\n                    \\n                    \\n                d[x]=currT+time;\\n                freq[x]++;\\n                pq.push({d[x],x});   \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return d[n];\\n    }\\n};```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\tint signal = currT/change;\\n\\t\\t\\t\\t\\t\\tif(signal%2==0) then colour would be green otherwise else red.\\n\\t\\t\\t\\t\\t```\n```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tint secondMinimum(int n, vector<vector<int>>& edges, int time, int change){\\n\\t\\t\\tvector<vector<int>>adj(n+1);\\n\\t\\t\\tfor(auto ed:edges){\\n\\t\\t\\t\\tint u=ed[0];\\n\\t\\t\\t\\tint v= ed[1];\\n\\t\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\t\\tadj[v].push_back(u);\\n\\t\\t\\t}\\n        bool flag=false;\\n        vector<int>d(n+1);\\n        vector<int>freq(n+1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        d[1]=0;\\n        pq.push({0,1});\\n        while(!pq.empty()){\\n            int currT = pq.top().first;\\n            int currN = pq.top().second;\\n            pq.pop();\\n            \\n            int signal = currT/change;\\n            if(signal%2!=0){\\n                currT+=((signal+1)*change - currT);\\n            }\\n            \\n            for(auto x:adj[currN]){\\n                if(d[x]!=currT+time && freq[x]<2){\\n                \\n                if(x==n && flag){\\n                    // cout<<currT+time<<endl;\\n                    return currT+time;\\n                }\\n                 if(x==n){\\n                     flag=true;\\n                 }   \\n                    \\n                    \\n                d[x]=currT+time;\\n                freq[x]++;\\n                pq.push({d[x],x});   \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return d[n];\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 2154999,
                "title": "python-bfs-with-limiting-two-minimum-times-to-reach-per-node",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        g = defaultdict(list)\\n        for (u, v) in edges:\\n            g[u].append(v) \\n            g[v].append(u) \\n        \\n        dq = deque([(0, 1)])\\n        seen = defaultdict(set)\\n        \\n        \\n        def get_time(elapsed):\\n            res, steps = 0, elapsed // time\\n            while steps > 1:\\n                steps -= 1\\n                res += time\\n                if (res//change) % 2 == 1: \\n                    res = (res//change + 1) * change\\n            return res + time\\n        \\n                \\n        while dq:\\n            t, u = dq.popleft()\\n            if u == n:\\n                if len(seen[n]) < 2:  seen[n].add(t)\\n                else: return get_time(max(seen[n]))\\n            for v in g[u]:\\n                new_time = t + time\\n                if len(seen[v]) == 2: continue\\n                seen[v].add(new_time)\\n                dq.append((new_time, v))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        g = defaultdict(list)\\n        for (u, v) in edges:\\n            g[u].append(v) \\n            g[v].append(u) \\n        \\n        dq = deque([(0, 1)])\\n        seen = defaultdict(set)\\n        \\n        \\n        def get_time(elapsed):\\n            res, steps = 0, elapsed // time\\n            while steps > 1:\\n                steps -= 1\\n                res += time\\n                if (res//change) % 2 == 1: \\n                    res = (res//change + 1) * change\\n            return res + time\\n        \\n                \\n        while dq:\\n            t, u = dq.popleft()\\n            if u == n:\\n                if len(seen[n]) < 2:  seen[n].add(t)\\n                else: return get_time(max(seen[n]))\\n            for v in g[u]:\\n                new_time = t + time\\n                if len(seen[v]) == 2: continue\\n                seen[v].add(new_time)\\n                dq.append((new_time, v))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036852,
                "title": "rust-bfs",
                "content": "```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn second_minimum(n: i32, edges: Vec<Vec<i32>>, time: i32, change: i32) -> i32 {\\n        let n = n as usize;\\n        let mut adj_list: Vec<Vec<usize>> = vec![vec![]; n];\\n        for (v, u) in edges.into_iter().map(|edge| (edge[0] as usize - 1, edge[1] as usize - 1)) {\\n            adj_list[v].push(u);\\n            adj_list[u].push(v);\\n        }\\n        let mut queue: VecDeque<(i32, usize)>  = VecDeque::from([(0, 0)]);\\n        let mut visited: Vec<[Option<i32>; 2]>= vec![[None, None]; n];\\n        visited[0][0] = Some(0); \\n        while let Some((cost, v)) = queue.pop_front() {\\n            if v == n - 1 {\\n                if let Some(cost_1) = visited[v][1] {\\n                    return cost_1;\\n                }\\n            }\\n            let wait_time = if cost % (2 * change) < change { 0 } else { 2 * change -  cost % (2 * change) };\\n            let next_cost = cost + time + wait_time;\\n            for &u in adj_list[v].iter() {\\n                match (visited[u][0], visited[u][1]) {\\n                    (None, None) => { visited[u][0] = Some(next_cost); },\\n                    (Some(cost_0), None) if cost_0 < next_cost => { visited[u][1] = Some(next_cost); },\\n                    (_, _) => { continue; },\\n                };\\n                queue.push_back((next_cost, u));\\n            }\\n        }\\n        unreachable!()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn second_minimum(n: i32, edges: Vec<Vec<i32>>, time: i32, change: i32) -> i32 {\\n        let n = n as usize;\\n        let mut adj_list: Vec<Vec<usize>> = vec![vec![]; n];\\n        for (v, u) in edges.into_iter().map(|edge| (edge[0] as usize - 1, edge[1] as usize - 1)) {\\n            adj_list[v].push(u);\\n            adj_list[u].push(v);\\n        }\\n        let mut queue: VecDeque<(i32, usize)>  = VecDeque::from([(0, 0)]);\\n        let mut visited: Vec<[Option<i32>; 2]>= vec![[None, None]; n];\\n        visited[0][0] = Some(0); \\n        while let Some((cost, v)) = queue.pop_front() {\\n            if v == n - 1 {\\n                if let Some(cost_1) = visited[v][1] {\\n                    return cost_1;\\n                }\\n            }\\n            let wait_time = if cost % (2 * change) < change { 0 } else { 2 * change -  cost % (2 * change) };\\n            let next_cost = cost + time + wait_time;\\n            for &u in adj_list[v].iter() {\\n                match (visited[u][0], visited[u][1]) {\\n                    (None, None) => { visited[u][0] = Some(next_cost); },\\n                    (Some(cost_0), None) if cost_0 < next_cost => { visited[u][1] = Some(next_cost); },\\n                    (_, _) => { continue; },\\n                };\\n                queue.push_back((next_cost, u));\\n            }\\n        }\\n        unreachable!()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686823,
                "title": "simple-and-easy-to-understand-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n, vector<int>());\\n        vector<int> q;\\n        vector<int> cost;\\n        int s = 0;\\n        int c = 0;\\n        vector<int> cost1(n, 1000000000);\\n        vector<int> cost2(n, 1000000000);\\n        \\n        for(int i = 0; i < edges.size(); i++){\\n            edges[i][0]--;\\n            edges[i][1]--;\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(int i = 0; i < adj[0].size(); i++){\\n            q.push_back(adj[0][i]);\\n            cost.push_back(time);\\n            s++;\\n        }\\n        \\n        while(c < s){\\n            if((cost[c] < cost1[q[c]] or cost[c] < cost2[q[c]]) and cost1[q[c]] != cost[c] and cost2[q[c]] != cost[c]){\\n                if(cost[c] < cost1[q[c]]){\\n                    cost2[q[c]] = cost1[q[c]];\\n                    cost1[q[c]] = cost[c];\\n                }\\n                else{\\n                    cost2[q[c]] = cost[c];\\n                }\\n                for(int i = 0; i < adj[q[c]].size(); i++){\\n                    q.push_back(adj[q[c]][i]);\\n                    if((cost[c] / change) % 2)\\n                        cost.push_back(((cost[c] / change) + 1) * change + time);\\n                    else\\n                        cost.push_back(cost[c] + time);\\n                    s++;\\n                }\\n            }\\n            c++;\\n        }\\n        return cost2[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> adj(n, vector<int>());\\n        vector<int> q;\\n        vector<int> cost;\\n        int s = 0;\\n        int c = 0;\\n        vector<int> cost1(n, 1000000000);\\n        vector<int> cost2(n, 1000000000);\\n        \\n        for(int i = 0; i < edges.size(); i++){\\n            edges[i][0]--;\\n            edges[i][1]--;\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(int i = 0; i < adj[0].size(); i++){\\n            q.push_back(adj[0][i]);\\n            cost.push_back(time);\\n            s++;\\n        }\\n        \\n        while(c < s){\\n            if((cost[c] < cost1[q[c]] or cost[c] < cost2[q[c]]) and cost1[q[c]] != cost[c] and cost2[q[c]] != cost[c]){\\n                if(cost[c] < cost1[q[c]]){\\n                    cost2[q[c]] = cost1[q[c]];\\n                    cost1[q[c]] = cost[c];\\n                }\\n                else{\\n                    cost2[q[c]] = cost[c];\\n                }\\n                for(int i = 0; i < adj[q[c]].size(); i++){\\n                    q.push_back(adj[q[c]][i]);\\n                    if((cost[c] / change) % 2)\\n                        cost.push_back(((cost[c] / change) + 1) * change + time);\\n                    else\\n                        cost.push_back(cost[c] + time);\\n                    s++;\\n                }\\n            }\\n            c++;\\n        }\\n        return cost2[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627565,
                "title": "python-bfs-99-6",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        visited = [0] * (n+1)\\n        cur = [1]\\n        step = 0\\n        while cur and visited[n] != 2:\\n            step += 1\\n            temp = set()\\n            for node in cur:\\n                for i in graph[node]:\\n                    if visited[i] < 2 and i not in temp:\\n                        visited[i] += 1\\n                        temp.add(i)\\n                        if visited[n] == 2:\\n                            break\\n                if visited[n] == 2:\\n                    break\\n            cur = list(temp)\\n        # Calculate the time required from 1 to n.\\n        totalTime = 0\\n        greenLightCycle = 2 * change\\n        for _ in range(step):\\n\\t\\t\\t# Make totalTime meet the light cycle \\n            if totalTime % greenLightCycle >= change:\\n                totalTime += greenLightCycle - totalTime % greenLightCycle\\n            totalTime += time\\n        return totalTime\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        visited = [0] * (n+1)\\n        cur = [1]\\n        step = 0\\n        while cur and visited[n] != 2:\\n            step += 1\\n            temp = set()\\n            for node in cur:\\n                for i in graph[node]:\\n                    if visited[i] < 2 and i not in temp:\\n                        visited[i] += 1\\n                        temp.add(i)\\n                        if visited[n] == 2:\\n                            break\\n                if visited[n] == 2:\\n                    break\\n            cur = list(temp)\\n        # Calculate the time required from 1 to n.\\n        totalTime = 0\\n        greenLightCycle = 2 * change\\n        for _ in range(step):\\n\\t\\t\\t# Make totalTime meet the light cycle \\n            if totalTime % greenLightCycle >= change:\\n                totalTime += greenLightCycle - totalTime % greenLightCycle\\n            totalTime += time\\n        return totalTime\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569467,
                "title": "one-bfs-on-two-distances-one-is-the-smallest-distance-and-another-one-is-the-second-smallest-one",
                "content": "```scala\\n  def secondMinimum(n: Int, edges: Array[Array[Int]], time: Int, change: Int): Int = {\\n\\n    type int = Int\\n    import scala.collection.mutable.{HashMap, HashSet, Queue}\\n    type set = HashSet[int]\\n    val graph = new HashMap[int, set]\\n    edges.foreach(ed => {\\n      val a = ed(0)\\n      val b = ed(1)\\n      if (!graph.contains(a)) graph += (a -> new set)\\n      graph(a) += b\\n      if (!graph.contains(b)) graph += (b -> new set)\\n      graph(b) += a\\n    })\\n\\n    val v1, v2 = new HashMap[int, int]\\n    val q      = new Queue[int]\\n    q += 1\\n\\n    var ct = 0\\n    while (q.nonEmpty) {\\n      val k = q.size\\n      val add =\\n        if ((ct / change) % 2 == 0) 0\\n        else\\n          change - (ct % change)\\n\\n      (0 until k).foreach(x => {\\n        val cn = q.dequeue\\n\\n        if (v1.contains(cn) && cn == n && ct != v1(cn)) return ct\\n\\n        if (!v1.contains(cn)) {\\n          v1 += (cn -> ct)\\n        } else if (v1(cn) != ct && !v2.contains(cn)) {\\n          v2 += (cn -> ct)\\n        }\\n\\n        graph(cn).foreach(nb => {\\n          if (\\n            !v1.contains(nb) || (v1.contains(nb) && !v2.contains(nb) && v1(nb) != ct + time + add)\\n          ) {\\n            q += nb\\n          }\\n        })\\n      })\\n      ct = ct + time + add\\n\\n    }\\n    v2(n)\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def secondMinimum(n: Int, edges: Array[Array[Int]], time: Int, change: Int): Int = {\\n\\n    type int = Int\\n    import scala.collection.mutable.{HashMap, HashSet, Queue}\\n    type set = HashSet[int]\\n    val graph = new HashMap[int, set]\\n    edges.foreach(ed => {\\n      val a = ed(0)\\n      val b = ed(1)\\n      if (!graph.contains(a)) graph += (a -> new set)\\n      graph(a) += b\\n      if (!graph.contains(b)) graph += (b -> new set)\\n      graph(b) += a\\n    })\\n\\n    val v1, v2 = new HashMap[int, int]\\n    val q      = new Queue[int]\\n    q += 1\\n\\n    var ct = 0\\n    while (q.nonEmpty) {\\n      val k = q.size\\n      val add =\\n        if ((ct / change) % 2 == 0) 0\\n        else\\n          change - (ct % change)\\n\\n      (0 until k).foreach(x => {\\n        val cn = q.dequeue\\n\\n        if (v1.contains(cn) && cn == n && ct != v1(cn)) return ct\\n\\n        if (!v1.contains(cn)) {\\n          v1 += (cn -> ct)\\n        } else if (v1(cn) != ct && !v2.contains(cn)) {\\n          v2 += (cn -> ct)\\n        }\\n\\n        graph(cn).foreach(nb => {\\n          if (\\n            !v1.contains(nb) || (v1.contains(nb) && !v2.contains(nb) && v1(nb) != ct + time + add)\\n          ) {\\n            q += nb\\n          }\\n        })\\n      })\\n      ct = ct + time + add\\n\\n    }\\n    v2(n)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1532147,
                "title": "python-dijkstra-s-algorithm-bfs",
                "content": "Dijkstra\\'s Algorithm\\n```\\nfrom heapq import heappush, heappop\\nclass Solution(object):\\n    def secondMinimum(self, n, edges, time, change):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type time: int\\n        :type change: int\\n        :rtype: int\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        elapsed = [float(\\'inf\\')]*(n+1)\\n        freq = [0]*(n+1)\\n        change2 = 2*change\\n        pq = [(0, 1)]  # time, vertex\\n        found = False\\n        \\n        while pq:\\n            currT, currV = heappop(pq)\\n            quo = currT//change\\n            if quo%2:\\n                currT += (change2 - currT%change2)\\n            for nxt in graph[currV]:\\n                if currT + time != elapsed[nxt] and freq[nxt] < 2:\\n                    if nxt == n:\\n                        if not found:\\n                            found = True\\n                        else:\\n                            return currT+time\\n                    freq[nxt] += 1\\n                    elapsed[nxt] = currT + time\\n                    heappush(pq, (currT+time,nxt) )\\n```\\n\\n\\nBFS (No need to use Dijkstra because all weights of the edges are equal)\\n\\n```\\nclass Solution(object):\\n    def secondMinimum(self, n, edges, time, change):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type time: int\\n        :type change: int\\n        :rtype: int\\n        \"\"\"        \\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        elapsed = [float(\\'inf\\')]*(n+1)\\n        freq = [0]*(n+1)\\n        change2 = 2*change\\n        queue = collections.deque([(0, 1)])  # time, vertex\\n        found = False\\n        \\n        while queue:\\n            currT, currV = queue.popleft()\\n            quo = currT//change\\n            if quo%2:\\n                currT += (change2 - currT%change2)\\n            for nxt in graph[currV]:\\n                if currT + time != elapsed[nxt] and freq[nxt] < 2:\\n                    if nxt == n:\\n                        if not found:\\n                            found = True\\n                        else:\\n                            return currT+time\\n                    freq[nxt] += 1\\n                    elapsed[nxt] = currT + time\\n                    queue.append((currT+time,nxt))   \\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution(object):\\n    def secondMinimum(self, n, edges, time, change):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type time: int\\n        :type change: int\\n        :rtype: int\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        elapsed = [float(\\'inf\\')]*(n+1)\\n        freq = [0]*(n+1)\\n        change2 = 2*change\\n        pq = [(0, 1)]  # time, vertex\\n        found = False\\n        \\n        while pq:\\n            currT, currV = heappop(pq)\\n            quo = currT//change\\n            if quo%2:\\n                currT += (change2 - currT%change2)\\n            for nxt in graph[currV]:\\n                if currT + time != elapsed[nxt] and freq[nxt] < 2:\\n                    if nxt == n:\\n                        if not found:\\n                            found = True\\n                        else:\\n                            return currT+time\\n                    freq[nxt] += 1\\n                    elapsed[nxt] = currT + time\\n                    heappush(pq, (currT+time,nxt) )\\n```\n```\\nclass Solution(object):\\n    def secondMinimum(self, n, edges, time, change):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type time: int\\n        :type change: int\\n        :rtype: int\\n        \"\"\"        \\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        elapsed = [float(\\'inf\\')]*(n+1)\\n        freq = [0]*(n+1)\\n        change2 = 2*change\\n        queue = collections.deque([(0, 1)])  # time, vertex\\n        found = False\\n        \\n        while queue:\\n            currT, currV = queue.popleft()\\n            quo = currT//change\\n            if quo%2:\\n                currT += (change2 - currT%change2)\\n            for nxt in graph[currV]:\\n                if currT + time != elapsed[nxt] and freq[nxt] < 2:\\n                    if nxt == n:\\n                        if not found:\\n                            found = True\\n                        else:\\n                            return currT+time\\n                    freq[nxt] += 1\\n                    elapsed[nxt] = currT + time\\n                    queue.append((currT+time,nxt))   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529282,
                "title": "commented-java-bfs-code",
                "content": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        ArrayList<Integer> graph[] = new ArrayList[n+1];\\n        for(int node =0;node<=n;node++) graph[node] = new ArrayList();\\n        for(int edge[] : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n        int minTime[][] = new int[n+1][2];\\n        // minTime[node][0] -> minimum time to reach node\\n        // minTime[node][1] -> second minimum time to reach node\\n        for(int node =0;node<=n;node++){\\n            Arrays.fill(minTime[node],Integer.MAX_VALUE);\\n        }\\n        \\n        Queue<Helper> queue = new ArrayDeque();\\n        queue.add(new Helper(1,0,1,false));\\n        \\n        while(queue.size()>0){\\n                Helper helper = queue.remove();\\n                int node = helper.node;\\n                int currTime = helper.currTime;\\n                int counter =  helper.counter;\\n                boolean isRed = helper.isRed;\\n            \\n                // process current node only if better minimum time found or\\n                // better second minimum time found \\n                if(currTime<minTime[node][0]){\\n                    minTime[node][0] = currTime;\\n                }else if(currTime>minTime[node][0]&&currTime<minTime[node][1]){\\n                    minTime[node][1] = currTime;\\n                }\\n                else continue;\\n            \\n                // if current signal is red , then wait till it becomes green\\n                if(isRed==true){\\n                   currTime = change*counter;\\n                   counter++; // counter incremented , counter points to \\n                              // next multiple of change when signal will turn red \\n                }\\n                \\n                boolean isNextSignalRed = false; // now current signal is green , next signal will also be\\n                                                 // green as specified in question \\n                                                 // All signals change at the same time\\n              \\n                // find out state of signal so that once you process next node\\n                // you know whether the signal for the node is red or green\\n                while((currTime+time)>=change*counter){\\n                        isNextSignalRed^=true;\\n                        counter++;\\n                }\\n                \\n                // process next node if and only if\\n                // better minimum time found for next node or\\n                // better second minimum time found for next node\\n                for(int nextNode : graph[node]){\\n                    if((currTime+time)<minTime[nextNode][0]){        \\n                        queue.add(new Helper(nextNode,currTime+time,counter,isNextSignalRed));\\n                    }else if((currTime+time)>minTime[nextNode][0]&&(currTime+time)<minTime[nextNode][1]){\\n                        queue.add(new Helper(nextNode,currTime+time,counter,isNextSignalRed));\\n                    }\\n                }\\n            }\\n        \\n        return minTime[n][1];\\n    }\\n}\\nclass Helper{\\n    int node;\\n    int currTime; // current time required to reach node\\n    int counter; // next multiple when signal will turn red \\n    boolean isRed; // if isRed is true that means currently signal is red \\n    \\n    public Helper(int node ,int currTime , int counter , boolean isRed){\\n        this.node = node;\\n        this.currTime = currTime;\\n        this.counter = counter;\\n        this.isRed = isRed;\\n    }\\n}\\n```\\n\\nWe will be visiting each node atmost twice so time complexity iss similar to BFS",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        ArrayList<Integer> graph[] = new ArrayList[n+1];\\n        for(int node =0;node<=n;node++) graph[node] = new ArrayList();\\n        for(int edge[] : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n        int minTime[][] = new int[n+1][2];\\n        // minTime[node][0] -> minimum time to reach node\\n        // minTime[node][1] -> second minimum time to reach node\\n        for(int node =0;node<=n;node++){\\n            Arrays.fill(minTime[node],Integer.MAX_VALUE);\\n        }\\n        \\n        Queue<Helper> queue = new ArrayDeque();\\n        queue.add(new Helper(1,0,1,false));\\n        \\n        while(queue.size()>0){\\n                Helper helper = queue.remove();\\n                int node = helper.node;\\n                int currTime = helper.currTime;\\n                int counter =  helper.counter;\\n                boolean isRed = helper.isRed;\\n            \\n                // process current node only if better minimum time found or\\n                // better second minimum time found \\n                if(currTime<minTime[node][0]){\\n                    minTime[node][0] = currTime;\\n                }else if(currTime>minTime[node][0]&&currTime<minTime[node][1]){\\n                    minTime[node][1] = currTime;\\n                }\\n                else continue;\\n            \\n                // if current signal is red , then wait till it becomes green\\n                if(isRed==true){\\n                   currTime = change*counter;\\n                   counter++; // counter incremented , counter points to \\n                              // next multiple of change when signal will turn red \\n                }\\n                \\n                boolean isNextSignalRed = false; // now current signal is green , next signal will also be\\n                                                 // green as specified in question \\n                                                 // All signals change at the same time\\n              \\n                // find out state of signal so that once you process next node\\n                // you know whether the signal for the node is red or green\\n                while((currTime+time)>=change*counter){\\n                        isNextSignalRed^=true;\\n                        counter++;\\n                }\\n                \\n                // process next node if and only if\\n                // better minimum time found for next node or\\n                // better second minimum time found for next node\\n                for(int nextNode : graph[node]){\\n                    if((currTime+time)<minTime[nextNode][0]){        \\n                        queue.add(new Helper(nextNode,currTime+time,counter,isNextSignalRed));\\n                    }else if((currTime+time)>minTime[nextNode][0]&&(currTime+time)<minTime[nextNode][1]){\\n                        queue.add(new Helper(nextNode,currTime+time,counter,isNextSignalRed));\\n                    }\\n                }\\n            }\\n        \\n        return minTime[n][1];\\n    }\\n}\\nclass Helper{\\n    int node;\\n    int currTime; // current time required to reach node\\n    int counter; // next multiple when signal will turn red \\n    boolean isRed; // if isRed is true that means currently signal is red \\n    \\n    public Helper(int node ,int currTime , int counter , boolean isRed){\\n        this.node = node;\\n        this.currTime = currTime;\\n        this.counter = counter;\\n        this.isRed = isRed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528487,
                "title": "python-bfs-faster-than-100",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n\\n        N = dict()\\n        Test = dict()\\n        ##N[j] is a list of neighbors of j\\n        ##Test[j] will be a length 2 list [shortestpath from 1, second shortest path from 1]\\n        \\n        ##Initialize\\n        for j in range(n):\\n            N[j+1] =[]\\n            Test[j+1] = []\\n        \\n        #set up neighbors\\n        for x,y in edges:\\n            N[x].append(y)\\n            N[y].append(x)\\n            \\n        ##We perform a Breadth First Search\\n        D = deque()\\n        \\n        ## D will consist of elements of the form (x,y) where x is a vertex\\n        ## and y represents that one of the minimum two distances from 1 to \\n        ## x is y\\n        D.append((1,0))\\n        Test[1] = [0]\\n\\n        while len(D) > 0:\\n\\n            x,d = D.popleft()\\n            for neighbor in N[x]:\\n                ##if we haven\\'t seen neighbor before, add it to the queue\\n                ## and keep track of it in Test dictionary\\n                if len(Test[neighbor]) == 0:\\n                    Test[neighbor].append(d+1)\\n                    D.append((neighbor,d+1))\\n                ##if we have seen it before, check if the new distance is different from \\n                ## what we have seen. If so add it to the queue and update Test\\n                elif len(Test[neighbor]) == 1:\\n                    if Test[neighbor][0] != d+1:\\n                        Test[neighbor].append(d+1)\\n                        D.append((neighbor,d+1))\\n                ##Otherwise we have seen it before and move on\\n                else:\\n                    continue\\n        steps = Test[n][1]\\n        ##lastly, the computation of time only depends on the number of steps\\n        ## so we create an auxillary function to compute this\\n        return self.f(steps,time,change,0)\\n    ##auxillary function to compute the time it takes to travel a given number of steps\\n\\n    def f(self,steps, time, change,mymod):\\n        if steps ==0:\\n            return 0\\n        else:\\n            extra = 0\\n            if mymod >= change:\\n                extra += 2*change - mymod \\n\\n            return time +extra+ self.f(steps - 1, time, change,(mymod + time+extra) % (2*change))\\n    \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n\\n        N = dict()\\n        Test = dict()\\n        ##N[j] is a list of neighbors of j\\n        ##Test[j] will be a length 2 list [shortestpath from 1, second shortest path from 1]\\n        \\n        ##Initialize\\n        for j in range(n):\\n            N[j+1] =[]\\n            Test[j+1] = []\\n        \\n        #set up neighbors\\n        for x,y in edges:\\n            N[x].append(y)\\n            N[y].append(x)\\n            \\n        ##We perform a Breadth First Search\\n        D = deque()\\n        \\n        ## D will consist of elements of the form (x,y) where x is a vertex\\n        ## and y represents that one of the minimum two distances from 1 to \\n        ## x is y\\n        D.append((1,0))\\n        Test[1] = [0]\\n\\n        while len(D) > 0:\\n\\n            x,d = D.popleft()\\n            for neighbor in N[x]:\\n                ##if we haven\\'t seen neighbor before, add it to the queue\\n                ## and keep track of it in Test dictionary\\n                if len(Test[neighbor]) == 0:\\n                    Test[neighbor].append(d+1)\\n                    D.append((neighbor,d+1))\\n                ##if we have seen it before, check if the new distance is different from \\n                ## what we have seen. If so add it to the queue and update Test\\n                elif len(Test[neighbor]) == 1:\\n                    if Test[neighbor][0] != d+1:\\n                        Test[neighbor].append(d+1)\\n                        D.append((neighbor,d+1))\\n                ##Otherwise we have seen it before and move on\\n                else:\\n                    continue\\n        steps = Test[n][1]\\n        ##lastly, the computation of time only depends on the number of steps\\n        ## so we create an auxillary function to compute this\\n        return self.f(steps,time,change,0)\\n    ##auxillary function to compute the time it takes to travel a given number of steps\\n\\n    def f(self,steps, time, change,mymod):\\n        if steps ==0:\\n            return 0\\n        else:\\n            extra = 0\\n            if mymod >= change:\\n                extra += 2*change - mymod \\n\\n            return time +extra+ self.f(steps - 1, time, change,(mymod + time+extra) % (2*change))\\n    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528222,
                "title": "python-basically-dijkstra",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], dt: int, change: int) -> int:\\n        \\'\\'\\'\\n        If we have a 1D graph (ie, a straight line of nodes) then the answer will always be the time taken to walk\\n        to node n, walk back to n - 1 and back to n.\\n        \\n        If we do not have a 1D graph, then we still have to consider the above path as a contender. However, that should be\\n        the only contending path for which we revisit a node. Reasoning: The path i ==> i+1 ==> i ==> i+1 takes the same amount of time\\n        regardless of which node i.\\n        \\n        If time // change is odd, then stop. Else, go. Stopping just incurs a time penalty of change, and then we still go anyway\\n        \\'\\'\\'\\n        \\n        visited = set()\\n        graph = defaultdict(list)\\n        \\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        qHeap = [(0, 1)]  # time (t), node\\n        finished = set()        \\n        freq = defaultdict(int)\\n        \\n        while qHeap:\\n            t, node = heappop(qHeap)       \\n            \\n            if node == n:\\n                finished.add(t)\\n                    \\n                if len(finished) == 2:\\n                    return max(finished)\\n                \\n            stop_cost = t//change % 2\\n            if stop_cost:\\n                # t should now become the first multiple of change that is larger than t. t = change * (t//change + 1)\\n                t = change * (t // change + 1)\\n            \\n            for v in graph[node]:\\n                # We can filter by frequency less than 2 because we should never have to visit a node more\\n                # than twice, since we are looking for the second minimum time\\n                if (t + dt, v) not in visited and (v != node or (v == n - 1 and node == n)) and freq[v] < 2:                    \\n                    visited.add((t + dt, v))                    \\n                    freq[v] += 1\\n                    heappush(qHeap, (t + dt, v))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], dt: int, change: int) -> int:\\n        \\'\\'\\'\\n        If we have a 1D graph (ie, a straight line of nodes) then the answer will always be the time taken to walk\\n        to node n, walk back to n - 1 and back to n.\\n        \\n        If we do not have a 1D graph, then we still have to consider the above path as a contender. However, that should be\\n        the only contending path for which we revisit a node. Reasoning: The path i ==> i+1 ==> i ==> i+1 takes the same amount of time\\n        regardless of which node i.\\n        \\n        If time // change is odd, then stop. Else, go. Stopping just incurs a time penalty of change, and then we still go anyway\\n        \\'\\'\\'\\n        \\n        visited = set()\\n        graph = defaultdict(list)\\n        \\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        qHeap = [(0, 1)]  # time (t), node\\n        finished = set()        \\n        freq = defaultdict(int)\\n        \\n        while qHeap:\\n            t, node = heappop(qHeap)       \\n            \\n            if node == n:\\n                finished.add(t)\\n                    \\n                if len(finished) == 2:\\n                    return max(finished)\\n                \\n            stop_cost = t//change % 2\\n            if stop_cost:\\n                # t should now become the first multiple of change that is larger than t. t = change * (t//change + 1)\\n                t = change * (t // change + 1)\\n            \\n            for v in graph[node]:\\n                # We can filter by frequency less than 2 because we should never have to visit a node more\\n                # than twice, since we are looking for the second minimum time\\n                if (t + dt, v) not in visited and (v != node or (v == n - 1 and node == n)) and freq[v] < 2:                    \\n                    visited.add((t + dt, v))                    \\n                    freq[v] += 1\\n                    heappush(qHeap, (t + dt, v))",
                "codeTag": "Java"
            },
            {
                "id": 1527744,
                "title": "python-bfs-once-reach-n-then-the-second-could-be-step-back-and-forward",
                "content": "shortest path graph problem \\nuse BFS to get the shortest path to destination\\nonce reach n break the loop\\nsearch in the nextstep if there is any point was connect to n: if so. then the second path would be the firstpathstep+1\\nif not then the second path would be the firstpath step back and forward that is the firstpathsetp+2\\n\\nto make the function more efficient\\nreduce the duplicate visit\\nwe would like to find the second reach\\nso in  bfs  every points no need to visit three times. as the second time visit was slow enough.\\n```\\n def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        adj = defaultdict(list)\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n       \\n        visitonce=[False]*(n+1)\\n        visittwice=[False]*(n+1)\\n        visitonce[1]=True\\n        second = 0\\n        current = set([1])\\n\\n        while len(current):\\n            multiinternal = second // change\\n            if multiinternal % 2 == 1:\\n                second += change-(second % change)\\n            second += time\\n            nextpoint = set()\\n            for p in current:\\n                for conn in adj[p]:\\n                    nextpoint.add(conn)\\n            \\n            if n in nextpoint:                 \\n                current=nextpoint\\n                break\\n            newpath=set()\\n            for con in nextpoint:\\n                if visitonce[con]==False:\\n                    visitonce[con]=True\\n                    newpath.add(con)\\n                elif visittwice[con]==False:\\n                    visittwice[con]=True\\n                    newpath.add(con)               \\n            current = newpath    \\n                       \\n        step=2\\n        for cur in current:\\n            if cur in adj[n]:\\n                step=1\\n                break\\n        for i in range(step):\\n            multiinternal = second // change\\n            if multiinternal % 2 == 1:\\n                second += change-(second % change)\\n            second += time\\n        return second\\n```",
                "solutionTags": [],
                "code": "```\\n def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        adj = defaultdict(list)\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n       \\n        visitonce=[False]*(n+1)\\n        visittwice=[False]*(n+1)\\n        visitonce[1]=True\\n        second = 0\\n        current = set([1])\\n\\n        while len(current):\\n            multiinternal = second // change\\n            if multiinternal % 2 == 1:\\n                second += change-(second % change)\\n            second += time\\n            nextpoint = set()\\n            for p in current:\\n                for conn in adj[p]:\\n                    nextpoint.add(conn)\\n            \\n            if n in nextpoint:                 \\n                current=nextpoint\\n                break\\n            newpath=set()\\n            for con in nextpoint:\\n                if visitonce[con]==False:\\n                    visitonce[con]=True\\n                    newpath.add(con)\\n                elif visittwice[con]==False:\\n                    visittwice[con]=True\\n                    newpath.add(con)               \\n            current = newpath    \\n                       \\n        step=2\\n        for cur in current:\\n            if cur in adj[n]:\\n                step=1\\n                break\\n        for i in range(step):\\n            multiinternal = second // change\\n            if multiinternal % 2 == 1:\\n                second += change-(second % change)\\n            second += time\\n        return second\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1527349,
                "title": "c-clean-code",
                "content": "\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> gmp[n + 1];\\n        int mint1[n+1];\\n        int mint2[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            mint1[i] = mint2[i] = INT_MAX;\\n        }\\n        queue<int> mq;\\n        \\n        for (auto & e : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            gmp[u].push_back(v);\\n            gmp[v].push_back(u);\\n        }\\n        \\n        mint1[1] = 0;\\n        \\n        mq.push(1);\\n        \\n        int curr_time = 0;\\n        \\n        while (mq.size()) {\\n            curr_time += time;\\n            \\n            for (int i = mq.size(); i > 0; i--) {\\n                int prev_node = mq.front();\\n                mq.pop();\\n                \\n                for (auto node : gmp[prev_node]) {\\n                    if (curr_time < mint1[node]) {\\n                        mint2[node] = mint1[node];\\n                        mint1[node] = curr_time;\\n                        mq.push(node);\\n                    }\\n                    else if (curr_time == mint1[node]) {\\n\\n                    }\\n                    else if (curr_time < mint2[node]) {\\n                        mint2[node] = curr_time;\\n                        mq.push(node);\\n                    }                    \\n                }\\n            }\\n            \\n            if ((curr_time / change) % 2) {\\n                // odd, red light\\n                int offset = curr_time % change;\\n                curr_time += change - offset;\\n                // now green light, let\\'s go\\n            }            \\n        }\\n        \\n        return mint2[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<int> gmp[n + 1];\\n        int mint1[n+1];\\n        int mint2[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            mint1[i] = mint2[i] = INT_MAX;\\n        }\\n        queue<int> mq;\\n        \\n        for (auto & e : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            gmp[u].push_back(v);\\n            gmp[v].push_back(u);\\n        }\\n        \\n        mint1[1] = 0;\\n        \\n        mq.push(1);\\n        \\n        int curr_time = 0;\\n        \\n        while (mq.size()) {\\n            curr_time += time;\\n            \\n            for (int i = mq.size(); i > 0; i--) {\\n                int prev_node = mq.front();\\n                mq.pop();\\n                \\n                for (auto node : gmp[prev_node]) {\\n                    if (curr_time < mint1[node]) {\\n                        mint2[node] = mint1[node];\\n                        mint1[node] = curr_time;\\n                        mq.push(node);\\n                    }\\n                    else if (curr_time == mint1[node]) {\\n\\n                    }\\n                    else if (curr_time < mint2[node]) {\\n                        mint2[node] = curr_time;\\n                        mq.push(node);\\n                    }                    \\n                }\\n            }\\n            \\n            if ((curr_time / change) % 2) {\\n                // odd, red light\\n                int offset = curr_time % change;\\n                curr_time += change - offset;\\n                // now green light, let\\'s go\\n            }            \\n        }\\n        \\n        return mint2[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526817,
                "title": "clean-2-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> g(n); // graph\\n        vector<int> d20(n), d2n(n); //BFS distance from 0 and BFS distance from n\\n        for(auto & v : edges){\\n            v[0]--; v[1]--; //let indices go from 0 to n-1\\n            g[v[0]].emplace_back(v[1]);\\n            g[v[1]].emplace_back(v[0]);\\n        }\\n        \\n        queue<int> q;\\n        \\n        //BFS from 0\\n        q.push(0);\\n        while(q.size()){\\n            int t = q.front(); q.pop();\\n            for(int to : g[t]){\\n                if(!to or d20[to]) continue;\\n                d20[to] = d20[t]+1;\\n                q.push(to);\\n            }\\n        }\\n        \\n        //BFS from n-1\\n        q.push(n-1);\\n        while(q.size()){\\n            int t = q.front(); q.pop();\\n            for(int to : g[t]){\\n                if(to == n-1 or d2n[to]) continue;\\n                d2n[to] = d2n[t] + 1;\\n                q.push(to);\\n            }\\n        }\\n\\n        int sec = d20[n-1] + 2;\\n        for(int i = 0; i < n; i++){\\n            if(d20[i] + d2n[i] == d20[n-1] + 1){\\n                sec--;\\n                break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < sec; i++){\\n            ans += time;\\n            if((ans / change)%2 and i != sec - 1){\\n                ans += (change - (ans % change));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<vector<int>> g(n); // graph\\n        vector<int> d20(n), d2n(n); //BFS distance from 0 and BFS distance from n\\n        for(auto & v : edges){\\n            v[0]--; v[1]--; //let indices go from 0 to n-1\\n            g[v[0]].emplace_back(v[1]);\\n            g[v[1]].emplace_back(v[0]);\\n        }\\n        \\n        queue<int> q;\\n        \\n        //BFS from 0\\n        q.push(0);\\n        while(q.size()){\\n            int t = q.front(); q.pop();\\n            for(int to : g[t]){\\n                if(!to or d20[to]) continue;\\n                d20[to] = d20[t]+1;\\n                q.push(to);\\n            }\\n        }\\n        \\n        //BFS from n-1\\n        q.push(n-1);\\n        while(q.size()){\\n            int t = q.front(); q.pop();\\n            for(int to : g[t]){\\n                if(to == n-1 or d2n[to]) continue;\\n                d2n[to] = d2n[t] + 1;\\n                q.push(to);\\n            }\\n        }\\n\\n        int sec = d20[n-1] + 2;\\n        for(int i = 0; i < n; i++){\\n            if(d20[i] + d2n[i] == d20[n-1] + 1){\\n                sec--;\\n                break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < sec; i++){\\n            ans += time;\\n            if((ans / change)%2 and i != sec - 1){\\n                ans += (change - (ans % change));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526663,
                "title": "go-modified-dijkstra-s",
                "content": "# Explanation\\n\\nUse Dijkstra\\'s, but find the two min times rather than one. When visiting a node with a total time that is the same as before, or greater than the second smallest time, then skip the visit.\\n\\n# Perf notes\\n\\n* The maximum possible time for a second visit is (10^4+2) * 10^3 ~= 10^7, so it\\'s OK to use an uint32 instead of int. Recall that ints are a \"machine word\" in size, which on Leetcode machines is 64 bits. That\\'s 32 bits of wasted space\\n* Indices should be uint16 (1-10^4). For the weightedEdge struct it will not help because of struct padding / memory alignment, but it reduces the size of the adjacency list.\\n\\n# Solution\\n\\n```go\\nfunc secondMinimum(n int, edges [][]int, time int, change int) int {\\n\\t// Perform Dijkstra\\'s with the modification that each node can be visited\\n\\t// twice, and there are two (unique) min times.\\n\\tadj := make([][]uint16, n+1)\\n\\tfor _, edge := range edges {\\n\\t\\ta, b := edge[0], edge[1]\\n\\t\\tadj[a] = append(adj[a], uint16(b))\\n\\t\\tadj[b] = append(adj[b], uint16(a))\\n\\t}\\n\\n\\tminTimes := make([][2]uint32, n+1)\\n\\tfor i := range minTimes {\\n\\t\\tminTimes[i] = [2]uint32{math.MaxInt32, math.MaxInt32}\\n\\t}\\n\\n\\th := DistanceHeap{weightedEdge{0, 1}}\\n\\tfor len(h) > 0 {\\n\\t\\te := heap.Pop(&h).(weightedEdge)\\n\\t\\tu, t := e.node, e.arrivalTime\\n\\t\\tif t == minTimes[u][0] || t >= minTimes[u][1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif t < minTimes[u][0] {\\n\\t\\t\\tminTimes[u][0] = t\\n\\t\\t} else {\\n\\t\\t\\tminTimes[u][1] = t\\n\\t\\t}\\n\\n\\t\\t// If light is currently red, wait for a green signal.\\n\\t\\td := t / uint32(change)\\n\\t\\tif isGreen := d%2 == 0; !isGreen {\\n\\t\\t\\tnextGreen := (d + 1) * uint32(change)\\n\\t\\t\\tt = max(t, nextGreen)\\n\\t\\t}\\n\\t\\tfor _, nei := range adj[u] {\\n\\t\\t\\tif t+uint32(time) >= minTimes[nei][1] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\theap.Push(&h, weightedEdge{\\n\\t\\t\\t\\tarrivalTime: t + uint32(time),\\n\\t\\t\\t\\tnode:        nei,\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\treturn int(minTimes[n][1])\\n}\\n\\nfunc max(a, b uint32) uint32 {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\ntype weightedEdge struct {\\n\\tarrivalTime uint32\\n\\tnode        uint16\\n}\\n\\ntype DistanceHeap []weightedEdge\\n\\nfunc (h DistanceHeap) Len() int { return len(h) }\\nfunc (h DistanceHeap) Swap(i, j int) {\\n\\th[i], h[j] = h[j], h[i]\\n}\\nfunc (h DistanceHeap) Less(i, j int) bool {\\n\\treturn h[i].arrivalTime < h[j].arrivalTime\\n}\\nfunc (h *DistanceHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(weightedEdge))\\n}\\nfunc (h *DistanceHeap) Pop() interface{} {\\n\\tn := len(*h)\\n\\tit := (*h)[n-1]\\n\\t*h = (*h)[:n-1]\\n\\treturn it\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc secondMinimum(n int, edges [][]int, time int, change int) int {\\n\\t// Perform Dijkstra\\'s with the modification that each node can be visited\\n\\t// twice, and there are two (unique) min times.\\n\\tadj := make([][]uint16, n+1)\\n\\tfor _, edge := range edges {\\n\\t\\ta, b := edge[0], edge[1]\\n\\t\\tadj[a] = append(adj[a], uint16(b))\\n\\t\\tadj[b] = append(adj[b], uint16(a))\\n\\t}\\n\\n\\tminTimes := make([][2]uint32, n+1)\\n\\tfor i := range minTimes {\\n\\t\\tminTimes[i] = [2]uint32{math.MaxInt32, math.MaxInt32}\\n\\t}\\n\\n\\th := DistanceHeap{weightedEdge{0, 1}}\\n\\tfor len(h) > 0 {\\n\\t\\te := heap.Pop(&h).(weightedEdge)\\n\\t\\tu, t := e.node, e.arrivalTime\\n\\t\\tif t == minTimes[u][0] || t >= minTimes[u][1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif t < minTimes[u][0] {\\n\\t\\t\\tminTimes[u][0] = t\\n\\t\\t} else {\\n\\t\\t\\tminTimes[u][1] = t\\n\\t\\t}\\n\\n\\t\\t// If light is currently red, wait for a green signal.\\n\\t\\td := t / uint32(change)\\n\\t\\tif isGreen := d%2 == 0; !isGreen {\\n\\t\\t\\tnextGreen := (d + 1) * uint32(change)\\n\\t\\t\\tt = max(t, nextGreen)\\n\\t\\t}\\n\\t\\tfor _, nei := range adj[u] {\\n\\t\\t\\tif t+uint32(time) >= minTimes[nei][1] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\theap.Push(&h, weightedEdge{\\n\\t\\t\\t\\tarrivalTime: t + uint32(time),\\n\\t\\t\\t\\tnode:        nei,\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\treturn int(minTimes[n][1])\\n}\\n\\nfunc max(a, b uint32) uint32 {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\ntype weightedEdge struct {\\n\\tarrivalTime uint32\\n\\tnode        uint16\\n}\\n\\ntype DistanceHeap []weightedEdge\\n\\nfunc (h DistanceHeap) Len() int { return len(h) }\\nfunc (h DistanceHeap) Swap(i, j int) {\\n\\th[i], h[j] = h[j], h[i]\\n}\\nfunc (h DistanceHeap) Less(i, j int) bool {\\n\\treturn h[i].arrivalTime < h[j].arrivalTime\\n}\\nfunc (h *DistanceHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(weightedEdge))\\n}\\nfunc (h *DistanceHeap) Pop() interface{} {\\n\\tn := len(*h)\\n\\tit := (*h)[n-1]\\n\\t*h = (*h)[:n-1]\\n\\treturn it\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1526377,
                "title": "kotlin-single-bfs-solution-o-n",
                "content": "Solution:\\n- Observation: The time and change were for distraction only. Any path that has the same length ended up costing the same amount of time. Moreover, the longer the path the more time it costs. Thus, only the length of the path is important.\\n1. We use BFS to get the second minimum length of the path from 1 to n. To do that, we allow each node to be visited twice and record the shortest path & second shortest path to that node.\\n2. Next, with that length, we only need to calculate the total time it takes.\\n\\n```\\nclass Solution {\\n    private lateinit var adj: List<MutableList<Int>> \\n    \\n    fun bfs(n: Int): Int {\\n        val dist = MutableList<Pair<Int, Int>>(n + 1) { 0 to 0 }\\n        val q = LinkedList<Pair<Int,Int>>()\\n        q.add(1 to 0)\\n        while (!q.isEmpty()) {\\n            val (u, d) = q.poll()\\n            val (firstMin, secondMin) = dist[u]\\n            if (firstMin != 0 && secondMin != 0) continue \\n            if (firstMin == 0) {\\n                dist[u] = d to 0\\n            } else if (firstMin < d) {\\n                dist[u] = firstMin to d\\n            }\\n            for (v in adj[u]) {\\n                q.add(v to d + 1)\\n            }\\n        }\\n        val (_, secondMinReach) = dist.last()\\n        return secondMinReach\\n    }\\n    \\n    fun calculateTotalTime(pathLength: Int, time: Int, change: Int): Int {\\n        var elapsed = 0\\n        for (i in 1..pathLength) {\\n            elapsed += time\\n            val redLight = (elapsed / change) % 2 == 1\\n            if (redLight && i < pathLength) {\\n                elapsed = (elapsed / change + 1) * change\\n            }\\n        }\\n        return elapsed\\n    }\\n    \\n    fun secondMinimum(n: Int, edges: Array<IntArray>, time: Int, change: Int): Int {\\n        adj = List<MutableList<Int>>(n + 1) { mutableListOf() }\\n        for ((u, v) in edges) {\\n           adj[u].add(v)\\n           adj[v].add(u)\\n        }\\n        return calculateTotalTime(bfs(n), time, change)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private lateinit var adj: List<MutableList<Int>> \\n    \\n    fun bfs(n: Int): Int {\\n        val dist = MutableList<Pair<Int, Int>>(n + 1) { 0 to 0 }\\n        val q = LinkedList<Pair<Int,Int>>()\\n        q.add(1 to 0)\\n        while (!q.isEmpty()) {\\n            val (u, d) = q.poll()\\n            val (firstMin, secondMin) = dist[u]\\n            if (firstMin != 0 && secondMin != 0) continue \\n            if (firstMin == 0) {\\n                dist[u] = d to 0\\n            } else if (firstMin < d) {\\n                dist[u] = firstMin to d\\n            }\\n            for (v in adj[u]) {\\n                q.add(v to d + 1)\\n            }\\n        }\\n        val (_, secondMinReach) = dist.last()\\n        return secondMinReach\\n    }\\n    \\n    fun calculateTotalTime(pathLength: Int, time: Int, change: Int): Int {\\n        var elapsed = 0\\n        for (i in 1..pathLength) {\\n            elapsed += time\\n            val redLight = (elapsed / change) % 2 == 1\\n            if (redLight && i < pathLength) {\\n                elapsed = (elapsed / change + 1) * change\\n            }\\n        }\\n        return elapsed\\n    }\\n    \\n    fun secondMinimum(n: Int, edges: Array<IntArray>, time: Int, change: Int): Int {\\n        adj = List<MutableList<Int>>(n + 1) { mutableListOf() }\\n        for ((u, v) in edges) {\\n           adj[u].add(v)\\n           adj[v].add(u)\\n        }\\n        return calculateTotalTime(bfs(n), time, change)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526306,
                "title": "python-3-bfs-keep-last-two-minimum-step-counts",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        g = defaultdict(set)\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)              \\n        \\n        q = deque([(1, 0)])\\n        # to store the two minimum node counts for each visited node\\n        vis = defaultdict(set, {0: {0}})\\n        minval = set()\\n        while q:\\n            node, cnt = q.popleft()\\n            if node == n:\\n                minval.add(cnt)\\n                if len(minval) == 2: break\\n            for nei in g[node]:\\n                if len(vis[nei]) > 1 and cnt + 1 >= max(vis[nei]): continue\\n                vis[nei] = {min(vis[nei])} | {cnt + 1} if vis[nei] else {cnt + 1}\\n                q.append((nei, cnt + 1))\\n        \\n        minval = sorted(minval)\\n        def helper(nodes):\\n            t = 0\\n            while nodes > 0:\\n                t += time\\n                nodes -= 1\\n                if nodes == 0: break\\n                # if current time exceeds change and change frequency is odd\\n                if t >= change and (t // change) % 2:\\n                    t = (t // change + 1) * change\\n            return t\\n        \\n        if len(minval) == 1:\\n            return helper(minval[0] + 2)\\n        \\n        # either use the 2nd minimum path or the 1st path add two more nodes (like example 2)\\n        return min(helper(minval[0]+2), helper(minval[1]))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        g = defaultdict(set)\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)              \\n        \\n        q = deque([(1, 0)])\\n        # to store the two minimum node counts for each visited node\\n        vis = defaultdict(set, {0: {0}",
                "codeTag": "Java"
            },
            {
                "id": 1526134,
                "title": "heap-bfs-easy-understanding-solution",
                "content": "Use the fact that each node arrived at most two different time ,and use a heap to keep track the min time in the path.\\nAlthough it beats 100% in python,I thought it would not a good solution.\\n```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        adj=[[] for i in range(n+1)]\\n        node=[0]*(n+1)\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        h=[]\\n        heappush(h, (0,1))\\n        flag=1\\n        Minimum_Time=0\\n        last=(-1,-1)\\n        while True:\\n            current=heappop(h)\\n            current_time=current[0]\\n            current_node=current[1]\\n            \\n            if last==current:\\n                continue\\n            else:\\n                node[current_node]+=1\\n                last=current\\n            if current_node==n:\\n                if flag:\\n                    flag=0\\n                    Minimum_Time=current_time\\n                else:\\n                    if current_time>Minimum_Time:\\n                        return current_time\\n            out_time=current_time\\n            if out_time%(2*change)>=change:\\n                out_time=out_time+2*change-(out_time%(2*change))+time\\n            else:\\n                out_time+=time\\n\\n            for out_node in adj[current_node]:\\n                if node[out_node]<2:\\n                    heappush(h, (out_time,out_node))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        adj=[[] for i in range(n+1)]\\n        node=[0]*(n+1)\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        h=[]\\n        heappush(h, (0,1))\\n        flag=1\\n        Minimum_Time=0\\n        last=(-1,-1)\\n        while True:\\n            current=heappop(h)\\n            current_time=current[0]\\n            current_node=current[1]\\n            \\n            if last==current:\\n                continue\\n            else:\\n                node[current_node]+=1\\n                last=current\\n            if current_node==n:\\n                if flag:\\n                    flag=0\\n                    Minimum_Time=current_time\\n                else:\\n                    if current_time>Minimum_Time:\\n                        return current_time\\n            out_time=current_time\\n            if out_time%(2*change)>=change:\\n                out_time=out_time+2*change-(out_time%(2*change))+time\\n            else:\\n                out_time+=time\\n\\n            for out_node in adj[current_node]:\\n                if node[out_node]<2:\\n                    heappush(h, (out_time,out_node))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526093,
                "title": "c-using-dijkstra-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int bfss(vector<int> g[], int node,int time,int change )\\n    {\\n      vector<int>vis(node+1,0);\\n      vector<int>dist(node+1,0);\\n      priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>qq; //min heap\\n      qq.push({0,0});\\n        bool chk = false;\\n      while(qq.size()>0)\\n      {\\n          auto it = qq.top();\\n          qq.pop();\\n          auto tim = it.first;\\n          auto vertex = it.second;\\n          int chkk = tim/change;\\n          if(chkk%2!=0)\\n          {\\n              // red\\n              tim = ((change*(chkk+1)) );\\n          }\\n          for(auto pp: g[vertex])\\n          {\\n              if(dist[pp]!= tim+time && vis[pp]<2)\\n              {\\n                  qq.push({tim+time,pp});\\n                  vis[pp]++;\\n                  dist[pp] = tim+time;\\n                  if(pp==node && chk==false)\\n                  {  \\n                      chk = true;\\n                  }\\n                 else if(pp==node && chk == true)\\n                  {\\n                      return tim+time;\\n                  }\\n              }\\n          }  \\n      }\\n           \\n        return -1;\\n    }\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) \\n    \\n    {\\n         vector<int>g[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            auto it1 =  edges[i][0];\\n            auto it2 = edges[i][1];\\n            g[it1-1].push_back(it2-1);\\n            g[it2-1].push_back(it1-1);\\n        }\\n        int ans = bfss(g,n-1,time,change);\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int bfss(vector<int> g[], int node,int time,int change )\\n    {\\n      vector<int>vis(node+1,0);\\n      vector<int>dist(node+1,0);\\n      priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>qq; //min heap\\n      qq.push({0,0});\\n        bool chk = false;\\n      while(qq.size()>0)\\n      {\\n          auto it = qq.top();\\n          qq.pop();\\n          auto tim = it.first;\\n          auto vertex = it.second;\\n          int chkk = tim/change;\\n          if(chkk%2!=0)\\n          {\\n              // red\\n              tim = ((change*(chkk+1)) );\\n          }\\n          for(auto pp: g[vertex])\\n          {\\n              if(dist[pp]!= tim+time && vis[pp]<2)\\n              {\\n                  qq.push({tim+time,pp});\\n                  vis[pp]++;\\n                  dist[pp] = tim+time;\\n                  if(pp==node && chk==false)\\n                  {  \\n                      chk = true;\\n                  }\\n                 else if(pp==node && chk == true)\\n                  {\\n                      return tim+time;\\n                  }\\n              }\\n          }  \\n      }\\n           \\n        return -1;\\n    }\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) \\n    \\n    {\\n         vector<int>g[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            auto it1 =  edges[i][0];\\n            auto it2 = edges[i][1];\\n            g[it1-1].push_back(it2-1);\\n            g[it2-1].push_back(it1-1);\\n        }\\n        int ans = bfss(g,n-1,time,change);\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525648,
                "title": "c-bfs-solution-allowing-revisiting-only-if-the-step-count-is-at-most-1-greater-with-explanation",
                "content": "Idea:\\n1. With BFS, we can get the minimum duration required\\n2. To get the second minimum duration required, we should allow revisiting a position if the step count is at most 1 greater\\n3. The second minimum duration can be no more than the minimum duration plus 2 steps\\n-> Because we can just go back and forth an edge\\n```\\nclass Solution \\n{\\n    public:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) \\n    {\\n        int m=edges.size();\\n        vector<int> total[n+1]; // the graph of the edges\\n        for(int i=0;i<m;i++)\\n        {\\n            total[edges[i][0]].push_back(edges[i][1]);\\n            total[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int c=0,duration=0,step=-1;\\n\\t\\t// c is the step count\\n\\t\\t// duration is the time required to the node\\n\\t\\t// step is the minimum steps required to get to node n\\n        int counter[n+1]; // the number of steps required to get to the node\\n        bool check[n+1]; // to prevent revisiting a node if the step count is 2 steps greater or more\\n        memset(counter,-1,sizeof(counter));\\n        memset(check,false,sizeof(check));\\n        deque<int> q={1};\\n        while(true)\\n        {\\n            int s=q.size();\\n            c++;\\n            if((duration/change)%2) duration=duration+change-duration%change; // time required to get here\\n            duration+=time;\\n            if(step!=-1&&c==step+2) return duration;\\n            for(int i=0;i<s;i++)\\n            {\\n                int p=q.front();\\n                q.pop_front();\\n                for(int j=0;j<total[p].size();j++)\\n                {\\n                    if(counter[total[p][j]]==-1||(counter[total[p][j]]==c-1&&!check[total[p][j]]))\\n                    {\\n                        q.push_back(total[p][j]);\\n                        if(counter[total[p][j]]==c-1)\\n                        {\\n                            check[total[p][j]]=true;\\n                            if(total[p][j]==n&&step!=-1) return duration;\\n                        }\\n                        counter[total[p][j]]=c;\\n                        if(total[p][j]==n) step=c;\\n                    }\\n                }\\n            }\\n        }\\n        return duration;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) \\n    {\\n        int m=edges.size();\\n        vector<int> total[n+1]; // the graph of the edges\\n        for(int i=0;i<m;i++)\\n        {\\n            total[edges[i][0]].push_back(edges[i][1]);\\n            total[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int c=0,duration=0,step=-1;\\n\\t\\t// c is the step count\\n\\t\\t// duration is the time required to the node\\n\\t\\t// step is the minimum steps required to get to node n\\n        int counter[n+1]; // the number of steps required to get to the node\\n        bool check[n+1]; // to prevent revisiting a node if the step count is 2 steps greater or more\\n        memset(counter,-1,sizeof(counter));\\n        memset(check,false,sizeof(check));\\n        deque<int> q={1};\\n        while(true)\\n        {\\n            int s=q.size();\\n            c++;\\n            if((duration/change)%2) duration=duration+change-duration%change; // time required to get here\\n            duration+=time;\\n            if(step!=-1&&c==step+2) return duration;\\n            for(int i=0;i<s;i++)\\n            {\\n                int p=q.front();\\n                q.pop_front();\\n                for(int j=0;j<total[p].size();j++)\\n                {\\n                    if(counter[total[p][j]]==-1||(counter[total[p][j]]==c-1&&!check[total[p][j]]))\\n                    {\\n                        q.push_back(total[p][j]);\\n                        if(counter[total[p][j]]==c-1)\\n                        {\\n                            check[total[p][j]]=true;\\n                            if(total[p][j]==n&&step!=-1) return duration;\\n                        }\\n                        counter[total[p][j]]=c;\\n                        if(total[p][j]==n) step=c;\\n                    }\\n                }\\n            }\\n        }\\n        return duration;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525555,
                "title": "java-dijkstra-priorityqueue-min-heap",
                "content": "```\\n\\nclass Solution {\\n    private class Node {\\n        int id;\\n        long entry;\\n        long exit;\\n\\n        public Node(int id, long entry, long exit) {\\n            this.id = id;\\n            this.entry = entry;\\n            this.exit = exit;\\n        }\\n    }\\n\\n    private static final Comparator<Node> comparator = new Comparator<Node>() {\\n        public int compare(Node left, Node right) {\\n            if(left.exit <= right.exit) {\\n                return -1;\\n            }\\n            return 1;\\n        }\\n    };\\n\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        int id = 0;\\n        long entry = 0, exit = 0, nextEntry = 0, nextExit = 0;\\n        long[] lastNodeReachedTimes = new long[n + 1];\\n        int[] count = new int[n + 1];\\n        Node currentNode = null;\\n        Map<Integer, Set<Integer>> graph = getGraph(edges);\\n        PriorityQueue<Node> queue = new PriorityQueue<>(comparator);\\n        Arrays.fill(lastNodeReachedTimes, -1);\\n        lastNodeReachedTimes[1] = 0;\\n        count[1]++;\\n        queue.add(new Node(1, 0L, 0L));\\n        while(!queue.isEmpty()) {\\n            currentNode = queue.poll();\\n            id = currentNode.id;\\n            entry = currentNode.entry;\\n            exit = currentNode.exit;\\n            if(id == n) {\\n                if(count[id] == 2) {\\n                    break;\\n                }\\n            }\\n            if(graph.containsKey(id)) {\\n                for(Integer neighbour : graph.get(id)) {\\n                    nextEntry = (exit + time);\\n                    nextExit = getExitTime(nextEntry, change);\\n                    if(lastNodeReachedTimes[neighbour] == -1) {\\n                        lastNodeReachedTimes[neighbour] = nextEntry;\\n                        count[neighbour]++;\\n                        queue.add(new Node(neighbour, nextEntry, nextExit));\\n                    } else if((lastNodeReachedTimes[neighbour] < nextEntry) && (count[neighbour] == 1)) {\\n                        lastNodeReachedTimes[neighbour] = nextEntry;\\n                        count[neighbour]++;\\n                        queue.add(new Node(neighbour, nextEntry, nextExit));\\n                    }\\n                }\\n            }\\n        }\\n        return ((int) lastNodeReachedTimes[n]);\\n    }\\n\\n    private long getExitTime(long entry, long change) {\\n        long turn = (entry / change);\\n        if((turn % 2) == 1) {\\n            return ((turn + 1) * change);\\n        }\\n        return entry;\\n    }\\n\\n    private Map<Integer, Set<Integer>> getGraph(int[][] edges) {\\n        Set<Integer> neighbours = null;\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for(int[] edge : edges) {\\n            neighbours = graph.getOrDefault(edge[0], new HashSet<>());\\n            neighbours.add(edge[1]);\\n            graph.put(edge[0], neighbours);\\n            neighbours = graph.getOrDefault(edge[1], new HashSet<>());\\n            neighbours.add(edge[0]);\\n            graph.put(edge[1], neighbours);\\n        }\\n        return graph;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    private class Node {\\n        int id;\\n        long entry;\\n        long exit;\\n\\n        public Node(int id, long entry, long exit) {\\n            this.id = id;\\n            this.entry = entry;\\n            this.exit = exit;\\n        }\\n    }\\n\\n    private static final Comparator<Node> comparator = new Comparator<Node>() {\\n        public int compare(Node left, Node right) {\\n            if(left.exit <= right.exit) {\\n                return -1;\\n            }\\n            return 1;\\n        }\\n    };\\n\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        int id = 0;\\n        long entry = 0, exit = 0, nextEntry = 0, nextExit = 0;\\n        long[] lastNodeReachedTimes = new long[n + 1];\\n        int[] count = new int[n + 1];\\n        Node currentNode = null;\\n        Map<Integer, Set<Integer>> graph = getGraph(edges);\\n        PriorityQueue<Node> queue = new PriorityQueue<>(comparator);\\n        Arrays.fill(lastNodeReachedTimes, -1);\\n        lastNodeReachedTimes[1] = 0;\\n        count[1]++;\\n        queue.add(new Node(1, 0L, 0L));\\n        while(!queue.isEmpty()) {\\n            currentNode = queue.poll();\\n            id = currentNode.id;\\n            entry = currentNode.entry;\\n            exit = currentNode.exit;\\n            if(id == n) {\\n                if(count[id] == 2) {\\n                    break;\\n                }\\n            }\\n            if(graph.containsKey(id)) {\\n                for(Integer neighbour : graph.get(id)) {\\n                    nextEntry = (exit + time);\\n                    nextExit = getExitTime(nextEntry, change);\\n                    if(lastNodeReachedTimes[neighbour] == -1) {\\n                        lastNodeReachedTimes[neighbour] = nextEntry;\\n                        count[neighbour]++;\\n                        queue.add(new Node(neighbour, nextEntry, nextExit));\\n                    } else if((lastNodeReachedTimes[neighbour] < nextEntry) && (count[neighbour] == 1)) {\\n                        lastNodeReachedTimes[neighbour] = nextEntry;\\n                        count[neighbour]++;\\n                        queue.add(new Node(neighbour, nextEntry, nextExit));\\n                    }\\n                }\\n            }\\n        }\\n        return ((int) lastNodeReachedTimes[n]);\\n    }\\n\\n    private long getExitTime(long entry, long change) {\\n        long turn = (entry / change);\\n        if((turn % 2) == 1) {\\n            return ((turn + 1) * change);\\n        }\\n        return entry;\\n    }\\n\\n    private Map<Integer, Set<Integer>> getGraph(int[][] edges) {\\n        Set<Integer> neighbours = null;\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for(int[] edge : edges) {\\n            neighbours = graph.getOrDefault(edge[0], new HashSet<>());\\n            neighbours.add(edge[1]);\\n            graph.put(edge[0], neighbours);\\n            neighbours = graph.getOrDefault(edge[1], new HashSet<>());\\n            neighbours.add(edge[0]);\\n            graph.put(edge[1], neighbours);\\n        }\\n        return graph;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525466,
                "title": "c-dijkstra-to-solve-second-shortest-path-o-elogv-explained",
                "content": "Observations:\\n\\n1. The total time of a path from u to v is a function of the number of edges, so we can focus on this.\\n2. Suppose dis[n][0] is the shortest path (assume unweighted graph, weight == 1 for all edges) from 1 to n, dis[n][1] is the strictly second shortest path from 1 to n. Then the second minimum time\\'s corresponding path\\'s length D = dis[n][0] + 1 if dis[n][1] == dis[n][0] + 1; or D = dis[n][0] + 2 otherwise. \\n3.  We can solve the shortest path and second shortest path simultaneously using Dijkstra\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    class State{\\n    public:\\n        ll u, dis, flag;\\n        // flag == 0, shortest; flag == 1, second shortest\\n        \\n        State() {}\\n        State(ll u_, ll dis_, ll flag_) : u(u_), dis(dis_), flag(flag_) {}\\n    };\\n    \\n    // use dijkstra to solve second shortest path\\n    inline void dijkstra(vector<list<ll>> graph, ll s, vector<vector<ll>>& dis) {\\n        ll n = graph.size() - 1;\\n        vector<vector<ll>> vis(n + 1, vector<ll>(2));\\n        auto MyCompare = [](State& a, State& b) {\\n            return a.dis > b.dis;   \\n        };\\n        \\n        priority_queue<State, vector<State>, decltype(MyCompare)> pq(MyCompare);\\n        dis[s][0] = 0;\\n        pq.push(State(s, 0, 0));\\n        \\n        while (!pq.empty()) {\\n            State s = pq.top();\\n            pq.pop();\\n            \\n            if (vis[s.u][s.flag] == 1) continue;\\n            vis[s.u][s.flag] = 1;\\n            \\n            for (auto&& v : graph[s.u]) {\\n                if (vis[v][0] == 0 && dis[v][0] > dis[s.u][s.flag] + 1) {\\n                    dis[v][0] = dis[s.u][s.flag] + 1;\\n                    pq.push(State(v, dis[v][0], 0));\\n                }\\n                else if (vis[v][1] == 0 && dis[v][1] > dis[s.u][s.flag] + 1 && dis[v][0] < dis[s.u][s.flag] + 1) {\\n                    dis[v][1] = dis[s.u][s.flag] + 1;\\n                    pq.push(State(v, dis[v][1], 1));\\n                }\\n            }\\n        }                \\n        \\n    }\\n    \\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<list<ll>> graph(n + 1);\\n        for (auto&& e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        \\n        // for the answer, the number of edges should be dis[n] + 2 or dis[n] + 1\\n        \\n        // dijkstra(graph, 1);\\n        vector<vector<ll>> dis(n + 1, vector<ll>(2, LLONG_MAX)); // dis[u][0] shortest path, dis[u][1] strictly second shortest path\\n        dijkstra(graph, 1, dis);\\n        \\n        ll D;\\n        if (dis[n][1] == dis[n][0] + 1) D = dis[n][1];\\n        else D = dis[n][0] + 2;\\n        \\n        ll T = 0;\\n        \\n        for (ll i = 0; i < D; ++i) {\\n            if ((T / change) % 2 == 1) {\\n                T = (T / change + 1) * change;\\n            }\\n            T += time;\\n        }\\n        \\n        return T;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    class State{\\n    public:\\n        ll u, dis, flag;\\n        // flag == 0, shortest; flag == 1, second shortest\\n        \\n        State() {}\\n        State(ll u_, ll dis_, ll flag_) : u(u_), dis(dis_), flag(flag_) {}\\n    };\\n    \\n    // use dijkstra to solve second shortest path\\n    inline void dijkstra(vector<list<ll>> graph, ll s, vector<vector<ll>>& dis) {\\n        ll n = graph.size() - 1;\\n        vector<vector<ll>> vis(n + 1, vector<ll>(2));\\n        auto MyCompare = [](State& a, State& b) {\\n            return a.dis > b.dis;   \\n        };\\n        \\n        priority_queue<State, vector<State>, decltype(MyCompare)> pq(MyCompare);\\n        dis[s][0] = 0;\\n        pq.push(State(s, 0, 0));\\n        \\n        while (!pq.empty()) {\\n            State s = pq.top();\\n            pq.pop();\\n            \\n            if (vis[s.u][s.flag] == 1) continue;\\n            vis[s.u][s.flag] = 1;\\n            \\n            for (auto&& v : graph[s.u]) {\\n                if (vis[v][0] == 0 && dis[v][0] > dis[s.u][s.flag] + 1) {\\n                    dis[v][0] = dis[s.u][s.flag] + 1;\\n                    pq.push(State(v, dis[v][0], 0));\\n                }\\n                else if (vis[v][1] == 0 && dis[v][1] > dis[s.u][s.flag] + 1 && dis[v][0] < dis[s.u][s.flag] + 1) {\\n                    dis[v][1] = dis[s.u][s.flag] + 1;\\n                    pq.push(State(v, dis[v][1], 1));\\n                }\\n            }\\n        }                \\n        \\n    }\\n    \\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\\n        vector<list<ll>> graph(n + 1);\\n        for (auto&& e : edges) {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        \\n        // for the answer, the number of edges should be dis[n] + 2 or dis[n] + 1\\n        \\n        // dijkstra(graph, 1);\\n        vector<vector<ll>> dis(n + 1, vector<ll>(2, LLONG_MAX)); // dis[u][0] shortest path, dis[u][1] strictly second shortest path\\n        dijkstra(graph, 1, dis);\\n        \\n        ll D;\\n        if (dis[n][1] == dis[n][0] + 1) D = dis[n][1];\\n        else D = dis[n][0] + 2;\\n        \\n        ll T = 0;\\n        \\n        for (ll i = 0; i < D; ++i) {\\n            if ((T / change) % 2 == 1) {\\n                T = (T / change + 1) * change;\\n            }\\n            T += time;\\n        }\\n        \\n        return T;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525448,
                "title": "modified-dijkstra-java-pruning-450-ms",
                "content": "The thinking process is like follows:\\n1. We consider the problem without the traffic lights, this would make things easier. In this case, finding the minimum path is the standard Dijkstra.\\n2. We then consider how to find the second minimum. We need to keep track of the found results to a list, until we find one that differs than the first one, we know this is the 2nd minimum based on Dijkstra.\\n3. We then consider adding the traffic light contraint. This is relatively easy, each time when we consider how to add  the time/edge/length, we need to compute based on the current time, i.e. the time when we arrive the current node. If it falls to the even interval, then we have green light, edge length doesn\\'t change, if it falls to the odd interval, then we need to wait, just add the wait time to the length/travel time.\\n4. We need to dedupe the node visit, because we try to find the 2nd minimum, so each node can be visited 2 times at different time stamp. The 3rd visit and visits after it should be pruned because the first 2 visits are guaranteed to find the 2nd minimum. Keep count how many time each node is visited. \\n\\n```\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        int[] cnt = new int[n+1];\\n        Set<String> dup = new HashSet<>();\\n        for (int[] e : edges) {\\n            Set<Integer> set = map.getOrDefault(e[0], new HashSet<>());\\n            set.add(e[1]);\\n            map.put(e[0], set);\\n            Set<Integer> set2 = map.getOrDefault(e[1], new HashSet<>());\\n            set2.add(e[0]);\\n            map.put(e[1], set2);\\n        }\\n        PriorityQueue<int[]> valid = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        valid.add(new int[]{1, 0});\\n        cnt[1]++;\\n        dup.add(\"1#0\");\\n        List<Integer> ans = new ArrayList<>();\\n        while (!valid.isEmpty()) {\\n            int[] cur = valid.poll();\\n            if (cur[0] == n) {\\n                ans.add(cur[1]);\\n                if (ans.get(0) != cur[1])\\n                    return cur[1];\\n            }\\n            Set<Integer> nei = map.get(cur[0]);\\n            int nInterval = cur[1] / change;\\n            int travelTime = nInterval % 2 == 0 ? time : time + change - cur[1]%change;\\n            if (nei != null)\\n                for (int i : nei) {\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(i).append(\"#\").append(cur[1] + travelTime);\\n                    if (dup.contains(sb.toString()) || cnt[i] >= 2) continue;\\n                    valid.add(new int[]{i, cur[1] + travelTime});\\n                    dup.add(sb.toString());\\n                    cnt[i]++;\\n                }\\n        }\\n        return 0;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        int[] cnt = new int[n+1];\\n        Set<String> dup = new HashSet<>();\\n        for (int[] e : edges) {\\n            Set<Integer> set = map.getOrDefault(e[0], new HashSet<>());\\n            set.add(e[1]);\\n            map.put(e[0], set);\\n            Set<Integer> set2 = map.getOrDefault(e[1], new HashSet<>());\\n            set2.add(e[0]);\\n            map.put(e[1], set2);\\n        }\\n        PriorityQueue<int[]> valid = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        valid.add(new int[]{1, 0});\\n        cnt[1]++;\\n        dup.add(\"1#0\");\\n        List<Integer> ans = new ArrayList<>();\\n        while (!valid.isEmpty()) {\\n            int[] cur = valid.poll();\\n            if (cur[0] == n) {\\n                ans.add(cur[1]);\\n                if (ans.get(0) != cur[1])\\n                    return cur[1];\\n            }\\n            Set<Integer> nei = map.get(cur[0]);\\n            int nInterval = cur[1] / change;\\n            int travelTime = nInterval % 2 == 0 ? time : time + change - cur[1]%change;\\n            if (nei != null)\\n                for (int i : nei) {\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(i).append(\"#\").append(cur[1] + travelTime);\\n                    if (dup.contains(sb.toString()) || cnt[i] >= 2) continue;\\n                    valid.add(new int[]{i, cur[1] + travelTime});\\n                    dup.add(sb.toString());\\n                    cnt[i]++;\\n                }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525429,
                "title": "javascript-min-pq-dijkstra-1955ms",
                "content": "```\\nconst initializeGraph = (n) => { let G = []; for (let i = 0; i < n; i++) { G.push([]); } return G; };\\nconst addEdgeToG = (G, Edges) => { for (const [u, v] of Edges) { G[u].push(v); G[v].push(u); } };\\n\\nconst secondMinimum = (n, edges, time, change) => {\\n    let adj = initializeGraph(n + 1);\\n    addEdgeToG(adj, edges);\\n    let cost = initializeGraph(n + 1);\\n    let pq = new MinPriorityQueue({ priority: x => x[0] });\\n    pq.enqueue([0, 1]);\\n    let green = 2 * change;\\n    while (pq.size()) {\\n        let cur = pq.dequeue().element;\\n        let [t, node] = cur;\\n        if (cost[node].length == 2) continue;\\n        let nextT = t % green < change ? t : ((t + green - 1) / green >> 0) * green;\\n        let cn = cost[node].length;\\n        if (node == n) {\\n            if (cn == 0 || cost[node][cn - 1] != t) {\\n                cost[node].push(t);\\n            } else {\\n                continue;\\n            }\\n        } else {\\n            if (cn == 0 || cost[node][cn - 1] != nextT) {\\n                cost[node].push(nextT);\\n            } else {\\n                continue;\\n            }\\n        }\\n        for (const next_node of adj[node]) pq.enqueue([nextT + time, next_node]);\\n    }\\n    return cost[n][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let G = []; for (let i = 0; i < n; i++) { G.push([]); } return G; };\\nconst addEdgeToG = (G, Edges) => { for (const [u, v] of Edges) { G[u].push(v); G[v].push(u); } };\\n\\nconst secondMinimum = (n, edges, time, change) => {\\n    let adj = initializeGraph(n + 1);\\n    addEdgeToG(adj, edges);\\n    let cost = initializeGraph(n + 1);\\n    let pq = new MinPriorityQueue({ priority: x => x[0] });\\n    pq.enqueue([0, 1]);\\n    let green = 2 * change;\\n    while (pq.size()) {\\n        let cur = pq.dequeue().element;\\n        let [t, node] = cur;\\n        if (cost[node].length == 2) continue;\\n        let nextT = t % green < change ? t : ((t + green - 1) / green >> 0) * green;\\n        let cn = cost[node].length;\\n        if (node == n) {\\n            if (cn == 0 || cost[node][cn - 1] != t) {\\n                cost[node].push(t);\\n            } else {\\n                continue;\\n            }\\n        } else {\\n            if (cn == 0 || cost[node][cn - 1] != nextT) {\\n                cost[node].push(nextT);\\n            } else {\\n                continue;\\n            }\\n        }\\n        for (const next_node of adj[node]) pq.enqueue([nextT + time, next_node]);\\n    }\\n    return cost[n][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525415,
                "title": "python3-bfs-faster-than-100-visited-no-more-than-twice",
                "content": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        neighbors = [[] for _ in range(n+1)]\\n        for edge in edges:\\n            i, j = edge[0], edge[1]\\n            neighbors[i].append(j)\\n            neighbors[j].append(i)\\n            \\n        visited = [0] * (n+1)\\n        \\n        \\n        def secondShortestPath():\\n            thisLevel = {1}\\n            dist = 0\\n            visited[1] = 1\\n\\n            while True:\\n                lastLevel = thisLevel.copy()\\n                thisLevel = set()\\n                dist += 1\\n                for i in lastLevel:\\n                    for j in neighbors[i]:\\n                        if j in thisLevel:\\n                            continue\\n                        if j == n and visited[j] == 1:\\n                            return dist\\n                        if visited[j] < 2:\\n                            visited[j] += 1\\n                            thisLevel.add(j)\\n                                \\n        num_step = secondShortestPath()\\n        total = 0\\n        for _ in range(num_step):\\n            if (total // change) % 2 == 1:\\n                total = (total // change + 1) * change\\n            total += time\\n        return total\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        neighbors = [[] for _ in range(n+1)]\\n        for edge in edges:\\n            i, j = edge[0], edge[1]\\n            neighbors[i].append(j)\\n            neighbors[j].append(i)\\n            \\n        visited = [0] * (n+1)\\n        \\n        \\n        def secondShortestPath():\\n            thisLevel = {1}\\n            dist = 0\\n            visited[1] = 1\\n\\n            while True:\\n                lastLevel = thisLevel.copy()\\n                thisLevel = set()\\n                dist += 1\\n                for i in lastLevel:\\n                    for j in neighbors[i]:\\n                        if j in thisLevel:\\n                            continue\\n                        if j == n and visited[j] == 1:\\n                            return dist\\n                        if visited[j] < 2:\\n                            visited[j] += 1\\n                            thisLevel.add(j)\\n                                \\n        num_step = secondShortestPath()\\n        total = 0\\n        for _ in range(num_step):\\n            if (total // change) % 2 == 1:\\n                total = (total // change + 1) * change\\n            total += time\\n        return total\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1525404,
                "title": "java-modified-bfs",
                "content": "The idea use BFS, the only change is visited array, we need to store each node into queue at most twice. (I use BFS by level, at each round/level you update time once.)\\nSo start from Node 0, when first visit the final Node n, you mark that. and next time you reach Node n, that\\'s solution.\\nFor the time compute: each round + time, but if total time mod change is odd, which you have to wait. \\n```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge: edges) {\\n            if (!graph.containsKey(edge[0]))\\n                graph.put(edge[0], new ArrayList<Integer>());\\n            if (!graph.containsKey(edge[1]))\\n                graph.put(edge[1], new ArrayList<Integer>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        int[] mark=new int[n+1];\\n\\n        boolean lastfind=false;\\n        boolean findmin=false;\\n        int res=0;\\n        Deque<Integer> q=new ArrayDeque<Integer>();\\n        q.addFirst(1);\\n        while(true){\\n            res+=time;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int cur=q.pollFirst();\\n                mark[cur]++;\\n                for(int node:graph.get(cur)){\\n                    if(mark[node]>=2) continue;\\n                    if(lastfind&&findmin&&node==n) return res;\\n                    q.addLast(node);\\n                    if(node==n) findmin=true;\\n                }\\n            }\\n            if(findmin) lastfind=true;\\n            if((res/change)%2==1) {\\n                    res+=change-res%change;\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge: edges) {\\n            if (!graph.containsKey(edge[0]))\\n                graph.put(edge[0], new ArrayList<Integer>());\\n            if (!graph.containsKey(edge[1]))\\n                graph.put(edge[1], new ArrayList<Integer>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        int[] mark=new int[n+1];\\n\\n        boolean lastfind=false;\\n        boolean findmin=false;\\n        int res=0;\\n        Deque<Integer> q=new ArrayDeque<Integer>();\\n        q.addFirst(1);\\n        while(true){\\n            res+=time;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int cur=q.pollFirst();\\n                mark[cur]++;\\n                for(int node:graph.get(cur)){\\n                    if(mark[node]>=2) continue;\\n                    if(lastfind&&findmin&&node==n) return res;\\n                    q.addLast(node);\\n                    if(node==n) findmin=true;\\n                }\\n            }\\n            if(findmin) lastfind=true;\\n            if((res/change)%2==1) {\\n                    res+=change-res%change;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525386,
                "title": "java-double-relaxation",
                "content": "```\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        for(int[] edge : edges) {\\n            int v1 = edge[0]-1, v2 = edge[1]-1;\\n            graph[v1].add(v2);\\n            graph[v2].add(v1);\\n        }\\n        \\n        Set<Integer>[] visited = new HashSet[n];\\n        for(int i = 0; i < n; i++) {\\n            visited[i] = new HashSet<>();\\n        }\\n        boolean green;\\n        int prev = -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0});\\n        while(true) {\\n            int cnt = q.size();\\n            while(cnt-- > 0) {\\n                int[] cur = q.poll();\\n                int node = cur[0], elapse = cur[1];\\n                if(node == n-1) {\\n                    if(prev != -1 && prev != elapse) return elapse;\\n                    prev = elapse;\\n                }\\n                if(visited[node].size() > 2 || visited[node].contains(elapse)) continue;\\n                visited[node].add(elapse);\\n                green = (elapse/change) % 2 == 0;\\n                int wait = change - elapse % change;\\n                for(Integer neighbor : graph[node]) {\\n                    int elapse_n = elapse  + (green ? 0 : wait) + time;\\n                    q.offer(new int[]{neighbor, elapse_n});\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        for(int[] edge : edges) {\\n            int v1 = edge[0]-1, v2 = edge[1]-1;\\n            graph[v1].add(v2);\\n            graph[v2].add(v1);\\n        }\\n        \\n        Set<Integer>[] visited = new HashSet[n];\\n        for(int i = 0; i < n; i++) {\\n            visited[i] = new HashSet<>();\\n        }\\n        boolean green;\\n        int prev = -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0});\\n        while(true) {\\n            int cnt = q.size();\\n            while(cnt-- > 0) {\\n                int[] cur = q.poll();\\n                int node = cur[0], elapse = cur[1];\\n                if(node == n-1) {\\n                    if(prev != -1 && prev != elapse) return elapse;\\n                    prev = elapse;\\n                }\\n                if(visited[node].size() > 2 || visited[node].contains(elapse)) continue;\\n                visited[node].add(elapse);\\n                green = (elapse/change) % 2 == 0;\\n                int wait = change - elapse % change;\\n                for(Integer neighbor : graph[node]) {\\n                    int elapse_n = elapse  + (green ? 0 : wait) + time;\\n                    q.offer(new int[]{neighbor, elapse_n});\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1789702,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Since all the edges have equal weight, the problem can be simplified to getting the second-lowest number of edges to reach from 1 to `n`. Then at the end you can calculate how long it takes to traverse that many edges when taking into account the red/green lights.\\n\\nAlso, you don\\'t have to worry about \"going back\" like in the second example.. If you only find one path, the second-most optimal path will be that path + 2 additional edges (go back 1 & go forward again)"
                    },
                    {
                        "username": "GrandCoder",
                        "content": "no. example #1 shows you second-most is not necessarily +2, can be + 1"
                    },
                    {
                        "username": "stefan1096",
                        "content": "It would be interesting,and a real hard problem, if edges had different weights"
                    }
                ]
            },
            {
                "id": 2004979,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Since all the edges have equal weight, the problem can be simplified to getting the second-lowest number of edges to reach from 1 to `n`. Then at the end you can calculate how long it takes to traverse that many edges when taking into account the red/green lights.\\n\\nAlso, you don\\'t have to worry about \"going back\" like in the second example.. If you only find one path, the second-most optimal path will be that path + 2 additional edges (go back 1 & go forward again)"
                    },
                    {
                        "username": "GrandCoder",
                        "content": "no. example #1 shows you second-most is not necessarily +2, can be + 1"
                    },
                    {
                        "username": "stefan1096",
                        "content": "It would be interesting,and a real hard problem, if edges had different weights"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sort Linked List Already Sorted Using Absolute Values",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]